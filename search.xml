<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BOM基础知识</title>
    <url>/135xyq.github.io/2021/04/12/BOM-BOM%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><hr>
<p>BOM是browser object model的缩写，简称浏览器对象模型</p>
<p>主要处理浏览器窗口（window）和框架（iframe），<br>描述了与浏览器进行交互的方法和接口，可以对浏览器窗口进行访问和操作，不过通常浏览器特定的 JavaScript 扩展都被看做 BOM 的一部分。扩展如下：</p>
<ol>
<li>弹出新的浏览器窗口</li>
</ol>
<ol start="2">
<li><p>移动、关闭浏览器窗口以及调整窗口大小</p>
</li>
<li><p>提供 Web 浏览器详细信息的定位对象</p>
</li>
<li><p>提供用户屏幕分辨率详细信息的屏幕对象</p>
</li>
</ol>
<ol start="5">
<li>对 cookie 的支持</li>
</ol>
<ol start="6">
<li>IE 扩展了BOM，加入了ActiveXObject 类，可以通过 JavaScript 实例化 ActiveX 对象</li>
</ol>
<h2 id="一、BOM"><a href="#一、BOM" class="headerlink" title="一、BOM"></a>一、BOM</h2><p>BOM 是 browser object model 的缩写，简称浏览器对象模型。</p>
<p>主要处理浏览器窗口和框架， 描述了与浏览器进行交互的方法和接口，可以对浏览器窗口进行访问和操作，譬如可以弹出新的窗口，回退历史记录，获取 url…… </p>
<h2 id="二、BOM-与-DOM（Document-Object-Model）的关系"><a href="#二、BOM-与-DOM（Document-Object-Model）的关系" class="headerlink" title="二、BOM 与 DOM（Document Object Model）的关系"></a>二、BOM 与 DOM（Document Object Model）的关系</h2><ol>
<li><p>javacsript 是通过访问 BOM 对象来访问、控制、修改浏览器 </p>
</li>
<li><p>BOM 的 window 包含了 document，因此通过 window 对象的 document 属性就可以访问、 </p>
</li>
</ol>
<p>检索、修改文档内容与结构。 </p>
<ol start="3">
<li>document 对象又是 DOM 模型的根节点。</li>
</ol>
<p>因此，BOM 包含了 DOM，浏览器提供出来给予访问的是 BOM 对象，从 BOM 对象再访问到 DOM 对象，从而 js 可以操作浏览器以及浏览器读取到的文档</p>
<h2 id="三、BOM-对象包含以下内容"><a href="#三、BOM-对象包含以下内容" class="headerlink" title="三、BOM 对象包含以下内容"></a>三、BOM 对象包含以下内容</h2><ul>
<li><p>Window JavaScript 层级中的顶层对象，表示浏览器窗口。 </p>
</li>
<li><p>Navigator包含客户端浏览器的信息。 </p>
</li>
<li><p>History 包含了浏览器窗口访问过的 URL。 </p>
</li>
<li><p>Location 包含了当前 URL 的信息。 </p>
</li>
<li><p>Screen 包含客户端显示屏的信息。</p>
</li>
</ul>
<h2 id="四、Window-对象"><a href="#四、Window-对象" class="headerlink" title="四、Window 对象"></a>四、Window 对象</h2><p>Window 对象表示一个浏览器窗口或一个框架。在客户端 JavaScript 中，Window 对象是全局对象，所有的表达式都在当前的环境中计算。也就是说，要引用当前窗口根本不需要特殊的语法，可以把那个窗口的属性作为全局变量来使用。例如，可以只写 document，而不必写 window.document。</p>
<h3 id="1-window-对象属性"><a href="#1-window-对象属性" class="headerlink" title="1. window 对象属性"></a>1. window 对象属性</h3><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>closed</td>
<td>返回窗口是否已被关闭。</td>
</tr>
<tr>
<td>defaultStatus</td>
<td>设置或返回窗口状态栏中的默认文本。（仅 Opera 支持）</td>
</tr>
<tr>
<td>document</td>
<td>对 Document 对象的只读引用。请参阅 Document 对象</td>
</tr>
<tr>
<td>history</td>
<td>对 History 对象的只读引用。请参见 History 对象</td>
</tr>
<tr>
<td>innerheight</td>
<td>返回窗口的文档显示区的高度</td>
</tr>
<tr>
<td>innerwidth</td>
<td>返回窗口的文档显示区的宽度</td>
</tr>
<tr>
<td>length</td>
<td>设置或返回窗口中的框架数量。</td>
</tr>
<tr>
<td>location</td>
<td>用于窗口或框架的 Location 对象。请参阅 Location 对象</td>
</tr>
<tr>
<td>name</td>
<td>设置或返回窗口的名称</td>
</tr>
<tr>
<td>navigator</td>
<td>对 Navigator 对象的只读引用。请参数 Navigator 对象</td>
</tr>
<tr>
<td>opener</td>
<td>返回对创建此窗口的窗口的引用</td>
</tr>
<tr>
<td>outerheight</td>
<td>返回窗口的外部高度</td>
</tr>
<tr>
<td>outerwidth</td>
<td>返回窗口的外部宽度</td>
</tr>
<tr>
<td>pageXOffset</td>
<td>设置或返回当前页面相对于窗口显示区左上角的 X 位置</td>
</tr>
<tr>
<td>pageYOffset</td>
<td>设置或返回当前页面相对于窗口显示区左上角的 Y 位置</td>
</tr>
<tr>
<td>parent</td>
<td>返回父窗口</td>
</tr>
<tr>
<td>screen</td>
<td>对 Screen 对象的只读引用。请参数 Screen 对象</td>
</tr>
<tr>
<td>self</td>
<td>返回对当前窗口的引用。等价于 Window 属性</td>
</tr>
<tr>
<td>status</td>
<td>设置窗口状态栏的文本。(默认只支持 Opera)</td>
</tr>
<tr>
<td>top</td>
<td>返回最顶层的先辈窗口</td>
</tr>
<tr>
<td>window</td>
<td>window 属性等价于 self 属性，它包含了对窗口自身的引用</td>
</tr>
<tr>
<td>screenLeft  screenTop  screenX  screenY</td>
<td>只读整数。声明了窗口的左上角在屏幕上的的 x 坐标和 y 坐标。 IE、Safari、Chrome 和 Opera 支持 screenLeft 和 screenTop，  Chrome、Firefox 和 Safari 支持 screenX 和 screenY</td>
</tr>
</tbody></table>
<h3 id="2-window对象方法"><a href="#2-window对象方法" class="headerlink" title="2. window对象方法"></a>2. window对象方法</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>alert()</td>
<td>显示带有一段消息和一个确认按钮的警告框</td>
</tr>
<tr>
<td>blur()</td>
<td>把键盘焦点从顶层窗口移开。</td>
</tr>
<tr>
<td>clearInterval()</td>
<td>取消由 setInterval() 设置的 timeout。</td>
</tr>
<tr>
<td>clearTimeout()</td>
<td>取消由 setTimeout() 方法设置的 timeout。</td>
</tr>
<tr>
<td>close()</td>
<td>关闭浏览器窗口。</td>
</tr>
<tr>
<td>confirm()</td>
<td>显示带有一段消息以及确认按钮和取消按钮的对话框。</td>
</tr>
<tr>
<td>createPopup()</td>
<td>创建一个弹出窗口。只有 ie 支持（不包括 ie11）</td>
</tr>
<tr>
<td>focus()</td>
<td>把键盘焦点给予一个窗口。</td>
</tr>
<tr>
<td>moveBy()</td>
<td>可相对窗口的当前坐标把它移动指定的像素</td>
</tr>
<tr>
<td>moveTo()</td>
<td>把窗口的左上角移动到一个指定的坐标</td>
</tr>
<tr>
<td>open()</td>
<td>打开一个新的浏览器窗口或查找一个已命名的窗口。window.open(URL,name,features,replace)</td>
</tr>
<tr>
<td>print()</td>
<td>打印当前窗口的内容。</td>
</tr>
<tr>
<td>prompt()</td>
<td>显示可提示用户输入的对话框。</td>
</tr>
<tr>
<td>resizeBy()</td>
<td>按照指定的像素调整窗口的大小。</td>
</tr>
<tr>
<td>resizeTo()</td>
<td>把窗口的大小调整到指定的宽度和高度。</td>
</tr>
<tr>
<td>scrollBy()</td>
<td>按照指定的像素值来滚动内容。</td>
</tr>
<tr>
<td>scrollTo()</td>
<td>把内容滚动到指定的坐标。</td>
</tr>
<tr>
<td>setInterval()</td>
<td>按照指定的周期（以毫秒计）来调用函数或计算表达式。</td>
</tr>
<tr>
<td>setTimeout()</td>
<td>在指定的毫秒数后调用函数或计算表达式。</td>
</tr>
</tbody></table>
<h2 id="五、Navigator-对象"><a href="#五、Navigator-对象" class="headerlink" title="五、Navigator 对象"></a>五、Navigator 对象</h2><p>Navigator 对象包含的属性描述了正在使用的浏览器。</p>
<p>可以使用这些属性进行平台专用的配置。虽然这个对象的名称显而易见的是 Netscape 的 Navigator 浏览器，但其他实现了 JavaScript 的浏览器也支持这个对象。</p>
<h3 id="1-Navigator-对象属性"><a href="#1-Navigator-对象属性" class="headerlink" title="1. Navigator 对象属性"></a>1. Navigator 对象属性</h3><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>appCodeName</td>
<td>返回浏览器的代码名。 以 Netscape 代码为基础的浏览器中，它的值是 “Mozilla”。为兼容 Microsoft 也是</td>
</tr>
<tr>
<td>appMinorVersion</td>
<td>返回浏览器的次级版本。（IE4、Opera 支持）</td>
</tr>
<tr>
<td>appName</td>
<td>返回浏览器的名称。</td>
</tr>
<tr>
<td>appVersion</td>
<td>返回浏览器的平台和版本信息。</td>
</tr>
<tr>
<td>browserLanguage</td>
<td>返回当前浏览器的语言。（IE 和 Opera 支持）</td>
</tr>
<tr>
<td>cookieEnabled</td>
<td>返回指明浏览器中是否启用 cookie 的布尔值。</td>
</tr>
<tr>
<td>cpuClass</td>
<td>返回浏览器系统的 CPU 等级。（IE 支持）</td>
</tr>
<tr>
<td>onLine</td>
<td>返回指明系统是否处于脱机模式的布尔值。</td>
</tr>
<tr>
<td>platform</td>
<td>返回运行浏览器的操作系统平台。</td>
</tr>
<tr>
<td>systemLanguage</td>
<td>返回当前操作系统的默认语言。（IE 支持）</td>
</tr>
<tr>
<td>userAgent</td>
<td>返回由客户机发送服务器的 user-agent 头部的值。</td>
</tr>
<tr>
<td>userLanguage</td>
<td>返回操作系统设定的自然语言。（IE 和 Opera 支持）</td>
</tr>
<tr>
<td>plugins</td>
<td>返回包含客户端安装的所有插件的数组</td>
</tr>
</tbody></table>
<h3 id="2-Navigator-对象方法"><a href="#2-Navigator-对象方法" class="headerlink" title="2. Navigator 对象方法"></a>2. Navigator 对象方法</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>javaEnabled()</td>
<td>规定浏览器是否支持并启用了 Java</td>
</tr>
<tr>
<td>taintEnabled()</td>
<td>规定浏览器是否启用数据污点 (data tainting)</td>
</tr>
</tbody></table>
<h2 id="六、History-对象"><a href="#六、History-对象" class="headerlink" title="六、History 对象"></a>六、History 对象</h2><p>History 对象包含用户（在浏览器窗口中）访问过的 URL</p>
<h3 id="1-History-对象属性"><a href="#1-History-对象属性" class="headerlink" title="1. History 对象属性"></a>1. History 对象属性</h3><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>length</td>
<td>返回浏览器历史列表中的 URL 数量</td>
</tr>
</tbody></table>
<h3 id="2-History-对象方法"><a href="#2-History-对象方法" class="headerlink" title="2. History 对象方法"></a>2. History 对象方法</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>back()</td>
<td>加载 history 列表中的前一个 URL</td>
</tr>
<tr>
<td>forward()</td>
<td>加载 history 列表中的下一个 URL</td>
</tr>
<tr>
<td>go()</td>
<td>加载 history 列表中的某个具体页面</td>
</tr>
</tbody></table>
<h2 id="七、Location-对象"><a href="#七、Location-对象" class="headerlink" title="七、Location 对象"></a>七、Location 对象</h2><p>Location 对象包含有关当前 URL 的信息</p>
<h3 id="1-Location-对象属性"><a href="#1-Location-对象属性" class="headerlink" title="1. Location 对象属性"></a>1. Location 对象属性</h3><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>hash</td>
<td>设置或返回从井号 (#) 开始的 URL（锚）</td>
</tr>
<tr>
<td>host</td>
<td>设置或返回主机名和当前 URL 的端口号</td>
</tr>
<tr>
<td>hostname</td>
<td>设置或返回当前 URL 的主机名</td>
</tr>
<tr>
<td>href</td>
<td>设置或返回完整的 URL</td>
</tr>
<tr>
<td>pathname</td>
<td>设置或返回当前 URL 的路径部分</td>
</tr>
<tr>
<td>port</td>
<td>设置或返回当前 URL 的端口号</td>
</tr>
<tr>
<td>protocol</td>
<td>设置或返回当前 URL 的协议。</td>
</tr>
<tr>
<td>search</td>
<td>设置或返回从问号 (?) 开始的 URL（查询部分）</td>
</tr>
</tbody></table>
<h3 id="2-Location-对象方法"><a href="#2-Location-对象方法" class="headerlink" title="2. Location 对象方法"></a>2. Location 对象方法</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>assign()</td>
<td>加载新的文档</td>
</tr>
<tr>
<td>reload(‘force’)</td>
<td>重新加载当前文档。参数可选，不填或填 false 则取浏览器缓存的文档</td>
</tr>
<tr>
<td>replace()</td>
<td>用新的文档替换当前文档</td>
</tr>
</tbody></table>
<h2 id="八、Screen-对象"><a href="#八、Screen-对象" class="headerlink" title="八、Screen 对象"></a>八、Screen 对象</h2><p>Screen 对象包含有关客户端显示屏幕的信息。每个 Window 对象的 screen 属性都引用一个 Screen 对象。Screen 对象中存放着有关显示浏览器屏幕的信息。JavaScript 程序将利用这些信息来优化它们的输出，以达到用户的显示要求。例如，一个程序可以根据显示器的尺寸选择使用大图像还是使用小图像，它还可以根据显示器的颜色深度选择使用 16 位色 还是使用 8 位色的图形。另外，JavaScript 程序还能根据有关屏幕尺寸的信息将新的浏览器 </p>
<p>窗口定位在屏幕中间。</p>
<h3 id="1-Screen-对象属性"><a href="#1-Screen-对象属性" class="headerlink" title="1. Screen 对象属性"></a>1. Screen 对象属性</h3><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>availHeight</td>
<td>返回显示屏幕的高度 (除 Windows 任务栏之外)。</td>
</tr>
<tr>
<td>availWidth</td>
<td>返回显示屏幕的宽度 (除 Windows 任务栏之外)。</td>
</tr>
<tr>
<td>bufferDepth</td>
<td>设置或返回调色板的比特深度。（仅 IE 支持）</td>
</tr>
<tr>
<td>colorDepth</td>
<td>返回目标设备或缓冲器上的调色板的比特深度。</td>
</tr>
<tr>
<td>deviceXDPI</td>
<td>返回显示屏幕的每英寸水平点数。（仅 IE 支持）</td>
</tr>
<tr>
<td>deviceYDPI</td>
<td>返回显示屏幕的每英寸垂直点数。（仅 IE 支持）</td>
</tr>
<tr>
<td>fontSmoothingEnabled</td>
<td>返回用户是否在显示控制面板中启用了字体平滑。（仅 IE 支持）</td>
</tr>
<tr>
<td>height</td>
<td>返回显示屏幕的高度</td>
</tr>
<tr>
<td>logicalXDPI</td>
<td>返回显示屏幕每英寸的水平方向的常规点数。（仅 IE 支持）</td>
</tr>
<tr>
<td>logicalYDPI</td>
<td>返回显示屏幕每英寸的垂直方向的常规点数。（仅 IE 支持）</td>
</tr>
<tr>
<td>pixelDepth</td>
<td>返回显示屏幕的颜色分辨率（比特每像素）</td>
</tr>
<tr>
<td>updateInterval</td>
<td>设置或返回屏幕的刷新率。（仅 IE11 以下支持）</td>
</tr>
<tr>
<td>width</td>
<td>返回显示器屏幕的宽度</td>
</tr>
</tbody></table>
<h2 id="归纳："><a href="#归纳：" class="headerlink" title="归纳："></a>归纳：</h2><p>Window JavaScript 层级中的顶层对象表示浏览器窗口</p>
<p>包含客户端浏览器的信息</p>
<p>History 包含了浏览器窗口访问过的 URL</p>
<p>Location 包含了当前 URL 的信息</p>
<p>Screen 包含客户端显示屏的信息</p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>BOM</category>
      </categories>
      <tags>
        <tag>bom</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS3动画</title>
    <url>/135xyq.github.io/2021/01/05/CSS-%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<h1 id="动画"><a href="#动画" class="headerlink" title="动画"></a><a href="http://css.doyoe.com/">动画</a></h1><hr>
<h2 id="transition-过渡"><a href="#transition-过渡" class="headerlink" title="transition: 过渡"></a>transition: 过渡</h2><p>（过渡对象，持续时间，变化函数（可选），延迟时间（可选））</p>
<h4 id="变化函数："><a href="#变化函数：" class="headerlink" title="变化函数："></a>变化函数：</h4><p>贝塞尔曲线<code>cubic-bezier(&lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;)</code>：特定的贝塞尔曲线类型，1,3数值需在[0, 1]区间内</p>
<p>贝塞尔曲线<br>输入的四个数为P1,P2的坐标点</p>
<h2 id="animations：动画"><a href="#animations：动画" class="headerlink" title="animations：动画"></a>animations：动画</h2><h3 id="八个属性值："><a href="#八个属性值：" class="headerlink" title="八个属性值："></a>八个属性值：</h3><ul>
<li><p>animation-name：<br>检索或设置对象所应用的动画名称</p>
</li>
<li><p>animation-duration：<br>检索或设置对象动画的持续时间</p>
</li>
<li><p>animation-timing-function：<br>检索或设置对象动画的过渡类型</p>
</li>
<li><p>steps（步数，start/ end）</p>
</li>
<li><p>start:保留下一帧状态，直到这一段动画时间结束</p>
</li>
<li><p>end:保留当前帧状态，直到这一段动画时间结束，最后一帧可能看不到，可加上forwords来弥补</p>
</li>
</ul>
<p><code>steps(1,start) === step-start</code><br><code>steps(1,end) === step-end </code></p>
<ul>
<li>animation-delay：<br>检索或设置对象动画延迟的时间</li>
<li>animation-iteration-count：<br>检索或设置对象动画的循环次数</li>
<li>animation-direction：<br>检索或设置对象动画在循环中是否反向运动</li>
<li>animation-fill-mode：<br>检索或设置对象动画时间之外的状态</li>
<li>animation-play-state：<br>检索或设置对象动画的状态。</li>
</ul>
<h3 id="关键帧定义："><a href="#关键帧定义：" class="headerlink" title="关键帧定义："></a>关键帧定义：</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> 自定义名字&#123;</span><br><span class="line">数字%（执行时间占比其中<span class="number">0%</span>可变为<span class="selector-tag">from</span> ，<span class="number">100%</span>可变为<span class="selector-tag">to</span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="scale-伸缩"><a href="#scale-伸缩" class="headerlink" title="scale:伸缩"></a>scale:伸缩</h3><p>可3d变化</p>
<p>伸缩的是此元素变化的坐标轴的刻度。可叠加操作<br>scale的坐标轴会随着旋转轴的旋转而旋转，但会保留影响，设置过的会保留效果。</p>
<h3 id="skew-倾斜"><a href="#skew-倾斜" class="headerlink" title="skew:倾斜"></a>skew:倾斜</h3><p>2d变化<br>倾斜的是此元素变化的坐标轴，还会拉伸坐标轴</p>
<p>可水平居中</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">left</span>:<span class="number">50%</span>;</span><br><span class="line"><span class="attribute">transform</span>:<span class="built_in">translateX</span>(-<span class="number">50%</span>);</span><br></pre></td></tr></table></figure>


<p>perspective：景深，我们视线距离浏览器的距离，只设置这一个并不会影响大小</p>
<p>transform-origin：旋转中心，可填三个值x , y, z</p>
<p>matrix:矩阵，transform的强大属性，可以完成各种变换</p>
<p><img src="/images/CSS3Images/%E5%8A%A8%E7%94%BB-%E8%BD%AC%E6%8D%A2%E7%9F%A9%E9%98%B5.jpg" alt="转换矩阵"></p>
<h2 id="浏览器渲染过程"><a href="#浏览器渲染过程" class="headerlink" title="浏览器渲染过程"></a>浏览器渲染过程</h2><h3 id="reflow"><a href="#reflow" class="headerlink" title="reflow:"></a>reflow:</h3><ul>
<li>改变窗口大小</li>
<li>改变文字大小</li>
<li>内容的改变，输入框输入文字</li>
<li>激活伪类，如:hover</li>
<li>操作class属性</li>
<li>脚本操作DOM</li>
<li>计算offsetWidth和offsetHeight</li>
<li>设置style属性</li>
</ul>
<h3 id="repaint："><a href="#repaint：" class="headerlink" title="repaint："></a>repaint：</h3><p>如果只是改变某个元素的背景色、文字颜色、边框颜色，不影响它周围或内部布局的属性</p>
<p>repaint 速度快于 reflow</p>
<p>像素里面有三个色点，三个在一个平面排列，里面每个像点代表三原色的每一个颜色，空间混色法</p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS3选择器、border、background、flex</title>
    <url>/135xyq.github.io/2021/01/04/CSS-%E9%80%89%E6%8B%A9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="选择器："><a href="#选择器：" class="headerlink" title="选择器："></a>选择器：</h1><hr>
<h2 id="关系选择器："><a href="#关系选择器：" class="headerlink" title="关系选择器："></a>关系选择器：</h2><ul>
<li><p> + ：下一个满足条件的兄弟元素节点。<br><code>div + P&#123;&#125;  //选出div的兄弟节点并且是p标签</code></p>
</li>
<li><p>~ ： 后面的满足条件的所有兄弟节点<br><code>div ~ p&#123;&#125;  //选出div兄弟节点中所有的p节点</code></p>
</li>
</ul>
<h2 id="属性选择器："><a href="#属性选择器：" class="headerlink" title="属性选择器："></a>属性选择器：</h2><ul>
<li>[attribute~=”value”] 选择器选取属性值包含指定词的元素。</li>
<li>[attribute|=”value”] 选择器用于选取指定属性以指定值开头的元素,该值必须是一个完整的单词。</li>
<li>[attribute^=”value”] 选择器用于选取指定属性以指定值开头的元素。</li>
<li>[attribute$=”value”] 选择器用于选取指定属性以指定值结尾的元素。</li>
<li>[attribute*=”value”] 选择器选取属性值包含指定词的元素。</li>
<li>::placeholer  选择带placeholeder元素</li>
<li>::selection   设置页面字体选中后的状态</li>
</ul>
<h2 id="伪类选择器："><a href="#伪类选择器：" class="headerlink" title="伪类选择器："></a>伪类选择器：</h2><p>当前元素的状态（全部是当前元素的限制条件,想操作谁就选谁）</p>
<ul>
<li>:not  不是什么什么</li>
<li>:root 根目录选择器（HTML下是html标签）</li>
<li>:target 选择被锚点标记之后的元素</li>
</ul>
<h3 id="要考虑其他元素（要关注其他元素）："><a href="#要考虑其他元素（要关注其他元素）：" class="headerlink" title="要考虑其他元素（要关注其他元素）："></a>要考虑其他元素（要关注其他元素）：</h3><ul>
<li>:first-child 第一个子元素</li>
<li>:last-child 最后一个子元素</li>
<li>:only-child  仅有一个子元素</li>
<li>:nth-child(n) 第n 个子元素 （可写计算公式 ，n从0开始查数）CSS从1开始查数 </li>
<li>:nth-last-child(n) 第n 个子元素,倒着数 （可写计算公式）</li>
</ul>
<h3 id="不用考虑其他元素-不关注其他类型元素-："><a href="#不用考虑其他元素-不关注其他类型元素-：" class="headerlink" title="不用考虑其他元素(不关注其他类型元素)："></a>不用考虑其他元素(不关注其他类型元素)：</h3><ul>
<li>:first-of-type  当前类型的第一个</li>
<li>:last-of-type  当前类型的最后一个</li>
<li>:only-of-type  当前类型的仅有一个</li>
<li>:nth-of-type  当前类型的第n个</li>
<li>:nth-of-last-type  当前类型的第n个，倒着查</li>
<li>:empty     元素内容为空</li>
<li>:checked  元素被选中状态</li>
<li>:disabled  被禁用的</li>
<li>:ready-only  只能读,不能写的<br>:ready-write  可读可写的</li>
</ul>
<p>当给html和body设置高度为100%后，再给里面的元素高度设置100%可充满整个页面。</p>
<h2 id="border："><a href="#border：" class="headerlink" title="border："></a>border：</h2><h3 id="border-radious"><a href="#border-radious" class="headerlink" title="border-radious :"></a>border-radious :</h3><p>(左上，右上，右下，左下)<br>（上，上，下，下 / 左，右，右，左）不常用 </p>
<p>可写为border-top-left-radious:左上角<br>用正方形画四分之一圆：一个角的值等于正方形的边长</p>
<h3 id="box-shadow："><a href="#box-shadow：" class="headerlink" title="box-shadow："></a>box-shadow：</h3><p>普通写法：<br>（inset（内阴影默认为外阴影（不写）），水平偏移量（正是向右，负是向左），垂直偏移量（正值向下，负值向上），阴影模糊程度（基于原边框向两侧同时模糊），传播距离（可选）（在四个方向上同时增大阴影的大小），颜色）。</p>
<p>可设置多个box-shadow值，先写的在上面，重复的会加重颜色。</p>
<p>阴影在背景颜色是上面，在文字的下面</p>
<h3 id="border-image："><a href="#border-image：" class="headerlink" title="border-image："></a>border-image：</h3><p><code>border-image-source:url()  引入图片</code></p>
<ul>
<li>border-image-slice：(1-5个参数，前四个参数只能为数值，不能带px表示图片的分割方式，最后一个参数填上fill会把内容区也填充)</li>
</ul>
<ul>
<li>border-image-ouset  向外延伸多少<br>border-image-width  图片显示的宽度（为1表示完全填充，默认为1）</li>
<li>border-image-repeat  默认为stretch将被分割的图像使用拉伸的方式来填充满边框图像区域。</li>
<li>repeat：将被分割的图像使用重复平铺的方式来填充满边框图像区域。当图像碰到边界时，如果超过则被截断。</li>
<li>round：与 repeat 关键字类似。不同在于，当背景图像不能以整数次平铺时，会根据情况缩放图像。</li>
<li>space： 与 repeat 关键字类似。不同在于，当背景图像不能以整数次平铺时，会用空白间隙填充在图像周围。</li>
</ul>
<h2 id="background："><a href="#background：" class="headerlink" title="background："></a>background：</h2><h3 id="渐变两种生成方法："><a href="#渐变两种生成方法：" class="headerlink" title="渐变两种生成方法："></a>渐变两种生成方法：</h3><ul>
<li>linear-gradient()线性渐变，</li>
<li>radial-gradient()径向渐变，当成一个图片来看待</li>
</ul>
<h3 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h3><ul>
<li>background-image ： 可以添加多个背景图片，多url</li>
<li>background-origin:图片的起始位置（结束位置无法确定），<ul>
<li>border-box；从边框开始，</li>
<li>padding-box：从padding开始(默认值)</li>
<li>content-box:从content开始 </li>
</ul>
</li>
<li>background-clip:图片的截断部分，从哪开始以外部分都不显示，<ul>
<li>border-box：（默认值），</li>
<li>padding-box：,content-box:，text（除了文字展示范围内展示图片（只在文字下面展示），以外区域不展示图片，只在webkit下可以用，需配合谷歌特有属性 </li>
</ul>
</li>
<li>-webkit-text-fill-color:transparent使用，用完之后文字会变成背景的一部分，这时候在设置阴影，阴影会显示在文字的前面，可以适当设置阴影的透明度来缓冲效果）</li>
<li>background-attchent:<ul>
<li>fixed：背景图像相对于视口（viewport）固定，当范围超出原来容器就不会再显示了。；</li>
<li>scroll：背景图像相对于元素固定，也就是说当元素内容滚动时背景图像不会跟着滚动，因为背景图像总是要跟着元素本身，但会随元素的祖先元素或窗体一起滚动。（默认值）；</li>
<li>local：背景图像相对于元素内容固定，也就是说当元素随元素滚动时背景图像也会跟着滚动，因为背景图像总是要跟着内容</li>
</ul>
</li>
<li>background-repeat: 可以填两个值代表水平和垂直方向，   <ul>
<li>repeat-x：背景图像在横向上平铺;</li>
<li>repeat-y：背景图像在纵向上平铺;</li>
<li>repeat：背景图像在横向和纵向平铺;</li>
<li>no-repeat：背景图像不平铺(默认值);</li>
<li>round：当背景图像不能以整数次平铺时，会根据情况缩放图像。;</li>
<li>space：当背景图像不能以整数次平铺时，会用空白间隙填充在图像周围。</li>
</ul>
</li>
<li>background-size:</li>
<li>background-position:定位开始位置参考图片的起始位置（background-origin）    </li>
</ul>
<h2 id="渐变："><a href="#渐变：" class="headerlink" title="渐变："></a>渐变：</h2><p><code>linear-gradient(方向(可选，默认为自下到上 to bottom,to top right ：到右上)，起始颜色，结束颜色)</code></p>
<p><a href="http://css.doyoe.com/">参考</a></p>
<p>border-color的默认值等于color         </p>
<h2 id="Text："><a href="#Text：" class="headerlink" title="Text："></a>Text：</h2><ul>
<li>text-shadow：（水平偏移，垂直偏移，模糊值，颜色 ）</li>
<li>-webkit-text-stroke:描边（宽度，颜色）</li>
</ul>
<p>调用外部的字体包：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@font-face</span>&#123;</span><br><span class="line"><span class="attribute">font-family</span>:  字体的名称;</span><br><span class="line"><span class="attribute">src</span>:<span class="built_in">url</span>() /*地址*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>user-select: none; /*禁止文字被复制*/</code></p>
<h2 id="box"><a href="#box" class="headerlink" title="box:"></a>box:</h2><p>IE6混杂模式的盒模型<br>box-width = width;<br>触发方式：box-sizing = border-box;</p>
<h2 id="overflow"><a href="#overflow" class="headerlink" title="overflow:"></a>overflow:</h2><ul>
<li>hidden(溢出部分隐藏);</li>
<li>scroll(溢出之后出现滚动条) ;</li>
<li>auto(溢出之后出现滚动条，更标准)，<br>可单独设置x,y轴（overflow）</li>
</ul>
<h2 id="resize-必须配合overflow来使用，不然没效果"><a href="#resize-必须配合overflow来使用，不然没效果" class="headerlink" title="resize: 必须配合overflow来使用，不然没效果"></a>resize: 必须配合overflow来使用，不然没效果</h2><ul>
<li>none：不允许用户调整元素大小。</li>
<li>both：用户可以调节元素的宽度和高度。</li>
<li>horizontal：用户可以调节元素的宽度。</li>
<li>vertical：用户可以调节元素的高度。</li>
</ul>
<h2 id="弹性盒模型：flex"><a href="#弹性盒模型：flex" class="headerlink" title="弹性盒模型：flex"></a>弹性盒模型：flex</h2><h3 id="弹性盒"><a href="#弹性盒" class="headerlink" title="弹性盒"></a>弹性盒</h3><p>flex-shrink:计算要计算加权，而且压缩的部分是盒子的内容区。</p>
<p>压缩大小 = 自己真实内容区 * flex-shrink / 所有元素（真实内容区 * flex-shrink）的总和  * 要压缩的总范围。</p>
<p>只设置 flex-basis 或flex-basis &gt; width代表元素的最小宽度，会随内容区增大；<br>设置width后，并且width &gt; flex-basis，width表示元素的最大宽度，则flex-basis &lt; realwidth &lt; width。</p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Fetch Api</title>
    <url>/135xyq.github.io/2021/03/09/ES6-fetchAPI/</url>
    <content><![CDATA[<h1 id="Fetch-Api"><a href="#Fetch-Api" class="headerlink" title="Fetch Api"></a>Fetch Api</h1><hr>
<h2 id="Fetch-Api-1"><a href="#Fetch-Api-1" class="headerlink" title="Fetch Api"></a>Fetch Api</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>使用 <code>fetch</code> 函数即可立即向服务器发送网络请求</p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>该函数有两个参数：</p>
<ol>
<li>必填，字符串，请求地址</li>
<li>选填，对象，请求配置</li>
</ol>
<h3 id="请求配置对象"><a href="#请求配置对象" class="headerlink" title="请求配置对象"></a><strong>请求配置对象</strong></h3><ul>
<li>method：字符串，请求方法，默认值GET</li>
<li>headers：对象，请求头信息</li>
<li>body: 请求体的内容，必须匹配请求头中的 Content-Type</li>
<li>mode：字符串，请求模式<ul>
<li>cors：默认值，配置为该值，会在请求头中加入 origin 和 referer</li>
<li>no-cors：配置为该值，不会在请求头中加入 origin 和 referer，跨域的时候可能会出现问题</li>
<li>same-origin：指示请求必须在同一个域中发生，如果请求其他域，则会报错</li>
</ul>
</li>
<li>credentials: 如何携带凭据（cookie）<ul>
<li>omit：默认值，不携带cookie</li>
<li>same-origin：请求同源地址时携带cookie</li>
<li>include：请求任何地址都携带cookie</li>
</ul>
</li>
<li>cache：配置缓存模式<ul>
<li>default: 表示fetch请求之前将检查下http的缓存.</li>
<li>no-store: 表示fetch请求将完全忽略http缓存的存在. 这意味着请求之前将不再检查下http的缓存, 拿到响应后, 它也不会更新http缓存.</li>
<li>no-cache: 如果存在缓存, 那么fetch将发送一个条件查询request和一个正常的request, 拿到响应后, 它会更新http缓存.</li>
<li>reload: 表示fetch请求之前将忽略http缓存的存在, 但是请求拿到响应后, 它将主动更新http缓存.</li>
<li>force-cache: 表示fetch请求不顾一切的依赖缓存, 即使缓存过期了, 它依然从缓存中读取. 除非没有任何缓存, 那么它将发送一个正常的request.</li>
<li>only-if-cached: 表示fetch请求不顾一切的依赖缓存, 即使缓存过期了, 它依然从缓存中读取. 如果没有缓存, 它将抛出网络错误(该设置只在mode为”same-origin”时有效).</li>
</ul>
</li>
</ul>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>fetch 函数返回一个 Promise 对象</p>
<ul>
<li>当收到服务器的返回结果后，Promise 进入resolved状态，状态数据为 Response 对象</li>
<li>当网络发生错误（或其他导致无法完成交互的错误）时，Promise 进入 rejected 状态，状态数据为错误信息</li>
</ul>
<h3 id="Response对象"><a href="#Response对象" class="headerlink" title="Response对象"></a><strong>Response对象</strong></h3><ul>
<li>ok：boolean，当响应消息码在200~299之间时为true，其他为false</li>
<li>status：number，响应的状态码</li>
<li>text()：用于处理文本格式的 Ajax 响应。它从响应中获取文本流，将其读完，然后返回一个被解决为 string 对象的 Promise。</li>
<li>blob()：用于处理二进制文件格式（比如图片或者电子表格）的 Ajax 响应。它读取文件的原始数据，一旦读取完整个文件，就返回一个被解决为 blob 对象的 Promise。</li>
<li>json()：用于处理 JSON 格式的 Ajax 的响应。它将 JSON 数据流转换为一个被解决为 JavaScript 对象的promise。</li>
<li>redirect()：可以用于重定向到另一个 URL。它会创建一个新的 Promise，以解决来自重定向的 URL 的响应。</li>
</ul>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>代理和反射</title>
    <url>/135xyq.github.io/2021/03/30/ES6-%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h1 id="代理和反射"><a href="#代理和反射" class="headerlink" title="代理和反射"></a>代理和反射</h1><h2 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h2><p>Property Descriptor 属性描述符  是一个普通对象，用于描述一个属性的相关信息</p>
<p>通过<code>Object.getOwnPropertyDescriptor(对象, 属性名)</code>可以得到一个对象的某个属性的属性描述符</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&#x27;a&#x27;</span>))</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">&#123;<span class="attr">value</span>: <span class="number">1</span>, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">configurable</span>: <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>value：属性值</li>
<li>configurable：该属性的描述符是否可以修改</li>
<li>enumerable：该属性是否可以被枚举</li>
<li>writable：该属性是否可以被重新赋值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">const obj = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 2</span><br><span class="line">&#125;</span><br><span class="line">console.log(Object.getOwnPropertyDescriptors(obj))</span><br><span class="line"></span><br><span class="line">// 输出结果：</span><br><span class="line">// a: &#123;value: 1, writable: true, enumerable: true, configurable: true&#125;</span><br><span class="line">// b: &#123;value: 2, writable: true, enumerable: true, configurable: true&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要为某个对象添加属性时 或 修改属性时， 配置其属性描述符，可以使用下面的代码:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(对象, 属性名, 描述符);</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(对象, 多个属性的描述符)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;b&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">7</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperties(obj, &#123;</span><br><span class="line">    <span class="attr">a</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="number">3</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">b</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="存取器属性"><a href="#存取器属性" class="headerlink" title="存取器属性"></a>存取器属性</h2><p>属性描述符中，如果配置了 get 和 set 中的任何一个，则该属性，不再是一个普通属性，而变成了存取器属性。</p>
<p>get 和 set配置均为函数，如果一个属性是存取器属性，则读取该属性时，会运行get方法，将get方法得到的返回值作为属性值；如果给该属性赋值，则会运行set方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;b&#x27;</span>, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;调用了get方法!&quot;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;调用了set方法！&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">obj.b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="comment">// 调用了set方法！</span></span><br><span class="line"><span class="comment">// 调用了get方法!</span></span><br><span class="line"><span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 变成正常的属性（将值先存储到其他变量中）</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;b&#x27;</span>, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;调用了get方法!&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> obj._a;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;调用了set方法！&quot;</span>)</span><br><span class="line">        obj._a = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">obj.b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.b)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="comment">// 调用了set方法！</span></span><br><span class="line"><span class="comment">// 调用了get方法!</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>存取器属性最大的意义，在于可以控制属性的读取和赋值。</p>
<h2 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h2><h3 id="1-Reflect是什么？"><a href="#1-Reflect是什么？" class="headerlink" title="1. Reflect是什么？"></a>1. Reflect是什么？</h3><p>Reflect是一个内置的JS对象，它提供了一系列方法，可以让开发者通过调用这些方法，访问一些JS底层功能</p>
<p>由于它类似于其他语言的<strong>反射</strong>，因此取名为Reflect</p>
<h3 id="2-它可以做什么？"><a href="#2-它可以做什么？" class="headerlink" title="2. 它可以做什么？"></a>2. 它可以做什么？</h3><p>使用Reflect可以实现诸如 属性的赋值与取值、调用普通函数、调用构造函数、判断属性是否存在与对象中  等等功能</p>
<h3 id="3-这些功能不是已经存在了吗？为什么还需要用Reflect实现一次？"><a href="#3-这些功能不是已经存在了吗？为什么还需要用Reflect实现一次？" class="headerlink" title="3. 这些功能不是已经存在了吗？为什么还需要用Reflect实现一次？"></a>3. 这些功能不是已经存在了吗？为什么还需要用Reflect实现一次？</h3><p>有一个重要的理念，在ES5就被提出：减少魔法、让代码更加纯粹</p>
<p>这种理念很大程度上是受到函数式编程的影响</p>
<p>ES6进一步贯彻了这种理念，它认为，对属性内存的控制、原型链的修改、函数的调用等等，这些都属于底层实现，属于一种魔法，因此，需要将它们提取出来，形成一个正常的API，并高度聚合到某个对象中，于是，就造就了Reflect对象</p>
<p>因此，你可以看到Reflect对象中有很多的API都可以使用过去的某种语法或其他API实现。</p>
<h3 id="4-它里面到底提供了哪些API呢？"><a href="#4-它里面到底提供了哪些API呢？" class="headerlink" title="4. 它里面到底提供了哪些API呢？"></a>4. 它里面到底提供了哪些API呢？</h3><ul>
<li>Reflect.set(target, propertyKey, value): 设置对象target的属性propertyKey的值为value，等同于给对象的属性赋值</li>
<li>Reflect.get(target, propertyKey): 读取对象target的属性propertyKey，等同于读取对象的属性值</li>
<li>Reflect.apply(target, thisArgument, argumentsList)：调用一个指定的函数，并绑定this和参数列表。等同于函数调用</li>
<li>Reflect.deleteProperty(target, propertyKey)：删除一个对象的属性</li>
<li>Reflect.defineProperty(target, propertyKey, attributes)：类似于Object.defineProperty，不同的是如果配置出现问题，返回false而不是报错</li>
<li>Reflect.construct(target, argumentsList)：用构造函数的方式创建一个对象</li>
<li>Reflect.has(target, propertyKey): 判断一个对象是否拥有一个属性</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">其他API</a></li>
</ul>
<h2 id="Proxy-代理"><a href="#Proxy-代理" class="headerlink" title="Proxy 代理"></a>Proxy 代理</h2><p>代理：提供了修改底层实现的方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//代理一个目标对象</span></span><br><span class="line"><span class="comment">//target：目标对象</span></span><br><span class="line"><span class="comment">//handler：是一个普通对象，其中可以重写底层实现</span></span><br><span class="line"><span class="comment">//返回一个代理对象</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6新增的集合</title>
    <url>/135xyq.github.io/2021/03/13/ES6-%E5%85%B6%E4%BB%96%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h1 id="其他集合"><a href="#其他集合" class="headerlink" title="其他集合"></a>其他集合</h1><hr>
<h2 id="set-集合"><a href="#set-集合" class="headerlink" title="set 集合"></a>set 集合</h2><p><strong>set 用于存放不重复的数据</strong></p>
<h3 id="1-如何创建-set-集合"><a href="#1-如何创建-set-集合" class="headerlink" title="1. 如何创建 set 集合"></a>1. 如何创建 set 集合</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Set</span>(); <span class="comment">//创建一个没有任何内容的set集合</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Set</span>(iterable); <span class="comment">//创建一个具有初始内容的set集合，内容来自于可迭代对象每一次迭代的结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="comment">// Set(5) &#123;1, 2, 3, 4, 5&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-如何对-set-集合进行后续操作"><a href="#2-如何对-set-集合进行后续操作" class="headerlink" title="2. 如何对 set 集合进行后续操作"></a>2. 如何对 set 集合进行后续操作</h3><ul>
<li>add(数据): 添加一个数据到 set 集合末尾，如果数据已存在，则不进行任何操作<ul>
<li>  set 使用 Object.is 的方式判断两个数据是否相同，但是，针对+0 和-0，set 认为是相等</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">s.add(<span class="number">1</span>);</span><br><span class="line">s.add(<span class="number">2</span>);</span><br><span class="line">s.add(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br></pre></td></tr></table></figure>

<ul>
<li>  has(数据): 判断 set 中是否存在对应的数据</li>
<li>  delete(数据)：删除匹配的数据，返回是否删除成功</li>
<li>  clear()：清空整个 set 集合</li>
<li>  size: 获取 set 集合中的元素数量，只读属性，无法重新赋值</li>
</ul>
<h3 id="3-如何与数组进行相互转换"><a href="#3-如何与数组进行相互转换" class="headerlink" title="3. 如何与数组进行相互转换"></a>3. 如何与数组进行相互转换</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([x, x, x, x, x]);</span><br><span class="line"><span class="comment">// set本身也是一个可迭代对象，每次迭代的结果就是每一项的值</span></span><br><span class="line"><span class="keyword">const</span> arr = [...s];</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将集合变为数组</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]);</span><br><span class="line"><span class="keyword">const</span> result = [...s];</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>

<h3 id="4-如何遍历"><a href="#4-如何遍历" class="headerlink" title="4. 如何遍历"></a>4. 如何遍历</h3><p>1). 使用 for-of 循环</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> s) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：1 2 3 4 5 6 7</span></span><br></pre></td></tr></table></figure>

<p>2). 使用 set 中的实例方法 forEach</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>]);</span><br><span class="line">set.forEach(<span class="function">(<span class="params">item,index</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item,index)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 1 1</span></span><br><span class="line"><span class="comment">// 2 2</span></span><br><span class="line"><span class="comment">// 3 3</span></span><br><span class="line"><span class="comment">// 4 4</span></span><br><span class="line"><span class="comment">// 5 5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意：set集合中不存在下标，因此forEach中的回调的第二个参数和第一个参数是一致的，均表示set中的每一项</strong></p>
<h3 id="set的应用"><a href="#set的应用" class="headerlink" title="set的应用"></a>set的应用</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">24</span>, <span class="number">42</span>, <span class="number">32</span>, <span class="number">34</span>, <span class="number">42</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">90</span>, <span class="number">86</span>, <span class="number">32</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">24</span>, <span class="number">47</span>, <span class="number">32</span>, <span class="number">38</span>, <span class="number">49</span>, <span class="number">11</span>, <span class="number">32</span>, <span class="number">90</span>, <span class="number">47</span>];</span><br><span class="line"><span class="comment">// 求两个数组的并集</span></span><br><span class="line"><span class="keyword">const</span> arr3 = [...new <span class="built_in">Set</span>([...arr1, ...arr2])];</span><br><span class="line"><span class="built_in">console</span>.log(arr3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求两个数组的交集</span></span><br><span class="line"><span class="keyword">const</span> arr4 = <span class="keyword">new</span> <span class="built_in">Set</span>(arr1);</span><br><span class="line"><span class="keyword">const</span> arr5 = [...new <span class="built_in">Set</span>(arr2)];</span><br><span class="line"><span class="keyword">const</span> result = arr5.filter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> arr4.has(item);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求两个数组的差集</span></span><br><span class="line"><span class="keyword">const</span> result1 = arr3.filter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !(arr4.has(item))</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(result1)</span><br></pre></td></tr></table></figure>

<h2 id="map-集合"><a href="#map-集合" class="headerlink" title="map 集合"></a>map 集合</h2><p>键值对（key value pair）数据集合的特点：键不可重复</p>
<p>map 集合专门用于存储多个键值对数据。</p>
<p>在 map 出现之前，我们使用的是对象的方式来存储键值对，键是属性名，值是属性值。</p>
<h3 id="使用对象存储有以下问题："><a href="#使用对象存储有以下问题：" class="headerlink" title="使用对象存储有以下问题："></a>使用对象存储有以下问题：</h3><ol>
<li>键名只能是字符串</li>
<li>获取数据的数量不方便</li>
<li>键名容易跟原型上的名称冲突</li>
</ol>
<h3 id="1-如何创建-map"><a href="#1-如何创建-map" class="headerlink" title="1. 如何创建 map"></a>1. 如何创建 map</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Map</span>(); <span class="comment">//创建一个空的map</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Map</span>(iterable); <span class="comment">//创建一个具有初始内容的map，初始内容来自于可迭代对象每一次迭代的结果，但是，它要求每一次迭代的结果必须是一个长度为2的数组，数组第一项表示键，数组的第二项表示值</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mp = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">   [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">   [<span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">   [<span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">   [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">]);</span><br><span class="line"><span class="built_in">console</span>.log(mp)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="function"><span class="title">Map</span>(<span class="params"><span class="number">3</span></span>)</span> &#123;<span class="number">1</span> =&gt; <span class="number">2</span>, <span class="number">3</span> =&gt; <span class="number">4</span>, <span class="number">5</span> =&gt; <span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-属性和方法"><a href="#2-属性和方法" class="headerlink" title="2. 属性和方法"></a>2. 属性和方法</h3><ul>
<li>  size：只读属性，获取当前 map 中键的数量</li>
<li>set(键, 值)：设置一个键值对，键和值可以是任何类型<ul>
<li>  如果键不存在，则添加一项</li>
<li>  如果键已存在，则修改它的值</li>
<li>  比较键的方式和 set 相同</li>
</ul>
</li>
<li>  get(键): 根据一个键得到对应的值</li>
<li>  has(键)：判断某个键是否存在</li>
<li>  delete(键)：删除指定的键</li>
<li>  clear(): 清空 map</li>
</ul>
<h3 id="3-和数组互相转换"><a href="#3-和数组互相转换" class="headerlink" title="3. 和数组互相转换"></a>3. 和数组互相转换</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mp = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">    [<span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">    [<span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">]);</span><br><span class="line"><span class="keyword">const</span> arr = [...mp];</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">(<span class="number">3</span>) [<span class="built_in">Array</span>(<span class="number">2</span>), <span class="built_in">Array</span>(<span class="number">2</span>), <span class="built_in">Array</span>(<span class="number">2</span>)]</span><br><span class="line"><span class="number">0</span>: (<span class="number">2</span>) [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="number">1</span>: (<span class="number">2</span>) [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="number">2</span>: (<span class="number">2</span>) [<span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>

<h3 id="4-遍历"><a href="#4-遍历" class="headerlink" title="4. 遍历"></a>4. 遍历</h3><ul>
<li>  for-of，每次迭代得到的是一个长度为 2 的数组</li>
<li>forEach，通过回调函数遍历<ul>
<li>  参数 1：每一项的值</li>
<li>  参数 2：每一项的键</li>
<li>  参数 3：map 本身</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>,<span class="string">&quot;a&quot;</span>],[<span class="number">2</span>,<span class="string">&quot;b&quot;</span>],[<span class="number">3</span>,<span class="string">&quot;c&quot;</span>]])</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [key,value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key,value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="number">1</span> <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="number">2</span> <span class="string">&#x27;b&#x27;</span></span><br><span class="line"><span class="number">3</span> <span class="string">&#x27;c&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mp = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">    [<span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">    [<span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">]);</span><br><span class="line">mp.forEach(<span class="function">(<span class="params">value, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value, index, array)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="function"><span class="title">Map</span>(<span class="params"><span class="number">3</span></span>)</span> &#123;<span class="number">1</span> =&gt; <span class="number">2</span>, <span class="number">3</span> =&gt; <span class="number">4</span>, <span class="number">5</span> =&gt; <span class="number">6</span>&#125;</span><br><span class="line"><span class="number">4</span> <span class="number">3</span> <span class="function"><span class="title">Map</span>(<span class="params"><span class="number">3</span></span>)</span> &#123;<span class="number">1</span> =&gt; <span class="number">2</span>, <span class="number">3</span> =&gt; <span class="number">4</span>, <span class="number">5</span> =&gt; <span class="number">6</span>&#125;</span><br><span class="line"><span class="number">6</span> <span class="number">5</span> <span class="function"><span class="title">Map</span>(<span class="params"><span class="number">3</span></span>)</span> &#123;<span class="number">1</span> =&gt; <span class="number">2</span>, <span class="number">3</span> =&gt; <span class="number">4</span>, <span class="number">5</span> =&gt; <span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6中的变量 字符串 函数对象</title>
    <url>/135xyq.github.io/2021/03/01/ES6-%E5%8F%98%E9%87%8F_%E5%AD%97%E7%AC%A6%E4%B8%B2%20_%E5%87%BD%E6%95%B0%20_%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="变量-字符串-函数-对象"><a href="#变量-字符串-函数-对象" class="headerlink" title="变量 字符串 函数 对象"></a>变量 字符串 函数 对象</h1><hr>
<h2 id="变量："><a href="#变量：" class="headerlink" title="变量："></a>变量：</h2><h3 id="let-声明变量："><a href="#let-声明变量：" class="headerlink" title="let 声明变量："></a>let 声明变量：</h3><ul>
<li>  解决全局污染问题，let 声明的变量不会挂载到全局变量。</li>
<li>  let 声明的变量，不允许在一个作用域范围内（全局作用域，函数作用域，块级作用域）重复声明 。</li>
<li>  块级作用域：{}，在块级作用域中定义的变量，在外部无法访问。</li>
<li>  let 变量不会变量提升，不能在定义之前使用该变量。</li>
<li>  在循环中，用 let 声明的变量会进行特殊处理，每次进入循环体，都会开启一个新的作用域，并且将循环变- 量绑定到该作用域（每次循环使用的是一个全新的变量）。</li>
<li>  用 let 声明的循环变量在循环结束时会自动销毁。</li>
</ul>
<h3 id="const-声明常量："><a href="#const-声明常量：" class="headerlink" title="const 声明常量："></a>const 声明常量：</h3><ul>
<li>  const 和 let 完全相同，仅在于 const 声明的变量，必须在变量声明时赋值，而且不可以重新赋值。</li>
<li>  多使用 const 避免犯错。</li>
<li>  const 声明一个对象时，对象里面的属性是可以更改的，仅仅是对象的名不能重新赋值。</li>
<li>  在 for 循环中循环变量不能使用 const 常量，在 for in 循环中可以使用。</li>
</ul>
<h2 id="字符串："><a href="#字符串：" class="headerlink" title="字符串："></a>字符串：</h2><h3 id="字符串-API（以下全为实例方法）："><a href="#字符串-API（以下全为实例方法）：" class="headerlink" title="字符串 API（以下全为实例方法）："></a>字符串 API（以下全为实例方法）：</h3><ul>
<li>  includes（子字符串，开始查找的索引值（可省略，默认从 0 开始））：判断字符串是否包含指定的子字符串。</li>
<li>  startWith（子字符串，开始查找的索引值（可省略，默认从 0 开始））:是否以指定字符串开头。</li>
<li>  endWith（子字符串，字符串的长度（可省略，默认为字符串 长度））：是否以指定字符串结尾。</li>
<li>  repeat（count）：将字符串重复指定的次数，重新返回一个新的字符串。</li>
</ul>
<h3 id="模板字符串："><a href="#模板字符串：" class="headerlink" title="模板字符串："></a>模板字符串：</h3><p>写在 `` 里面，<br>要拼接字符串，将要拼接的字符串加在${}里。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> level1 = <span class="string">&quot;谢永强&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> level2 = <span class="string">&quot;帅&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> txt = <span class="string">`我感觉<span class="subst">$&#123;level1&#125;</span>很<span class="subst">$&#123;level2&#125;</span>`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(txt);</span><br></pre></td></tr></table></figure>

<p>在模板字符串前面加上标记 ： String.raw ,可以将模板字符串里面的特殊字符直接输出。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> text1 = <span class="built_in">String</span>.raw<span class="string">`谢永强\t真帅！`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(text1);</span><br></pre></td></tr></table></figure>

<h2 id="函数："><a href="#函数：" class="headerlink" title="函数："></a>函数：</h2><h3 id="参数默认值："><a href="#参数默认值：" class="headerlink" title="参数默认值："></a>参数默认值：</h3><p>参数默认值，在定义函数时直接给形参赋值，如果调用函数时不传递参数（或传递 undefined），则使用默认值。<br>在严格模式下（“use strict”）下形参和 arguments 是脱离的（不再满足一一映射关系），只要给函数加上了参数默认值，该函数会自动变成严格模式下的规则（形参和 arguments 是脱离的）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a, b = <span class="number">4</span></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(a + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剩余参数："><a href="#剩余参数：" class="headerlink" title="剩余参数："></a>剩余参数：</h3><p><code>函数名.length</code> :可得到函数形参的个数<br>解决参数数量不确定情况下的问题。<br>实现方法：在函数是形参中加上 （…数组名）就可以了，用一个数组收集剩下的所有参数。<br>一个函数只能有一个剩余参数。<br>一个函数如果有剩余参数，剩余参数必须是最后一个参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b, ...args</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">	sum = sum + a + b;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">		sum += args[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="展开运算符："><a href="#展开运算符：" class="headerlink" title="展开运算符："></a>展开运算符：</h3><p>作用：将数组的每一项分别提取出来。<br>语法：在要展开的数组和对象前面加上(…数组名 / …对象名)。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>];</span><br><span class="line"><span class="built_in">console</span>.log(...arr);</span><br><span class="line"><span class="comment">// 输出结果：1 2 3 4 5 6 7 8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&quot;xyq&quot;</span>,</span><br><span class="line">	<span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">	<span class="attr">sex</span>: <span class="string">&quot;male&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">	...obj,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj1, obj === obj1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// &#123;name: &#x27;xyq&#x27;, age: 20, sex: &#x27;male&#x27;&#125; false</span></span><br></pre></td></tr></table></figure>

<p>new.target :可用来判断函数是否用 new 来调用函数。</p>
<h3 id="this-指向："><a href="#this-指向：" class="headerlink" title="this 指向："></a>this 指向：</h3><ol>
<li>通过对象调用函数，this 指向对象</li>
<li>直接调用函数，this 指向全局对象</li>
<li>如果通过 new 调用函数，this 指向新创建的对象</li>
<li>如果通过 apply、call、bind 等调用函数，this 指向指定的数据</li>
<li>如果是 dom 对象，this 指向事件源</li>
</ol>
<h3 id="箭头函数："><a href="#箭头函数：" class="headerlink" title="箭头函数："></a>箭头函数：</h3><h4 id="使用语法"><a href="#使用语法" class="headerlink" title="使用语法"></a>使用语法</h4><p>箭头函数是一个函数表达式，理论上，任何使用函数表达式的场景都可以使用箭头函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 完整语法：</span></span><br><span class="line"> (参数<span class="number">1</span>, 参数<span class="number">2</span>, ...)=&gt;&#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果参数只有一个，可以省略小括号</span></span><br><span class="line">参数 =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果箭头函数只有一条返回语句，可以省略大括号，和return关键字</span></span><br><span class="line">参数 =&gt; 返回值</span><br></pre></td></tr></table></figure>

<h4 id="注意细节"><a href="#注意细节" class="headerlink" title="注意细节"></a>注意细节</h4><ul>
<li>  箭头函数中，不存在 this、arguments、new.target，如果使用了，则使用的是函数外层的对应的 this、arguments、new.target</li>
<li>  箭头函数没有原型</li>
<li>  箭头函数不能作用构造函数使用</li>
</ul>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>临时性使用的函数，并不会可以调用它，比如：</p>
<ul>
<li>  事件处理函数</li>
<li>  异步处理函数</li>
<li>  其他临时性的函数</li>
<li>  为了绑定外层 this 的函数</li>
<li>  在不影响其他代码的情况下，保持代码的简洁，最常见的，数组方法中的回调函数</li>
</ul>
<h2 id="对象："><a href="#对象：" class="headerlink" title="对象："></a>对象：</h2><h3 id="变量字面量语法："><a href="#变量字面量语法：" class="headerlink" title="变量字面量语法："></a>变量字面量语法：</h3><h4 id="成员速写："><a href="#成员速写：" class="headerlink" title="成员速写："></a>成员速写：</h4><p>如果对象字面量初始化时，成员的名称来自于一个变量，并且和变量的名称相同，则可以进行简写，可将 变量名：变量名 简写成 变量名</p>
<h4 id="方法速写："><a href="#方法速写：" class="headerlink" title="方法速写："></a>方法速写：</h4><p>可以将：function 省略。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">name, age, sex</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		name,</span><br><span class="line">		age,</span><br><span class="line">		sex,</span><br><span class="line">		<span class="function"><span class="title">fuc</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="number">123</span>);</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="计算属性名："><a href="#计算属性名：" class="headerlink" title="计算属性名："></a>计算属性名：</h4><p>有的时候，初始化对象时，某些属性名可能来自于某个表达式的值，在 ES6，可以使用中括号来表示该属性名是通过计算得到的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> prop1 = <span class="string">&quot;name&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> prop2 = <span class="string">&quot;age&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> prop3 = <span class="string">&quot;sex&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">	[prop1]: <span class="string">&quot;xyq&quot;</span>,</span><br><span class="line">	[prop2]: <span class="number">20</span>,</span><br><span class="line">	[prop3]: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj1);</span><br></pre></td></tr></table></figure>

<h3 id="Object-的新增-API："><a href="#Object-的新增-API：" class="headerlink" title="Object 的新增 API："></a>Object 的新增 API：</h3><ul>
<li>Object.is:<br>  判断两个对象是否相等，基本和 === 是一致的，除了 NaN 和 NaN 相等 、 +0 和-0 不相等</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>), <span class="literal">NaN</span> === <span class="literal">NaN</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(+<span class="number">0</span>, -<span class="number">0</span>), +<span class="number">0</span> === -<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// true false</span></span><br><span class="line"><span class="comment">// false true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Object.assign：<br>  用于混合对象（可以用展开运算符实现）；<br>  缺陷：会更改原来的第一个对象，解决方案：第一个参数传递一个空对象</li>
<li>Object.getOwnPropertyNames:<br>  Object.getOwnPropertyNames 方法之前就存在，只不过，官方没有明确要求，对属性的顺序如何排序，如何排序，完全由浏览器厂商决定。<br>  ES6 规定了该方法返回的数组的排序方式如下：<br>  先排数字，并按照升序排序<br>  再排其他，按照书写顺序排序</li>
<li>Object.setPrototypeOf<br>  该函数用于设置某个对象的隐式原型<br>  比如： <code>Object.setPrototypeOf(obj1, obj2)， 相当于： obj1.__proto__ = obj2</code></li>
</ul>
<h2 id="类："><a href="#类：" class="headerlink" title="类："></a>类：</h2><h3 id="传统的构造函数的问题"><a href="#传统的构造函数的问题" class="headerlink" title="传统的构造函数的问题"></a>传统的构造函数的问题</h3><ul>
<li>  属性和原型方法定义分离，降低了可读性</li>
<li>  原型成员可以被枚举</li>
<li>  默认情况下，构造函数仍然可以被当作普通函数使用</li>
</ul>
<h3 id="类的特点"><a href="#类的特点" class="headerlink" title="类的特点"></a>类的特点</h3><ul>
<li>  类声明不会被提升，与 let 和 const 一样，存在暂时性死区</li>
<li>  类中的所有代码均在严格模式下执行</li>
<li>  类的所有方法都是不可枚举的</li>
<li>  类的所有方法都无法被当作构造函数使用</li>
<li>  类的构造器必须使用 new 来调用</li>
</ul>
<h3 id="类的语法："><a href="#类的语法：" class="headerlink" title="类的语法："></a>类的语法：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    <span class="title">constructor</span>（参数）&#123;</span><br><span class="line">        属性值</span><br><span class="line">    &#125;</span><br><span class="line">    方法名()&#123;</span><br><span class="line">        方法体</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 构造函数，写属性</span></span><br><span class="line">	<span class="function"><span class="title">constructor</span>(<span class="params">type, name, age, sex</span>)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.type = type;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">		<span class="built_in">this</span>.sex = sex;</span><br><span class="line">	&#125; <span class="comment">// 方法</span></span><br><span class="line">	<span class="function"><span class="title">print</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">`【种类】：<span class="subst">$&#123;<span class="built_in">this</span>.type&#125;</span>`</span>);</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">`【名字】：<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">`【年龄】：<span class="subst">$&#123;<span class="built_in">this</span>.age&#125;</span>`</span>);</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">`【性别】：<span class="subst">$&#123;<span class="built_in">this</span>.sex&#125;</span>`</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类里面属性的获取和更改："><a href="#类里面属性的获取和更改：" class="headerlink" title="类里面属性的获取和更改："></a>类里面属性的获取和更改：</h3><p>可达到像普通对象一样直接获取，设置属性又不保证安全。</p>
<h4 id="获取："><a href="#获取：" class="headerlink" title="获取："></a>获取：</h4><p>可定义一个方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">get 属性名（）&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="更改："><a href="#更改：" class="headerlink" title="更改："></a>更改：</h4><p>定义一个方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">set 属性名（参数）&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">set</span> <span class="title">age</span>(<span class="params">val</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (val &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			val = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">this</span>._age = val;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">get</span> <span class="title">age</span>() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>._age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="title">print</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="built_in">this</span>._age);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> test = <span class="keyword">new</span> Test(<span class="string">&quot;xyq&quot;</span>, <span class="number">21</span>);</span><br><span class="line"><span class="built_in">console</span>.log(test.age);</span><br><span class="line">test.age = <span class="number">22</span>;</span><br><span class="line"><span class="built_in">console</span>.log(test.age);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="comment">// 21</span></span><br><span class="line"><span class="comment">// 22</span></span><br></pre></td></tr></table></figure>

<h3 id="静态成员："><a href="#静态成员：" class="headerlink" title="静态成员："></a>静态成员：</h3><p>直接定义在类上的属性或方法，在类中用关键字 static 定义，不用创建实例对象就可以访问的属性，创建的实例对象不可以访问这个属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> a = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="function"><span class="title">b</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">set</span> <span class="title">age</span>(<span class="params">val</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (val &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			val = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">this</span>._age = val;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">get</span> <span class="title">age</span>() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>._age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="title">print</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字段初始化器："><a href="#字段初始化器：" class="headerlink" title="字段初始化器："></a>字段初始化器：</h3><p>可以将一些有固定值的属性直接写在构造函数外面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	sex = <span class="string">&quot;男&quot;</span>;</span><br><span class="line">	<span class="keyword">static</span> a = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="function"><span class="title">b</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">set</span> <span class="title">age</span>(<span class="params">val</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (val &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			val = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">this</span>._age = val;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">get</span> <span class="title">age</span>() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>._age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="title">print</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><h4 id="如果两个类-A-和-B，如果可以描述为：B-是-A，则，A-和-B-形成继承关系则："><a href="#如果两个类-A-和-B，如果可以描述为：B-是-A，则，A-和-B-形成继承关系则：" class="headerlink" title="如果两个类 A 和 B，如果可以描述为：B 是 A，则，A 和 B 形成继承关系则："></a>如果两个类 A 和 B，如果可以描述为：B 是 A，则，A 和 B 形成继承关系则：</h4><ul>
<li>  B 继承自 A</li>
<li>  A 派生 B</li>
<li>  B 是 A 的子类</li>
<li>  A 是 B 的父类  </li>
</ul>
<p>如果 A 是 B 的父类，则 B 会自动拥有 A 中的所有实例成员。</p>
<h4 id="继承的关键字："><a href="#继承的关键字：" class="headerlink" title="继承的关键字："></a>继承的关键字：</h4><p>extends：继承，用于类的定义<br>super</p>
<ul>
<li>  直接当作函数调用，表示父类构造函数</li>
<li>  如果当作对象使用，则表示父类的原型</li>
</ul>
<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><ul>
<li>  ES6 要求，如果定义了 constructor，并且该类是子类，则必须在 constructor 的第一行手动调用父类的构造函数</li>
<li>  如果子类不写 constructor，则会有默认的构造器，该构造器需要的参数和父类一致，并且自动调用父类构造器</li>
</ul>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><h5 id="用-JS-制作抽象类"><a href="#用-JS-制作抽象类" class="headerlink" title="用 JS 制作抽象类"></a>用 JS 制作抽象类</h5><p>抽象类：一般是父类，不能通过该类创建对象<br>正常情况下，this 的指向，this 始终指向具体的类的对象</p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6中的解构 符号 异步处理</title>
    <url>/135xyq.github.io/2021/03/20/ES6-%E8%A7%A3%E6%9E%84_%E7%AC%A6%E5%8F%B7_%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="解构-符号-异步处理"><a href="#解构-符号-异步处理" class="headerlink" title="解构 符号 异步处理"></a>解构 符号 异步处理</h1><hr>
<h2 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h2><p>将数组或对象的某一属性提取到变量中(可以互相嵌套使用)<br>可以给结构出来的变量赋默认值（变量名 = 默认值）</p>
<h3 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h3><h4 id="解构剩余参数："><a href="#解构剩余参数：" class="headerlink" title="解构剩余参数："></a>解构剩余参数：</h4><p>将剩余的所有参数都敢放到一个数组或对象中（使用展开运算符）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> [nn1, ...arr1] = arr;</span><br><span class="line"><span class="built_in">console</span>.log(nn1, arr1);</span><br><span class="line"><span class="comment">// 将第一个结构出来，其他放到arr1 数组中</span></span><br></pre></td></tr></table></figure>

<h4 id="同名解构（变量名要和属性名一致）"><a href="#同名解构（变量名要和属性名一致）" class="headerlink" title="同名解构（变量名要和属性名一致）"></a>同名解构（变量名要和属性名一致）</h4><h5 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h5><ul>
<li>  先定义再解构变量：（{变量名，…..} = 对象名）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&quot;xyq&quot;</span>,</span><br><span class="line">	<span class="attr">sex</span>: <span class="string">&quot;male&quot;</span>,</span><br><span class="line">	<span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">	<span class="attr">address</span>: &#123;</span><br><span class="line">		<span class="attr">province</span>: <span class="string">&quot;河南&quot;</span>,</span><br><span class="line">		<span class="attr">city</span>: <span class="string">&quot;驻马店&quot;</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> name, age;</span><br><span class="line"></span><br><span class="line">(&#123; name, age &#125; = obj);</span><br><span class="line"><span class="built_in">console</span>.log(name, age);</span><br></pre></td></tr></table></figure>

<ul>
<li>  直接解构 ： let / const / var {变量名} = 对象名</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对象解构</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&quot;xyq&quot;</span>,</span><br><span class="line">	<span class="attr">sex</span>: <span class="string">&quot;male&quot;</span>,</span><br><span class="line">	<span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">	<span class="attr">address</span>: &#123;</span><br><span class="line">		<span class="attr">province</span>: <span class="string">&quot;河南&quot;</span>,</span><br><span class="line">		<span class="attr">city</span>: <span class="string">&quot;驻马店&quot;</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; name, sex, age, address &#125; = obj;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(t, sex, age, address);</span><br></pre></td></tr></table></figure>

<h4 id="异名解构"><a href="#异名解构" class="headerlink" title="异名解构"></a>异名解构</h4><p>```{属性名：变量名}`````</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将name解构成变量t</span></span><br><span class="line"><span class="keyword">let</span> &#123; name, <span class="attr">age</span>: t &#125; = obj;</span><br><span class="line"><span class="built_in">console</span>.log(name, t);</span><br></pre></td></tr></table></figure>

<h4 id="嵌套解构"><a href="#嵌套解构" class="headerlink" title="嵌套解构"></a>嵌套解构</h4><p><code>&#123;属性名：&#123;属性名&#125;</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">	name,</span><br><span class="line">	<span class="attr">address</span>: &#123; city &#125;,</span><br><span class="line">&#125; = obj;</span><br><span class="line"><span class="comment">// 此时address为 undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(city);</span><br></pre></td></tr></table></figure>

<h3 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h3><h4 id="模拟对象"><a href="#模拟对象" class="headerlink" title="模拟对象"></a>模拟对象</h4><p>数组可以看成特殊的对象，可以参考对象的异名解构</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="number">0</span>: n1, <span class="number">1</span>: n2 &#125; = arr;</span><br><span class="line"><span class="built_in">console</span>.log(n1, n2);</span><br></pre></td></tr></table></figure>

<h4 id="数组自己的结构"><a href="#数组自己的结构" class="headerlink" title="数组自己的结构"></a>数组自己的结构</h4><p>[变量名，，，，，变量名],按顺序结构数组，不想结构的对象用空格空出</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> [n1, n2, , n4] = arr;</span><br><span class="line"><span class="built_in">console</span>.log(n1, n2, n4);</span><br></pre></td></tr></table></figure>

<h3 id="参数解构"><a href="#参数解构" class="headerlink" title="参数解构"></a>参数解构</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//常用于函数参数的定义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">&#123; method = <span class="string">&quot;get&quot;</span>, url = <span class="string">&quot;/&quot;</span> &#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(method, url);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ajax();</span><br></pre></td></tr></table></figure>

<h2 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h2><p>对象的属性名一定是一个字符串</p>
<h3 id="普通符号"><a href="#普通符号" class="headerlink" title="普通符号"></a>普通符号</h3><p>符号是 ES6 新增的一个数据类型，它通过使用函数 <code>Symbol(符号描述)</code> 来创建</p>
<p>符号设计的初衷，是为了给对象设置私有属性</p>
<p>私有属性：只能在对象内部使用，外面无法使用</p>
<p>符号具有以下特点：</p>
<ul>
<li>  没有字面量</li>
<li>  使用 typeof 得到的类型是 symbol</li>
<li>  <strong>每次调用 Symbol 函数得到的符号永远不相等，无论符号名是否相同</strong></li>
<li>符号可以作为对象的属性名存在，这种属性称之为符号属性<ul>
<li>  开发者可以通过精心的设计，让这些属性无法通过常规方式被外界访问</li>
<li>  符号属性是不能枚举的，因此在 for-in 循环中无法读取到符号属性，Object.keys 方法也无法读取到符号属性</li>
<li>  Object.getOwnPropertyNames 尽管可以得到所有无法枚举的属性，但是仍然无法读取到符号属性</li>
<li>  ES6 新增 Object.getOwnPropertySymbols 方法，可以读取符号</li>
</ul>
</li>
<li>  符号无法被隐式转换，因此不能被用于数学运算、字符串拼接或其他隐式转换的场景，但符号可以显式的转换为字符串，通过 String 构造函数进行转换即可，console.log 之所以可以输出符号，是它在内部进行了显式转换</li>
</ul>
<h3 id="共享符号"><a href="#共享符号" class="headerlink" title="共享符号"></a>共享符号</h3><p>根据某个符号名称（符号描述）能够得到同一个符号</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>.for(<span class="string">&quot;符号名/符号描述&quot;</span>); <span class="comment">//获取共享符号</span></span><br></pre></td></tr></table></figure>

<h3 id="知名符号"><a href="#知名符号" class="headerlink" title="知名符号"></a>知名符号</h3><p>知名符号是一些具有特殊含义的共享符号，通过 Symbol 的静态属性得到</p>
<p>ES6 延续了 ES5 的思想：减少魔法，暴露内部实现！</p>
<p>因此，ES6 用知名符号暴露了某些场景的内部实现</p>
<ol>
<li>Symbol.hasInstance</li>
</ol>
<p>该符号用于定义构造函数的静态成员，它将影响 instanceof 的判定</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">obj <span class="keyword">instanceof</span> A;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等效于</span></span><br><span class="line"></span><br><span class="line">A[<span class="built_in">Symbol</span>.hasInstance](obj); <span class="comment">// Function.prototype[Symbol.hasInstance]</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Symbol.isConcatSpreadable</li>
</ol>
<p>该知名符号会影响数组的 concat 方法</p>
<ol start="3">
<li>Symbol.toPrimitive</li>
</ol>
<p>该知名符号会影响类型转换的结果</p>
<ol start="4">
<li>Symbol.toStringTag</li>
</ol>
<p>该知名符号会影响 Object.prototype.toString 的返回值</p>
<h2 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h2><h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>JS 运行的环境称之为宿主环境。</p>
<h4 id="执行栈："><a href="#执行栈：" class="headerlink" title="执行栈："></a>执行栈：</h4><p>call stack，一个数据结构，用于存放各种函数的执行环境，每一个函数执行之前，它的相关信息会加入到执行栈。函数调用之前，创建执行环境，然后加入到执行栈；函数调用之后，销毁执行环境。</p>
<p>JS 引擎永远执行的是执行栈的最顶部。</p>
<h4 id="异步函数："><a href="#异步函数：" class="headerlink" title="异步函数："></a>异步函数：</h4><p>某些函数不会立即执行，需要等到某个时机到达后才会执行，这样的函数称之为异步函数。比如事件处理函数。异步函数的执行时机，会被宿主环境控制。</p>
<h4 id="浏览器宿主环境中包含-5-个线程："><a href="#浏览器宿主环境中包含-5-个线程：" class="headerlink" title="浏览器宿主环境中包含 5 个线程："></a>浏览器宿主环境中包含 5 个线程：</h4><ol>
<li>JS 引擎：负责执行执行栈的最顶部代码</li>
<li>GUI 线程：负责渲染页面</li>
<li>事件监听线程：负责监听各种事件</li>
<li>计时线程：负责计时</li>
<li>网络线程：负责网络通信</li>
</ol>
<p>当上面的线程发生了某些事请，如果该线程发现，这件事情有处理程序，它会将该处理程序加入一个叫做事件队列的内存。当 JS 引擎发现，执行栈中已经没有了任何内容后，会将事件队列中的第一个函数加入到执行栈中执行。</p>
<p>JS 引擎对事件队列的取出执行方式，以及与宿主环境的配合，称之为事件循环。</p>
<p>事件队列在不同的宿主环境中有所差异，大部分宿主环境会将事件队列进行细分。在浏览器中，事件队列分为两种：</p>
<ul>
<li>  宏任务（队列）：macroTask，计时器结束的回调、事件回调、http 回调等等绝大部分异步函数进入宏队列</li>
<li>  微任务（队列）：MutationObserver，Promise 产生的回调进入微队列</li>
</ul>
<h4 id="MutationObserver-用于监听某个-DOM-对象的变化"><a href="#MutationObserver-用于监听某个-DOM-对象的变化" class="headerlink" title="MutationObserver 用于监听某个 DOM 对象的变化"></a>MutationObserver 用于监听某个 DOM 对象的变化</h4><p>当执行栈清空时，JS 引擎首先会将微任务中的所有任务依次执行结束，如果没有微任务，则执行宏任务。</p>
<h3 id="异步处理的通用模型"><a href="#异步处理的通用模型" class="headerlink" title="异步处理的通用模型"></a>异步处理的通用模型</h3><p>ES 官方参考了大量的异步场景，总结出了一套异步的通用模型，该模型可以覆盖几乎所有的异步场景，甚至是同步场景。</p>
<p>值得注意的是，为了兼容旧系统，ES6 并不打算抛弃掉过去的做法，只是基于该模型推出一个全新的 API，使用该 API，会让异步处理更加的简洁优雅。</p>
<p>理解该 API，最重要的，是理解它的异步模型</p>
<ol>
<li>ES6 将某一件可能发生异步操作的事情，分为两个阶段：<strong>unsettled</strong> 和 <strong>settled</strong></li>
</ol>
<p><img src="/images/ES6/%E8%A7%A3%E6%9E%84_%E7%AC%A6%E5%8F%B7_%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86-%E4%B8%A4%E4%B8%AA%E9%98%B6%E6%AE%B5.jpg"></p>
<ul>
<li>  unsettled： 未决阶段，表示事情还在进行前期的处理，并没有发生通向结果的那件事</li>
<li>  settled：已决阶段，事情已经有了一个结果，不管这个结果是好是坏，整件事情无法逆转</li>
</ul>
<p>事情总是从 未决阶段 逐步发展到 已决阶段的。并且，未决阶段拥有控制何时通向已决阶段的能力。</p>
<ol start="2">
<li>ES6 将事情划分为三种状态： pending、resolved、rejected</li>
</ol>
<ul>
<li>  pending: 挂起，处于未决阶段，则表示这件事情还在挂起（最终的结果还没出来）</li>
<li>  resolved：已处理，已决阶段的一种状态，表示整件事情已经出现结果，并是一个可以按照正常逻辑进行下去的结果</li>
<li>  rejected：已拒绝，已决阶段的一种状态，表示整件事情已经出现结果，并是一个无法按照正常逻辑进行下去的结果，通常用于表示有一个错误</li>
</ul>
<p>既然未决阶段有权力决定事情的走向，因此，未决阶段可以决定事情最终的状态！</p>
<p>我们将 把事情变为 resolved 状态的过程叫做：<strong>resolve</strong>，推向该状态时，可能会传递一些数据</p>
<p>我们将 把事情变为 rejected 状态的过程叫做：<strong>reject</strong>，推向该状态时，同样可能会传递一些数据，通常为错误信息</p>
<p><strong>始终记住，无论是阶段，还是状态，是不可逆的！</strong></p>
<p><img src="/images/ES6/%E8%A7%A3%E6%9E%84_%E7%AC%A6%E5%8F%B7_%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86-%E4%B8%A4%E4%B8%AA%E9%98%B6%E6%AE%B5%E7%9A%84%E8%BD%AC%E6%8D%A2.jpg"></p>
<ol start="3">
<li>当事情达到已决阶段后，通常需要进行后续处理，不同的已决状态，决定了不同的后续处理。</li>
</ol>
<ul>
<li>  resolved 状态：这是一个正常的已决状态，后续处理表示为 thenable</li>
<li>  rejected 状态：这是一个非正常的已决状态，后续处理表示为 catchable</li>
</ul>
<p>后续处理可能有多个，因此会形成作业队列，这些后续处理会按照顺序，当状态到达后依次执行</p>
<p><img src="/images/ES6/%E8%A7%A3%E6%9E%84_%E7%AC%A6%E5%8F%B7_%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86-%E5%90%8E%E7%BB%AD%E5%A4%84%E7%90%86%E7%8A%B6%E6%80%81.jpg"></p>
<ol start="4">
<li>整件事称之为 Promise</li>
</ol>
<p><img src="/images/ES6/%E8%A7%A3%E6%9E%84_%E7%AC%A6%E5%8F%B7_%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86-Promise.jpg"></p>
<h3 id="Promise-的基本用法"><a href="#Promise-的基本用法" class="headerlink" title="Promise 的基本用法"></a>Promise 的基本用法</h3><h4 id="格式："><a href="#格式：" class="headerlink" title="格式："></a>格式：</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pro = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// 未决阶段的处理</span></span><br><span class="line">	<span class="comment">// 通过调用resolve函数将Promise推向已决阶段的resolved状态</span></span><br><span class="line">	<span class="comment">// 通过调用reject函数将Promise推向已决阶段的rejected状态</span></span><br><span class="line">	<span class="comment">// resolve和reject均可以传递最多一个参数，表示推向状态的数据</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">pro.then(</span><br><span class="line">	<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="comment">//这是thenable函数，如果当前的Promise已经是resolved状态，该函数会立即执行</span></span><br><span class="line">		<span class="comment">//如果当前是未决阶段，则会加入到作业队列，等待到达resolved状态后执行</span></span><br><span class="line">		<span class="comment">//data为状态数据</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="comment">//这是catchable函数，如果当前的Promise已经是rejected状态，该函数会立即执行</span></span><br><span class="line">		<span class="comment">//如果当前是未决阶段，则会加入到作业队列，等待到达rejected状态后执行</span></span><br><span class="line">		<span class="comment">//err为状态数据</span></span><br><span class="line">	&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><ol>
<li>未决阶段的处理函数是同步的，会立即执行</li>
<li>thenable 和 catchable 函数是异步的，就算是立即执行，也会加入到事件队列中等待执行，并且，加入的队列是微队列</li>
<li>pro.then 可以只添加 thenable 函数，pro.catch 可以单独添加 catchable 函数</li>
<li>在未决阶段的处理函数中，如果发生未捕获的错误，会将状态推向 rejected，并会被 catchable 捕获</li>
<li>一旦状态推向了已决阶段，无法再对状态做任何更改</li>
<li><strong>Promise 并没有消除回调，只是让回调变得可控</strong></li>
</ol>
<h3 id="Promise-的串联"><a href="#Promise-的串联" class="headerlink" title="Promise 的串联"></a>Promise 的串联</h3><p>当后续的 Promise 需要用到之前的 Promise 的处理结果时，需要 Promise 的串联</p>
<h4 id="Promise-对象中，无论是-then-方法还是-catch-方法，它们都具有返回值，返回的是一个全新的-Promise-对象，它的状态满足下面的规则："><a href="#Promise-对象中，无论是-then-方法还是-catch-方法，它们都具有返回值，返回的是一个全新的-Promise-对象，它的状态满足下面的规则：" class="headerlink" title="Promise 对象中，无论是 then 方法还是 catch 方法，它们都具有返回值，返回的是一个全新的 Promise 对象，它的状态满足下面的规则："></a>Promise 对象中，无论是 then 方法还是 catch 方法，它们都具有返回值，返回的是一个全新的 Promise 对象，它的状态满足下面的规则：</h4><ol>
<li>如果当前的 Promise 是未决的，得到的新的 Promise 是挂起状态</li>
<li>如果当前的 Promise 是已决的，会运行相应的后续处理函数，并将后续处理函数的结果（返回值）作为 resolved 状态数据，应用到新的 Promise 中；如果后续处理函数发生错误，则把返回值作为 rejected 状态数据，应用到新的 Promise 中。</li>
</ol>
<p><strong>后续的 Promise 一定会等到前面的 Promise 有了后续处理结果后，才会变成已决状态</strong></p>
<p>如果前面的 Promise 的后续处理，返回的是一个 Promise，则返回的新的 Promise 状态和后续处理返回的 Promise 状态保持一致。</p>
<h3 id="Promise-的其他-api"><a href="#Promise-的其他-api" class="headerlink" title="Promise 的其他 api"></a>Promise 的其他 api</h3><h4 id="原型成员-实例成员"><a href="#原型成员-实例成员" class="headerlink" title="原型成员 (实例成员)"></a>原型成员 (实例成员)</h4><ul>
<li>  then：注册一个后续处理函数，当 Promise 为 resolved 状态时运行该函数</li>
<li>  catch：注册一个后续处理函数，当 Promise 为 rejected 状态时运行该函数</li>
<li>  finally：[ES2018]注册一个后续处理函数（无参），当 Promise 为已决时运行该函数</li>
</ul>
<h4 id="构造函数成员-（静态成员）"><a href="#构造函数成员-（静态成员）" class="headerlink" title="构造函数成员 （静态成员）"></a>构造函数成员 （静态成员）</h4><ul>
<li><p>resolve(数据)：该方法返回一个 resolved 状态的 Promise，传递的数据作为状态数据</p>
<ul>
<li>  特殊情况：如果传递的数据是 Promise，则直接返回传递的 Promise 对象</li>
</ul>
</li>
<li><p>  reject(数据)：该方法返回一个 rejected 状态的 Promise，传递的数据作为状态数据</p>
</li>
<li><p>  all(iterable)：这个方法返回一个新的 promise 对象，该 promise 对象在 iterable 参数对象里所有的 promise 对象都成功的时候才会触发成功，一旦有任何一个 iterable 里面的 promise 对象失败则立即触发该 promise 对象的失败。这个新的 promise 对象在触发成功状态以后，会把一个包含 iterable 里所有 promise 返回值的数组作为成功回调的返回值，顺序跟 iterable 的顺序保持一致；如果这个新的 promise 对象触发了失败状态，它会把 iterable 里第一个触发失败的 promise 对象的错误信息作为它的失败错误信息。Promise.all 方法常被用于处理多个 promise 对象的状态集合。</p>
</li>
<li><p>  race(iterable)：当 iterable 参数里的任意一个子 promise 被成功或失败后，父 promise 马上也会用子 promise 的成功返回值或失败详情作为参数调用父 promise 绑定的相应句柄，并返回该 promise 对象</p>
</li>
</ul>
<h3 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a>async 和 await</h3><p>async 和 await 是 ES2016 新增两个关键字，它们借鉴了 ES2015 中生成器在实际开发中的应用，目的是简化 Promise api 的使用，并非是替代 Promise。</p>
<h4 id="async"><a href="#async" class="headerlink" title="async"></a>async</h4><p>目的是简化在函数的返回值中对 Promise 的创建</p>
<p>async 用于修饰函数（无论是函数字面量还是函数表达式），放置在函数最开始的位置，被修饰函数的返回结果一定是 Promise 对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等效于</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">		resolve(<span class="number">2</span>);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="await"><a href="#await" class="headerlink" title="await"></a>await</h4><p><strong>await 关键字必须出现在 async 函数中！！！！</strong></p>
<p>await 用在某个表达式之前，如果表达式是一个 Promise，则得到的是 thenable 中的状态数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> result = <span class="keyword">await</span> test1();</span><br><span class="line">	<span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test2();</span><br></pre></td></tr></table></figure>

<p>等效于</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">		resolve(<span class="number">2</span>);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">		test1().then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">			<span class="keyword">const</span> result = data;</span><br><span class="line">			<span class="built_in">console</span>.log(result);</span><br><span class="line">			resolve();</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test2();</span><br></pre></td></tr></table></figure>

<p>如果 await 的表达式不是 Promise，则会将其使用 Promise.resolve 包装后按照规则运行</p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6新增的数组API</title>
    <url>/135xyq.github.io/2021/03/06/ES6-%E6%96%B0%E5%A2%9E%E6%95%B0%E7%BB%84API/</url>
    <content><![CDATA[<h1 id="数组增强"><a href="#数组增强" class="headerlink" title="数组增强"></a>数组增强</h1><h2 id="新增数组API"><a href="#新增数组API" class="headerlink" title="新增数组API"></a>新增数组API</h2><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><ul>
<li>Array.of(…args): 使用指定的数组项创建一个新数组</li>
<li>Array.from(arg): 通过给定的类数组 或 可迭代对象 创建一个新的数组。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = <span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// [3,4,5,6]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr2 = <span class="built_in">Array</span>.from([<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(arr2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// [5,6,7,8]</span></span><br></pre></td></tr></table></figure>
<h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><ul>
<li>find(callback): 用于查找满足条件的第一个元素</li>
<li>findIndex(callback)：用于查找满足条件的第一个元素的下标</li>
<li>fill(data)：用指定的数据填充满数组所有的内容</li>
<li>copyWithin(target, start?, end?): 在数组内部完成复制<ul>
<li>target：开始改变数组位置</li>
<li>start？：复制的开始位置（默认为0）</li>
<li>end？：复制的结束位置<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>];</span><br><span class="line"><span class="keyword">const</span> str = arr.find(<span class="function"><span class="params">item</span>=&gt;</span>item&gt;<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>];</span><br><span class="line"><span class="keyword">const</span> str1 = arr.findIndex(<span class="function"><span class="params">item</span>=&gt;</span>!(item%<span class="number">2</span>))</span><br><span class="line"><span class="built_in">console</span>.log(str1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>];</span><br><span class="line">arr.copyWithin(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// [1, 2, 3, 1,2,3,4,5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>];</span><br><span class="line">arr1.copyWithin(<span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// [1, 2, 3, 3, 4, 5, 6, 7]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>];</span><br><span class="line">arr2.copyWithin(<span class="number">3</span>, <span class="number">1</span>, <span class="number">6</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// [1, 2, 3, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>includes(data)：判断数组中是否包含某个值，使用Object.is匹配</li>
</ul>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>bom</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器和生成器</title>
    <url>/135xyq.github.io/2021/03/23/ES6-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/</url>
    <content><![CDATA[<h1 id="迭代器和生成器"><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h1><hr>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><ol>
<li>什么是迭代？</li>
</ol>
<p>从一个数据集合中按照一定的顺序，不断取出数据的过程</p>
<ol start="2">
<li>迭代和遍历的区别？</li>
</ol>
<p>迭代强调的是依次取数据，并不保证取多少，也不保证把所有的数据取完</p>
<p>遍历强调的是要把整个数据依次全部取出</p>
<ol start="3">
<li>迭代器</li>
</ol>
<p>对迭代过程的封装，在不同的语言中有不同的表现形式，通常为对象</p>
<ol start="4">
<li>迭代模式</li>
</ol>
<p>一种设计模式，用于统一迭代过程，并规范了迭代器规格：</p>
<ul>
<li>迭代器应该具有得到下一个数据的能力</li>
<li>迭代器应该具有判断是否还有后续数据的能力</li>
</ul>
<h3 id="JS中的迭代器"><a href="#JS中的迭代器" class="headerlink" title="JS中的迭代器"></a>JS中的迭代器</h3><p>JS规定，如果一个对象具有next方法，并且该方法返回一个对象，该对象的格式如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">value</span>: 值, <span class="attr">done</span>: 是否迭代完成&#125;</span><br></pre></td></tr></table></figure>

<p>则认为该对象是一个迭代器</p>
<p>含义：</p>
<ul>
<li>next方法：用于得到下一个数据</li>
<li>返回的对象<ul>
<li>value：下一个数据的值</li>
<li>done：boolean，是否迭代完成</li>
</ul>
</li>
</ul>
<h3 id="可迭代协议"><a href="#可迭代协议" class="headerlink" title="可迭代协议"></a>可迭代协议</h3><p><strong>概念回顾</strong></p>
<ul>
<li>迭代器(iterator)：一个具有next方法的对象，next方法返回下一个数据并且能指示是否迭代完成</li>
<li>迭代器创建函数（iterator creator）：一个返回迭代器的函数</li>
</ul>
<p><strong>可迭代协议</strong></p>
<p>ES6规定，如果一个对象具有知名符号属性<code>Symbol.iterator</code>，并且属性值是一个迭代器创建函数，则该对象是可迭代的（iterable）</p>
<h3 id="for-of-循环"><a href="#for-of-循环" class="headerlink" title="for-of 循环"></a>for-of 循环</h3><p>for-of 循环用于遍历可迭代对象，格式如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//迭代完成后循环结束</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> item <span class="keyword">in</span> iterable)&#123;</span><br><span class="line">    <span class="comment">//iterable：可迭代对象</span></span><br><span class="line">    <span class="comment">//item：每次迭代得到的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> iterator = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="keyword">let</span> result = iterator.next();</span><br><span class="line"><span class="keyword">while</span> (!result.done) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result.value);</span><br><span class="line">    result = iterator.next();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="展开运算符与可迭代对象"><a href="#展开运算符与可迭代对象" class="headerlink" title="展开运算符与可迭代对象"></a>展开运算符与可迭代对象</h3><p>展开运算符可以作用于可迭代对象，这样，就可以轻松的将可迭代对象转换为数组。</p>
<p>字符串时可迭代的。</p>
<h2 id="生成器-Generator"><a href="#生成器-Generator" class="headerlink" title="生成器 (Generator)"></a>生成器 (Generator)</h2><h3 id="1-什么是生成器？"><a href="#1-什么是生成器？" class="headerlink" title="1.什么是生成器？"></a>1.什么是生成器？</h3><p>生成器是一个通过构造函数Generator创建的对象，生成器既是一个迭代器，同时又是一个可迭代对象</p>
<h3 id="2-如何创建生成器？"><a href="#2-如何创建生成器？" class="headerlink" title="2. 如何创建生成器？"></a>2. 如何创建生成器？</h3><p>生成器的创建，必须使用生成器函数（Generator Function）</p>
<h3 id="3-如何书写一个生成器函数呢？"><a href="#3-如何书写一个生成器函数呢？" class="headerlink" title="3. 如何书写一个生成器函数呢？"></a>3. 如何书写一个生成器函数呢？</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是一个生成器函数，该函数一定返回一个生成器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* 函数名(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个生成器函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> generator = test();</span><br></pre></td></tr></table></figure>

<h3 id="4-生成器函数内部是如何执行的？"><a href="#4-生成器函数内部是如何执行的？" class="headerlink" title="4. 生成器函数内部是如何执行的？"></a>4. 生成器函数内部是如何执行的？</h3><p>生成器函数内部是为了给生成器的每次迭代提供的数据</p>
<p>每次调用生成器的next方法，将导致生成器函数运行到下一个yield关键字位置</p>
<p>yield是一个关键字，该关键字只能在生成器函数内部使用，表达“产生”一个迭代数据。</p>
<h3 id="5-有哪些需要注意的细节？"><a href="#5-有哪些需要注意的细节？" class="headerlink" title="5. 有哪些需要注意的细节？"></a>5. 有哪些需要注意的细节？</h3><p>1). 生成器函数可以有返回值，返回值出现在第一次done为true时的value属性中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> generator = test();</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">generator.next()</span><br><span class="line">&#123;<span class="attr">value</span>: <span class="number">1</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">generator.next()</span><br><span class="line">&#123;<span class="attr">value</span>: <span class="number">2</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">generator.next()</span><br><span class="line">&#123;<span class="attr">value</span>: <span class="number">10</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure>
<p>2). 调用生成器的next方法时，可以传递参数，传递的参数会交给yield表达式的返回值<br>3). 第一次调用next方法时，传参没有任何意义</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(n);</span><br><span class="line">    <span class="keyword">let</span> n1 = <span class="keyword">yield</span> <span class="number">2</span> + n;</span><br><span class="line">    <span class="built_in">console</span>.log(n1)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> generator = test();</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">generator.next()</span><br><span class="line">&#123;<span class="attr">value</span>: <span class="number">1</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">generator.next(<span class="number">33</span>)</span><br><span class="line"><span class="number">33</span></span><br><span class="line">&#123;<span class="attr">value</span>: <span class="number">35</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">generator.next(<span class="number">34</span>)</span><br><span class="line"> <span class="number">34</span></span><br><span class="line">&#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure>
<p>4). 在生成器函数内部，可以调用其他生成器函数，但是要注意加上*号</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">test1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">test2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span>* test1()</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> generator = test2();</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">generator.next()</span><br><span class="line">&#123;<span class="attr">value</span>: <span class="number">1</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">generator.next()</span><br><span class="line">&#123;<span class="attr">value</span>: <span class="number">2</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">generator.next()</span><br><span class="line">&#123;<span class="attr">value</span>: <span class="string">&#x27;a&#x27;</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">generator.next()</span><br><span class="line">&#123;<span class="attr">value</span>: <span class="string">&#x27;b&#x27;</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">generator.next()</span><br><span class="line">&#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-生成器的其他API"><a href="#6-生成器的其他API" class="headerlink" title="6. 生成器的其他API"></a>6. 生成器的其他API</h3><ul>
<li>return方法：调用该方法，可以提前结束生成器函数，从而提前让整个迭代过程结束</li>
<li>throw方法：调用该方法，可以在生成器中产生一个错误</li>
</ul>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6中的面向对象和面向过程的比较</title>
    <url>/135xyq.github.io/2021/03/16/ES6-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p><strong>面向过程</strong></p>
<p><img src="/images/ES6Images/%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B.jpg" alt="image-20210928104401662"></p>
<blockquote>
<p><strong>面向过程，就是按照我们分析好了的步骤，按部就班的依次执行就行了！</strong>所以当我们用面向过程的思想去编程或解决问题时，首先一定要把详细的实现过程弄清楚。一旦过程设计清楚，代码的实现简直轻而易举</p>
</blockquote>
<p><strong>面向对象</strong></p>
<p>实现步骤：</p>
<ol>
<li>分析哪些动作是由哪些实体发出的；（学生提出报名，学生缴费，机构收费，教师分配教室，班级增加学生信息）</li>
<li>定义这些实体，为其增加相应的属性和功能；（学生、机构、教师、班级）</li>
<li>让实体去执行相应的功能或动作。（学生提出报名、学生缴费、学校收费、教师分配教室、班级增加学生信息）</li>
</ol>
<p>​<img src="/images/ES6Images/%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4.jpg" alt="img"></p>
<h4 id="面向对象与面向过程的区别"><a href="#面向对象与面向过程的区别" class="headerlink" title="面向对象与面向过程的区别"></a>面向对象与面向过程的区别</h4><blockquote>
<p><strong>面向过程主要是针对功能，而面向对象主要是针对能够实现该功能的背后的实体。</strong>面向对象实质上就是面向实体，所以当我们使用面向对象进行编程时，一定要建立这样一个观念：万物皆对象！</p>
</blockquote>
<ul>
<li>都可以实现代码重用和模块化编程，但是面对对象的模块化更深，数据更封闭，也更安全！因为面向对象的封装性更强！</li>
<li>面对对象的思维方式更加贴近于现实生活，更容易解决大型的复杂的业务逻辑</li>
<li>从前期开发角度上来看，面对对象远比面向过程要复杂，但是从维护和扩展功能的角度上来看，面对对象远比面向过程要简单！</li>
<li>简单的从运行速度讲，面向对象与面向过程的运行速度区别不大，基本上面向对象的耗时操作在创建实例化对象的过程当中；</li>
</ul>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>canvas属性</title>
    <url>/135xyq.github.io/2021/01/03/HTML-canvas%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h1 id="CANVAS属性，方法"><a href="#CANVAS属性，方法" class="headerlink" title="CANVAS属性，方法"></a><a href="https://www.cnblogs.com/xinyouhunran/p/10968096.html">CANVAS属性，方法</a></h1><p><strong>基于：</strong><br>var canvas = document.getElementById(‘id’);<br>var ctx = canvas.getContext(‘2d’);</p>
<p><strong>1.样式：</strong><br>ctx.fillStyle = ‘color’-填充色<br>ctx.strokeStyle = ‘color’-线色<br>ctx.lineWidth = ‘length’-线宽<br>lineCap = type-设置线条末端的外观。<br>lineJoin = type-设置线条相交的“角落”的外观。<br>miterLimit = value-当两条线以锐角连接时，建立一个斜接限制，以控制结的厚度。<br>getLineDash()-返回包含偶数个非负数的当前行虚线模式数组。<br>setLineDash(segments)-设置当前行虚线模式。<br>lineDashOffset = value-指定在一行上启动破折号数组的位置。</p>
<p><strong>2.画矩形：</strong><br>ctx.fillRect(x, y, width, height)-填充矩形<br>ctx.strokeRect(x, y, width, height)-非填充矩形，只有边框<br>ctx.clearRect(x, y, width, height)-清除范围</p>
<p><strong>3.画路径</strong><br>ctx.beginPath()-开始画<br>ctx.moveTo(x,y)-算是定义起点吧<br>ctx.lineTo(x,y)-连线到某点<br>ctx.fill()-会自动闭合<br>ctx.stroke()-不会闭合<br>ctx.closePath()-关闭绘画</p>
<p><strong>4.画圆</strong><br>ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise)-radius代表半径，anticlockwise代表顺时针，逆时针(boolean)</p>
<p><strong>5.曲线</strong><br>quadraticCurveTo(cp1x, cp1y, x, y)-xy偏离一致的曲线<br>bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)-想怎么偏怎么偏</p>
<p><strong>6.new Path2D()</strong>:创建一个2d路径对象，对此对象进行操作，最后成为stroke()或fill()的参数。</p>
<p><strong>7.渐变</strong><br>createLinearGradient(x1, y1, x2, y2)<br>createRadialGradient(x1, y1, r1, x2, y2, r2)<br>gradient.addColorStop(position, color)（0~1，color）</p>
<p><strong>8.模式</strong><br>createPattern(image, type)-创建并返回一个新的画布模式对象<br>image是一个Canvasimgource,type是一个表示如何使用图像的字符串(如平铺)</p>
<p><strong>9.阴影</strong><br>shadowOffsetX = float<br>指示阴影应从对象延伸的水平距离。该值不受变换矩阵的影响。默认值为0。<br>shadowOffsetY = float<br>指示阴影应从对象延伸的垂直距离。该值不受变换矩阵的影响。默认值为0。<br>shadowBlur = float<br>表示模糊效果的大小; 该值不对应于多个像素，并且不受当前变换矩阵的影响。默认值为0。<br>shadowColor = color<br>标准CSS颜色值，表示阴影效果的颜色; 默认情况下，它是完全透明的黑色。</p>
<p><strong>10.绘文字</strong><br>fillText(text, x, y [, maxWidth])<br>在给定（x，y）位置填充给定文本。可选择绘制最大宽度。<br>strokeText(text, x, y [, maxWidth])<br>在给定（x，y）位置描边给定文本。可选择绘制最大宽度。<br>font = value<br>绘制文本时使用的当前文本样式。此字符串使用与CSS font属性相同的语法。默认字体是10px sans-serif。<br>textAlign = value<br>文本对齐设置。可能的值：start，end，left，right或center。默认值为start。<br>textBaseline = value<br>基线对齐设置。可能的值：top，hanging，middle，alphabetic，ideographic，bottom。默认值为alphabetic。<br>direction = value<br>方向性。可能的值：ltr，rtl，inherit。默认值为inherit。<br>measureText()<br>返回一个TextMetrics对象，该对象包含以当前文本样式绘制时指定文本的宽度</p>
<p><strong>11.图像</strong><br>drawImage(image, x, y,width,height)<br>绘制坐标（x，y）处Canvasimgource的image参数指定的值。<br>drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)-切片<br>给定一个image，该功能只通过其左上角是矩形指定的源图像的区域（sx，sy其宽度和高度是），并sWidth与sHeight和它绘制到画布，<br>在将其放置在画布上（dx，dy）和缩放它由指定的大小dWidth和dHeight。</p>
<p><strong>12.保存和恢复状态</strong><br>save()<br>保存画布的整个状态。<br>restore()<br>恢复最近保存的画布状态。<br>画布状态存储在堆栈中。每次save()调用该方法时，当前绘图状态都会被压入堆栈。<br>您可以save()根据需要多次调用该方法。每次restore()调用该方法时，最后保存的状态将从堆栈中弹出，并恢复所有保存的设置。</p>
<p><strong>13.动画</strong><br>translate(x, y)<br>rotate(angle)<br>scale(x, y)<br>transform(a, b, c, d, e, f)//矩阵<br>setTransform(a, b, c, d, e, f)<br>将当前变换重置为单位矩阵，然后transform()使用相同的参数调用该方法。这基本上撤消了当前的转换，然后在一个步骤中设置指定的转换。<br>resetTransform()<br>将当前变换重置为单位矩阵。<br>使用动画，使用window.requestAnimationFrame()而不是window.setInterval()<br>window.cancelAnimationFrame();取消帧动画</p>
<p><strong>14.合成</strong><br>globalCompositeOperation = type<br>这将设置在绘制新形状时应用的合成操作的类型，其中type是一个字符串，用于标识要使用的十二个合成操作中的哪一个。</p>
<p>**15.clip()**剪切路径</p>
<p><strong>16.获取上下文的像素数据</strong><br>ctx.getImageData(left, top, width, height);<br>此方法返回一个ImageData对象，该对象表示画布区域的像素数据，其角点由点（left，top），（left+width，top），（left，top+height）和（left+width，top+height）表示。坐标以画布坐标空间单位指定。</p>
<p><strong>17.将像素数据绘制到上下文中</strong><br>ctx.putImageData(myImageData, dx, dy);<br>该dx和dy参数显示在其中进行绘制要绘制的像素数据的左上角的范围内的设备坐标。</p>
<p><strong>18.保存图像</strong><br>canvas.toDataURL(‘image/png’)<br>默认设置。创建PNG图像。<br>canvas.toDataURL(‘image/jpeg’, quality)<br>创建JPG图像。或者，您可以提供0到1范围内的质量，其中一个是最好的质量，0几乎不可识别但文件大小很小。<br>canvas.toBlob(callback, type, encoderOptions)<br>创建Blob表示画布中包含的图像的对象。</p>
<p><strong>19.命中区域</strong><br>CanvasRenderingContext2D.addHitRegion()<br>在画布中添加命中区域。<br>CanvasRenderingContext2D.removeHitRegion()<br>使用id画布中指定的内容删除命中区域。<br>CanvasRenderingContext2D.clearHitRegions()<br>从画布中删除所有命中区域。<br>检查MouseEvent.region属性以测试鼠标是否正在击中您的区域</p>
<p><strong>20.聚焦环</strong><br>CanvasRenderingContext2D.drawFocusIfNeeded()<br>如果给定元素被聚焦，则此方法围绕当前路径绘制聚焦环。<br>CanvasRenderingContext2D.scrollPathIntoView()<br>将当前路径或给定路径滚动到视图中。</p>
<p><strong>21.基于canvas封装的代码片段</strong>（<a href="https://developer.mozilla.org/en-US/docs/Archive/Add-ons/Code_snippets/Canvas%EF%BC%89">https://developer.mozilla.org/en-US/docs/Archive/Add-ons/Code_snippets/Canvas）</a><br>获取画布中某种颜色的像素数<br>获取画布中像素的颜色<br>链接方法<br>将画布图像保存到文件<br>将远程页面加载到画布元素上<br>将图像文件转换为base64字符串</p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5新增</title>
    <url>/135xyq.github.io/2021/01/01/HTML-h5%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="HTML5-基础"><a href="#HTML5-基础" class="headerlink" title="HTML5 基础"></a>HTML5 基础</h1><hr>
<h2 id="input："><a href="#input：" class="headerlink" title="input："></a>input：</h2><p>placeholder：输入框提示</p>
<h3 id="type里面新增加的类型：（有兼容性问题，不推荐使用）"><a href="#type里面新增加的类型：（有兼容性问题，不推荐使用）" class="headerlink" title="type里面新增加的类型：（有兼容性问题，不推荐使用）"></a>type里面新增加的类型：（有兼容性问题，不推荐使用）</h3><ul>
<li>date:可以选择日期（兼容性不好）;</li>
<li>time:时间；week：星期；</li>
<li>datetime-local:可以选择日期时间；</li>
<li>number：只能填写数字 color：填颜色。</li>
</ul>
<h2 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h2><p><code>contenteditable=&quot;true&quot;</code> ：可修改元素的内容（可以继承）（没有兼容性问题）</p>
<p><code>draggable = &quot;true&quot;</code> :元素可拖拽（大部分元素默认为false，其中a标签img标签默认为true） （只有Chrome和Safari支持）</p>
<h3 id="拖拽周期：推拽开始，拖拽进行时，拖拽结束"><a href="#拖拽周期：推拽开始，拖拽进行时，拖拽结束" class="headerlink" title="拖拽周期：推拽开始，拖拽进行时，拖拽结束"></a>拖拽周期：推拽开始，拖拽进行时，拖拽结束</h3><h4 id="拖拽对象触发事件："><a href="#拖拽对象触发事件：" class="headerlink" title="拖拽对象触发事件："></a>拖拽对象触发事件：</h4><ul>
<li>拖拽开始（dragstart）,按下物体的瞬间不会触发事件，必须移动</li>
<li>拖拽移动事件（drag）,移动的时候触发</li>
<li>拖拽结束时间（dragend），结束时间</li>
</ul>
<h4 id="拖拽目标触发事件："><a href="#拖拽目标触发事件：" class="headerlink" title="拖拽目标触发事件："></a>拖拽目标触发事件：</h4><ul>
<li>dragenter：当拖拽进入目标区域时，不是元素图形进入触发，而是拖拽的鼠标进入才会触发</li>
<li>dragover：在拖拽目标的范围内移动触发(想要阻止元素回到默认位置，必须在这设置阻止默认事件)</li>
<li>dragleave：离开拖拽目标触发</li>
<li>dragdrop: 必须在dragover事件下阻止默认事件才会触发（e.preventDefault()）</li>
</ul>
<p>拖拽的时候元素会脱离文档结构，放回去的时候在恢复。</p>
<p><code>dataTransfer.effectAllowed</code>:可以改变拖拽时指针的样式（必须写在draggstart里，兼容性不行)</p>
<p><code>e.dataTransfer.effectAllowed = 样式</code></p>
<p><code>dataTransfer.dropEffect</code>:可以改变拖拽松手时指针的样式（必须写在drop里，兼容性不行）</p>
<p><code>e.dataTransfer.dropEffect = 样式</code></p>
<h2 id="canvas："><a href="#canvas：" class="headerlink" title="canvas："></a><a href="https://www.runoob.com/w3cnote/html5-canvas-intro.html">canvas</a>：</h2><p>canvas要在js中开始操作画图。<br>canvas设置画板的大小需要在行间设置</p>
<h3 id="canvas中画笔方法："><a href="#canvas中画笔方法：" class="headerlink" title="canvas中画笔方法："></a>canvas中画笔方法：</h3><figure class="highlight plaintext"><figcaption><span>: 生成一个画笔</span></figcaption><table><tr><td class="code"><pre><span class="line">```moveTo（x,y）```:画笔开始的的位置  </span><br><span class="line">```lineTo（x,y）```：下一笔要到的地方  </span><br><span class="line">```lineWidth```：设置画笔画出来线条的宽度（每个画笔画出来的图形苦读一样）  </span><br><span class="line">```beginPath``` ：开启一个新的路径  </span><br><span class="line">```closePath``` ：自动闭合所画的图形（闭合当前这一个路径）  </span><br><span class="line">```stroke``` ： 将画笔的轨迹写到画板上（即展示画的图形）  </span><br><span class="line">```fill``` : 将图形的内容区填满（会自动闭合图形）  </span><br><span class="line">```clearRect（起始X，起始Y，矩形的宽，矩形的高）```:清除这个矩形框的内容（相当于橡皮擦）</span><br><span class="line"></span><br><span class="line">### canvas画矩形：</span><br><span class="line">1. 一笔一笔的画</span><br><span class="line">2. rect（起始X，起始Y，矩形的宽，矩形的高）:一个矩形</span><br><span class="line">3. strokeRect(起始X，起始Y，矩形的宽，矩形的高):一个只有边框的矩形</span><br><span class="line">4. fillRect（起始X，起始Y，矩形的宽，矩形的高）：有填充内容的矩形</span><br><span class="line"></span><br><span class="line">### canvas画圆形，圆弧：</span><br><span class="line"></span><br><span class="line">参数：圆心（x,y），半径(r)，弧度（开始弧度start，结束弧度end，必须以π（Math.PI）为单位 例 Math.PI* 2 : 360度），方向（顺时针，逆时针，顺时针写为0，逆时针为1）</span><br><span class="line"></span><br><span class="line">arc（x,y,r,开始弧度,结束弧度,方向）：方法</span><br><span class="line"></span><br><span class="line">### canvas画圆角矩形：</span><br><span class="line"></span><br><span class="line">#### 画一条带弧的线：</span><br><span class="line">参数：线直线部分的结束坐标（x,y），线的结束部分弧的方向（需填写一个坐标表示延伸方向，只提供方向参考），圆弧的大小</span><br><span class="line"></span><br><span class="line">arcTo（x,y，弧所延伸方向的坐标，圆弧的大小）：画出一条线</span><br><span class="line"></span><br><span class="line">**注意**：四条线就可画出圆角矩形，画笔的起始位置应该为矩形的弧形大小预留出一定的位置</span><br><span class="line">```javascript</span><br><span class="line">        //画一个弧度为10px 起始位置位（100 100），宽高为100的圆角矩形</span><br><span class="line">        ctx.moveTo(100, 110);</span><br><span class="line">        ctx.arcTo(100, 200, 200, 200, 10);</span><br><span class="line">        ctx.arcTo(200, 200, 200, 100, 10);</span><br><span class="line">        ctx.arcTo(200, 100, 100, 100, 10);</span><br><span class="line">        ctx.arcTo(100, 100, 100, 200, 10);</span><br><span class="line">        ctx.stroke();</span><br></pre></td></tr></table></figure>
<h3 id="贝塞尔曲线："><a href="#贝塞尔曲线：" class="headerlink" title="贝塞尔曲线："></a>贝塞尔曲线：</h3><p>二次贝塞尔曲线需提供三个点，做出两条辅助线<br>三次需要四个点，三条辅助线，<br>其他类推（第一个点为画笔的起始点） </p>
<p>quadraticCurveTo（第二个点横坐标，第二个点纵坐标，第三个点横坐标，第三个点纵坐标）：二次贝塞尔曲线</p>
<p>bezierCurveTo(第二个点横坐标，第二个点纵坐标，第三个点横坐标，第三个点纵坐标,第四个点横坐标，第四个点纵坐标)：三次贝塞尔曲线</p>
<h3 id="变换："><a href="#变换：" class="headerlink" title="变换："></a>变换：</h3><p>translate（x,y）:画布的坐标系原点（对全局都有作用）<br>rotate(角度):所画图形的旋转角度（必须以π为单位），旋转中心为坐标系原点（对全局都有作用。<br>scale（x轴方向，y轴方向）：缩放图形，图形的每一个坐标点都乘以了相应的系数（对全局都有作用）<br>解决消除对全局的影响：再开始时调用save方法（），在对某一部分调用完rotate和translate方法后再次调用restore方法就可以将后面部分恢复为默认的。</p>
<h3 id="canvas改变样式："><a href="#canvas改变样式：" class="headerlink" title="canvas改变样式："></a>canvas改变样式：</h3><p>fillstyle：改变填充的颜色，<br>可以添加图片（图片从坐标原点开始渲染）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">        img.src = <span class="string">&quot;../images/1.jpeg&quot;</span></span><br><span class="line">        img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            ctx.beginPath();</span><br><span class="line">            <span class="keyword">var</span> bg = ctx.createPattern(img, <span class="string">&#x27;no-repeat&#x27;</span>)</span><br><span class="line">            ctx.fillStyle = bg;</span><br><span class="line">            ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="添加渐变-参考"><a href="#添加渐变-参考" class="headerlink" title="添加渐变  参考"></a>添加渐变  <a href="https://www.runoob.com/html/html5-canvas.html">参考</a></h3><h4 id="阴影：（默认是边框的里外都有）"><a href="#阴影：（默认是边框的里外都有）" class="headerlink" title="阴影：（默认是边框的里外都有）"></a>阴影：（默认是边框的里外都有）</h4><ul>
<li>shadowColor:添加阴影颜色</li>
<li>shadowBlur：添加阴影的大小</li>
<li>shadowOffsetX：阴影水平方向平移</li>
<li>shadowOffsetY：阴影垂直方向平移</li>
</ul>
<h4 id="线段样式（在线的两端添加样式）："><a href="#线段样式（在线的两端添加样式）：" class="headerlink" title="线段样式（在线的两端添加样式）："></a>线段样式（在线的两端添加样式）：</h4><ul>
<li>lineCap属性：在两端加一个图形，为扩大线段的长度（值为round表示加一个半圆，）</li>
<li>lineJoin属性：两个线相交时的样式</li>
</ul>
<h4 id="canvas绘制文字："><a href="#canvas绘制文字：" class="headerlink" title="canvas绘制文字："></a>canvas绘制文字：</h4><p>strokeText（文字，开始横坐标，开始纵坐标）：文字描边（空心字体）</p>
<p>fillText（文字，开始横坐标，开始纵坐标）：文字填充，（实心字体）可以用fillstyle改变字体颜色</p>
<h2 id="svg"><a href="#svg" class="headerlink" title="svg:"></a><a href="https://www.runoob.com/svg/svg-tutorial.html">svg</a>:</h2><p>svg适合矢量图，放大不会失真，适合大面积的贴图，通常动画较简单（标签和CSS绘画）<br>canvas适合用于小面积的绘图，适合动画（JS去画）</p>
<h3 id="画直线："><a href="#画直线：" class="headerlink" title="画直线："></a>画直线：</h3><p>在SVG标签里使用line标签有四个属性x1,y1,x2,y2分别代表开始位置坐标和结束位置坐标，画完之后要在css中为他们设置stroke属性</p>
<h3 id="画矩形："><a href="#画矩形：" class="headerlink" title="画矩形："></a>画矩形：</h3><p>在SVG里用标签rect标签，属性width，height，x,y,rx,ry,分别表示矩形的宽，高，起始位置的横纵坐标，圆角的宽高</p>
<h3 id="画圆："><a href="#画圆：" class="headerlink" title="画圆："></a>画圆：</h3><p>在SVG里用标签circle</p>
<h3 id="画椭圆："><a href="#画椭圆：" class="headerlink" title="画椭圆："></a>画椭圆：</h3><p>在SVG里用ellipse标签</p>
<h3 id="画折线："><a href="#画折线：" class="headerlink" title="画折线："></a>画折线：</h3><p>在SVG里用polyline标签，默认闭合<br>解决默认填充的可以在css中将fill值改为transparent</p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>jquery的基本语法</title>
    <url>/135xyq.github.io/2021/04/02/JQuery-jquery%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="jquery"><a href="#jquery" class="headerlink" title="jquery"></a>jquery</h1><h2 id="jquery-代码书写位置的三种"><a href="#jquery-代码书写位置的三种" class="headerlink" title="jquery 代码书写位置的三种"></a>jquery 代码书写位置的三种</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> box = <span class="built_in">document</span>.getElementById(<span class="string">&quot;box&quot;</span>);</span><br><span class="line">	<span class="built_in">console</span>.log(box);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$().ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> box = <span class="built_in">document</span>.getElementById(<span class="string">&quot;box&quot;</span>);</span><br><span class="line">	<span class="built_in">console</span>.log(box);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> box = <span class="built_in">document</span>.getElementById(<span class="string">&quot;box&quot;</span>);</span><br><span class="line">	<span class="built_in">console</span>.log(box);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>dom 元素加载完就会触发 ready</p>
<h3 id="jquery-的特点："><a href="#jquery-的特点：" class="headerlink" title="jquery 的特点："></a>jquery 的特点：</h3><ol>
<li>强大的选择器</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> $h1 = $(<span class="string">&quot;h1&quot;</span>);</span></span><br><span class="line"><span class="javascript">	<span class="built_in">console</span>.log($h1);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>链式操作</p>
<p> 原生 js 取到的 dom 对象和 jquery 取到的不一样。<br> 原生 js 取到的对象不能使用 jquery 里面的方法。<br> jquery 取到的对象也不能使用使用原生的 js 方法。</p>
</li>
</ol>
<h3 id="原生-js-和-jquery-元素之间可以相互转化："><a href="#原生-js-和-jquery-元素之间可以相互转化：" class="headerlink" title="原生 js 和 jquery 元素之间可以相互转化："></a>原生 js 和 jquery 元素之间可以相互转化：</h3><p>原生 js 转 jquery： $(dom 对象);<br>jquery 转原生 js： $jquery 对象[0];</p>
<p>jquery 取到的永远是一个数组</p>
<h2 id="jquery-选择器"><a href="#jquery-选择器" class="headerlink" title="jquery 选择器"></a><a href="https://www.jquery123.com/category/selectors/">jquery 选择器</a></h2><h3 id="基础选择器"><a href="#基础选择器" class="headerlink" title="基础选择器"></a>基础选择器</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box&quot;</span>&gt;</span>不错<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;className&quot;</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>p标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">	$(<span class="string">&quot;*&quot;</span>).css(<span class="string">&quot;border&quot;</span>, <span class="string">&quot;2px solid black&quot;</span>); <span class="comment">//通配符选择器</span></span></span><br><span class="line"><span class="javascript">	$(<span class="string">&quot;#box&quot;</span>).css(<span class="string">&quot;background&quot;</span>, <span class="string">&quot;red&quot;</span>); <span class="comment">//ID选择器</span></span></span><br><span class="line"><span class="javascript">	$(<span class="string">&quot;.className&quot;</span>).css(<span class="string">&quot;background&quot;</span>, <span class="string">&quot;green&quot;</span>); <span class="comment">//class选择器</span></span></span><br><span class="line"><span class="javascript">	$(<span class="string">&quot;p&quot;</span>).css(<span class="string">&quot;background&quot;</span>, <span class="string">&quot;blue&quot;</span>); <span class="comment">//标签选择器</span></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="层级选择器：可参考-CSS3-选择器"><a href="#层级选择器：可参考-CSS3-选择器" class="headerlink" title="层级选择器：可参考 CSS3 选择器"></a>层级选择器：可参考 CSS3 选择器</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span>啊这<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span>不错<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">	$(<span class="string">&quot;.wrapper p&quot;</span>).css(<span class="string">&quot;color&quot;</span>, <span class="string">&quot;green&quot;</span>);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="属性选择器："><a href="#属性选择器：" class="headerlink" title="属性选择器："></a>属性选择器：</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">name</span>=<span class="string">&quot;t&quot;</span>&gt;</span>不错<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">title</span>=<span class="string">&quot;j&quot;</span>&gt;</span>就这<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">title</span>=<span class="string">&quot;j-t&quot;</span>&gt;</span>啊这<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">title</span>=<span class="string">&quot;jr&quot;</span>&gt;</span>棒<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">title</span>=<span class="string">&quot;ttj&quot;</span>&gt;</span>强<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">title</span>=<span class="string">&quot;qgrp&quot;</span>&gt;</span>加油<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">title</span>=<span class="string">&quot;qgp&quot;</span>&gt;</span>冲<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;xyq&quot;</span>&gt;</span>很好<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">	$(<span class="string">&quot;[name]&quot;</span>).css(<span class="string">&quot;background&quot;</span>, <span class="string">&quot;red&quot;</span>); <span class="comment">//选择所有带name属性的元素</span></span></span><br><span class="line"><span class="javascript">	$(<span class="string">&quot;[title=j]&quot;</span>).css(<span class="string">&quot;background&quot;</span>, <span class="string">&quot;green&quot;</span>); <span class="comment">//选择title属性值为j的元素</span></span></span><br><span class="line"><span class="javascript">	$(<span class="string">&quot;div[title!=j]&quot;</span>).css(<span class="string">&quot;background&quot;</span>, <span class="string">&quot;blue&quot;</span>); <span class="comment">//选择有title属性值不为j的元素</span></span></span><br><span class="line"><span class="javascript">	$(<span class="string">&quot;div[title|=j]&quot;</span>).css(<span class="string">&quot;background&quot;</span>, <span class="string">&quot;red&quot;</span>); <span class="comment">//选择有title属性值以j前缀开始（- 隔开的）的元素   j-</span></span></span><br><span class="line"><span class="javascript">	$(<span class="string">&quot;div[title^=j]&quot;</span>).css(<span class="string">&quot;background&quot;</span>, <span class="string">&quot;yellow&quot;</span>); <span class="comment">//选择有title属性值以j开始的元素</span></span></span><br><span class="line"><span class="javascript">	$(<span class="string">&quot;div[title$=j]&quot;</span>).css(<span class="string">&quot;background&quot;</span>, <span class="string">&quot;hotpink&quot;</span>); <span class="comment">//选择有title属性值以j结束的元素</span></span></span><br><span class="line"><span class="javascript">	$(<span class="string">&quot;div[title*=gr]&quot;</span>).css(<span class="string">&quot;background&quot;</span>, <span class="string">&quot;purple&quot;</span>); <span class="comment">//选择有title属性值包含gr字符串的元素</span></span></span><br><span class="line"><span class="javascript">	$(<span class="string">&quot;div[title~=gr]&quot;</span>).css(<span class="string">&quot;background&quot;</span>, <span class="string">&quot;purple&quot;</span>); <span class="comment">//选择有title属性值包含gr单词（单词之间用空格隔开）的元素</span></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="基础过滤选择器"><a href="#基础过滤选择器" class="headerlink" title="基础过滤选择器"></a><a href="https://www.jquery123.com/category/selectors/basic-filter-selectors/">基础过滤选择器</a></h3><h3 id="DOM-操作："><a href="#DOM-操作：" class="headerlink" title="DOM 操作："></a><a href="https://www.jquery123.com/category/manipulation/">DOM 操作</a>：</h3><p>腾讯云<br>对象存储</p>
<h2 id="自定义插件："><a href="#自定义插件：" class="headerlink" title="自定义插件："></a>自定义插件：</h2><h3 id="1-给-jquery-对象本身扩展方法"><a href="#1-给-jquery-对象本身扩展方法" class="headerlink" title="1 .给 jquery 对象本身扩展方法"></a>1 .给 jquery 对象本身扩展方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.extend( &#123;</span><br><span class="line">    函数名：<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        函数体</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>使用：$.函数名();</p>
<h3 id="2-给-jquery-DOM-对象扩展方法"><a href="#2-给-jquery-DOM-对象扩展方法" class="headerlink" title="2. 给 jquery DOM 对象扩展方法"></a>2. 给 jquery DOM 对象扩展方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.fn.extend( &#123;</span><br><span class="line">    函数名：<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//$(this)指向调用该方法的对象</span></span><br><span class="line">        $(<span class="built_in">this</span>).jquery方法;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> $(<span class="built_in">this</span>);<span class="comment">//满足链式调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.fn.函数名 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">//$(this)指向调用该方法的对象</span></span><br><span class="line">	$(<span class="built_in">this</span>).jquery方法;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> $(<span class="built_in">this</span>); <span class="comment">//满足链式调用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用：<br><code>$(dom 对象).函数名()</code>;</p>
<p>attr 方法和 prop 方法都是用来设置属性值的，区别在于 attr 方法用于设置一般属性，而 prop 用来设置特殊属性。如果是自定义属性，使用 attr 方法来进行设置。当然，设置自定义属性，还可以使用 jquery 中提供的 data 方法。</p>
<p>hide（）方法可以隐藏元素<br>show() 方法可以展示元素<br>hover() 方法可以设置 hover 需传递两个参数，是两个函数，第一个函数处理·移入，第二个函数处理移出</p>
<p>user-select:none；禁止选中 CSS</p>
<p><code>$(dom).load(html 页面)</code> ：可以在一个页面中加载其他页面</p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>jquery</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title>document常用方法、事件、样式</title>
    <url>/135xyq.github.io/2021/02/21/JS-documen%E9%87%8C%E9%9D%A2%E7%9A%84%E6%96%B9%E6%B3%95%E3%80%81%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="document-里面的方法"><a href="#document-里面的方法" class="headerlink" title="document 里面的方法"></a>document 里面的方法</h1><hr>
<p>document：整个页面</p>
<p>querySelector(‘选择器’)：可以按 CSS 的选择器选择方式（选出一个）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">strong</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span>123<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> strong = <span class="built_in">document</span>.querySelector(<span class="string">&quot;div &gt; span strong&quot;</span>);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 可以选择出有123的strong标签          --&gt;</span></span><br></pre></td></tr></table></figure>

<p>querySelectorAll(‘选择器’):可以按 CSS 的选择器选择方式（选出一组）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">strong</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span>123<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> strong = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;div &gt; span strong&quot;</span>);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 可以选择出有123的一组strong标签    --&gt;</span></span><br></pre></td></tr></table></figure>

<p>querySeclect 和 querySelectAll 是静态的，选择后更新DOM，选择结果不会更新（选出来的是副本）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box1&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span>1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">	<span class="built_in">console</span>.log(<span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;#box1 p&quot;</span>));</span></span><br><span class="line"><span class="javascript">	<span class="built_in">console</span>.log(<span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;p&quot;</span>));</span></span><br><span class="line"><span class="javascript">	<span class="keyword">const</span> p = <span class="built_in">document</span>.createElement(<span class="string">&quot;p&quot;</span>);</span></span><br><span class="line"><span class="javascript">	p.innerHTML = <span class="string">&quot;2&quot;</span>;</span></span><br><span class="line"><span class="javascript">	box1.appendChild(p);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 输出 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">0: p</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">和</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">0: p</span></span><br><span class="line"><span class="comment">1: p --&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="遍历节点树：（包含所有节点）"><a href="#遍历节点树：（包含所有节点）" class="headerlink" title="遍历节点树：（包含所有节点）"></a>遍历节点树：（包含所有节点）</h3><ul>
<li>  parentNode:父节点</li>
<li>  childNodes：子节点集合</li>
<li>  firstChild：第一个子节点</li>
<li>  lastChild：最后一个子节点</li>
<li>  nextSibling：后一个兄弟节点</li>
<li>  previousSibling：前一个兄弟节点</li>
</ul>
<h3 id="遍历元素节点树：（只有元素节点）"><a href="#遍历元素节点树：（只有元素节点）" class="headerlink" title="遍历元素节点树：（只有元素节点）"></a>遍历元素节点树：（只有元素节点）</h3><ul>
<li>  parentElement：返回当前元素的父元素节点</li>
<li>  children：只返回当前元素的元素子节点</li>
<li>  node.childElementCount === node.children.length：当前元素节点的子元素个数</li>
<li>  firstElementChild：第一个元素节点</li>
<li>  lastElementChild：最后一个元素节点</li>
<li>  nextElementSibling：后一个兄弟元素节点</li>
<li>  previousElementSibling：前一个兄弟元素节点</li>
</ul>
<h3 id="节点的四个属性"><a href="#节点的四个属性" class="headerlink" title="节点的四个属性"></a>节点的四个属性</h3><ul>
<li>  nodeName：元素的标签名，以大些形式表示，只读</li>
<li>  nodeValue：Text 节点或 Comment 节点的文本内容，可读写</li>
<li>  nodeType：该节点的类型，只读</li>
<li>  attributes：Element 节点的属性集合</li>
</ul>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><ol>
<li><p>getElementById 方法定义在 Document.prototype 上，即 Element 节点上不能使用。</p>
</li>
<li><p>getElementsByName 方法定义在 HTMLDocument.prototype 上，即非 html 中的 document 以外不能使用(xml document,Element)</p>
</li>
<li><p>getElementsByTagName 方法定义在 Document.prototype 和 Element.prototype 上</p>
</li>
<li><p>HTMLDocument.prototype 定义了一些常用的属性，body,head,分别指代 HTML 文档中的&lt;body&gt;&lt;head&gt;标签。</p>
</li>
<li><p>Document.prototype 上定义了 documentElement 属性，指代文档的根元素，在 HTML 文档中，他总是指代&lt;html&gt;元素</p>
</li>
<li><p>getElementsByClassName、querySelectorAll、querySelector 在 Document,Element 类中均有定义</p>
</li>
</ol>
<h3 id="dom-的基本操作"><a href="#dom-的基本操作" class="headerlink" title="dom 的基本操作"></a>dom 的基本操作</h3><h4 id="增"><a href="#增" class="headerlink" title="增"></a>增</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 增加元素节点;</span></span><br><span class="line"><span class="built_in">document</span>.createElement();</span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加文本节点;</span></span><br><span class="line"><span class="built_in">document</span>.createTextNode();</span><br><span class="line"><span class="keyword">var</span> text = <span class="built_in">document</span>.createTextNode(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注释节点</span></span><br><span class="line"><span class="built_in">document</span>.createComment();</span><br><span class="line"><span class="keyword">var</span> comment = <span class="built_in">document</span>.createComment(<span class="string">&quot;This is a Comment&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文档碎片节点;</span></span><br><span class="line"><span class="built_in">document</span>.createDocumentFragment();</span><br></pre></td></tr></table></figure>

<h4 id="插"><a href="#插" class="headerlink" title="插"></a>插</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PARENTNODE.appendChild();插入节点（剪切操作）</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> text = <span class="built_in">document</span>.createTextNode(<span class="string">&quot;这里在div中插入一个文本节点&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> span = <span class="built_in">document</span>.createElement(<span class="string">&#x27;span&#x27;</span>);</span><br><span class="line">div.appendChild(text);</span><br><span class="line">div.appendChild(span);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// PARENTNODE.insertBefore(a, b);在父集中将a插在b前面</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> strong = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;strong&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> span = <span class="built_in">document</span>.createElement(<span class="string">&#x27;span&#x27;</span>);</span><br><span class="line">div.insertBefore(span, strong);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> strong = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;strong&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> text = <span class="built_in">document</span>.createTextNode(<span class="string">&quot;在strong前面插入一个文本节点&quot;</span>);</span><br><span class="line">div.insertBefore(text, strong);</span><br></pre></td></tr></table></figure>

<h4 id="删"><a href="#删" class="headerlink" title="删"></a>删</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// parent.removeChild();父节点调用方法删除子节点（剪切）</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> strong = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;strong&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">div.removeChild(strong);</span><br><span class="line"><span class="comment">// 删除div下面的strong标签</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// parent.remove();子节点自己调用方法删除自己（销毁）</span></span><br><span class="line"><span class="keyword">var</span> strong = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;strong&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">strong.remove()</span><br><span class="line"><span class="comment">// 删除div下面的strong标签</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// parent.replaceChild(new, origin);（剪切）</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> strong = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;strong&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> text = <span class="built_in">document</span>.createTextNode(<span class="string">&quot;将strong标签替换成为一个文本&quot;</span>);</span><br><span class="line">div.replaceChild(text, strong);</span><br><span class="line"><span class="comment">// Element节点的一些属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// innerHTML（取写HTML）</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">div.innerHTML;</span><br><span class="line"><span class="comment">// 将div里面的东西查找出来</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">div.innerHTML = <span class="string">&quot;将div原来的东西覆盖掉&quot;</span>;</span><br><span class="line"><span class="comment">// 将div里面的东西替换</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">div.innerHTML = <span class="string">&quot;将div原来的东西覆盖掉&quot;</span>;</span><br><span class="line">div.innerHTML += <span class="string">&quot;再加一点东西！&quot;</span>;</span><br><span class="line"><span class="comment">// 在原来的div后面再添加一点东西</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// innerText（取写文本，老版本火狐不支持（提供TextContent一样））</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">div.innerText;</span><br><span class="line"><span class="comment">// 将div里面的文本取出来</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">div.innerText = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="comment">// 将div里面的所有东西替换成123</span></span><br></pre></td></tr></table></figure>

<h3 id="Element-节点的一些方法"><a href="#Element-节点的一些方法" class="headerlink" title="Element 节点的一些方法"></a>Element 节点的一些方法</h3><h4 id="ele-setAttribute-设置属性"><a href="#ele-setAttribute-设置属性" class="headerlink" title="ele.setAttribute() ;设置属性"></a>ele.setAttribute() ;设置属性</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">div.setAttribute(<span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;class1&#x27;</span>);</span><br><span class="line"><span class="comment">// 给div添加名为class1 的 class属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">div.setAttribute(<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;only&#x27;</span>);</span><br><span class="line"><span class="comment">// 给div添加一个名为only的 id属性</span></span><br></pre></td></tr></table></figure>

<h4 id="ele-getAttribute-获取属性"><a href="#ele-getAttribute-获取属性" class="headerlink" title="ele.getAttribute() ;获取属性"></a>ele.getAttribute() ;获取属性</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;div&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">div.getAttribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="comment">// 获取div的id;</span></span><br></pre></td></tr></table></figure>

<p>document.getElementsByTagName(*);可以把所有标签取出来</p>
<h2 id="日期对象"><a href="#日期对象" class="headerlink" title="日期对象"></a>日期对象</h2><p>日期对象是系统提供好的。</p>
<p><code>var date = new Date();</code></p>
<p>setInterval(函数，时间间隔);循环执行（每隔一段时间执行函数），都会返回一个数字唯一标识</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每隔1000毫秒执行一次function;</span></span><br></pre></td></tr></table></figure>

<p>setTimeout(函数，时间间隔);推迟一段时间在执行，仅执行一次</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&quot;推迟1000毫秒执行，仅执行一次。&quot;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// clearInterval(数字); 停止执行;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> timer = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"><span class="built_in">clearInterval</span>(timer);</span><br><span class="line"><span class="comment">// 可以停止setInterval的执行;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// clearTimeout(数字); 停止执行;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&quot;隔1000毫秒执行，仅执行一次。&quot;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"><span class="built_in">clearTimeout</span>(timer);</span><br><span class="line"><span class="comment">// 清除setTimeout的执行;</span></span><br></pre></td></tr></table></figure>

<p>全局对象 window 上的方法，内部函数 this 指向 window</p>
<h4 id="注意-："><a href="#注意-：" class="headerlink" title="注意 ："></a>注意 ：</h4><p>setInterval(“字符串”,1000);会每隔一段时间执行字符串里面的代码（当成 js 代码）</p>
<h2 id="浏览器窗口"><a href="#浏览器窗口" class="headerlink" title="浏览器窗口"></a>浏览器窗口</h2><h3 id="查看滚动条的滚动距离："><a href="#查看滚动条的滚动距离：" class="headerlink" title="查看滚动条的滚动距离："></a>查看滚动条的滚动距离：</h3><p><code>window.pageXOffset/pageYOffset</code><br>IE8 及 IE8 以下不兼容</p>
<p><code>document.body.scrollLeft/scrollTop</code><br><code>document.documentElement.scrollLeft/scrollTop</code></p>
<p>兼容性比较混乱，用时取两个值相加，因为不可能存在两个同时有值。</p>
<h3 id="查看视口的尺寸："><a href="#查看视口的尺寸：" class="headerlink" title="查看视口的尺寸："></a>查看视口的尺寸：</h3><p><code>window.innerWidth/innerHeight</code><br>IE8 及 IE8 以下不兼容</p>
<p><code>document.documentElement.clientWidth/clientHeight</code></p>
<p>标准模式下，任意浏览器都兼容</p>
<p><code>document.body.clientWidth/clientHeight</code></p>
<p>适用于怪异模式下的浏览器</p>
<h3 id="浏览器的渲染模式："><a href="#浏览器的渲染模式：" class="headerlink" title="浏览器的渲染模式："></a>浏览器的渲染模式：</h3><ol>
<li>标准模式：</li>
<li>怪异模式（混扎模式）：可支持老版本，启动方法（删除&lt;!DOCTYPE html&gt;）</li>
</ol>
<h3 id="查看元素的几何尺寸"><a href="#查看元素的几何尺寸" class="headerlink" title="查看元素的几何尺寸:"></a>查看元素的几何尺寸:</h3><p><code>domEle.getBoundingClientRect();</code></p>
<p>兼容性很好。</p>
<p>该方法返回一个对象，对象里面有 left,top,right,bottom 等属性。left 和 top 代表该元素左上角的 X 和 Y 坐标，right 和 bottom 代表元素右下角的 X 和 Y 坐标<br>height 和 width 属性。<br>老版本 IE 并未实现。</p>
<p>返回的结果并不是“实时的”。</p>
<h4 id="查看元素的尺寸："><a href="#查看元素的尺寸：" class="headerlink" title="查看元素的尺寸："></a>查看元素的尺寸：</h4><p><code>dom.offsetWidth，dom.offsetHeight</code></p>
<h4 id="查看元素的位置："><a href="#查看元素的位置：" class="headerlink" title="查看元素的位置："></a>查看元素的位置：</h4><p><code>dom.offsetLeft, dom.offsetTop</code></p>
<p>对于无定位父级的元素，返回相对文档的坐标。对于有定位父级的元素，返回相对于最近的有定位的父级的坐标。</p>
<p><code>dom.offsetParent</code></p>
<p>返回最近的有定位的父级，如无，返回 body, body.offsetParent 返回 null</p>
<h3 id="让滚动条滚动："><a href="#让滚动条滚动：" class="headerlink" title="让滚动条滚动："></a>让滚动条滚动：</h3><p>window 上有三个方法</p>
<ul>
<li>  scroll(),</li>
<li>  scrollTo(),</li>
<li>  scrollBy();</li>
</ul>
<p>三个方法功能类似，用法都是将 x,y 坐标传入。即实现让滚动轮滚动到当前位置。</p>
<p>区别：scrollBy()会在之前的数据基础之上做累加。</p>
<h3 id="脚本化-CSS"><a href="#脚本化-CSS" class="headerlink" title="脚本化 CSS"></a>脚本化 CSS</h3><p><code>dom.style.prop（获取的是行间样式表）</code></p>
<p>可读写行间样式，没有兼容性问题，碰到 float 这样的关键字属性，前面应加 css</p>
<p><code>eg:float — &gt; cssFloat</code></p>
<p>复合属性必须拆解，组合单词变成小驼峰式写法</p>
<p>写入的值必须是字符串格式</p>
<p>查询计算样式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// window.getComputedStyle(ele,null);（展示的值和默认值）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">window</span>.getComputedStyle(div,<span class="literal">null</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>计算样式只读</p>
<p>返回的计算样式的值都是绝对值，没有相对单位</p>
<p>IE8 及 IE8 以下不兼容<br>可以用 <code>getComputedStyle（ele,伪元素名）</code>来获取伪元素的属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;div&quot;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">window</span>.getComputedStyle(div, <span class="string">&quot;after&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="查询样式"><a href="#查询样式" class="headerlink" title="查询样式"></a>查询样式</h4><p><code>ele.currentStyle</code></p>
<ul>
<li>计算样式只读</li>
<li>返回的计算样式的值不是经过转换的绝对值</li>
<li>IE 独有的属性</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;div&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">div.currentStyle.width;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>元素名.className = “class 名”;可以改元素的 class</p>
<h3 id="事件："><a href="#事件：" class="headerlink" title="事件："></a>事件：</h3><h4 id="绑定事件："><a href="#绑定事件：" class="headerlink" title="绑定事件："></a>绑定事件：</h4><ol>
<li><code>ele.onxxx = function (event) &#123;&#125;</code>  </li>
</ol>
<p>兼容性很好，但是一个元素只能绑定一个处理程序</p>
<p>基本等同于写在 HTML 行间上。（在行间不用写 function 直接写执行语句就行）<br>程序 this 指向是 dom 元素本身</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;div&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">div.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	函数体;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>obj.addEventListener(事件类型, 处理函数, false);</code></li>
</ol>
<p>IE9 以下不兼容，可以为一个事件绑定多个处理程序。<br>程序 this 指向是 dom 元素本身</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">div.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br><span class="line">div.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>a<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>a<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>a<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>a<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> i = <span class="number">0</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> lis = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;li&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; lis.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">        (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            lis[i].addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(i + <span class="number">1</span>);</span></span><br><span class="line"><span class="javascript">            &#125;, <span class="literal">false</span>)</span></span><br><span class="line"><span class="javascript">        &#125;(i))</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 点击每个li展示其序号（注意闭包的应用） --&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>obj.attachEvent(‘on’ + type, fn);</code></li>
</ol>
<p>IE 独有，一个事件同样可以绑定多个处理程序,IE 独有<br>程序 this 指向是 window</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;div&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">div.attachEvent(<span class="string">&quot;onclick&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="解除事件处理函数"><a href="#解除事件处理函数" class="headerlink" title="解除事件处理函数"></a>解除事件处理函数</h3><p><strong>注:若绑定匿名函数，则无法解除</strong></p>
<ol>
<li><code>ele.onclick = false/&#39;&#39;/null;</code></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;div&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">div.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">div.onclick = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>ele.removeEventListener(type, fn, false)</code>;</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;div&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">div.addEventListener(<span class="string">&quot;click&quot;</span>, f, <span class="literal">false</span>);</span><br><span class="line">div.removeEventListener(<span class="string">&quot;click&quot;</span>, f, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若为:</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;div&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">div.addEventListener(</span><br><span class="line">	<span class="string">&quot;click&quot;</span>,</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="literal">false</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">// 则无法解除事件绑定;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>ele.detachEvent(‘on’ + type, fn);</code></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;div&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">div.attachEvent(<span class="string">&quot;onclick&quot;</span>, f);</span><br><span class="line">div.detachEvent(<span class="string">&quot;onclick&quot;</span>, f);</span><br></pre></td></tr></table></figure>

<h3 id="事件处理模-事件冒泡、捕获"><a href="#事件处理模-事件冒泡、捕获" class="headerlink" title="事件处理模: 事件冒泡、捕获"></a>事件处理模: 事件冒泡、捕获</h3><p>一个事件只能执行一个事件模型</p>
<h4 id="事件冒泡："><a href="#事件冒泡：" class="headerlink" title="事件冒泡："></a>事件冒泡：</h4><p>结构上（非视觉上）嵌套关系的元素，会存在事件冒泡的功能，即同一事件，自子元素冒泡向父元素。（自底向上）（从子元素到父元素）</p>
<h4 id="事件捕获："><a href="#事件捕获：" class="headerlink" title="事件捕获："></a>事件捕获：</h4><p>结构上（非视觉上）嵌套关系的元素，会存在事件捕获的功能，即同一事件，自父元素捕获至子元素（事件源元素）。（自顶向下）</p>
<h5 id="触发方式"><a href="#触发方式" class="headerlink" title="触发方式:"></a>触发方式:</h5><p>elem.addEventListeren(‘type’,function(){} ,true);<br>IE 没有捕获事件</p>
<p>触发顺序，先捕获，后冒泡</p>
<p>focus，blur，change，submit，reset，select 等事件不冒泡</p>
<h4 id="取消冒泡和阻止默认事件："><a href="#取消冒泡和阻止默认事件：" class="headerlink" title="取消冒泡和阻止默认事件："></a>取消冒泡和阻止默认事件：</h4><h5 id="取消冒泡："><a href="#取消冒泡：" class="headerlink" title="取消冒泡："></a>取消冒泡：</h5><p><code>event.stopPropagation();</code></p>
<p>W3C 标准</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">document</span>.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&quot;你正在点击整个文档！&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;div&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">div.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">	<span class="comment">//可以加一个参数，代表当前事件的监听，是一个对象</span></span><br><span class="line">	e.stopPropagation();</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&quot;点击div时不再冒泡！&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但不支持 ie9 以下版本</p>
<p>IE 独有<br><code>event.cancelBubble = true;</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&quot;你正在点击整个文档！&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;div&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">div.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// e.stopPropagation();</span></span><br><span class="line">	e.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&quot;点击div时不再冒泡！&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="阻止默认事件"><a href="#阻止默认事件" class="headerlink" title="阻止默认事件:"></a>阻止默认事件:</h5><p>默认事件 — 表单提交，a 标签跳转，右键菜单等</p>
<ol>
<li><code>return false;</code> 以对象属性的方式注册的事件才生效</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.oncontextmenu = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以阻止右键出菜单</span></span><br><span class="line"></span><br><span class="line">&lt;a href=<span class="string">&quot;javascript:void(false)&quot;</span>&gt;demo&lt;/a&gt;</span><br><span class="line"><span class="comment">//  可以阻止a标签的跳转</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>event.preventDefault();</code> W3C 标注，IE9 以下不兼容</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.oncontextmenu = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">	e.preventDefault();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>event.returnValue = false;</code> 兼容 IE</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.oncontextmenu = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">	e.returnValue = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="事件对象："><a href="#事件对象：" class="headerlink" title="事件对象："></a>事件对象：</h4><p>event || window.event 用于 IE<br>事件源对象:<br><code>event.target</code>火狐独有的</p>
<p><code>event.srcElement</code> IE 独有的</p>
<p>这俩 chrome 都有</p>
<h4 id="事件委托："><a href="#事件委托：" class="headerlink" title="事件委托："></a>事件委托：</h4><p>利用事件冒泡，和事件源对象进行处理</p>
<h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ol>
<li><p>性能 不需要循环所有的元素一个个绑定事件</p>
</li>
<li><p>灵活 当有新的子元素时不需要重新绑定事件</p>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>6<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>7<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>8<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>9<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>10<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;ul&#x27;</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript">    ul.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> event = e || <span class="built_in">window</span>.event; <span class="comment">//考虑事件的兼容性</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> target = event.target || event.srcElement;<span class="comment">//考虑源事件的兼容性</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(target.innerText);</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 可以为所有的li添加事件，将li的事件委托给ul --&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="鼠标事件："><a href="#鼠标事件：" class="headerlink" title="鼠标事件："></a>鼠标事件：</h4><ul>
<li>  click、鼠标点击（包括按下和弹起）</li>
<li>  mousedown、鼠标按下</li>
<li>  mousemove、鼠标移动</li>
<li>  mouseup、鼠标弹起</li>
<li>  contextmenu、鼠标右键产生菜单</li>
<li>  mouseover == mouseenter、鼠标进入区域</li>
<li>  mouseout == mouseleave、鼠标移出区域</li>
</ul>
<p>只有 mouseup 和 mousedown 能区分鼠标左右键<br>用 button 来区分鼠标的按键，0/1/2</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.onmousedown = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (e.button == <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&quot;按下的是鼠标右键！&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.button == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&quot;按下的是鼠标左键!&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&quot;按下的是中间滚动轮!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>DOM3 标准规定:click 事件只能监听左键,只能通过 mousedown 和 mouseup 来判断鼠标键</p>
<h4 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h4><ul>
<li>  keydown 按下</li>
<li>  keyup 弹开</li>
<li>  keypress</li>
</ul>
<p>触发顺序：keydown &gt; keypress &gt; keyup</p>
<h5 id="keydown-和-keypress-的区别"><a href="#keydown-和-keypress-的区别" class="headerlink" title="keydown 和 keypress 的区别"></a>keydown 和 keypress 的区别</h5><p>keydown 可以响应任意键盘按键(charcode 始终为 0), keypress 只可以响应字符类键盘按键(charcode 对应 ACICC 码)</p>
<p>keypress 返回 ASCII 码，可以转换成相应字符<br>操作型按键用 keydown（可以使用 which 属性）<br>字符型按键用 keypress</p>
<h4 id="文本操作事件："><a href="#文本操作事件：" class="headerlink" title="文本操作事件："></a>文本操作事件：</h4><ul>
<li>  input,只要文本有变化就触发</li>
<li>  focus,聚焦时触发</li>
<li>  blur,失去焦点触发</li>
<li>  change，失去焦点比较前后两个状态，如果内容改变则触发，内容不变则不触发</li>
</ul>
<h4 id="窗体操作类-window-上的事件"><a href="#窗体操作类-window-上的事件" class="headerlink" title="窗体操作类(window 上的事件)"></a>窗体操作类(window 上的事件)</h4><ul>
<li>  scroll 滚动条滚动</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onscroll = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">this</span>.pageXOffset + <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>.pageYOffset);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>load,整个页面加载完才能触发</p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>DOM</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>js基本语法</title>
    <url>/135xyq.github.io/2021/02/02/JS-js%E7%9F%A5%E8%AF%86%E5%92%8C%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="js-知识和基础语法"><a href="#js-知识和基础语法" class="headerlink" title="js 知识和基础语法"></a>js 知识和基础语法</h1><hr>
<h2 id="浏览器组成："><a href="#浏览器组成：" class="headerlink" title="浏览器组成："></a>浏览器组成：</h2><ul>
<li>  shell：</li>
<li>内核（核心）：<ul>
<li>  渲染引擎（语法规则和渲染）</li>
<li>  js 引擎</li>
<li>  其他模块</li>
</ul>
</li>
</ul>
<p>google 发布的 Chrome，引擎号 V8（C 语言），能直接将就是代码转化为机械码。</p>
<p>计算机中的同步和异步与现实生活中相反<br>异步：同时执行（link 标签的加载）<br>同步：先干一件再干另一件</p>
<h3 id="JavaScript："><a href="#JavaScript：" class="headerlink" title="JavaScript："></a>JavaScript：</h3><p>解释性语言:一行一行执行，不生成文件；<br>单线程:同一时间只能干一件事<br>ECMA 标准</p>
<p>js 执行队列：<br>轮转时间片</p>
<p>js 三大部分：<br>ECMAScript, DOM,BOM</p>
<h3 id="编译语言和解释语言："><a href="#编译语言和解释语言：" class="headerlink" title="编译语言和解释语言："></a>编译语言和解释语言：</h3><ul>
<li>编译（c c++ ）：<br>   优点：快<br>   缺点：不跨平台，移植性不好</li>
<li>解释(javascript php)：<br>   优点：跨平台，移植性好<br>  不足：稍微慢</li>
</ul>
<p>java 既不是编译型语言，也不是解释性语言（oak 语言）</p>
<table>
<thead>
<tr>
<th align="center">主流浏览器</th>
<th align="center">内核</th>
</tr>
</thead>
<tbody><tr>
<td align="center">IE</td>
<td align="center">trident</td>
</tr>
<tr>
<td align="center">Chrom</td>
<td align="center">webkit / blink</td>
</tr>
<tr>
<td align="center">firefox</td>
<td align="center">Gecko</td>
</tr>
<tr>
<td align="center">Opera</td>
<td align="center">presto</td>
</tr>
<tr>
<td align="center">Safari</td>
<td align="center">webkit</td>
</tr>
</tbody></table>
<p>|</p>
<h3 id="js-引入："><a href="#js-引入：" class="headerlink" title="js 引入："></a>js 引入：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script  type=<span class="string">&quot;text/javaScript&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>  <span class="attr">type</span>=<span class="string">&quot;text/javaScript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><strong>当一个 script 标签既引入外部 js 资源又有内部 js 时内部的失效</strong></p>
<p>javascript 是面向对象语言</p>
<p>var 单一类型</p>
<h3 id="数据类型："><a href="#数据类型：" class="headerlink" title="数据类型："></a>数据类型：</h3><ol>
<li>原始值 (存储在栈中，栈与栈之间的赋值是拷贝)：Number Boolean String undefined(未赋值的) null(占位置)</li>
<li>引用值（存储在堆中， ）：array object function</li>
</ol>
<h3 id="代码错误：代码错误只会影响当前代码块"><a href="#代码错误：代码错误只会影响当前代码块" class="headerlink" title="代码错误：代码错误只会影响当前代码块"></a>代码错误：代码错误只会影响当前代码块</h3><ol>
<li>低级错误（语法错误）</li>
<li>逻辑错误</li>
</ol>
<p>赋值顺序：自右向左<br>计算顺序：自左向右</p>
<p>NaN 不等于任何数，包括自己。</p>
<p>undefined , null , NaN ,”” , 0 , false 转为布尔值都为 false</p>
<p>&amp;&amp;运算符（假设有两个值比较）（可用作短路语句），如果第一个值为 false，直接输出第一个的值（结束执行），否则输出第二个值 。</p>
<p>||运算符（假设有两个值比较）：只有两个都为假时才返回假。前一个为真时后一个条件直接忽略（不执行）,前一个为假时，直接返回第二个的值(计算后)</p>
<figure class="highlight plaintext"><figcaption><span>-1；</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```javaScript</span><br><span class="line">never - ending loop：死循环</span><br><span class="line">while (&quot;never - ending loop&quot;) &#123;</span><br><span class="line">    document.write(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>document.write() 可在页面中显示</code><br><code>console.log() :控制台输出</code></p>
<h4 id="switch-case-语句选择："><a href="#switch-case-语句选择：" class="headerlink" title="switch - case 语句选择："></a>switch - case 语句选择：</h4><p>case 里面的类型不要求一致</p>
<p>continue :终止本次循环，开始下次的循环</p>
<p>数组里面的每个元素不用类型一样<br>length ：数组长度</p>
<h3 id="对象："><a href="#对象：" class="headerlink" title="对象："></a>对象：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 对象名 = &#123;</span><br><span class="line">    属性名（key）：属性值（value）,(属性之间用逗号分开)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>取出：对象名.属性名</p>
<p>typeof(变量名) / typeof 变量名:返回数据的类型：<br>返回值有：</p>
<ul>
<li>  number</li>
<li>  string</li>
<li>  boolean</li>
<li>  object</li>
<li>  undefined</li>
<li>  function</li>
<li>  symbol</li>
</ul>
<p>数据 null 返回 object</p>
<h3 id="类型转换："><a href="#类型转换：" class="headerlink" title="类型转换："></a>类型转换：</h3><h4 id="（显式类型转换）："><a href="#（显式类型转换）：" class="headerlink" title="（显式类型转换）："></a>（显式类型转换）：</h4><ul>
<li>  <code>Number()</code>：转为数字。null 和 “” 转为数字是 0 ，undefined 转为数字为 NaN, 根据常识不能转为数字的显示为 NaN ，true 转为 1 ， false 转为 0 。</li>
<li>  <code>parseInt(参数 1)</code>： 转为整数型 ，不能转 true 和 false（为 NaN）。parseInt （参数一，参数二）：参数一：要转换的数，参数二：将数据看成什么进制（2,10,16（取值为 2 - 36））转为 10 进制。转换原理：直接读取数值，遇到非数值部分截断。</li>
<li>  <code>parseFloat()</code>：转为浮点型。转换原理：直接读取数值，遇到除第一个小数点以外的非数值部分截断。</li>
<li>  <code>参数名.toString()</code>：转为字符串,undefined 和 null 不能使用。参数名.toString（参数 1）：参数 1 是进制，将参数转为目标进制。</li>
<li>  <code>String()</code>：转为字符串。</li>
<li>  <code>Boolean()</code>：转为布尔类型。</li>
<li>  <code>toFixed(参数值)</code>：保留 参数值位 小数</li>
</ul>
<h4 id="（隐式类型转换）："><a href="#（隐式类型转换）：" class="headerlink" title="（隐式类型转换）："></a>（隐式类型转换）：</h4><ul>
<li><p>  isNaN（）：判断是否为 NaN ，先调用 Number（），再调用此方法。</p>
</li>
<li><p>  ++ / - - / - :先调用 Number（），再计算，（都变成数字类型）。</p>
</li>
<li><p>  + :当两端有一个为字符串时，调用 String（）,</p>
</li>
<li><p>  */ % / / - :先调用 Number（），再计算，（都变成数字类型）。</p>
</li>
<li><p>  &gt; / &lt; / &gt;= &lt;= :转为其他的类型</p>
</li>
<li><p>  == / != :转为其他的类型（null == undefined 结果为 true ，NaN == NaN 结果为 false）。</p>
</li>
<li><p>  === / !==： 不发生类型转换的判断，直观判断左右是否相等。（NaN=== NaN 结果为 false）。</p>
</li>
</ul>
<p>当一个变量未定义就使用时只有调用 typeof(变量) （显示为 undefined）不会报错，其他情况都报错。</p>
<p>alert() :网页弹出框</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>高内聚，低耦合。</p>
<p>解释性语言输出不了地址。</p>
<h3 id="定义方法："><a href="#定义方法：" class="headerlink" title="定义方法："></a>定义方法：</h3><ol>
<li>函数声明</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名（）</span>&#123;</span><br><span class="line">   函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>命名函数表达式</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 函数名 = <span class="function"><span class="keyword">function</span> 函数名</span>&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>匿名函数表达式（函数表达式）</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 函数名 = <span class="function"><span class="keyword">function</span> </span>&#123;</span><br><span class="line">	函数体</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="调用方法："><a href="#调用方法：" class="headerlink" title="调用方法："></a>调用方法：</h3><p><code>函数名();</code><br><code>函数名（参数，参数）：参数不需要指明类型。</code></p>
<p>定义函数的参数不要求与使用函数时传递的参数一样多，从前到后依次传，多的部分舍弃。</p>
<p>每个函数里面都有一个 arguments(类似于数组，参数列表，用来存放传递过来的实参，可以当成正常数组使用)。<br>当形参比实参多时：arguments 和 形参 多出来的部分不再满足映射（两个同时变化）。<br>可以通过 函数名.length 来求出形参的个数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">w</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// document.write(&quot;a&quot; + &quot;&lt;br&gt;&quot;);</span></span><br><span class="line">	<span class="comment">// document.write(&quot;xyq&quot; + &quot;&lt;br&gt;&quot;);</span></span><br><span class="line">	<span class="comment">// document.write(x + y);</span></span><br><span class="line">	<span class="built_in">arguments</span>[<span class="number">2</span>] = <span class="number">4</span>;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line">w(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>return 函数返回值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 银行金额输出：</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="built_in">window</span>.prompt(<span class="string">&quot;input&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transform</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (number) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;1&quot;</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;壹&quot;</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;2&quot;</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;贰&quot;</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;3&quot;</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;叁&quot;</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;4&quot;</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;肆&quot;</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;5&quot;</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;伍&quot;</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;6&quot;</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;陆&quot;</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;7&quot;</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;柒&quot;</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;8&quot;</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;捌&quot;</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;9&quot;</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;玖&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (number) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;拾&quot;</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;佰&quot;</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;仟&quot;</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;万&quot;</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;拾万&quot;</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;佰万&quot;</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;千万&quot;</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;亿&quot;</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> i;</span><br><span class="line">	<span class="keyword">var</span> result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n.length; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n[i] == <span class="string">&quot;0&quot;</span>) &#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			result += transform(n[i]);</span><br><span class="line">			<span class="keyword">if</span> (n.length - i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">				result += change(n.length - i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	result += <span class="string">&quot;元整&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(write(n));</span><br></pre></td></tr></table></figure>

<h3 id="递归-规律：先执行的最后执行完-："><a href="#递归-规律：先执行的最后执行完-：" class="headerlink" title="递归(规律：先执行的最后执行完)："></a>递归(规律：先执行的最后执行完)：</h3><ol>
<li>找规律</li>
<li>找出口</li>
</ol>
<p>函数变量作用域：里层可以访问外层，外层不能访问里层</p>
<h3 id="js-执行三部曲："><a href="#js-执行三部曲：" class="headerlink" title="js 执行三部曲："></a>js 执行三部曲：</h3><ul>
<li>  语法分析</li>
<li>  预编译</li>
<li>  解释执行</li>
</ul>
<h3 id="预编译的结果："><a href="#预编译的结果：" class="headerlink" title="预编译的结果："></a>预编译的结果：</h3><ul>
<li>  函数声明整体提升</li>
<li>  变量 声明提升（只是声明了变量，不能使用里面的值）</li>
</ul>
<p>imply global 暗示全局变量：即任何变量，如果<strong>变量未经声明就赋值，此变量就为全局对象所有</strong>。<br>全局对象（window)<br>一切声明的全局变量，全是 window 的属性，即 var a = 123 =====&gt; window.a =123;<br>window 就是全局</p>
<h3 id="全局的预编译过程："><a href="#全局的预编译过程：" class="headerlink" title="全局的预编译过程："></a>全局的预编译过程：</h3><ol>
<li>创建 GO 对象（全局的执行期上下文） GO === window</li>
<li>找形参和变量声明，将变量和形参名作为 GO 属性名，值为 undefined 。</li>
<li>在函数体里面找函数声明（函数表达式不行），值赋予函数体</li>
</ol>
<h3 id="函数体里的预编译过程：（预编译发生在函数执行的前一刻）"><a href="#函数体里的预编译过程：（预编译发生在函数执行的前一刻）" class="headerlink" title="函数体里的预编译过程：（预编译发生在函数执行的前一刻）"></a>函数体里的预编译过程：（预编译发生在函数执行的前一刻）</h3><ol>
<li>创建 AO 对象（执行期上下文）</li>
<li>找形参和变量声明，将变量和形参名作为 AO 属性名，值为 undefined。</li>
<li>将实参值与形参统一</li>
<li>在函数体里面找函数声明（函数表达式不行），值赋予函数体</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(a);</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">123</span>;</span><br><span class="line">	<span class="built_in">console</span>.log(a);</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">	<span class="built_in">console</span>.log(a);</span><br><span class="line">	<span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">	<span class="built_in">console</span>.log(b);</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">ƒ <span class="function"><span class="title">a</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="number">123</span></span><br><span class="line">ƒ () &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> c;</span><br><span class="line">    a = <span class="number">3</span>;</span><br><span class="line">    b = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">答案</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>函数可以看成特殊的对象</p>
<h3 id="函数里面的属性："><a href="#函数里面的属性：" class="headerlink" title="函数里面的属性："></a>函数里面的属性：</h3><h4 id="可访问的："><a href="#可访问的：" class="headerlink" title="可访问的："></a>可访问的：</h4><ul>
<li>  name:函数名</li>
<li>  prototype</li>
</ul>
<h4 id="不可访问的（隐式属性）："><a href="#不可访问的（隐式属性）：" class="headerlink" title="不可访问的（隐式属性）："></a>不可访问的（隐式属性）：</h4><p>[[scope]] :存放作用域</p>
<p>但凡内部的函数保存到外部，一定生成了闭包。<br>闭包会导致作用链不释放，造成内存泄漏。</p>
<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>针对初始化功能的函数（立即执行函数）：<br>执行完一次就销毁，其他和普通函数一样。</p>
<h4 id="普通的"><a href="#普通的" class="headerlink" title="普通的"></a>普通的</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	函数体</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure>

<h4 id="带参数的"><a href="#带参数的" class="headerlink" title="带参数的"></a>带参数的</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">形参</span>) </span>&#123;</span><br><span class="line">	函数体</span><br><span class="line">&#125;(实参))</span><br></pre></td></tr></table></figure>

<h4 id="带返回值的"><a href="#带返回值的" class="headerlink" title="带返回值的"></a>带返回值的</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	函数体</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>

<p>只有表达式才能被执行符号执行<br>被执行符号执行的函数名字会被直接放弃（丢弃），相当于变成了立即执行函数。</p>
<p>嵌套函数将内部函数保存到外部，一定会生成闭包，保存到外部的函数可以调用原来所处位置的变量。</p>
<p>多个函数和一个函数形成闭包，则多个函数的变量共用。</p>
<p>函数不执行（只定义）就不会运行函数内部的语句，什么时候执行函数，函数再运行内部语句。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num);</span><br><span class="line">&#125;</span><br><span class="line">num = <span class="number">200</span>;</span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line">输出<span class="number">200</span></span><br></pre></td></tr></table></figure>

<h3 id="，-也可以作为运算符，返回后面的计算值。"><a href="#，-也可以作为运算符，返回后面的计算值。" class="headerlink" title="， 也可以作为运算符，返回后面的计算值。"></a>， 也可以作为运算符，返回后面的计算值。</h3><p>例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = (<span class="number">1</span> -<span class="number">1</span> , <span class="number">1</span> + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">a 的值为<span class="number">2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = (</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">)();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> f);</span><br><span class="line"></span><br><span class="line">输出值为 number</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;) &#123; <span class="comment">//立即执行函数</span></span><br><span class="line">    x += <span class="keyword">typeof</span> f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line"></span><br><span class="line">输出 ： 1<span class="literal">undefined</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="对象创建方法："><a href="#对象创建方法：" class="headerlink" title="对象创建方法："></a>对象创建方法：</h3><h4 id="1-plainObject-对象字面量-对象直接量"><a href="#1-plainObject-对象字面量-对象直接量" class="headerlink" title="1. plainObject 对象字面量 / 对象直接量"></a>1. plainObject 对象字面量 / 对象直接量</h4><p>   每个属性之间用 ， 分隔开</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 对象名 = &#123;</span><br><span class="line">    属性名 ： 属性值，</span><br><span class="line"></span><br><span class="line">    方法名 ： <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="built_in">this</span>.属性名; <span class="comment">//调用属性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2. 构造函数"></a>2. 构造函数</h4><h5 id="1-系统自带的构造函数-Object"><a href="#1-系统自带的构造函数-Object" class="headerlink" title="1. 系统自带的构造函数 Object()"></a>1. 系统自带的构造函数 Object()</h5><p>可以增，删，查，改 ，属性和方法<br><code>var 对象名 = new Object();</code></p>
<h5 id="2-自定义-函数名使用大驼峰-（首字母全大写）"><a href="#2-自定义-函数名使用大驼峰-（首字母全大写）" class="headerlink" title="2. 自定义(函数名使用大驼峰 （首字母全大写）)"></a>2. 自定义(函数名使用大驼峰 （首字母全大写）)</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params">参数</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.属性名 = 属性值;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.方法名 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> 对象名 = <span class="keyword">new</span> 函数名(参数);</span><br></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;BMW&quot;</span>;</span><br><span class="line">    <span class="built_in">this</span>.height = <span class="string">&quot;1400&quot;</span>;</span><br><span class="line">    <span class="built_in">this</span>.lang = <span class="string">&quot;49000&quot;</span>;</span><br><span class="line">    <span class="built_in">this</span>.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&quot;I am Running!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> car = <span class="keyword">new</span> Car();</span><br></pre></td></tr></table></figure>

<h3 id="构造函数内部原理："><a href="#构造函数内部原理：" class="headerlink" title="构造函数内部原理："></a>构造函数内部原理：</h3><ol>
<li>在函数体最前面隐式的加上 this = {}</li>
<li>执行 this.xxx = xxx</li>
<li>隐式的返回 this</li>
</ol>
<p>当一个构造函数显式返回一个对象时(object、array、function),通过new 生成的对象是显式返回的对象。</p>
<p>当一个对象的属性未定义就使用不会报错，会返回 undefined。</p>
<p>对象属性使用：<br>对象名. 属性名 / 对象名. 方法名</p>
<p>this 第一人称可以用来指代对象。</p>
<h4 id="给对象增加属性和方法："><a href="#给对象增加属性和方法：" class="headerlink" title="给对象增加属性和方法："></a>给对象增加属性和方法：</h4><p>对象名.属性名 = “属性值” / 对象名. 方法名 = function() { }</p>
<h4 id="给对象改变属性和方法："><a href="#给对象改变属性和方法：" class="headerlink" title="给对象改变属性和方法："></a>给对象改变属性和方法：</h4><p>对象名.属性名 = “属性值” / 对象名. 方法名 = function() { }</p>
<h4 id="删除对象属性和方法："><a href="#删除对象属性和方法：" class="headerlink" title="删除对象属性和方法："></a>删除对象属性和方法：</h4><p>delete 对象名.属性名 / delete 对象名. 方法名</p>
<p><strong>原始值类型的变量没有属性和方法</strong>。</p>
<h3 id="包装类："><a href="#包装类：" class="headerlink" title="包装类："></a>包装类：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个数字型对象（可以有方法和属性）  </span></span><br><span class="line"><span class="keyword">var</span> 对象名 = <span class="keyword">new</span> <span class="built_in">Number</span>(数字);</span><br></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>);</span><br><span class="line"><span class="comment">//创建一个字符串型对象（可以有方法和属性）</span></span><br><span class="line"><span class="keyword">var</span>  对象名 = <span class="keyword">new</span> <span class="built_in">String</span>(字符串);</span><br></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;abc&#x27;</span>);</span><br><span class="line"><span class="comment">//创建一个布尔型对象（可以有方法和属性）</span></span><br><span class="line"><span class="keyword">var</span> 对象名 = <span class="keyword">new</span> Strng(布尔类型);</span><br></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bool = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>想操作原始值属性，系统会自动将其包装为对象，再删除对象。</p>
<h2 id="原型："><a href="#原型：" class="headerlink" title="原型："></a>原型：</h2><p>用法：函数名.prototype.属性名 = 属性值；<br>function 对象的一个属性，他定义了构造函数制造出的对象的公共祖先。通过该构造函数产生的对象，可以继承该原型的属性和方法，原型也是对象（可以按照对象操作）。<br>利用原型特点和概念，可以提取共有属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Car.prototype.height = <span class="string">&quot;1400&quot;</span>;</span><br><span class="line">Car.prototype.lang = <span class="string">&quot;49000&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&quot;I am Running!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> car = <span class="keyword">new</span> Car(<span class="string">&quot;BWM&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> car1 = <span class="keyword">new</span> Car(<span class="string">&quot;AoDi&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="不能通过对象修改原型。"><a href="#不能通过对象修改原型。" class="headerlink" title="不能通过对象修改原型。"></a>不能通过对象修改原型。</h4><p>函数名.prototype.属性  =  属性值;//修改属性</p>
<p>delete 函数名.prototype.属性; //删除</p>
<p>例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> Car.prototype.height;</span><br></pre></td></tr></table></figure>

<p>对象名.constructor； 可以找出对象的构造函数。</p>
<p>charCodeAt() 方法可找出字符串的每一位。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Person.prototype.name = <span class="string">&#x27;xyq&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">Person.prototype.name = <span class="string">&#x27;hsz&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name);</span><br><span class="line"></span><br><span class="line">输出为 hsz</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">&#x27;xyq&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">// Person.prototype.name = &#x27;hsz&#x27;;</span></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;hsz&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(person.name);</span><br><span class="line"></span><br><span class="line">输出为xyq</span><br><span class="line"><span class="comment">// 会重新创建一个对象，更改地址了</span></span><br></pre></td></tr></table></figure>

<h4 id="绝大多数对象最终都继承自-Object-prototype"><a href="#绝大多数对象最终都继承自-Object-prototype" class="headerlink" title="绝大多数对象最终都继承自 Object.prototype"></a>绝大多数对象最终都继承自 Object.prototype</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">可以创建一个没有继承<span class="built_in">Object</span>的对象</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.floor(number) ;  向下取整（舍弃小数部分）</span><br><span class="line"><span class="built_in">Math</span>.ceil(number); 向上取整（整数部分加一）</span><br></pre></td></tr></table></figure>

<p>可正常计算的范围：小数点前 16 位 ，后 16 位</p>
<h3 id="call-apply-方法-："><a href="#call-apply-方法-：" class="headerlink" title="call / apply 方法 ："></a>call / apply 方法 ：</h3><p>改变 this 的指向（可以借别人的方法来封装自己的功能）</p>
<h4 id="call-需要把实参按照形参的个数传进去，apply-只能传一个-arguments-数组"><a href="#call-需要把实参按照形参的个数传进去，apply-只能传一个-arguments-数组" class="headerlink" title="call 需要把实参按照形参的个数传进去，apply 只能传一个 arguments(数组)"></a>call 需要把实参按照形参的个数传进去，apply 只能传一个 arguments(数组)</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">&#x27;XYQ&#x27;</span>, <span class="number">21</span>);</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line">Person.call(obj, <span class="string">&#x27;xyq&#x27;</span>, <span class="number">21</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// obj会变成&#123;name: &quot;xyq&quot;, age: &quot;21&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, sex</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.sex = sex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, sex, tel, grade</span>) </span>&#123;</span><br><span class="line">    Person.call(<span class="built_in">this</span>, name, age, sex);</span><br><span class="line">    <span class="built_in">this</span>.tel = tel;</span><br><span class="line">    <span class="built_in">this</span>.grade = grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以生成Student函数有（name, age, sex, tel, grade）属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, sex</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = name;</span><br><span class="line">	<span class="built_in">this</span>.age = age;</span><br><span class="line">	<span class="built_in">this</span>.sex = sex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, sex, tel, grade</span>) </span>&#123;</span><br><span class="line">	Person.apply(<span class="built_in">this</span>, [name, age, sex]);</span><br><span class="line">	<span class="built_in">this</span>.tel = tel;</span><br><span class="line">	<span class="built_in">this</span>.grade = grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以生成Student函数有（name, age, sex, tel, grade）属性</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>js中的继承 枚举和数组介绍</title>
    <url>/135xyq.github.io/2021/02/11/JS-%E7%BB%A7%E6%89%BF_%E6%9E%9A%E4%B8%BE_%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="继承-枚举-数组"><a href="#继承-枚举-数组" class="headerlink" title="继承 枚举 数组"></a>继承 枚举 数组</h1><hr>
<h3 id="普通模式"><a href="#普通模式" class="headerlink" title="普通模式"></a>普通模式</h3><p>弊端：两个对象的原型会指向同一个内存空间，会一起改变。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Father.prototype.lastNmae = <span class="string">&#x27;xyq&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">Target, Origin</span>) </span>&#123;</span><br><span class="line">    Target.prototype = Origin.prototype;</span><br><span class="line">&#125;</span><br><span class="line">inherit(Son, Father);</span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> Son();</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以让son和father有相同的原型，互相之间更改相关联</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Father.prototype.lastNmae = <span class="string">&#x27;xyq&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">Target, Origin</span>) </span>&#123;</span><br><span class="line">    Target.prototype = Origin.prototype;</span><br><span class="line">&#125;</span><br><span class="line">inherit(Son, Father);</span><br><span class="line">Son.prototype.sex = <span class="string">&#x27;male&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> Son();</span><br><span class="line"><span class="keyword">var</span> father = <span class="keyword">new</span> Father();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果为son和father都可以访问sex属性为male</span></span><br></pre></td></tr></table></figure>

<h3 id="圣杯模式：解决互相影响的问题"><a href="#圣杯模式：解决互相影响的问题" class="headerlink" title="圣杯模式：解决互相影响的问题"></a>圣杯模式：解决互相影响的问题</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Father.prototype.lastName = <span class="string">&quot;xyq&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">Target, Origin</span>) </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">	F.prototype = Origin.prototype;</span><br><span class="line">	Target.prototype = <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line">inherit(Son, Father);</span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> Son();</span><br><span class="line"><span class="comment">// son和father有相同的原型，但son的更改对于father没有影响</span></span><br><span class="line"><span class="comment">// 此时son的constuctor指向Father（）</span></span><br><span class="line">Father.prototype.lastName = <span class="string">&quot;xyq&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">Target, Origin</span>) </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">	F.prototype = Origin.prototype;</span><br><span class="line">	Target.prototype = <span class="keyword">new</span> F();</span><br><span class="line">	Target.prototype.constuctor = Target;</span><br><span class="line">	<span class="comment">//使Target产生的对象的constuctor指向Target（）</span></span><br><span class="line">&#125;</span><br><span class="line">inherit(Son, Father);</span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> Son();</span><br></pre></td></tr></table></figure>

<p>命名空间：用对象解决变量重名，模块化开发。</p>
<h4 id="属性的表示方法："><a href="#属性的表示方法：" class="headerlink" title="属性的表示方法："></a>属性的表示方法：</h4><p>obj.属性名<br>obj.[“属性名”]</p>
<h3 id="遍历枚举"><a href="#遍历枚举" class="headerlink" title="遍历枚举"></a>遍历枚举</h3><h4 id="遍历对象的属性："><a href="#遍历对象的属性：" class="headerlink" title="遍历对象的属性："></a>遍历对象的属性：</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>（ <span class="keyword">var</span> 变量名 <span class="keyword">in</span> 对象名）&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;123&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">123</span>,</span><br><span class="line">    <span class="attr">sex</span>: <span class="string">&quot;male&quot;</span>,</span><br><span class="line">    <span class="attr">height</span>: <span class="number">180</span>,</span><br><span class="line">    <span class="attr">weight</span>: <span class="number">75</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(prop);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以遍历对象的属性名</span></span><br></pre></td></tr></table></figure>

<p>在枚举中调用对象属性不能用 对象名.属性名 ,可以用对象名[属性名]</p>
<p>A instanceof B 看 A 对象的原型链上有没有 B 的原型</p>
<p>typeof 可能返回的类型：</p>
<ul>
<li>  string</li>
<li>  object</li>
<li>  undefined</li>
<li>  function</li>
<li>  number</li>
<li>  boolean</li>
</ul>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><ol>
<li>函数预编译过程 this - &gt; window</li>
<li>全局作用域里 this -&gt; window</li>
<li>call / apply 可以改变函数运行时的 this 指向</li>
<li>obj.func(); func() 里面的 this 指向 obj</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">var</span> name = <span class="string">&quot;222&quot;</span>;</span><br><span class="line">        <span class="keyword">var</span> a = &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&quot;111&quot;</span>,</span><br><span class="line">            <span class="attr">say</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> fun = a.say;</span><br><span class="line">        fun(); <span class="comment">//222</span></span><br><span class="line">        a.say(); <span class="comment">//111</span></span><br><span class="line">        <span class="keyword">var</span> b = &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&quot;333&quot;</span>,</span><br><span class="line">            <span class="attr">say</span>: <span class="function"><span class="keyword">function</span>(<span class="params">fun</span>) </span>&#123;</span><br><span class="line">                fun();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        b.say(a.say); <span class="comment">//222</span></span><br><span class="line">        b.say = a.say;</span><br><span class="line">        b.say(); <span class="comment">//333</span></span><br></pre></td></tr></table></figure>

<p><code>arguments.callee();</code> 可以找到函数的引用名</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = (<span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    <span class="keyword">return</span> n * <span class="built_in">arguments</span>.callee(n - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num);</span><br><span class="line"></span><br><span class="line"><span class="comment">//用立即执行函数通过递归求100的阶乘</span></span><br></pre></td></tr></table></figure>

<h3 id="浅层克隆（引用值不独立，原始值独立）"><a href="#浅层克隆（引用值不独立，原始值独立）" class="headerlink" title="浅层克隆（引用值不独立，原始值独立）"></a>浅层克隆（引用值不独立，原始值独立）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//克隆函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">origin,target</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> target = target || &#123;&#125;; <span class="comment">//避免用户不传新的对象</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> prop <span class="keyword">in</span> origin)&#123;</span><br><span class="line">	    target[prop] = origin[prop];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="深层克隆（递归）"><a href="#深层克隆（递归）" class="headerlink" title="深层克隆（递归）"></a>深层克隆（递归）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">origin,target</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> target = target || &#123;&#125;,</span><br><span class="line">        toStr = <span class="built_in">Object</span>.prototype.toString,</span><br><span class="line">        arrStr = <span class="string">&quot;[object Array]&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> prop <span class="keyword">in</span> origin)&#123;</span><br><span class="line">        <span class="keyword">if</span>(origin.hasOwnProperty(prop))&#123;</span><br><span class="line">            <span class="keyword">if</span>(origin[prop] !== <span class="string">&quot;null&quot;</span> &amp;&amp; <span class="keyword">typeof</span>(origin[prop] == <span class="string">&#x27;object&#x27;</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span>(toStr.call(origin[prop] == arrStr))&#123;</span><br><span class="line">                    target[prop] = origin[prop];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    target[prop] = origin[prop];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            deepClone(origin[prop],target[prop]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            target[prop] = origin[prop];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="定义方式："><a href="#定义方式：" class="headerlink" title="定义方式："></a>定义方式：</h3><h4 id="数组字面量：var-数组名"><a href="#数组字面量：var-数组名" class="headerlink" title="数组字面量：var 数组名 = [];"></a>数组字面量：<code>var 数组名 = [];</code></h4><h4 id="构造方法：-var-数组名-new-Array-参数"><a href="#构造方法：-var-数组名-new-Array-参数" class="headerlink" title="构造方法： var 数组名 = new Array(参数); "></a>构造方法： <code>var 数组名 = new Array(参数); </code></h4><p>参数个数为 1 时代表数组的长度（只能为整数），个数大于 1 时代表数组的具体内容。</p>
<p>数组的所有方法全来自 Array.prototype</p>
<p>数组可以越界读取数据（undefined）</p>
<h3 id="数组的方法："><a href="#数组的方法：" class="headerlink" title="数组的方法："></a>数组的方法：</h3><h4 id="1-改变原数组："><a href="#1-改变原数组：" class="headerlink" title="1. 改变原数组："></a>1. 改变原数组：</h4><ul>
<li>  push : 在数组最后面添加内容（可一次添加多个,返回值:数组的新长度</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line">arr.push(<span class="number">123</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>  pop:剪切出数组最后一位,返回值:pop 得到的值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line">arr.pop();</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果为2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  unshift:在数组最前面加内容(可一次添加多个),返回值：新数组的长度</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.unshift(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组为：[0,1,2,3]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  shift:剪切数组最前面的内容，返回值:剪切得到的值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.shift();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组为[2,3]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  reverse:数组逆序,返回值：逆序后的数组</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.reverse();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组为[3,2,1]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  sort：将数组内容排序(按 ASCII 码排序)，返回值：排序后的数组</li>
</ul>
<h5 id="正常使用："><a href="#正常使用：" class="headerlink" title="正常使用："></a>正常使用：</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">数组名.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a , b </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  变量名；</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="规则："><a href="#规则：" class="headerlink" title="规则："></a>规则：</h3><ol>
<li>必须写俩形参</li>
<li>看返回值：<ol>
<li>返回值为负数：前一个数放在前面</li>
<li>返回值为正数：后一个数放在前面</li>
<li>返回值为 0 时：顺序不动</li>
</ol>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.sort();</span><br><span class="line"><span class="comment">// 数组为[2,3,4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">0</span>];</span><br><span class="line">arr.sort().reverse();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逆序</span></span><br><span class="line"><span class="comment">// 数组为：[9,4,3,2,1,0]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line">arr.sort();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组为：[1, 10, 2, 3, 4, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 顺序</span></span><br><span class="line"><span class="comment">// 数组为：[1,2,3,4,9,10]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line">	arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">	    <span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">	        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逆序</span></span><br><span class="line">    <span class="comment">// 数组为：[10,9,4,3,2,1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 升序：</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line">	arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 降序</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line">	arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b - a;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>splice:数组切片(可在任意位置添加内容) 返回值：切取下来的数据，组成一个数组<br>  数组名.splice(从第几位开始，截取的长度，在切口处添加新的数据)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>];</span><br><span class="line">arr.splice(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">//数组内容为[1,2,3,3,3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>];</span><br><span class="line">arr.splice(<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//数组内容为：[1, 0, 0, 2, 3, 3, 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line">arr.splice(<span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">//数组内容为：[1,2,3,4,5]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-不改变原数组："><a href="#2-不改变原数组：" class="headerlink" title="2.不改变原数组："></a>2.不改变原数组：</h4><ul>
<li>  concat() :连接两个数组</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">arr2 = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>];</span><br><span class="line">arr = arr1.concat(arr2);</span><br><span class="line">arr : [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>slice : 截取<br>  数组.slice(截取开始位置，截取结束位置)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> arr = arr1.slice(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// arr:[2]</span></span><br><span class="line"></span><br><span class="line">arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> arr = arr1.slice(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// arr:[2,3,4]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>join：将数组各位连接起来<br>  数组名.join(字符串)；<br>  无参数默认为用 , 连接</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> arr = arr1.join(<span class="string">&quot;!&quot;</span>);</span><br><span class="line"><span class="comment">// arr：&quot;1!2!3!4&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  split:将字符串按照某一规则拆分成数组,与 join 互逆</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="comment">// arr2 = [5, 6, 7, 8];</span></span><br><span class="line"><span class="comment">// var arr = arr1.concat(arr2);</span></span><br><span class="line"><span class="comment">// var arr = arr1.slice(1);</span></span><br><span class="line"><span class="keyword">var</span> str = arr1.join(<span class="string">&quot;!&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> arr = str.split(<span class="string">&quot;!&quot;</span>); </span><br><span class="line"><span class="comment">// arr: [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;]</span></span><br></pre></td></tr></table></figure>

<p>类数组：像数组的对象<br>属性要为索引（数字）属性，必须有 length 属性，最好加上 push<br>arguments 是个类数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="string">&quot;0&quot;</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    <span class="string">&quot;1&quot;</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">    <span class="string">&quot;2&quot;</span>: <span class="string">&quot;c&quot;</span>,</span><br><span class="line">    <span class="string">&quot;length&quot;</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="string">&quot;push&quot;</span>: <span class="built_in">Array</span>.prototype.push,</span><br><span class="line">    <span class="string">&quot;splice&quot;</span>: <span class="built_in">Array</span>.prototype.splice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 try 里面的发生错误，不会执行错误后的 try 里的代码<br>在 try 里面中断程序(return)，finally 里面的代码仍会执行，会跳过catch的执行</p>
<p><code>e.name:错误名称</code><br><code>e.message:错误信息</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;e&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;d&quot;</span>);</span><br><span class="line"><span class="comment">// 输出为：a  e  d</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.name + <span class="string">&quot;:&quot;</span> + e.message);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">可打印出出错信息</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&quot;try&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;测试&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(e);</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：try  finally</span></span><br></pre></td></tr></table></figure>

<h4 id="Error-name-的六种值对应的信息："><a href="#Error-name-的六种值对应的信息：" class="headerlink" title="Error.name 的六种值对应的信息："></a>Error.name 的六种值对应的信息：</h4><ol>
<li>EvalError : eval()的使用与定义不一致</li>
<li>RangeError：数值越界</li>
<li>ReferenceError：非法或不能识别的引用数值</li>
<li>SyntaxError：发生语法解析错误</li>
<li>TypeError：操作数类型错误</li>
<li>URIError：URI 处理函数使用不当</li>
</ol>
<h4 id="es5-0-严格模式："><a href="#es5-0-严格模式：" class="headerlink" title="es5.0 严格模式："></a>es5.0 严格模式：</h4><p>不再兼容 es3 的一些不规则语法，使用全新的 es5 规范（不会对不兼容严格模式的浏览器产生影响）</p>
<p>“use strict”;来启动 es5.0 严格模式（写在逻辑最顶端）<br>可以使用全局严格模式<br>也可以使用局部函数内严格模式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">with</span>(<span class="params">对象名</span>)</span>&#123;</span><br><span class="line">	代码体；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以将 with 里面的代码的作用域链最顶端改为新给出的对象（降低效率）</p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>js中常用的数组方法</title>
    <url>/135xyq.github.io/2021/02/06/JS-js%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="js-数组方法"><a href="#js-数组方法" class="headerlink" title="js 数组方法"></a>js 数组方法</h1><hr>
<h2 id="label-标签"><a href="#label-标签" class="headerlink" title="label 标签"></a>label 标签</h2><p>for 里面写上要关联内容的标识<br>添加事件时触发 label 时和 label 他关联的内容都触发，但触发内容事件时只触发自身</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;demo&quot;</span>&gt;</span>uesrname:<span class="tag">&lt;/<span class="name">label</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;demo&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="属性和特性："><a href="#属性和特性：" class="headerlink" title="属性和特性："></a>属性和特性：</h2><p>特性属于属性<br>特性：系统上自带的一些属性<br>元素的特性是与 dom 对象一 一映射的<br>不是特性的属性不是一 一映射的</p>
<h2 id="图片的预加载和懒加载"><a href="#图片的预加载和懒加载" class="headerlink" title="图片的预加载和懒加载"></a>图片的预加载和懒加载</h2><h3 id="预加载："><a href="#预加载：" class="headerlink" title="预加载："></a>预加载：</h3><p>图片加载完之后才展现，不一行一行加载展现出来</p>
<h3 id="懒加载："><a href="#懒加载：" class="headerlink" title="懒加载："></a>懒加载：</h3><p>浏览到才开始加载</p>
<h2 id="Math-random"><a href="#Math-random" class="headerlink" title="Math.random()"></a>Math.random()</h2><p>区间范围 ： [ 0 , 1 )</p>
<h2 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h2><h3 id="forEach-："><a href="#forEach-：" class="headerlink" title="forEach ："></a>forEach ：</h3><ul>
<li><p>循环遍历，两个参数为一个函数（（三个参数）第一个是数组中的元素，第二个是索引，第三个是数组本身），第二个参数代表this的指向（可省略（默认为window））</p>
</li>
<li><p>数组名.forEach(函数（有三个参数）（第一个是数组中的元素，第二个是索引，第三个是数组本身）)；<br>无返回值</p>
</li>
</ul>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter :"></a>filter :</h3><ul>
<li><p>对数组过滤，基于遍历 ，两个参数为一个函数（（三个参数）第一个是数组中的元素，第二个是索引，第三个是数组本身），第二个参数代表this的指向（可省略（默认为window））</p>
</li>
<li><p>执行完会返回一个新的数组。若函数的返回值为true代表当前元素保存在新数组中，为false时则过滤掉。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>];</span><br><span class="line"><span class="keyword">const</span> b = a.filter(<span class="function"><span class="params">item</span>=&gt;</span>item%<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;filter&quot;</span>,a,b)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// filter  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]  [1, 3, 5, 7, 9]</span></span><br></pre></td></tr></table></figure>

<h3 id="map"><a href="#map" class="headerlink" title="map :"></a>map :</h3><ul>
<li>映射，两个参数为一个函数（（三个参数）第一个是数组中的元素，第二个是索引，第三个是数组本身），第二个参数代表this的指向（可省略（默认为window））</li>
<li>函数执行完的返回值决定map返回的值，会返回一个新的数组</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> newArr = personArr.map(<span class="function"><span class="keyword">function</span> (<span class="params">ele, index, self</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> self[index].name;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以仅返回数组中每一项中的name属性</span></span><br><span class="line"><span class="built_in">console</span>.log(newArr);</span><br></pre></td></tr></table></figure>


<h3 id="every-："><a href="#every-：" class="headerlink" title="every ："></a>every ：</h3><ul>
<li><p>数组中每元素都符合什么条件，两个参数，第一个参数为函数（（三个参数）第一个是数组中的元素，第二个是索引，第三个是数组本身）第二个参数代表this的指向（可省略（默认为window））</p>
</li>
<li><p>返回值为false则有元素不符合，返回值为true则所有项都符合，只有遇到有返回值为false就停止执行，返回结果为false。</p>
</li>
</ul>
<p><strong>执行完会返回true或false</strong>。</p>
<h3 id="some-："><a href="#some-：" class="headerlink" title="some ："></a>some ：</h3><ul>
<li><p>数组中是否有元素都符合什么条件，两个参数，第一个参数为函数（（三个参数）第一个是数组中的元素，第二个是索引，第三个是数组本身）第二个参数代表this的指向（可省略（默认为window））</p>
</li>
<li><p>返回值为false则所有元素都不符合，返回值为true则至少有一个符合，只有遇到有返回值为true就停止执行，返回结果为true。<br>执行完会返回true或false。</p>
</li>
</ul>
<h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><p>可以把类数组转为数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> lis = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;li&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> temp = [].slice.call(lis)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>运动 正则表达式</title>
    <url>/135xyq.github.io/2021/02/13/JS-%E8%BF%90%E5%8A%A8_%E6%AD%A3%E5%88%99/</url>
    <content><![CDATA[<h1 id="运动-正则"><a href="#运动-正则" class="headerlink" title="运动 正则"></a>运动 正则</h1><hr>
<h2 id="运动"><a href="#运动" class="headerlink" title="运动"></a>运动</h2><p>offsetLeft：当前位置距离左边界距离<br>多物体运动：要给每个物体单独设置自己的定时器<br>回调机制：执行完主体函数再执行</p>
<p>JSON 是一种传输数据的格式（以对象为样板，本质上就是对象（json 的属性名要变成字符串样式），但用途有区别，对象就是本地用的，json 是用来传输的）</p>
<h4 id="JSON-stringify-json-—-gt-string"><a href="#JSON-stringify-json-—-gt-string" class="headerlink" title="JSON.stringify(); json — &gt; string"></a>JSON.stringify(); json — &gt; string</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&quot;xyq&quot;</span>,</span><br><span class="line">	<span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">JSON</span>.stringify(obj);</span><br><span class="line">返回结果为;</span><br><span class="line">(<span class="string">&#x27;&#123;&quot;name&quot;:&quot;xyq&quot;,&quot;age&quot;:20&#125;&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="JSON-parse-string-—-gt-json"><a href="#JSON-parse-string-—-gt-json" class="headerlink" title="JSON.parse(); string — &gt; json"></a>JSON.parse(); string — &gt; json</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;xyq&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> json = <span class="built_in">JSON</span>.stringify(obj) </span><br><span class="line"><span class="built_in">JSON</span>.parse(json)</span><br><span class="line"><span class="comment">// 返回值为：</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;xyq&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dom 树深度优先原则</p>
<h2 id="异步加载-JS"><a href="#异步加载-JS" class="headerlink" title="异步加载 JS"></a>异步加载 JS</h2><h3 id="js-加载的缺点："><a href="#js-加载的缺点：" class="headerlink" title="js 加载的缺点："></a>js 加载的缺点：</h3><ul>
<li>  加载工具方法没必要阻塞文档，过得 js 加载会影响页面效率，一旦网速不好，那么整个网站将等待 js 加载而不进行后续渲染等工作。</li>
<li>  有些工具方法需要按需加载，用到再加载，不用不加载。</li>
</ul>
<h3 id="javascript-异步加载-的-三种方案"><a href="#javascript-异步加载-的-三种方案" class="headerlink" title="javascript 异步加载 的 三种方案"></a>javascript 异步加载 的 三种方案</h3><ol>
<li>defer 异步加载，但要等到 dom 文档全部解析完才会被执行。只有 IE 能用。可以在 script 内写语句</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;tools.js&quot;</span> defer=<span class="string">&quot;defer&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>async 异步加载，加载完就执行，async 只能加载外部脚本，不能把 js 写在 script 标签里。</li>
</ol>
<p>1 和 2 执行时不阻塞页面<br>3. 创建 script，插入到 DOM 中，加载完毕后 callBack。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span></span><br><span class="line"><span class="javascript">	script.type = <span class="string">&quot;text/javascript&quot;</span>;</span></span><br><span class="line"><span class="javascript">	script.src = <span class="string">&quot;demo.js&quot;</span>;</span></span><br><span class="line"><span class="javascript">	<span class="built_in">document</span>.head.appendChild(script); <span class="comment">//执行这一行时js才开始执行</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span></span><br><span class="line"><span class="javascript">	script.type = <span class="string">&quot;text/javascript&quot;</span>;</span></span><br><span class="line"><span class="javascript">	script.src = <span class="string">&quot;demo.js&quot;</span>;</span></span><br><span class="line"><span class="javascript">	script.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">		<span class="comment">//会等js文件下载完之后在执行</span></span></span><br><span class="line"><span class="javascript">		语句;</span></span><br><span class="line"><span class="javascript">	&#125;;</span></span><br><span class="line"><span class="javascript">	<span class="built_in">document</span>.head.appendChild(script);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="js-加载时间"><a href="#js-加载时间" class="headerlink" title="js 加载时间"></a>js 加载时间</h3><ol>
<li><p>创建 Document 对象，开始解析 web 页面。解析 HTML 元素和他们的文本内容后添加 Element 对象和 Text 节点到文档中。这个阶段 document.readyState = ‘loading’。</p>
</li>
<li><p>遇到 link 外部 css，创建线程加载，并继续解析文档。</p>
</li>
<li><p>遇到 script 外部 js，并且没有设置 async、defer，浏览器加载，并阻塞，等待 js 加载完成并执行该脚本，然后继续解析文档。</p>
</li>
<li><p>遇到 script 外部 js，并且设置有 async、defer，浏览器创建线程加载，并继续解析文档。<br>对于 async 属性的脚本，脚本加载完成后立即执行。（异步禁止使用 document.write()）</p>
</li>
<li><p>遇到 img 等，先正常解析 dom 结构，然后浏览器异步加载 src，并继续解析文档。</p>
</li>
<li><p>当文档解析完成，document.readyState = ‘interactive’。</p>
</li>
<li><p>文档解析完成后，所有设置有 defer 的脚本会按照顺序执行。（注意与 async 的不同,但同样禁止使用 document.write()）;</p>
</li>
<li><p>document 对象触发 DOMContentLoaded 事件，这也标志着程序执行从同步脚本执行阶段，转化为事件驱动阶段。</p>
</li>
<li><p>当所有 async 的脚本加载完成并执行后、img 等加载完成后，document.readyState = ‘complete’，window 对象触发 load 事件。</p>
</li>
<li><p>从此，以异步响应方式处理用户输入、网络事件等。</p>
</li>
</ol>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a><a href="https://www.w3school.com.cn/jsref/jsref_obj_regexp.asp">正则表达式</a></h2><p>多行字符串（更清晰，通过 \ 将一行的结束符转义）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test =</span><br><span class="line"><span class="string">&quot;\</span></span><br><span class="line"><span class="string">&lt;div&gt;&lt;/div&gt;\</span></span><br><span class="line"><span class="string">&lt;span&gt;&lt;/span&gt;\</span></span><br><span class="line"><span class="string">&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="正则表达式两种创建方式："><a href="#正则表达式两种创建方式：" class="headerlink" title="正则表达式两种创建方式："></a>正则表达式两种创建方式：</h3><ol>
<li><p>直接量(var 变量名 = / 字符串 /属性（可不写） )<br>var reg = /abc/;</p>
</li>
<li><p>new RegExp(var  变量名  = new RegExp(“规则” ，”属性（可不写）”);)</p>
<p> <code>var reg = new RegExp(&quot;abc&quot;);</code></p>
</li>
</ol>
<p>[ ]: 表达式（里面填符合要求的范围）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/[ab][cd][d]/g</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">str.match(reg)</span><br><span class="line"><span class="comment">// 返回值： [&quot;bcd&quot;]</span></span><br></pre></td></tr></table></figure>

<p>^放在表达式里表示 非（除了）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/[^a]/</span>; <span class="comment">//匹配第一位不是a的字符串</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">str.match(reg);</span><br></pre></td></tr></table></figure>

<p>（条件 | 条件 |条件）：可表示范围</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(abc|bcd)/g</span>;</span><br><span class="line"><span class="comment">// 可匹配是abc 或 bcd 的字符串</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>\n : 与第 n 子表达式个完全一样的匹配条件（n 必须为具体的数字）</p>
<p>var reg = /(\w)\1\1\1/g; //匹配 4 个完全一样的字符串（例如 “aaaa”）</p>
<p>var reg = /(\w)\1(\w)\2/g; //可匹配 AABB 样式的字符串</p>
<h4 id="方括号"><a href="#方括号" class="headerlink" title="方括号"></a>方括号</h4><p>方括号用于查找某个范围内的字符：</p>
<table>
<thead>
<tr>
<th align="center">表达式</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">[abc]</td>
<td align="center">查找方括号之间的任何字符。</td>
</tr>
<tr>
<td align="center">[^abc]</td>
<td align="center">查找任何不在方括号之间的字符。</td>
</tr>
<tr>
<td align="center">[0-9]</td>
<td align="center">查找任何从 0 至 9 的数字。</td>
</tr>
<tr>
<td align="center">[a-z]</td>
<td align="center">查找任何从小写 a 到小写 z 的字符。</td>
</tr>
<tr>
<td align="center">[A-Z]</td>
<td align="center">查找任何从大写 A 到大写 Z 的字符。</td>
</tr>
<tr>
<td align="center">[A-z]</td>
<td align="center">查找任何从大写 A 到小写 z 的字符。</td>
</tr>
<tr>
<td align="center">[adgk]</td>
<td align="center">查找给定集合内的任何字符。</td>
</tr>
<tr>
<td align="center">[^adgk]</td>
<td align="center">查找给定集合外的任何字符。</td>
</tr>
<tr>
<td align="center">(red|blue|green)</td>
<td align="center">查找任何指定的选项。</td>
</tr>
</tbody></table>
<h4 id="元字符（Metacharacter）"><a href="#元字符（Metacharacter）" class="headerlink" title="元字符（Metacharacter）"></a>元字符（Metacharacter）</h4><p>是拥有特殊含义的字符：</p>
<table>
<thead>
<tr>
<th align="center">元字符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">.</td>
<td align="center">查找单个字符，除了换行和行结束符</td>
</tr>
<tr>
<td align="center">\w</td>
<td align="center">[ 0 - 9A-z_]查找单词字符</td>
</tr>
<tr>
<td align="center">\W</td>
<td align="center">查找非单词字符</td>
</tr>
<tr>
<td align="center">\d</td>
<td align="center">[ 0 - 9]查找数字</td>
</tr>
<tr>
<td align="center">\D</td>
<td align="center">查找非数字字符</td>
</tr>
<tr>
<td align="center">\s</td>
<td align="center">查找空白字符</td>
</tr>
<tr>
<td align="center">\S</td>
<td align="center">查找非空白字符</td>
</tr>
<tr>
<td align="center">\b</td>
<td align="center">匹配单词边界</td>
</tr>
<tr>
<td align="center">\B</td>
<td align="center">匹配非单词边界</td>
</tr>
<tr>
<td align="center">\0</td>
<td align="center">查找 NUL 字符</td>
</tr>
<tr>
<td align="center">\n</td>
<td align="center">查找换行符</td>
</tr>
<tr>
<td align="center">\f</td>
<td align="center">查找换页符</td>
</tr>
<tr>
<td align="center">\r</td>
<td align="center">查找回车符</td>
</tr>
<tr>
<td align="center">\t</td>
<td align="center">查找制表符</td>
</tr>
<tr>
<td align="center">\v</td>
<td align="center">查找垂直制表符</td>
</tr>
<tr>
<td align="center">\x</td>
<td align="center">xx 查找以八进制数 xxx 规定的字符</td>
</tr>
<tr>
<td align="center">\x</td>
<td align="center">dd 查找以十六进制数 dd 规定的字符</td>
</tr>
<tr>
<td align="center">\u</td>
<td align="center">xxxx 查找以十六进制数 xxxx 规定的 Unicode 字符</td>
</tr>
</tbody></table>
<h4 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h4><table>
<thead>
<tr>
<th align="left">量词</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">n+</td>
<td align="center">匹配任何包含至少一个 n 的字符串。</td>
</tr>
<tr>
<td align="left">n*</td>
<td align="center">匹配任何包含零个或多个 n 的字符串。</td>
</tr>
<tr>
<td align="left">n?</td>
<td align="center">匹配任何包含零个或一个 n 的字符串。</td>
</tr>
<tr>
<td align="left">n{X}</td>
<td align="center">匹配包含 X 个 n 的序列的字符串。</td>
</tr>
<tr>
<td align="left">n{X,Y}</td>
<td align="center">匹配包含 X 至 Y 个 n 的序列的字符串。</td>
</tr>
<tr>
<td align="left">n{X,}</td>
<td align="center">匹配包含至少 X 个 n 的序列的字符串。</td>
</tr>
<tr>
<td align="left">n$</td>
<td align="center">匹配任何结尾为 n 的字符串。</td>
</tr>
<tr>
<td align="left">^n</td>
<td align="center">匹配任何开头为 n 的字符串。</td>
</tr>
<tr>
<td align="left">?=n</td>
<td align="center">匹配任何其后紧接指定字符串 n 的字符串。</td>
</tr>
<tr>
<td align="left">?!n</td>
<td align="center">匹配任何其后没有紧接指定字符串 n 的字符串。</td>
</tr>
</tbody></table>
<h4 id="RegExp-对象属性"><a href="#RegExp-对象属性" class="headerlink" title="RegExp 对象属性"></a>RegExp 对象属性</h4><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>FF</th>
<th>IE</th>
</tr>
</thead>
<tbody><tr>
<td>globalRegExp</td>
<td>对象是否具有标志 g</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>ignoreCaseRegExp</td>
<td>对象是否具有标志 i</td>
<td>。1</td>
<td>4</td>
</tr>
<tr>
<td>lastIndex</td>
<td>一个整数，标示开始下一次匹配的字符位</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>multilineRegExp</td>
<td>对象是否具有标志 m</td>
<td>。1</td>
<td>4</td>
</tr>
<tr>
<td>source</td>
<td>正则表达式的源文本。</td>
<td>1</td>
<td>4</td>
</tr>
</tbody></table>
<h4 id="RegExp-对象方法"><a href="#RegExp-对象方法" class="headerlink" title="RegExp 对象方法"></a>RegExp 对象方法</h4><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>FF</th>
<th>IE</th>
</tr>
</thead>
<tbody><tr>
<td>compile</td>
<td>编译正则表达式。</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>exec</td>
<td>检索字符串中指定的值。返回找到的值，并确定其位置。</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>test</td>
<td>检索字符串中指定的值。返回 true 或 false。</td>
<td>1</td>
<td>4</td>
</tr>
</tbody></table>
<h4 id="支持正则表达式的-String-对象的方法"><a href="#支持正则表达式的-String-对象的方法" class="headerlink" title="支持正则表达式的 String 对象的方法"></a>支持正则表达式的 String 对象的方法</h4><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>FF</th>
<th>IE</th>
</tr>
</thead>
<tbody><tr>
<td>search</td>
<td>检索与正则表达式相匹配的值。</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>match</td>
<td>找到一个或多个正则表达式的匹配。</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>replace</td>
<td>替换与正则表达式匹配的子串。</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>split</td>
<td>把字符串分割为字符串数组。</td>
<td>1</td>
<td>4</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;aa&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.replace(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>));</span><br><span class="line">打印结果为ba;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;aa&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/a/g</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.replace(reg, <span class="string">&quot;b&quot;</span>));</span><br><span class="line">打印结果为bb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;aabb&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(\w)\1(\w)\2/g</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.replace(reg, <span class="string">&quot;$2$2$1$1&quot;</span>)); <span class="comment">//可以通过 $n 获取第n 个子表达式的匹配条件</span></span><br><span class="line">打印结果为bbaa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;the-first-name&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/-(\w)/g</span>;</span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">	str.replace(reg, <span class="function"><span class="keyword">function</span> (<span class="params">$, $<span class="number">1</span></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> $<span class="number">1.</span>toUpperCase();</span><br><span class="line">	&#125;)</span><br><span class="line">);</span><br><span class="line">打印结果为theFirstName;</span><br></pre></td></tr></table></figure>

<p>正则表达式默认为贪婪匹配（总是往最大的方向去匹配）<br>取消贪婪匹配（匹配最短）（在每个量词后面加上一个 ？）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/a&#123;3,5&#125;?/g</span>;</span><br><span class="line"><span class="keyword">var</span> reg1 = <span class="regexp">/a&#123;3,5&#125;/g</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;aaaaaaaaaaaaaaaa&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg));</span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg1));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果为：</span></span><br><span class="line"><span class="comment">// [&quot;aaa&quot;, &quot;aaa&quot;, &quot;aaa&quot;, &quot;aaa&quot;, &quot;aaa&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;aaaaa&quot;, &quot;aaaaa&quot;, &quot;aaaaa&quot;]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^(?!\d+$)(?![A-z]+$)[0-9A-z]&#123;8,16&#125;$/</span>;</span><br><span class="line">匹配密码<span class="number">8</span> - <span class="number">16</span>位不能只有数字或字母</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>DOM</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2中的动态路由</title>
    <url>/135xyq.github.io/2021/10/01/Vue-%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1&amp;watch/</url>
    <content><![CDATA[<h1 id="文章列表页逻辑"><a href="#文章列表页逻辑" class="headerlink" title="文章列表页逻辑"></a>文章列表页逻辑</h1><h2 id="路由跳转逻辑"><a href="#路由跳转逻辑" class="headerlink" title="路由跳转逻辑"></a>路由跳转逻辑</h2><p><img src="/images/vue2/%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1-%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC%E9%80%BB%E8%BE%91.jpg" alt="动态路由-路由跳转逻辑"></p>
<h2 id="组件逻辑"><a href="#组件逻辑" class="headerlink" title="组件逻辑"></a>组件逻辑</h2><p><img src="/images/vue2/%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1-%E7%BB%84%E4%BB%B6%E9%80%BB%E8%BE%91.jpg" alt="动态路由-组件逻辑"></p>
<h3 id="BlogList"><a href="#BlogList" class="headerlink" title="BlogList"></a>BlogList</h3><p><img src="/images/vue2/%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1-BlogList.jpg" alt="动态路由-BlogList"></p>
<h3 id="BlogCategory"><a href="#BlogCategory" class="headerlink" title="BlogCategory"></a>BlogCategory</h3><p><img src="/images/vue2/%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1-BlogCategory.jpg" alt="动态路由-BlogCategory"></p>
<h1 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h1><h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><p>我们希望下面的地址都能够匹配到<code>Blog</code>组件</p>
<ul>
<li><code>/article</code>，显示全部文章</li>
<li><code>/article/cate/1</code>，显示分类<code>id</code>为<code>1</code>的文章</li>
<li><code>/article/cate/3</code>，显示分类<code>id</code>为<code>3</code>的文章</li>
<li>…</li>
</ul>
<p>第一种情况很简单，只需要将一个固定的地址匹配到<code>Blog</code>组件即可</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&quot;/article&quot;</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Blog&quot;</span>,</span><br><span class="line">  <span class="attr">component</span>: Blog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但后面的情况则不同：匹配到<code>Blog</code>组件的地址中，有一部分是动态变化的，则需要使用一种特殊的表达方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&quot;/article/cate/:categoryId&quot;</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;CategoryBlog&quot;</span>,</span><br><span class="line">  <span class="attr">component</span>: Blog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在地址中使用<code>:xxx</code>，来表达这一部分的内容是变化的，在<code>vue-router</code>中，将变化的这一部分称之为<code>params</code>，可以在<code>vue</code>组件中通过<code>this.$route.params</code>来获取</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 访问 /article/cate/3</span></span><br><span class="line"><span class="built_in">this</span>.$route.params <span class="comment">// &#123; categoryId: &quot;3&quot; &#125;</span></span><br><span class="line"><span class="comment">// 访问 /article/cate/1</span></span><br><span class="line"><span class="built_in">this</span>.$route.params <span class="comment">// &#123; categoryId: &quot;1&quot; &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="动态路由的导航"><a href="#动态路由的导航" class="headerlink" title="动态路由的导航"></a>动态路由的导航</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;router-link to=&quot;/article/cate/3&quot;&gt;to article of category 3&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;router-link :to=&quot;&#123;</span><br><span class="line">   name: &#x27;CategoryBlog&#x27;,</span><br><span class="line">   params: &#123;</span><br><span class="line">       categoryId: 3           </span><br><span class="line">   &#125;                    </span><br><span class="line">&#125;&quot;&gt;to article of category 3&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>

<h2 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h2><p>除了使用<code>&lt;RouterLink&gt;</code>超链接导航外，<code>vue-router</code>还允许在代码中跳转页面</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$router.push(<span class="string">&quot;跳转地址&quot;</span>); <span class="comment">// 普通跳转</span></span><br><span class="line"><span class="built_in">this</span>.$router.push(&#123; <span class="comment">// 命名路由跳转</span></span><br><span class="line">  <span class="attr">name</span>:<span class="string">&quot;Blog&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.$router.go(-<span class="number">1</span>); <span class="comment">// 回退。类似于 history.go</span></span><br></pre></td></tr></table></figure>

<h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><p>利用<code>watch</code>配置，可以直接观察某个数据的变化，变化时可以做一些处理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ... 其他配置</span></span><br><span class="line">  <span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="comment">// 观察 this.$route 的变化，变化后，会调用该函数</span></span><br><span class="line">    $route(newVal, oldVal)&#123;</span><br><span class="line">      <span class="comment">// newVal：this.$route 新的值，等同 this.$route</span></span><br><span class="line">      <span class="comment">// oldVal：this.$route 旧的值</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 完整写法</span></span><br><span class="line">    <span class="attr">$route</span>: &#123;</span><br><span class="line">      <span class="function"><span class="title">handler</span>(<span class="params">newVal, oldVal</span>)</span>&#123;&#125;,</span><br><span class="line">      <span class="attr">deep</span>: <span class="literal">false</span>, <span class="comment">// 是否监听该数据内部属性的变化，默认 false</span></span><br><span class="line">      <span class="attr">immediate</span>: <span class="literal">false</span> <span class="comment">// 是否立即执行一次 handler，默认 false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 观察 this.$route.params 的变化，变化后，会调用该函数</span></span><br><span class="line">    [<span class="string">&quot;$route.params&quot;</span>](newVal, oldVal)&#123;</span><br><span class="line">      <span class="comment">// newVal：this.$route.params 新的值，等同 this.$route.params</span></span><br><span class="line">      <span class="comment">// oldVal：this.$route.params 旧的值</span></span><br><span class="line">    &#125;,</span><br><span class="line">  	<span class="comment">// 完整写法</span></span><br><span class="line">    [<span class="string">&quot;$route.params&quot;</span>]: &#123;</span><br><span class="line">      <span class="function"><span class="title">handler</span>(<span class="params">newVal, oldVal</span>)</span>&#123;&#125;,</span><br><span class="line">      <span class="attr">deep</span>: <span class="literal">false</span>, <span class="comment">// 是否监听该数据内部属性的变化，默认 false</span></span><br><span class="line">      <span class="attr">immediate</span>: <span class="literal">false</span> <span class="comment">// 是否立即执行一次 handler，默认 false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue2</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2中的v-model</title>
    <url>/135xyq.github.io/2021/09/06/Vue-v-model/</url>
    <content><![CDATA[<p>面试题：请阐述一下 <code>v-model</code> 的原理</p>
<p><code>v-model</code>即可以作用于表单元素，又可作用于自定义组件，无论是哪一种情况，它都是一个语法糖，最终会生成一个属性和一个事件</p>
<p><strong>当其作用于表单元素时</strong>，<code>vue</code>会根据作用的表单元素类型而生成合适的属性和事件。例如，作用于普通文本框的时候，它会生成<code>value</code>属性和<code>input</code>事件，而当其作用于单选框或多选框时，它会生成<code>checked</code>属性和<code>change</code>事件。</p>
<p><code>v-model</code>也可作用于自定义组件，<strong>当其作用于自定义组件时</strong>，默认情况下，它会生成一个<code>value</code>属性和<code>input</code>事件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Comp</span> <span class="attr">v-model</span>=<span class="string">&quot;data&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 等效于 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Comp</span> <span class="attr">:value</span>=<span class="string">&quot;data&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;data=$event&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>开发者可以通过组件的<code>model</code>配置来改变生成的属性和事件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Comp</span></span><br><span class="line"><span class="keyword">const</span> Comp = &#123;</span><br><span class="line">  <span class="attr">model</span>: &#123;</span><br><span class="line">    <span class="attr">prop</span>: <span class="string">&quot;number&quot;</span>, <span class="comment">// 默认为 value</span></span><br><span class="line">    <span class="attr">event</span>: <span class="string">&quot;change&quot;</span> <span class="comment">// 默认为 input</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Comp</span> <span class="attr">v-model</span>=<span class="string">&quot;data&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 等效于 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Comp</span> <span class="attr">:number</span>=<span class="string">&quot;data&quot;</span> @<span class="attr">change</span>=<span class="string">&quot;data=$event&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue2</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2基础知识</title>
    <url>/135xyq.github.io/2021/08/05/Vue-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h2><p><img src="/images/vue2/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E6%B3%A8%E5%85%A5.jpg" alt="image-20201110163548294"></p>
<p>vue会将以下配置注入到vue实例：</p>
<ul>
<li>data：和界面相关的数据</li>
<li>computed：通过已有数据计算得来的数据，</li>
<li>methods：方法</li>
</ul>
<blockquote>
<p>模板中可以使用vue实例中的成员</p>
</blockquote>
<p>对象或数组默认值必须从一个工厂函数获取</p>
<h2 id="虚拟DOM树"><a href="#虚拟DOM树" class="headerlink" title="虚拟DOM树"></a>虚拟DOM树</h2><p>直接操作真实的DOM会引发严重的效率问题，vue使用虚拟DOM（vnode）的方式来描述要渲染的内容</p>
<p>vnode是一个<strong>普通的</strong>JS对象，用于描述界面上应该有什么，比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vnode = &#123;</span><br><span class="line">  <span class="attr">tag</span>: <span class="string">&quot;h1&quot;</span>,</span><br><span class="line">  <span class="attr">children</span>: [</span><br><span class="line">    &#123; <span class="attr">tag</span>: <span class="literal">undefined</span>, <span class="attr">text</span>: <span class="string">&quot;第一个vue应用：Hello World&quot;</span>&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的对象描述了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有一个标签名为h1的节点，它有一个子节点，该子节点是一个文本，内容为「第一个vue应用：Hello World」</span><br></pre></td></tr></table></figure>

<p><strong>vue模板并不是真实的DOM，它会被编译为虚拟DOM</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>第一个vue应用：&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>作者：&#123;&#123;author&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面的模板会被编译为类似下面结构的虚拟DOM</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">tag</span>: <span class="string">&quot;div&quot;</span>,</span><br><span class="line">  <span class="attr">children</span>: [</span><br><span class="line">    &#123; <span class="attr">tag</span>: <span class="string">&quot;h1&quot;</span>, <span class="attr">children</span>: [ &#123; <span class="attr">text</span>: <span class="string">&quot;第一个vue应用：Hello World&quot;</span> &#125; ] &#125;,</span><br><span class="line">    &#123; <span class="attr">tag</span>: <span class="string">&quot;p&quot;</span>, <span class="attr">children</span>: [ &#123; <span class="attr">text</span>: <span class="string">&quot;作者：谢&quot;</span> &#125; ] &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虚拟DOM树会最终生成为真实的DOM树</p>
<p>当数据变化后，将引发重新渲染，vue会比较新旧两棵vnode tree，找出差异，然后仅把差异部分应用到真实dom tree中</p>
<p><strong>可见，在vue中，要得到最终的界面，必须要生成一个vnode tree</strong></p>
<p>vue通过以下逻辑生成vnode tree：</p>
<p><strong>注意：虚拟节点树必须是单根的</strong></p>
<h2 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h2><p>将生成的真实DOM树，放置到某个元素位置，称之为<strong>挂载</strong></p>
<p>挂载的方式：</p>
<ol>
<li>通过<code>el:&quot;css选择器&quot;</code>进行配置</li>
<li>通过<code>vue实例.$mount(&quot;css选择器&quot;)</code>进行配置</li>
</ol>
<h2 id="完整流程"><a href="#完整流程" class="headerlink" title="完整流程"></a>完整流程</h2><p><img src="/images/vue2/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E5%AE%8C%E6%95%B4%E9%80%BB%E8%BE%91.jpg"></p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue2</tag>
      </tags>
  </entry>
  <entry>
    <title>分析打包的结果</title>
    <url>/135xyq.github.io/2021/10/25/Vue-%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="分析打包结果"><a href="#分析打包结果" class="headerlink" title="分析打包结果"></a>分析打包结果</h1><p>由于<code>vue-cli</code>是利用<code>webpack</code>进行打包，我们仅需加入一个<code>webpack</code>插件<code>webpack-bundle-analyzer</code>即可分析打包结果</p>
<p>为了避免在开发环境中启动<code>webpack-bundle-analyzer</code>，我们仅需使用以下代码即可</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> BundleAnalyzerPlugin = <span class="built_in">require</span>(<span class="string">&quot;webpack-bundle-analyzer&quot;</span>)</span><br><span class="line">    .BundleAnalyzerPlugin;</span><br><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 通过 configureWebpack 选项，可对 webpack 进行额外的配置</span></span><br><span class="line">  <span class="comment">// 该配置最终会和 vue-cli 的默认配置进行合并（webpack-merge）</span></span><br><span class="line">  <span class="attr">configureWebpack</span>: &#123;</span><br><span class="line">    <span class="attr">plugins</span>: [<span class="keyword">new</span> BundleAnalyzerPlugin()]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="优化公共库打包体积"><a href="#优化公共库打包体积" class="headerlink" title="优化公共库打包体积"></a>优化公共库打包体积</h1><h2 id="使用CDN"><a href="#使用CDN" class="headerlink" title="使用CDN"></a>使用CDN</h2><p>CDN全称为Content Delivery Network，称之为内容分发网络</p>
<p>它的基本原理是：架设多台服务器，这些服务器定期从源站拿取资源保存本地，到让不同地域的用户能够通过访问最近的服务器获得资源</p>
<p><img src="/images/vue2/%E6%89%93%E5%8C%85%E5%88%86%E6%9E%90%E7%9A%84%E7%BB%93%E6%9E%9C-1.jpg" alt="img"></p>
<p>我们可以把项目中的所有静态资源都放到CDN上（收费），也可以利用现成免费的CDN获取公共库的资源</p>
<p><img src="/images/vue2/%E6%89%93%E5%8C%85%E5%88%86%E6%9E%90%E7%9A%84%E7%BB%93%E6%9E%9C-2.jpg" alt="img"></p>
<p>首先，我们需要告诉<code>webpack</code>不要对公共库进行打包</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">configureWebpack</span>: &#123;</span><br><span class="line">    <span class="attr">externals</span>: &#123;</span><br><span class="line">      <span class="attr">vue</span>: <span class="string">&quot;Vue&quot;</span>,</span><br><span class="line">      <span class="attr">vuex</span>: <span class="string">&quot;Vuex&quot;</span>,</span><br><span class="line">      <span class="string">&quot;vue-router&quot;</span>: <span class="string">&quot;VueRouter&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后，在页面中手动加入<code>cdn</code>链接，这里使用<a href="https://www.bootcdn.cn/">bootcn</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/vue/2.6.12/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/vuex/3.5.1/vuex.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/vue-router/3.4.7/vue-router.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- built files will be auto injected --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>对于<code>vuex</code>和<code>vue-router</code>，使用这种传统的方式引入的话会自动成为<code>Vue</code>的插件，因此需要去掉<code>Vue.use(xxx)</code></p>
<p>我们可以使用下面的代码来进行兼容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// store.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">window</span>.Vuex)&#123;</span><br><span class="line">  <span class="comment">// 没有使用传统的方式引入Vuex</span></span><br><span class="line">  Vue.use(Vuex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// router.js</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">window</span>.VueRouter)&#123;</span><br><span class="line">  <span class="comment">// 没有使用传统的方式引入VueRouter</span></span><br><span class="line">  Vue.use(VueRouter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="启用现代模式"><a href="#启用现代模式" class="headerlink" title="启用现代模式"></a>启用现代模式</h2><p>为了兼容各种浏览器，<code>vue-cli</code>在内部使用了<code>@babel/present-env</code>对代码进行降级，你可以通过<code>.browserlistrc</code>配置来设置需要兼容的目标浏览器</p>
<p>这是一种比较<em>偷懒</em>的办法，因为对于那些使用现代浏览器的用户，它们也<em>被迫</em>使用了降级之后的代码，而降低的代码中包含了大量的<code>polyfill</code>，从而提升了包的体积</p>
<p>因此，我们希望提供两种打包结果：</p>
<ol>
<li>降级后的包（大），提供给旧浏览器用户使用</li>
<li>未降级的包（小），提供给现代浏览器用户使用</li>
</ol>
<p>除了应用<code>webpack</code>进行多次打包外，还可以利用<code>vue-cli</code>给我们提供的命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vue-cli-service build --modern</span><br></pre></td></tr></table></figure>



<h1 id="优化项目包体积"><a href="#优化项目包体积" class="headerlink" title="优化项目包体积"></a>优化项目包体积</h1><p>这里的项目包是指<code>src</code>目录中的打包结果</p>
<h2 id="页面分包"><a href="#页面分包" class="headerlink" title="页面分包"></a>页面分包</h2><p>默认情况下，<code>vue-cli</code>会利用<code>webpack</code>将<code>src</code>目录中的所有代码打包成一个<code>bundle</code></p>
<p>这样就导致访问一个页面时，需要加载所有页面的<code>js</code>代码</p>
<p>我们可以利用<code>webpack</code>对<code>动态import</code>的支持，从而达到把不同页面的代码打包到不同文件中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// routes</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Home&quot;</span>,</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/&quot;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &quot;home&quot; */</span> <span class="string">&quot;@/views/Home&quot;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;About&quot;</span>,</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/about&quot;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &quot;about&quot; */</span><span class="string">&quot;@/views/About&quot;</span>),</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h1 id="优化首屏响应"><a href="#优化首屏响应" class="headerlink" title="优化首屏响应"></a>优化首屏响应</h1><blockquote>
<p>首页白屏受很多因素的影响</p>
</blockquote>
<p><code>vue</code>页面需要通过<code>js</code>构建，因此在<code>js</code>下载到本地之前，页面上什么也没有</p>
<p>一个非常简单有效的办法，即在页面中先渲染一个小的加载中效果，等到<code>js</code>下载到本地并运行后，即会自动替换</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;loading.gif&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue2</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2中的插槽</title>
    <url>/135xyq.github.io/2021/09/21/Vue-%E6%8F%92%E6%A7%BD/</url>
    <content><![CDATA[<h1 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h1><hr>
<p>在某些组件的模板中，有一部分区域需要父组件来指定</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- message组件：一个弹窗消息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;message-container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这里是消息内容，可以是一个文本，也可能是一段html，具体是什么不知道，需要父组件指定 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span>&gt;</span>确定<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span>&gt;</span>关闭<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="插槽的简单用法"><a href="#插槽的简单用法" class="headerlink" title="插槽的简单用法"></a>插槽的简单用法</h2><p>此时，就需要使用插槽来定制组件的功能</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- message组件：一个弹窗消息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;message-container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- slot是vue的内置组件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span>&gt;</span>确定<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span>&gt;</span>关闭<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 父组件App --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Message</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;app-message&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>App Message<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>detail<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Message</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 最终的结果 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;message-co r&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span> </span></span><br><span class="line"><span class="tag">    &lt;<span class="attr">div</span> <span class="attr">class</span>=<span class="string">&quot;app-message &gt;</span></span></span><br><span class="line"><span class="string"><span class="tag">    &lt;p&gt;App Message&lt;/p&gt;</span></span></span><br><span class="line"><span class="string"><span class="tag">      &lt;a href=&quot;</span>&quot;&gt;</span>detai </span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span>&gt;</span>确定<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span>&gt;</span>关闭<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/vue2/%E6%8F%92%E6%A7%BD-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D.jpg" alt="插槽"></p>
<h2 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h2><p>如果某个组件中需要父元素传递多个区域的内容，也就意味着需要提供多个插槽</p>
<p>为了避免冲突，就需要给不同的插槽赋予不同的名字</p>
<p>父组件中要使用 v-slot 指令，简写为<code>#</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Layout 组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layout-container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 我们希望把页头放这里，提供插槽，名为header --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;header&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 我们希望把主要内容放这里，提供插槽，名为default --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 我们希望把页脚放这里，提供插槽，名为footer --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;footer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 父组件App --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">BaseLayout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph for the main content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>And another one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here&#x27;s some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">BaseLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/vue2/%E6%8F%92%E6%A7%BD-%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD.jpg" alt="具名插槽"></p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue2</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2搭建工程</title>
    <url>/135xyq.github.io/2021/08/01/Vue-%E6%90%AD%E5%BB%BA%E5%B7%A5%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="搭建vue2工程"><a href="#搭建vue2工程" class="headerlink" title="搭建vue2工程"></a>搭建vue2工程</h1><p>vue-cli: <a href="https://cli.vuejs.org/zh/">https://cli.vuejs.org/zh/</a></p>
<h2 id="vue-cli"><a href="#vue-cli" class="headerlink" title="vue-cli"></a>vue-cli</h2><p><code>vue-cli</code>是一个脚手架工具，用于搭建<code>vue</code>工程</p>
<p>它内部使用了<code>webpack</code>，并预置了诸多插件（<code>plugin</code>）和加载器（<code>loader</code>），以达到开箱即用的效果</p>
<p>除了基本的插件和加载器外，<code>vue-cli</code>还预置了：</p>
<ul>
<li>babel</li>
<li>webpack-dev-server</li>
<li>eslint</li>
<li>postcss</li>
<li>less-loader</li>
</ul>
<h2 id="SFC"><a href="#SFC" class="headerlink" title="SFC"></a>SFC</h2><p>单文件组件，Single File Component，即一个文件就包含了一个组件所需的全部代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 组件模板代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 组件配置</span></span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">	<span class="comment">/* 组件样式 */</span></span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h2><p>当<code>vue-cli</code>进行<strong>打包</strong>时，会直接把组件中的模板转换为<code>render</code>函数，这叫做模板预编译</p>
<p>这样做的好处在于：</p>
<ol>
<li>运行时就不再需要编译模板了，提高了运行效率</li>
<li>打包结果中不再需要vue的编译代码，减少了打包体积</li>
</ol>
<p><img src="/images/vue2/vue2%E6%90%AD%E5%BB%BA%E5%B7%A5%E7%A8%8B-SFC.jpg"></p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue2</tag>
      </tags>
  </entry>
  <entry>
    <title>用户登录的逻辑</title>
    <url>/135xyq.github.io/2021/10/19/Vue-%E7%99%BB%E5%BD%95%E6%96%B9%E9%9D%A2%E7%9A%84%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="用户模块逻辑示意图"><a href="#用户模块逻辑示意图" class="headerlink" title="用户模块逻辑示意图"></a>用户模块逻辑示意图</h1><p>路由总体示意图</p>
<p><img src="/images/vue2/%E7%99%BB%E5%BD%95%E6%96%B9%E9%9D%A2%E7%9A%84%E7%9F%A5%E8%AF%86-%E8%B7%AF%E7%94%B1%E6%80%BB%E4%BD%93%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="image-20210130141625925"></p>
<p>鉴权守卫逻辑示意图</p>
<p><img src="/images/vue2/%E7%99%BB%E5%BD%95%E6%96%B9%E9%9D%A2%E7%9A%84%E7%9F%A5%E8%AF%86-%E9%89%B4%E6%9D%83%E5%AE%88%E5%8D%AB.jpg" alt="image-20210130144001709"></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><h2 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h2><p><a href="https://cn.vuejs.org/v2/api/#watch">watch配置</a></p>
<p><a href="https://cn.vuejs.org/v2/api/#vm-watch">Vue.prototype.$watch</a></p>
<h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><p><a href="https://vuex.vuejs.org/zh/guide/state.html#mapstate-%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0">mapState</a></p>
<p><a href="https://vuex.vuejs.org/zh/guide/getters.html">getters</a></p>
<p><a href="https://vuex.vuejs.org/zh/guide/getters.html#mapgetters-%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0">mapGetters</a></p>
<p><a href="https://vuex.vuejs.org/zh/guide/modules.html">modules</a></p>
<p><a href="https://vuex.vuejs.org/zh/api/#watch">watch</a></p>
<h2 id="router"><a href="#router" class="headerlink" title="router"></a>router</h2><p><a href="https://router.vuejs.org/api/#exact-path">exact-path</a></p>
<p><a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%85%A8%E5%B1%80%E5%89%8D%E7%BD%AE%E5%AE%88%E5%8D%AB">导航守卫</a></p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue2</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2中的数据共享</title>
    <url>/135xyq.github.io/2021/10/15/Vue-%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%ABvuex/</url>
    <content><![CDATA[<p><img src="/images/vue2/vue%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB-1.jpg" alt="image-20210126132906004"></p>
<p>在<code>vue</code>中遇到<strong>共享数据</strong>，会带来下面的多个问题：</p>
<ul>
<li>如何保证数据的唯一性？<ul>
<li>如果数据不唯一，则会浪费大量的内存资源，降低运行效率</li>
<li>如果数据不唯一，就可能出现不统一的数据，难以维护</li>
</ul>
</li>
<li>某个组件改动数据后，如何让其他用到该数据的组件知道数据变化了？<ul>
<li>事件总线貌似可以解决该问题，但需要在组件中手动的维护监听，极其不方便，而且事件总线的目的在于「通知」，而不是「共享数据」</li>
</ul>
</li>
</ul>
<p>一种比较容易想到的方案，就是把所有的共享数据<strong>全部</strong>提升到根组件，然后通过属性不断下发，当某个组件需要修改数据时，又不断向上抛出事件，直到根组件完成对数据的修改。</p>
<p><img src="/images/vue2/vue%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB-2.jpg" alt="image-20210126133905451"><br>这种方案的缺陷也非常明显：</p>
<ul>
<li>需要编写大量的代码层层下发数据，很多组件被迫拥有了自己根本不需要的数据</li>
<li>需要编写大量的代码层层上抛事件，很多组件被迫注册了自己根本处理不了的事件</li>
</ul>
<p>基于上面的问题，我们可以简单的设置一个<strong>独立的数据仓库</strong>。</p>
<p><img src="/images/vue2/vue%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB-3.jpg" alt="image-20210126140353891"></p>
<ul>
<li><p>组件需要什么共享数据，可以自由的从仓库中获取，需要什么拿什么。</p>
</li>
<li><p>组件可以自由的改变仓库中的数据，仓库的数据变化后，会自动通知用到对应数据的组件更新</p>
</li>
</ul>
<p>要实现这一切，可以选择<code>vuex</code></p>
<h1 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h1><p>安装<code>vuex</code>后，可以通过下面的代码创建一个数据仓库，在大部分情况下，一个工程仅需创建一个数据仓库</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line">Vue.use(Vuex); <span class="comment">// 应用vuex插件</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="comment">// 仓库的配置</span></span><br><span class="line">  <span class="attr">state</span>: &#123; <span class="comment">// 仓库的初始状态（数据）</span></span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure>

<p>仓库创建好后，你可以使用<code>store.state</code>来访问仓库中的数据</p>
<p>如果希望在<code>vue</code>中方便的使用仓库数据，需要将<code>vuex</code>作为插件安装</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// store.js</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line">Vue.use(Vuex); <span class="comment">// 安装Vuex插件</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex(&#123;</span><br><span class="line">  <span class="comment">// 仓库的配置</span></span><br><span class="line">  <span class="attr">state</span>: &#123; <span class="comment">// 仓库的初始状态（数据）</span></span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&quot;./App.vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&quot;./store.js&quot;</span>;</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  store, <span class="comment">// 向vue中注入仓库</span></span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">&quot;#app&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>之后，在<code>vue</code>组件中，可以通过实例的<code>$store</code>属性访问到仓库</p>
<p><code>Vuex</code>会自动将配置的状态数据设置为响应式数据，当数据变化时，依赖该数据的组件会自动渲染。</p>
<h1 id="数据的变更"><a href="#数据的变更" class="headerlink" title="数据的变更"></a>数据的变更</h1><p>尽管可以利用数据响应式的特点直接变更数据，但这样的做法在大型项目中会遇到问题</p>
<blockquote>
<p>如果有一天，你发现某个共享数据是错误的，而有一百多个组件都有可能变更过这块数据，你该如何知道是哪一步数据变更出现了问题？</p>
</blockquote>
<p>为了能够更好的跟踪数据的变化，<code>vuex</code>强烈建议使用<code>mutation</code>来更改数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex(&#123;</span><br><span class="line">  <span class="comment">// 仓库的配置</span></span><br><span class="line">  <span class="attr">state</span>: &#123; <span class="comment">// 仓库的初始状态（数据）</span></span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每个mutation是一个方法，它描述了数据在某种场景下的变化</span></span><br><span class="line"><span class="comment">     * increase mutation描述了数据在增加时应该发生的变化</span></span><br><span class="line"><span class="comment">     * 参数state为当前的仓库数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="title">increase</span>(<span class="params">state</span>)</span>&#123;</span><br><span class="line">      state.count++;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">decrease</span>(<span class="params">state</span>)</span>&#123;</span><br><span class="line">      state.count--;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 求n次幂</span></span><br><span class="line"><span class="comment">     * 该mutation需要一个额外的参数来提供指数</span></span><br><span class="line"><span class="comment">     * 我们把让数据产生变化时的附加信息称之为负荷（负载） payload</span></span><br><span class="line"><span class="comment">     * payload可以是任何类型，数字、字符串、对象均可</span></span><br><span class="line"><span class="comment">     * 在该mutation中，我们约定payload为一个数字，表示指数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="title">power</span>(<span class="params">state, payload</span>)</span>&#123;</span><br><span class="line">      state.count **= payload;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当我们有了<code>mutation</code>后，就不应该直接去改动仓库的数据了</p>
<p>而是通过<code>store.commit</code>方法提交一个<code>mutation</code>，具体做法是</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.commit(<span class="string">&quot;mutation的名字&quot;</span>, payload);</span><br></pre></td></tr></table></figure>

<p>现在，我们可以通过<code>vue devtools</code>观测到数据的变化了</p>
<p><strong>特别注意：</strong></p>
<ol>
<li><p><code>mutation</code>中不得出现异步操作</p>
<blockquote>
<p>在实际开发的规范中，甚至要求不得有副作用操作</p>
<p>副作用操作包括：</p>
<ul>
<li>异步</li>
<li>更改或读取外部环境的信息，例如<code>localStorage、location、DOM</code>等</li>
</ul>
</blockquote>
</li>
<li><p>提交<code>mutation</code>是数据改变的<strong>唯一原因</strong></p>
</li>
</ol>
<p><img src="/images/vue2/vue%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB-4.jpg"></p>
<h1 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h1><p>如果在<code>vuex</code>中要进行异步操作，需要使用<code>action</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123; </span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">increase</span>(<span class="params">state</span>)</span>&#123;</span><br><span class="line">      state.count++;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">decrease</span>(<span class="params">state</span>)</span>&#123;</span><br><span class="line">      state.count--;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">power</span>(<span class="params">state, payload</span>)</span>&#123;</span><br><span class="line">      state.count **= payload;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ctx: 类似于store的对象</span></span><br><span class="line"><span class="comment">     * payload: 本次异步操作的额外信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="title">asyncPower</span>(<span class="params">ctx, payload</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        ctx.commit(<span class="string">&quot;power&quot;</span>, payload)</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="/images/vue2/vue%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB-5.jpg"></p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue2</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2中混入和组件递归</title>
    <url>/135xyq.github.io/2021/10/06/Vue-%E6%B7%B7%E5%85%A5%E5%92%8C%E7%BB%84%E4%BB%B6%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<h2 id="混入"><a href="#混入" class="headerlink" title="混入"></a>混入</h2><p>有的时候，许多组件有着类似的功能，这些功能代码分散在组件不同的配置中。</p>
<p><img src="/images/vue2/%E6%B7%B7%E5%85%A5%E5%92%8C%E7%BB%84%E4%BB%B6%E9%80%92%E5%BD%92-%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="混入和组件递归-示意图"></p>
<p>于是，我们可以把这些配置代码抽离出来，利用<strong>混入</strong>融合到组件中。</p>
<p><img src="/images/vue2/%E6%B7%B7%E5%85%A5%E5%92%8C%E7%BB%84%E4%BB%B6%E9%80%92%E5%BD%92-%E4%BB%A3%E7%A0%81%E6%8A%BD%E7%A6%BB.jpg" alt="混入和组件递归-代码抽离"></p>
<p>具体的做法非常简单：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽离的公共代码</span></span><br><span class="line"><span class="keyword">const</span> common = &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">b</span>: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">created</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;common created&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">computed</span>:&#123;</span><br><span class="line">    <span class="function"><span class="title">sum</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.a + <span class="built_in">this</span>.b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用comp1，将会得到：</span></span><br><span class="line"><span class="comment"> * common created</span></span><br><span class="line"><span class="comment"> * comp1 created 1 2 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> comp1 = &#123;</span><br><span class="line">  <span class="attr">mixins</span>: [common] <span class="comment">// 之所以是数组，是因为可以混入多个配置代码</span></span><br><span class="line">  <span class="function"><span class="title">created</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;comp1 created&quot;</span>, <span class="built_in">this</span>.a, <span class="built_in">this</span>.b, <span class="built_in">this</span>.sum);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://cn.vuejs.org/v2/guide/mixins.html">官网</a></p>
<h2 id="组件递归"><a href="#组件递归" class="headerlink" title="组件递归"></a>组件递归</h2><p>递归：在组件内部使用自己<br>可以使用name来配置组件的名字，配置完成就可以使用了</p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue2</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2组件</title>
    <url>/135xyq.github.io/2021/08/10/Vue-%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><p>组件的出现是为了实现以下两个目标：</p>
<ol>
<li>降低整体复杂度，提升代码的可读性和可维护性</li>
<li>提升局部代码的可复用性</li>
</ol>
<p>绝大部分情况下，一个组件就是页面中某个区域，组件包含该区域的：</p>
<ul>
<li><p>功能（JS代码）</p>
</li>
<li><p>内容（模板代码）</p>
</li>
<li><p>样式（CSS代码）</p>
<blockquote>
<p>要在组件中包含样式，需要构建工具的支撑</p>
</blockquote>
</li>
</ul>
<h2 id="组件开发"><a href="#组件开发" class="headerlink" title="组件开发"></a>组件开发</h2><h3 id="创建组件"><a href="#创建组件" class="headerlink" title="创建组件"></a>创建组件</h3><p>组件是根据一个普通的配置对象创建的，所以要开发一个组件，只需要写一个配置对象即可</p>
<p>该配置对象和vue实例的配置是<strong>几乎一样</strong>的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//组件配置对象</span></span><br><span class="line"><span class="keyword">var</span> myComp = &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`....`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，组件配置对象和vue实例有以下几点差异：</p>
<ul>
<li>无<code>el</code></li>
<li><code>data</code>必须是一个函数，该函数返回的对象作为数据</li>
<li>由于没有<code>el</code>配置，组件的虚拟DOM树必须定义在<code>template</code>或<code>render</code>中</li>
</ul>
<h3 id="注册组件"><a href="#注册组件" class="headerlink" title="注册组件"></a>注册组件</h3><p>注册组件分为两种方式，一种是<strong>全局注册</strong>，一种是<strong>局部注册</strong></p>
<h4 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h4><p>一旦全局注册了一个组件，整个应用中任何地方都可以使用该组件</p>
<p><img src="/images/vue2/vue2%E7%BB%84%E4%BB%B6-%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C.jpg"></p>
<p>全局注册的方式是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数1：组件名称，将来在模板中使用组件时，会使用该名称</span></span><br><span class="line"><span class="comment">// 参数2：组件配置对象</span></span><br><span class="line"><span class="comment">// 该代码运行后，即可在模板中使用组件</span></span><br><span class="line">Vue.component(<span class="string">&#x27;my-comp&#x27;</span>, myComp)</span><br></pre></td></tr></table></figure>

<p>在模板中，可以使用组件了</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-comp</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 或 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-comp</span>&gt;</span><span class="tag">&lt;/<span class="name">my-comp</span>&gt;</span></span><br></pre></td></tr></table></figure>


<blockquote>
<p>但在一些工程化的大型项目中，很多组件都不需要全局使用。<br>比如一个登录组件，只有在登录的相关页面中使用，如果全局注册，将导致构建工具无法优化打包<br><strong>因此，除非组件特别通用，否则不建议使用全局注册</strong></p>
</blockquote>
<h4 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h4><p>局部注册就是哪里要用到组件，就在哪里注册</p>
<p><img src="/images/vue2/vue2%E7%BB%84%E4%BB%B6-%E5%B1%80%E9%83%A8%E6%B3%A8%E5%86%8C.jpg"></p>
<p>局部注册的方式是，在要使用组件的组件或实例中加入一个配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是另一个要使用my-comp的组件</span></span><br><span class="line"><span class="keyword">var</span> otherComp = &#123;</span><br><span class="line">  <span class="attr">components</span>:&#123;</span><br><span class="line">    <span class="comment">// 属性名为组件名称，模板中将使用该名称</span></span><br><span class="line">    <span class="comment">// 属性值为组件配置对象</span></span><br><span class="line">    <span class="string">&quot;my-comp&quot;</span>: myComp</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &lt;!-- 该组件的其他内容 --&gt;</span></span><br><span class="line"><span class="string">      &lt;my-comp&gt;&lt;/my-comp&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="应用组件"><a href="#应用组件" class="headerlink" title="应用组件"></a>应用组件</h2><p>在模板中使用组件特别简单，把组件名当作HTML元素名使用即可。</p>
<p>但要注意以下几点：</p>
<ol>
<li><strong>组件必须有结束</strong></li>
</ol>
<p>组件可以自结束，也可以用结束标记结束，但必须要有结束</p>
<p>下面的组件使用是错误的：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-comp</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>组件的命名</strong></li>
</ol>
<p>无论你使用哪种方式注册组件，组件的命名需要遵循规范。</p>
<p>组件可以使用<code>kebab-case 短横线命名法</code>，也可以使用<code>PascalCase 大驼峰命名法</code></p>
<p>下面两种命名均是可以的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> otherComp = &#123;</span><br><span class="line">  <span class="attr">components</span>:&#123;</span><br><span class="line">    <span class="string">&quot;my-comp&quot;</span>: myComp,  <span class="comment">// 方式1</span></span><br><span class="line">    <span class="attr">MyComp</span>: myComp <span class="comment">//方式2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实际上，使用<code>小驼峰命名法 camelCase</code>也是可以识别的，只不过不符合官方要求的规范</p>
</blockquote>
<p>使用<code>PascalCase</code>方式命名还有一个额外的好处，即可以在模板中使用两种组件名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> otherComp = &#123;</span><br><span class="line">  <span class="attr">components</span>:&#123;</span><br><span class="line">    <span class="attr">MyComp</span>: myComp</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模板中：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 可用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-comp</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">MyComp</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>因此，在使用组件时，为了方便，往往使用以下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> MyComp = &#123;</span><br><span class="line">  <span class="comment">//组件配置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> OtherComp = &#123;</span><br><span class="line">  <span class="attr">components</span>:&#123;</span><br><span class="line">    MyComp <span class="comment">// ES6速写属性</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="组件树"><a href="#组件树" class="headerlink" title="组件树"></a>组件树</h2><p>一个组件创建好后，往往会在各种地方使用它。它可能多次出现在vue实例中，也可能出现在其他组件中。</p>
<p>于是就形成了一个组件树</p>
<p><img src="/images/vue2/vue2%E7%BB%84%E4%BB%B6-%E7%BB%84%E4%BB%B6%E6%A0%91.jpg"></p>
<h2 id="向组件传递数据"><a href="#向组件传递数据" class="headerlink" title="向组件传递数据"></a>向组件传递数据</h2><p>大部分组件要完成自身的功能，都需要一些额外的信息</p>
<p>比如一个头像组件，需要告诉它头像的地址，这就需要在使用组件时向组件传递数据</p>
<p>传递数据的方式有很多种，最常见的一种是使用<strong>组件属性 component props</strong></p>
<p>首先在组件中申明可以接收哪些属性:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> MyComp = &#123;</span><br><span class="line">  <span class="attr">props</span>:[<span class="string">&quot;p1&quot;</span>, <span class="string">&quot;p2&quot;</span>, <span class="string">&quot;p3&quot;</span>],</span><br><span class="line">  <span class="comment">// 和vue实例一样，使用组件时也会创建组件的实例</span></span><br><span class="line">  <span class="comment">// 而组件的属性会被提取到组件实例中，因此可以在模板中使用</span></span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &#123;&#123;p1&#125;&#125;, &#123;&#123;p2&#125;&#125;, &#123;&#123;p3&#125;&#125;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用组件时，向其传递属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> OtherComp = &#123;</span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    MyComp</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">a</span>:<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;my-comp :p1=&quot;a&quot; :p2=&quot;2&quot; p3=&quot;3&quot;/&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：在组件中，属性是只读的，绝不可以更改，这叫做单向数据流</strong></p>
<p><img src="/images/vue2/vue2%E7%BB%84%E4%BB%B6-%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81.jpg"></p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue2</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2中响应式原理</title>
    <url>/135xyq.github.io/2021/08/08/Vue-%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94/</url>
    <content><![CDATA[<blockquote>
<p>面试题：请阐述<code>vue2</code>响应式原理</p>
</blockquote>
<blockquote>
<p>vue官方阐述：<a href="https://cn.vuejs.org/v2/guide/reactivity.html">https://cn.vuejs.org/v2/guide/reactivity.html</a></p>
</blockquote>
<p><strong>响应式数据的最终目标</strong>，是当对象本身或对象属性发生变化时，将会运行一些函数，最常见的就是render函数。</p>
<p>在具体实现上，vue用到了<strong>几个核心部件</strong>：</p>
<ol>
<li>Observer</li>
<li>Dep</li>
<li>Watcher</li>
<li>Scheduler</li>
</ol>
<h1 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h1><p>Observer要实现的目标非常简单，就是把一个普通的对象转换为响应式的对象</p>
<p>为了实现这一点，Observer把对象的每个属性通过<code>Object.defineProperty</code>转换为带有<code>getter</code>和<code>setter</code>的属性，这样一来，当访问或设置属性时，<code>vue</code>就有机会做一些别的事情。</p>
<p><img src="/images/vue2/%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94-%E5%8E%9F%E7%90%86.jpg" alt="数据响应"></p>
<p>Observer是vue内部的构造器，我们可以通过Vue提供的静态方法<code>Vue.observable( object )</code>间接的使用该功能。</p>
<p>在组件生命周期中，这件事发生在<code>beforeCreate</code>之后，<code>created</code>之前。</p>
<p>具体实现上，它会递归遍历对象的所有属性，以完成深度的属性转换。</p>
<p>由于遍历时只能遍历到对象的当前属性，因此无法监测到将来动态增加或删除的属性，因此<code>vue</code>提供了<code>$set</code>和<code>$delete</code>两个实例方法，让开发者通过这两个实例方法对已有响应式对象添加或删除属性。</p>
<p>对于数组，<code>vue</code>会更改它的隐式原型，之所以这样做，是因为vue需要监听那些可能改变数组内容的方法</p>
<p><img src="images/vue2/%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94-Observer.jpg"></p>
<p>总之，Observer的目标，就是要让一个对象，它属性的读取、赋值，内部数组的变化都要能够被vue感知到。</p>
<h1 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h1><p>这里有两个问题没解决，就是读取属性时要做什么事，而属性变化时要做什么事，这个问题需要依靠Dep来解决。</p>
<p>Dep的含义是<code>Dependency</code>，表示依赖的意思。</p>
<p><code>Vue</code>会为响应式对象中的每个属性、对象本身、数组本身创建一个<code>Dep</code>实例，每个<code>Dep</code>实例都有能力做以下两件事：</p>
<ul>
<li>记录依赖：是谁在用我</li>
<li>派发更新：我变了，我要通知那些用到我的人</li>
</ul>
<p>当读取响应式对象的某个属性时，它会进行依赖收集：有人用到了我</p>
<p>当改变某个属性时，它会派发更新：那些用我的人听好了，我变了</p>
<p><img src="/images/vue2/%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94-Dep.jpg"></p>
<h1 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h1><p>这里又出现一个问题，就是Dep如何知道是谁在用我？</p>
<p>要解决这个问题，需要依靠另一个东西，就是Watcher。</p>
<p>当某个函数执行的过程中，用到了响应式数据，响应式数据是无法知道是哪个函数在用自己的</p>
<p>因此，vue通过一种巧妙的办法来解决这个问题</p>
<p>我们不要直接执行函数，而是把函数交给一个叫做watcher的东西去执行，watcher是一个对象，每个这样的函数执行时都应该创建一个watcher，通过watcher去执行</p>
<p>watcher会设置一个全局变量，让全局变量记录当前负责执行的watcher等于自己，然后再去执行函数，在函数的执行过程中，如果发生了依赖记录<code>dep.depend()</code>，那么<code>Dep</code>就会把这个全局变量记录下来，表示：有一个watcher用到了我这个属性</p>
<p>当Dep进行派发更新时，它会通知之前记录的所有watcher：我变了</p>
<p><img src="/images/vue2/%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94-Watcher.jpg"></p>
<p>每一个<code>vue</code>组件实例，都至少对应一个<code>watcher</code>，该<code>watcher</code>中记录了该组件的<code>render</code>函数。</p>
<p><code>watcher</code>首先会把<code>render</code>函数运行一次以收集依赖，于是那些在render中用到的响应式数据就会记录这个watcher。</p>
<p>当数据变化时，dep就会通知该watcher，而watcher将重新运行render函数，从而让界面重新渲染同时重新记录当前的依赖。</p>
<h1 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h1><p>现在还剩下最后一个问题，就是Dep通知watcher之后，如果watcher执行重运行对应的函数，就有可能导致函数频繁运行，从而导致效率低下</p>
<p>试想，如果一个交给watcher的函数，它里面用到了属性a、b、c、d，那么a、b、c、d属性都会记录依赖，于是下面的代码将触发4次更新：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">state.a = <span class="string">&quot;new data&quot;</span>;</span><br><span class="line">state.b = <span class="string">&quot;new data&quot;</span>;</span><br><span class="line">state.c = <span class="string">&quot;new data&quot;</span>;</span><br><span class="line">state.d = <span class="string">&quot;new data&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这样显然是不合适的，因此，watcher收到派发更新的通知后，实际上不是立即执行对应函数，而是把自己交给一个叫调度器的东西</p>
<p>调度器维护一个执行队列，该队列同一个watcher仅会存在一次，队列中的watcher不是立即执行，它会通过一个叫做<code>nextTick</code>的工具方法，把这些需要执行的watcher放入到事件循环的微队列中，nextTick的具体做法是通过<code>Promise</code>完成的</p>
<blockquote>
<p>nextTick 通过 <code>this.$nextTick</code> 暴露给开发者</p>
<p>nextTick 的具体处理方式见：<a href="https://cn.vuejs.org/v2/guide/reactivity.html#%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E9%98%9F%E5%88%97">链接</a></p>
</blockquote>
<p>也就是说，当响应式数据变化时，<code>render</code>函数的执行是异步的，并且在微队列中</p>
<h1 id="总体流程"><a href="#总体流程" class="headerlink" title="总体流程"></a>总体流程</h1><p><img src="/images/vue2/%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94-%E6%80%BB%E4%BD%93%E6%B5%81%E7%A8%8B.jpg"></p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue2</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2中的组件生命周期</title>
    <url>/135xyq.github.io/2021/08/20/Vue-%E7%BB%84%E4%BB%B6%E7%94%9F%E5%AD%98%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h1 id="组件生命周期"><a href="#组件生命周期" class="headerlink" title="组件生命周期"></a>组件生命周期</h1><p><img src="/images/vue2/%E7%BB%84%E4%BB%B6%E7%94%9F%E5%AD%98%E5%91%A8%E6%9C%9F-1.jpg"></p>
<p><img src="/images/vue2/%E7%BB%84%E4%BB%B6%E7%94%9F%E5%AD%98%E5%91%A8%E6%9C%9F-2.jpg"></p>
<h1 id="常见应用"><a href="#常见应用" class="headerlink" title="常见应用"></a>常见应用</h1><blockquote>
<p>不要死记硬背，要根据具体情况灵活处理</p>
</blockquote>
<h2 id="加载远程数据"><a href="#加载远程数据" class="headerlink" title="加载远程数据"></a>加载远程数据</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">news</span>: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">created</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.news = <span class="keyword">await</span> getNews();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="直接操作DOM"><a href="#直接操作DOM" class="headerlink" title="直接操作DOM"></a>直接操作DOM</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">containerWidth</span>:<span class="number">0</span>,</span><br><span class="line">    	<span class="attr">containerHeight</span>:<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.containerWidth = <span class="built_in">this</span>.$refs.container.clientWidth;</span><br><span class="line">    <span class="built_in">this</span>.containerHeight = <span class="built_in">this</span>.$refs.container.containerHeight;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="启动和清除计时器"><a href="#启动和清除计时器" class="headerlink" title="启动和清除计时器"></a>启动和清除计时器</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">timer</span>: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">created</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.timer = <span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">     ... </span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">destroyed</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(<span class="built_in">this</span>.timer);               </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue2</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2中的组件事件</title>
    <url>/135xyq.github.io/2021/08/22/Vue-%E7%BB%84%E4%BB%B6%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<p>在样式中可以用 ‘~@’定位到src目录<br>在script中用‘@’可定位到src目录</p>
<ol>
<li><p><strong>v-if 和 v-show</strong></p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="/images/vue2/%E7%BB%84%E4%BB%B6%E4%BA%8B%E4%BB%B6-v-if&v-show.jpg" alt="image-20201113133827438"></h2><p><img src="/images/vue2/%E7%BB%84%E4%BB%B6%E4%BA%8B%E4%BB%B6-v-if&v-show1.jpg" alt="image-20201113134051281"><br><strong>面试题：v-if 和 v-show 有什么区别？</strong></p>
</li>
</ol>
<p>v-if能够控制是否生成vnode，也就间接控制了是否生成对应的dom。当v-if为true时，会生成对应的vnode，并生成对应的dom元素；当其为false时，不会生成对应的vnode，自然不会生成任何的dom元素。<br>v-show始终会生成vnode，也就间接导致了始终生成dom。它只是控制dom的display属性，当v-show为true时，不做任何处理；当其为false时，生成的dom的display属性为none。<br>使用v-if可以有效的减少树的节点和渲染量，但也会导致树的不稳定；而使用v-show可以保持树的稳定，但不能减少树的节点和渲染量。<br>因此，在实际开发中，显示状态变化频繁的情况下应该使用v-show，以保持树的稳定；显示状态变化较少时应该使用v-if，以减少树的节点和渲染量。</p>
<ol start="2">
<li><strong>组件事件</strong></li>
</ol>
<p><img src="/images/vue2/vue2%E7%BB%84%E4%BB%B6%E4%BA%8B%E4%BB%B6-%E7%BB%84%E4%BB%B6%E4%BA%8B%E4%BB%B6.jpg" alt="vue2组件事件"><br>抛出事件：子组件在某个时候发生了一件事，但自身无法处理，于是通过事件的方式通知父组件处理</p>
<p>事件参数：子组件抛出事件时，传递给父组件的数据</p>
<p>注册事件：父组件申明，当子组件发生某件事的时候，自身将做出一些处理</p>
<p><img src="/images/vue2/%E7%BB%84%E4%BB%B6%E4%BA%8B%E4%BB%B6-%E7%BB%84%E4%BB%B6%E4%BA%8B%E4%BB%B6.jpg" alt="事件"></p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue2</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2中的组件通信</title>
    <url>/135xyq.github.io/2021/08/25/Vue-%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<p>面试题：vue组件之间有哪些通信方式？</p>
<h1 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a>父子组件通信</h1><blockquote>
<p>绝大部分<code>vue</code>本身提供的通信方式，都是父子组件通信</p>
</blockquote>
<h2 id="prop"><a href="#prop" class="headerlink" title="prop"></a><code>prop</code></h2><p>最常见的组件通信方式之一，由父组件传递到子组件</p>
<h2 id="event"><a href="#event" class="headerlink" title="event"></a><code>event</code></h2><p>最常见的组件通信方式之一，当子组件发生了某些事，可以通过<code>event</code>通知父组件</p>
<h2 id="style和class"><a href="#style和class" class="headerlink" title="style和class"></a><code>style</code>和<code>class</code></h2><p>父组件可以向子组件传递<code>style</code>和<code>class</code>，它们会合并到子组件的根元素中</p>
<p><strong>示例</strong></p>
<p>父组件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">HelloWorld</span></span></span><br><span class="line"><span class="tag">      <span class="attr">style</span>=<span class="string">&quot;color:red&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;hello&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">msg</span>=<span class="string">&quot;Welcome to Your Vue.js App&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> HelloWorld <span class="keyword">from</span> <span class="string">&quot;./components/HelloWorld.vue&quot;</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">    HelloWorld,</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">&#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>子组件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;world&quot;</span> <span class="attr">style</span>=<span class="string">&quot;text-align:center&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">name</span>: <span class="string">&quot;HelloWorld&quot;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="attr">props</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">msg</span>: <span class="built_in">String</span>,</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">&#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>渲染结果：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hello world&quot;</span> <span class="attr">style</span>=<span class="string">&quot;color:red; text-aling:center&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Welcome to Your Vue.js App<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="attribute"><a href="#attribute" class="headerlink" title="attribute"></a><code>attribute</code></h2><p>如果父组件传递了一些属性到子组件，但子组件并没有声明这些属性，则它们称之为<code>attribute</code>，这些属性会直接附着在子组件的根元素上</p>
<blockquote>
<p>不包括<code>style</code>和<code>class</code>，它们会被特殊处理</p>
</blockquote>
<p><strong>示例</strong></p>
<p>父组件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 除 msg 外，其他均为 attribute --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">HelloWorld</span></span></span><br><span class="line"><span class="tag">      <span class="attr">data-a</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">data-b</span>=<span class="string">&quot;2&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">msg</span>=<span class="string">&quot;Welcome to Your Vue.js App&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> HelloWorld <span class="keyword">from</span> <span class="string">&quot;./components/HelloWorld.vue&quot;</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">    HelloWorld,</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">&#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>子组件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">name</span>: <span class="string">&quot;HelloWorld&quot;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="attr">props</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">msg</span>: <span class="built_in">String</span>,</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.$attrs); <span class="comment">// 得到： &#123; &quot;data-a&quot;: &quot;1&quot;, &quot;data-b&quot;: &quot;2&quot; &#125;</span></span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">&#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>渲染结果：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">data-a</span>=<span class="string">&quot;1&quot;</span> <span class="attr">data-b</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Welcome to Your Vue.js App<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>子组件可以通过<code>inheritAttrs: false</code>配置，禁止将<code>attribute</code>附着在子组件的根元素上，但不影响通过<code>$attrs</code>获取</p>
<h2 id="natvie修饰符"><a href="#natvie修饰符" class="headerlink" title="natvie修饰符"></a><code>natvie</code>修饰符</h2><p>在注册事件时，父组件可以使用<code>native</code>修饰符，将事件注册到子组件的根元素上</p>
<p><strong>示例</strong></p>
<p>父组件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">HelloWorld</span> @<span class="attr">click.native</span>=<span class="string">&quot;handleClick&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> HelloWorld <span class="keyword">from</span> <span class="string">&quot;./components/HelloWorld.vue&quot;</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">    HelloWorld,</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">handleClick</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="number">1</span>);</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">&#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>子组件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>渲染结果</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 点击该 div，会输出 1 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="listeners"><a href="#listeners" class="headerlink" title="$listeners"></a><code>$listeners</code></h2><p>子组件可以通过<code>$listeners</code>获取父组件传递过来的所有事件处理函数</p>
<h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a><code>v-model</code></h2><h2 id="sync修饰符"><a href="#sync修饰符" class="headerlink" title="sync修饰符"></a><code>sync</code>修饰符</h2><p>和<code>v-model</code>的作用类似，用于双向绑定，不同点在于<code>v-model</code>只能针对一个数据进行双向绑定，而<code>sync</code>修饰符没有限制</p>
<p>示例</p>
<p>子组件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;$emit(`update:num1`, num1 - 1)&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      &#123;&#123; num1 &#125;&#125;</span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;$emit(`update:num1`, num1 + 1)&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;$emit(`update:num2`, num2 - 1)&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      &#123;&#123; num2 &#125;&#125;</span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;$emit(`update:num2`, num2 + 1)&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">props</span>: [<span class="string">&quot;num1&quot;</span>, <span class="string">&quot;num2&quot;</span>],</span></span><br><span class="line"><span class="javascript">&#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>父组件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Numbers</span> <span class="attr">:num1.sync</span>=<span class="string">&quot;n1&quot;</span> <span class="attr">:num2.sync</span>=<span class="string">&quot;n2&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 等同于 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Numbers</span></span></span><br><span class="line"><span class="tag">      <span class="attr">:num1</span>=<span class="string">&quot;n1&quot;</span></span></span><br><span class="line"><span class="tag">      @<span class="attr">update:num1</span>=<span class="string">&quot;n1 = $event&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">:num2</span>=<span class="string">&quot;n2&quot;</span></span></span><br><span class="line"><span class="tag">      @<span class="attr">update:num2</span>=<span class="string">&quot;n2 = $event&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Numbers <span class="keyword">from</span> <span class="string">&quot;./components/Numbers.vue&quot;</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">    Numbers,</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">n1</span>: <span class="number">0</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">n2</span>: <span class="number">0</span>,</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">&#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="parent和-children"><a href="#parent和-children" class="headerlink" title="$parent和$children"></a><code>$parent</code>和<code>$children</code></h2><p>在组件内部，可以通过<code>$parent</code>和<code>$children</code>属性，分别得到当前组件的父组件和子组件实例</p>
<h2 id="slots和-scopedSlots"><a href="#slots和-scopedSlots" class="headerlink" title="$slots和$scopedSlots"></a><code>$slots</code>和<code>$scopedSlots</code></h2><p>后续章节讲解</p>
<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a><code>ref</code></h2><p>父组件可以通过<code>ref</code>获取到子组件的实例</p>
<h1 id="跨组件通信"><a href="#跨组件通信" class="headerlink" title="跨组件通信"></a>跨组件通信</h1><h2 id="Provide和Inject"><a href="#Provide和Inject" class="headerlink" title="Provide和Inject"></a><code>Provide</code>和<code>Inject</code></h2><p>示例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// 父级组件提供 &#x27;foo&#x27;</span><br><span class="line">var Provider = &#123;</span><br><span class="line">  provide: &#123;</span><br><span class="line">    foo: &#x27;bar&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 组件注入 &#x27;foo&#x27;</span><br><span class="line">var Child = &#123;</span><br><span class="line">  inject: [&#x27;foo&#x27;],</span><br><span class="line">  created () &#123;</span><br><span class="line">    console.log(this.foo) // =&gt; &quot;bar&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详见：<a href="https://cn.vuejs.org/v2/api/#provide-inject">https://cn.vuejs.org/v2/api/?#provide-inject</a></p>
<h2 id="router"><a href="#router" class="headerlink" title="router"></a><code>router</code></h2><p>如果一个组件改变了地址栏，所有监听地址栏的组件都会做出相应反应</p>
<p>最常见的场景就是通过点击<code>router-link</code>组件改变了地址，<code>router-view</code>组件就渲染其他内容</p>
<h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a><code>vuex</code></h2><p>适用于大型项目的数据仓库</p>
<h2 id="store模式"><a href="#store模式" class="headerlink" title="store模式"></a><code>store</code>模式</h2><p>适用于中小型项目的数据仓库</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// store.js</span></span><br><span class="line"><span class="keyword">const</span> store = &#123;</span><br><span class="line">  <span class="attr">loginUser</span>: ...,</span><br><span class="line">  <span class="attr">setting</span>: ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compA</span></span><br><span class="line"><span class="keyword">const</span> compA = &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">loginUser</span>: store.loginUser</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compB</span></span><br><span class="line"><span class="keyword">const</span> compB = &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">setting</span>: store.setting,</span><br><span class="line">      <span class="attr">loginUser</span>: store.loginUser</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="eventbus"><a href="#eventbus" class="headerlink" title="eventbus"></a><code>eventbus</code></h2><p>组件通知事件总线发生了某件事，事件总线通知其他监听该事件的所有组件运行某个函数</p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue2</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2中虚拟节点</title>
    <url>/135xyq.github.io/2021/08/10/Vue-%E8%99%9A%E6%8B%9F%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<p>面试题：请你阐述一下对vue虚拟dom的理解</p>
<ol>
<li><p>什么是虚拟dom？</p>
<p>虚拟dom本质上就是一个普通的JS对象，用于描述视图的界面结构</p>
<p>在vue中，每个组件都有一个<code>render</code>函数，每个<code>render</code>函数都会返回一个虚拟dom树，这也就意味着每个组件都对应一棵虚拟DOM树</p>
</li>
</ol>
<p><img src="/images/vue2/%E8%99%9A%E6%8B%9F%E8%8A%82%E7%82%B9-%E8%99%9A%E6%8B%9FDOM.jpg" alt="虚拟dom"></p>
<ol start="2">
<li><p>为什么需要虚拟dom？</p>
<p>在<code>vue</code>中，渲染视图会调用<code>render</code>函数，这种渲染不仅发生在组件创建时，同时发生在视图依赖的数据更新时。如果在渲染时，直接使用真实<code>DOM</code>，由于真实<code>DOM</code>的创建、更新、插入等操作会带来大量的性能损耗，从而就会极大的降低渲染效率。</p>
<p>因此，<code>vue</code>在渲染时，使用虚拟dom来替代真实dom，主要为解决渲染效率的问题。</p>
</li>
<li><p>虚拟dom是如何转换为真实dom的？</p>
<p>在一个组件实例首次被渲染时，它先生成虚拟dom树，然后根据虚拟dom树创建真实dom，并把真实dom挂载到页面中合适的位置，此时，每个虚拟dom便会对应一个真实的dom。</p>
<p>如果一个组件受响应式数据变化的影响，需要重新渲染时，它仍然会重新调用render函数，创建出一个新的虚拟dom树，用新树和旧树对比，通过对比，vue会找到最小更新量，然后更新必要的虚拟dom节点，最后，这些更新过的虚拟节点，会去修改它们对应的真实dom</p>
<p>这样一来，就保证了对真实dom达到最小的改动。</p>
</li>
</ol>
<p><img src="/images/vue2/%E8%99%9A%E6%8B%9F%E8%8A%82%E7%82%B9-%E6%9B%B4%E6%96%B0.jpg"></p>
<ol start="4">
<li><p>模板和虚拟dom的关系</p>
<p>vue框架中有一个<code>compile</code>模块，它主要负责将模板转换为<code>render</code>函数，而<code>render</code>函数调用后将得到虚拟dom。</p>
<p>编译的过程分两步：</p>
<ol>
<li>将模板字符串转换成为<code>AST</code></li>
<li>将<code>AST</code>转换为<code>render</code>函数</li>
</ol>
<p>如果使用传统的引入方式，则编译时间发生在组件第一次加载时，这称之为运行时编译。</p>
<p>如果是在<code>vue-cli</code>的默认配置下，编译发生在打包时，这称之为模板预编译。</p>
<p>编译是一个极其耗费性能的操作，预编译可以有效的提高运行时的性能，而且，由于运行的时候已不需要编译，<code>vue-cli</code>在打包时会排除掉<code>vue</code>中的<code>compile</code>模块，以减少打包体积</p>
<p>模板的存在，仅仅是为了让开发人员更加方便的书写界面代码</p>
<p><strong>vue最终运行的时候，最终需要的是render函数，而不是模板，因此，模板中的各种语法，在虚拟dom中都是不存在的，它们都会变成虚拟dom的配置</strong></p>
</li>
</ol>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue2</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>数据与跨域</title>
    <url>/135xyq.github.io/2021/10/21/Vue-%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<blockquote>
<p>vue cli: <a href="https://cli.vuejs.org/zh/">https://cli.vuejs.org/zh/</a></p>
<p>axios: <a href="https://github.com/axios/axios">https://github.com/axios/axios</a></p>
<p>mockjs：<a href="http://mockjs.com/">http://mockjs.com/</a></p>
</blockquote>
<h1 id="远程获取数据的意义"><a href="#远程获取数据的意义" class="headerlink" title="远程获取数据的意义"></a>远程获取数据的意义</h1><p><img src="/images/vue2/%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE-1.jpg" alt="获取数据"></p>
<h1 id="开发环境有跨域问题"><a href="#开发环境有跨域问题" class="headerlink" title="开发环境有跨域问题"></a>开发环境有跨域问题</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">浏览器-&gt;&gt;前端开发服务器: http://localhost:8080/</span><br><span class="line">前端开发服务器-&gt;&gt;浏览器: 页面</span><br><span class="line">浏览器-&gt;&gt;后端测试服务器: ajax 跨域：http://test-data:3000/api/news</span><br><span class="line">后端测试服务器-&gt;&gt;浏览器: JSON数据</span><br><span class="line">rect rgb(224,74,74)</span><br><span class="line">Note right of 浏览器: 浏览器阻止数据移交</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h1 id="生产环境没有跨域问题"><a href="#生产环境没有跨域问题" class="headerlink" title="生产环境没有跨域问题"></a>生产环境没有跨域问题</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">浏览器-&gt;&gt;服务器: http://www.my-site.com/</span><br><span class="line">服务器-&gt;&gt;浏览器: 页面</span><br><span class="line">浏览器-&gt;&gt;服务器: ajax：http://www.my-site.com/api/news</span><br><span class="line">服务器-&gt;&gt;浏览器: JSON数据</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">浏览器-&gt;&gt;静态资源服务器: http://www.my-site.com/</span><br><span class="line">静态资源服务器-&gt;&gt;浏览器: 页面</span><br><span class="line">浏览器-&gt;&gt;数据服务器: ajax 跨域：http://api.my-site.com/api/news</span><br><span class="line">数据服务器-&gt;&gt;浏览器: [允许www.my-site.com]JSON数据</span><br></pre></td></tr></table></figure>

<h1 id="解决开发环境的跨域问题"><a href="#解决开发环境的跨域问题" class="headerlink" title="解决开发环境的跨域问题"></a>解决开发环境的跨域问题</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">浏览器-&gt;&gt;前端开发服务器: http://localhost:8080/</span><br><span class="line">前端开发服务器-&gt;&gt;浏览器: 页面</span><br><span class="line">浏览器-&gt;&gt;前端开发服务器: ajax：http://localhost:8080/api/news</span><br><span class="line">前端开发服务器-&gt;&gt;后端测试服务器: 代理请求：http://test-data:3000/api/news</span><br><span class="line">后端测试服务器-&gt;&gt;前端开发服务器: JSON数据</span><br><span class="line">前端开发服务器-&gt;&gt;浏览器: JSON数据</span><br></pre></td></tr></table></figure>

<h1 id="为什么要Mock数据"><a href="#为什么要Mock数据" class="headerlink" title="为什么要Mock数据"></a>为什么要Mock数据</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">浏览器-&gt;&gt;前端开发服务器: http://localhost:8080/</span><br><span class="line">前端开发服务器-&gt;&gt;浏览器: 页面</span><br><span class="line">浏览器-&gt;&gt;前端开发服务器: ajax：http://localhost:8080/api/news</span><br><span class="line">前端开发服务器-&gt;&gt;后端测试服务器: 代理请求：http://test-data:3000/api/news</span><br><span class="line">后端测试服务器-&gt;&gt;前端开发服务器: 404 （后端正在开发中）</span><br><span class="line">前端开发服务器-&gt;&gt;浏览器: 404</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">participant 浏览器</span><br><span class="line">participant MockJS</span><br><span class="line">participant 前端开发服务器</span><br><span class="line">activate MockJS</span><br><span class="line">Note left of MockJS: 定义ajax拦截规则</span><br><span class="line">deactivate MockJS</span><br><span class="line">浏览器-&gt;&gt;前端开发服务器: http://localhost:8080/</span><br><span class="line">前端开发服务器-&gt;&gt;浏览器: 页面</span><br><span class="line">浏览器-&gt;&gt;MockJS: ajax：http://localhost:8080/api/news</span><br><span class="line">MockJS-&gt;&gt;浏览器: 模拟的JSON数据</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/qq_45808923/article/details/122667013"></a></p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue2</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2中计算属性</title>
    <url>/135xyq.github.io/2021/09/01/Vue-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<p>面试题：计算属性和方法有什么区别？</p>
<ul>
<li>计算属性本质上是包含getter和setter的方法</li>
<li>当获取计算属性时，实际上是在调用计算属性的getter方法。vue会收集计算属性的依赖，并缓存计算属性的返回结果。只有当依赖变化后才会重新进行计算。</li>
<li>方法没有缓存，每次调用方法都会导致重新执行。</li>
<li>计算属性的getter和setter参数固定，getter没有参数，setter只有一个参数。而方法的参数不限。</li>
</ul>
<p>由于有以上的这些区别，因此计算属性通常是根据已有数据得到其他数据，并在得到数据的过程中不建议使用异步、当前时间、随机数等副作用操作。<br>实际上，他们最重要的区别是含义上的区别。计算属性含义上也是一个数据，可以读取也可以赋值；方法含义上是一个操作，用于处理一些事情。</p>
<p>完整的计算属性书写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  <span class="attr">propName</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="comment">// getter</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">      <span class="comment">// setter</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只包含getter的计算属性简写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  <span class="function"><span class="title">propName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// getter</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>父组件为影响子组件的最外层结构</p>
<p><img src="/images/vue2/%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7-%E7%88%B6%E7%BB%84%E4%BB%B6%E5%AF%B9%E5%AD%90%E7%BB%84%E4%BB%B6%E7%9A%84%E5%BD%B1%E5%93%8D.jpg"></p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue2</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>bootstrap响应网页和栅格系统</title>
    <url>/135xyq.github.io/2021/04/01/boostrap-%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BD%91%E9%A1%B5%E5%92%8C%E6%A0%85%E6%A0%BC%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="bootstrap-响应网页和栅格系统"><a href="#bootstrap-响应网页和栅格系统" class="headerlink" title="bootstrap 响应网页和栅格系统"></a>bootstrap 响应网页和栅格系统</h1><h2 id="响应式网页具有的特点："><a href="#响应式网页具有的特点：" class="headerlink" title="响应式网页具有的特点："></a>响应式网页具有的特点：</h2><ol>
<li>网页宽度自动调整</li>
<li>少用绝对宽度</li>
<li>字体要使用 rem（根节点的相对大小）、em 作为单位</li>
<li>布局要使用浮动或弹性</li>
</ol>
<h2 id="媒体查询："><a href="#媒体查询：" class="headerlink" title="媒体查询："></a>媒体查询：</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> 媒体类型 逻辑运算符（媒体特性）&#123;</span><br><span class="line">正常的CSS样式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="媒体类型："><a href="#媒体类型：" class="headerlink" title="媒体类型："></a>媒体类型：</h2><ul>
<li>  all:所有设备</li>
<li>  print：打印机设备</li>
<li>  screen：彩色的电脑屏幕</li>
<li>  speech：听觉设备</li>
</ul>
<h2 id="媒体特性："><a href="#媒体特性：" class="headerlink" title="媒体特性："></a>媒体特性：</h2><ul>
<li>  min-width 最小宽度</li>
<li>  width 宽度</li>
<li>  max-width 最大宽度</li>
<li>  height 高度</li>
<li>  min-width 最小高度</li>
<li>  max-width 最大高度</li>
<li>  orientation 方向</li>
<li>  landscape 横屏（宽度大于高度）</li>
<li>  portrait 竖屏（高度大于宽度）</li>
<li>  aspect-ratio 宽度比</li>
<li>  -webkit-device-pixel-ratio 像素比（webkit 内核专属）</li>
</ul>
<h2 id="逻辑运算符："><a href="#逻辑运算符：" class="headerlink" title="逻辑运算符："></a>逻辑运算符：</h2><ul>
<li>  and 合并多个媒体查询（并且）</li>
<li>  ， 匹配某个媒体查询（或者）</li>
<li>  not 对媒体查询结构取反</li>
<li>  only 仅在媒体查询匹配成功后应用样式（防范老旧浏览器）</li>
</ul>
<p>CSS @规则：</p>
<ul>
<li>  @chartest 定义编码</li>
<li>  @import 引入 css 文件</li>
<li>  @font-face 自定义字体</li>
<li>  @keyframes animation 里面的关键帧</li>
<li>  @media 媒体查询</li>
</ul>
<h2 id="栅格系统："><a href="#栅格系统：" class="headerlink" title="栅格系统："></a>栅格系统：</h2><p>X3.0 使用的是浮动原理，X4.0 使用的是弹性盒。</p>
<p>结构：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col- &quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="设置最外层容器为-container-时（表示宽度会有所限制）："><a href="#设置最外层容器为-container-时（表示宽度会有所限制）：" class="headerlink" title="设置最外层容器为 container 时（表示宽度会有所限制）："></a>设置最外层容器为 container 时（表示宽度会有所限制）：</h3><ul>
<li>  xl 为超大屏。屏幕宽度&gt;=1200，容器的宽度固定为 1140px，一行可以设置 12 个列。屏幕尺寸&lt;1200 的时候，一行只能设置 1 列</li>
<li>lg 为大屏。屏幕宽度&gt;=992px，容器的宽度固定为 960px，一行可以设置 12 个列。屏幕尺寸&lt;992 的时候，一行只能设置 1 列<br>  md 为中等屏。屏幕宽度&gt;=768px，容器的宽度固定为 720px，一行可以设置 12 个列。屏幕尺寸&lt;768 的时候，一行只能设置 1 列</li>
<li>  sm 为小屏。屏幕宽度&gt;=576px，容器的宽度固定为 540px，一行可以设置 12 个列。屏幕尺寸&lt;576 的时候，一行只能设置 1 列</li>
<li>  col 为超小屏。屏幕宽度&lt;576px，容器的宽度为 auto，一行永远可以设置 12 列</li>
</ul>
<p>设置最外层容器为 container-fluid 时（表示宽度为 100%）</p>
<p>等宽列：<br>设置 col 类</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>想换行，在从何处换行的元素后面加上一个元素设置 class 为 w-100</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;w-100&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>bootstrap</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2中的路由</title>
    <url>/135xyq.github.io/2021/09/25/Vue-%E8%B7%AF%E7%94%B1/</url>
    <content><![CDATA[<p>vue-router 官网：<a href="https://router.vuejs.org/zh/">https://router.vuejs.org/zh/</a></p>
<p><img src="/images/vue2/%E8%B7%AF%E7%94%B1-1.jpg" alt="路由1"></p>
<ol>
<li><p><strong>如何根据地址中的路径选择不同的组件？</strong></p>
</li>
<li><p><strong>把选择的组件放到哪个位置？</strong></p>
</li>
<li><p><strong>如何无刷新的切换组件？</strong></p>
</li>
</ol>
<h1 id="路由插件"><a href="#路由插件" class="headerlink" title="路由插件"></a>路由插件</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i vue-router</span><br></pre></td></tr></table></figure>

<p>路由插件的使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter); <span class="comment">// Vue.use(插件)  在Vue中使用插件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="comment">// 路由配置</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  ...,</span><br><span class="line">  router</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 路由配置</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">	<span class="attr">routes</span>: [</span><br><span class="line">		<span class="comment">// 路由规则</span></span><br><span class="line">		<span class="comment">// 当匹配到路径 /foo 时，渲染 Foo 组件</span></span><br><span class="line">		&#123; <span class="attr">path</span>: <span class="string">&quot;/foo&quot;</span>, <span class="attr">component</span>: Foo &#125;,</span><br><span class="line">		<span class="comment">// 当匹配到路径 /bar 时，渲染 Bar 组件</span></span><br><span class="line">		&#123; <span class="attr">path</span>: <span class="string">&quot;/bar&quot;</span>, <span class="attr">component</span>: Bar &#125;,</span><br><span class="line">	],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- App.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 公共区域 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 页面区域 --&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- vue-router 匹配到的组件会渲染到这里 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">RouterView</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h1><p>路由模式决定了：</p>
<ol>
<li>路由从哪里获取访问路径</li>
<li>路由如何改变访问路径</li>
</ol>
<p><code>vue-router</code>提供了三种路由模式：</p>
<ol>
<li><p>hash：默认值。路由从浏览器地址栏中的 hash 部分获取路径，改变路径也是改变的 hash 部分。该模式兼容性最好。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:8081/#/blog  --&gt;  /blog</span><br><span class="line">http://localhost:8081/about#/blog  --&gt; /blog</span><br></pre></td></tr></table></figure></li>
<li><p>history：路由从浏览器地址栏的<code>location.pathname</code>中获取路径，改变路径使用的 H5 的<code>history api</code>。该模式可以让地址栏最友好，但是需要浏览器支持<code>history api</code></p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:8081/#/blog  --&gt;  /</span><br><span class="line">http://localhost:8081/about#/blog  --&gt; /about</span><br><span class="line">http://localhost:8081/blog  --&gt; /blog</span><br></pre></td></tr></table></figure></li>
<li><p>abstract：路由从内存中获取路径，改变路径也只是改动内存中的值。这种模式通常应用到非浏览器环境中。</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">内存： /	    --&gt; /</span><br><span class="line">内存： /about	--&gt; /about</span><br><span class="line">内存： /blog	--&gt; /blog</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h1><p><code>vue-router</code>提供了全局的组件<code>RouterLink</code>，它的渲染结果是一个<code>a</code>元素</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">to</span>=<span class="string">&quot;/blog&quot;</span>&gt;</span>文章<span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- mode:hash 生成 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/blog&quot;</span>&gt;</span>文章<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- mode:history 生成 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 为了避免刷新页面，vue-router实际上为它添加了点击事件，并阻止了默认行为，在事件内部使用hitory api更改路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/blog&quot;</span>&gt;</span>文章<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/vue2/%E8%B7%AF%E7%94%B1-3.jpg" alt="路由3"></p>
<p><img src="/images/vue2/%E8%B7%AF%E7%94%B1-2.jpg" alt="路由2"></p>
<h2 id="激活状态"><a href="#激活状态" class="headerlink" title="激活状态"></a>激活状态</h2><p>默认情况下，<code>vue-router</code>会用 <strong>当前路径</strong> 匹配 <strong>导航路径</strong> ：</p>
<ul>
<li>  如果当前路径是以导航路径开头，则算作匹配，会为导航的 a 元素添加类名<code>router-link-active</code></li>
<li>  如果当前路径完全等于导航路径，则算作精确匹配，会为导航的 a 元素添加类名<code>router-link-exact-active</code></li>
</ul>
<p>例如，当前访问的路径是<code>/blog</code>，则：</p>
<table>
<thead>
<tr>
<th>导航路径</th>
<th>类名</th>
</tr>
</thead>
<tbody><tr>
<td>/</td>
<td>router-link-active</td>
</tr>
<tr>
<td>/blog</td>
<td>router-link-active router-link-exact-active</td>
</tr>
<tr>
<td>/about</td>
<td>无</td>
</tr>
<tr>
<td>/message</td>
<td>无</td>
</tr>
</tbody></table>
<p>可以为组件<code>RouterLink</code>添加 bool 属性<code>exact</code>，将匹配规则改为：必须要精确匹配才能添加匹配类名<code>router-link-active</code></p>
<p>例如，当前访问的路径是<code>/blog</code>，则：</p>
<table>
<thead>
<tr>
<th>导航路径</th>
<th>exact</th>
<th>类名</th>
</tr>
</thead>
<tbody><tr>
<td>/</td>
<td>true</td>
<td>无</td>
</tr>
<tr>
<td>/blog</td>
<td>false</td>
<td>router-link-active router-link-exact-active</td>
</tr>
<tr>
<td>/about</td>
<td>true</td>
<td>无</td>
</tr>
<tr>
<td>/message</td>
<td>true</td>
<td>无</td>
</tr>
</tbody></table>
<p>例如，当前访问的路径是<code>/blog/detail/123</code>，则：</p>
<table>
<thead>
<tr>
<th>导航路径</th>
<th>exact</th>
<th>类名</th>
</tr>
</thead>
<tbody><tr>
<td>/</td>
<td>true</td>
<td>无</td>
</tr>
<tr>
<td>/blog</td>
<td>false</td>
<td>router-link-active</td>
</tr>
<tr>
<td>/about</td>
<td>true</td>
<td>无</td>
</tr>
<tr>
<td>/message</td>
<td>true</td>
<td>无</td>
</tr>
</tbody></table>
<p>另外，可以通过<code>active-class</code>属性更改匹配的类名，通过<code>exact-active-class</code>更改精确匹配的类名</p>
<h1 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h1><p>使用命名路由可以解除系统与路径之间的耦合</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 路由配置</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">	<span class="attr">routes</span>: [</span><br><span class="line">		<span class="comment">// 路由规则</span></span><br><span class="line">		<span class="comment">// 当匹配到路径 /foo 时，渲染 Foo 组件</span></span><br><span class="line">		&#123; <span class="attr">name</span>: <span class="string">&quot;foo&quot;</span>, <span class="attr">path</span>: <span class="string">&quot;/foo&quot;</span>, <span class="attr">component</span>: Foo &#125;,</span><br><span class="line">		<span class="comment">// 当匹配到路径 /bar 时，渲染 Bar 组件</span></span><br><span class="line">		&#123; <span class="attr">name</span>: <span class="string">&quot;bar&quot;</span>, <span class="attr">path</span>: <span class="string">&quot;/bar&quot;</span>, <span class="attr">component</span>: Bar &#125;,</span><br><span class="line">	],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 向to属性传递路由信息对象 RouterLink会根据你传递的信息以及路由配置生成对应的路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">:to</span>=<span class="string">&quot;&#123; name:&#x27;foo&#x27; &#125;&quot;</span>&gt;</span>go to foo<span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue2</tag>
      </tags>
  </entry>
  <entry>
    <title>lodash的基本语法</title>
    <url>/135xyq.github.io/2021/04/06/js%E5%B7%A5%E5%85%B7%E5%BA%93-lodash%E7%9A%84%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="lodash"><a href="#lodash" class="headerlink" title="lodash"></a><a href="https://javasoho.com/lodash/docs/4.16.1.html">lodash</a></h1><h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//chunk()   把数组拆分成一个二维数组，拆分后的第1个数组的长度为第二个参数的值</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(_.chunk([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>], <span class="number">2</span>)); <span class="comment">//[[&quot;a&quot;, &quot;b&quot;],[&quot;c&quot;, &quot;d&quot;]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//compact() 过滤掉原数组里的非真（转布尔值后为false）数据</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(_.compact([<span class="number">0</span>, <span class="number">1</span>, <span class="literal">false</span>, <span class="number">2</span>, <span class="string">&quot;&quot;</span>, <span class="number">3</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">undefined</span>])); <span class="comment">//[1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//concat()  合并数组，与Array对象的方法一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//difference()  在第一个数组中把第二个数组里的数据都排除掉</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(_.difference([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>], [<span class="number">3</span>, <span class="number">7</span>])); <span class="comment">// [1, 5, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//differenceBy  与上面的方法一样，只不过它可以再接收一个迭代器的函数做为参数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(_.differenceBy([<span class="number">3.1</span>, <span class="number">2.2</span>, <span class="number">1.3</span>], [<span class="number">4.4</span>, <span class="number">2.5</span>], <span class="built_in">Math</span>.floor)); <span class="comment">//[3.1, 1.3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//differenceWith()  与上面的方法一样，只不过它可以接收一个比较器的函数做为参数，对每个数据都要比较一下</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> objects = [</span><br><span class="line">	&#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;,</span><br><span class="line">	&#123; <span class="attr">x</span>: <span class="number">2</span>, <span class="attr">y</span>: <span class="number">1</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(_.differenceWith(objects, [&#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;], _.isEqual)); <span class="comment">//[&#123; &#x27;x&#x27;: 2, &#x27;y&#x27;: 1 &#125;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//drop()    切掉数组的前n（第二个参数，默认为1）位</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(_.drop([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>], <span class="number">2</span>)); <span class="comment">//[&#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//dropRight()   切割数组，切掉数组的后n位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//dropWhile()   去掉数组中，从起点到第二个方法返回假的数据。与Array对象身上的filter()方法一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//dropRightWhile()  与上面一样，不过它是从右边开始查，查到返回假的那个数据都去除</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//take()    提取数组的前n（第二个参数，默认为1）位。与drop方法相反</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(_.take([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>], <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//takeRight()/takeWhile()/takeRightWhile()  与上面的一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//fill()    填充数组，与Array对象身上的fill()方法一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//findIndex()   查找到第一个满足条件的数据的索引值（从左往右查），没找到返回-1。与Array对象身上的findIndex()方法一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//findLastIndex()   这与上面的findIndex是一样的，区别是它是从右往左的查</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//flatten() 减少一级数组嵌套深度，与Array的flat()这个方法相似</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(_.flatten([<span class="string">&quot;a&quot;</span>, [<span class="string">&quot;b&quot;</span>, [<span class="string">&quot;c&quot;</span>, [<span class="string">&quot;d&quot;</span>]]]]));</span><br><span class="line"></span><br><span class="line"><span class="comment">//flattenDeep() 把数组递归为一维数组。相当于[].flat(Infinity)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(_.flattenDeep([<span class="string">&quot;a&quot;</span>, [<span class="string">&quot;b&quot;</span>, [<span class="string">&quot;c&quot;</span>, [<span class="string">&quot;d&quot;</span>]]]])); <span class="comment">//[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//flattenDepth()    减少n（第二个参数）层数组的嵌套。相当于[].flat(2)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(_.flattenDepth([<span class="string">&quot;a&quot;</span>, [<span class="string">&quot;b&quot;</span>, [<span class="string">&quot;c&quot;</span>, [<span class="string">&quot;d&quot;</span>]]]], <span class="number">2</span>)); <span class="comment">//[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//fromPairs()   把数组转换为一个对象，与Object.fromEntries()方法一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//head()/first()    获取数组里第一个元素，就是取下标为0的那个数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//last()    取数组里的最后一位数据，取下标为length-1的那个数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//indexOf() 查找数据，并返回数据对应的索引值，与Array对象身上的indexOf()方法一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//lastIndexOf() 查找数据，并返回数据对应的索引值，与Array对象身上的lastIndexOf()方法一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//initial() 获取数组里除了最后一位的所有数据。相当于删除数组里的最后一个数据，与Array对象身上的pop()方法一样。区别在于pop方法会改变原数组，而这个方法不会改变原数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//tail()    获取除了array数组第一个元素以外的全部元素，想当于Array对象身上的shift()，与initial()相反</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//intersection()    取数组的交集</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(_.intersection([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>], [<span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>], [<span class="string">&quot;e&quot;</span>, <span class="string">&quot;b&quot;</span>])); <span class="comment">//[&#x27;b&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//union()   取数组的并集（合并起来，去掉重复的）</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(_.union([<span class="number">2</span>], [<span class="number">1</span>, <span class="number">2</span>])); <span class="comment">//[2, 1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//xor() 删除数组的交集，留下非交集的部分</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(_.xor([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>], [<span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>], [<span class="string">&quot;e&quot;</span>, <span class="string">&quot;b&quot;</span>])); <span class="comment">//[&quot;a&quot;, &quot;c&quot;, &quot;e&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//join()    把数组转成字符串，这个方法原生的Array对象也有</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//nth() 取数组里的某个数据，就是通过下标取到某个数据。只不过它的数字可以为负。表示倒着找</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> array = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">	_.nth(array, <span class="number">1</span>), <span class="comment">//b</span></span><br><span class="line"></span><br><span class="line">	_.nth(array, -<span class="number">3</span>) <span class="comment">//c</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下这几个方法，用后面remove的方法代替</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//pull()    根据给的参数（参数为数据）删除原数组里的对应数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//pullAll() 与上面的方法一样，就是参数为数组（好比call,apply这两个方法）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//pullAllBy()\pullAllWith() 与前面方面的语法一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//pullAt()  根据给的参数（参数为索引）删除原数组里的对应数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//remove()  根据函数删除原数组里的数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>];</span><br><span class="line"></span><br><span class="line">_.remove(arr, <span class="function"><span class="keyword">function</span> (<span class="params">value, index, array</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> index &gt; <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//without() 根据给的参数（参数为数据）删除原数组里的对应数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">	_.without(arr, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>),</span><br><span class="line"></span><br><span class="line">	arr</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//reverse() 颠倒数组，这个方法原生的Array对象也有</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//slice()   截取数组，这个方法原生的Array对象也有</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//uniq()</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(_.uniq([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>])); <span class="comment">//[1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//uniqBy()/uniqWith() 与前面的一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//zip() 把各数组中索引值相同的数据放到一起，组成新数组</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(_.zip([<span class="string">&quot;小明&quot;</span>, <span class="string">&quot;小红&quot;</span>, <span class="string">&quot;小刚&quot;</span>], [<span class="string">&quot;男&quot;</span>, <span class="string">&quot;女&quot;</span>, <span class="string">&quot;男&quot;</span>], [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>])); <span class="comment">//[[&quot;小明&quot;, &quot;男&quot;, 12],[&quot;小红&quot;, &quot;女&quot;, 13],[&quot;小刚&quot;, &quot;男&quot;, 14]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//zipObject()   与上面方法一样，区别是它输出的是对象</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">	_.zipObject([<span class="string">&quot;小明&quot;</span>, <span class="string">&quot;小红&quot;</span>, <span class="string">&quot;小刚&quot;</span>], [<span class="string">&quot;男&quot;</span>, <span class="string">&quot;女&quot;</span>, <span class="string">&quot;男&quot;</span>], [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>])</span><br><span class="line">); <span class="comment">//&#123;小明: &quot;男&quot;, 小红: &quot;女&quot;, 小刚: &quot;男&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//zipWith()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//unzip()   这个方法与zip相反，把每个数组里索引值一样的数据放在一起</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">	_.unzip([</span><br><span class="line">		[<span class="string">&quot;小明&quot;</span>, <span class="string">&quot;男&quot;</span>, <span class="number">12</span>],</span><br><span class="line">		[<span class="string">&quot;小红&quot;</span>, <span class="string">&quot;女&quot;</span>, <span class="number">13</span>],</span><br><span class="line">		[<span class="string">&quot;小刚&quot;</span>, <span class="string">&quot;男&quot;</span>, <span class="number">14</span>],</span><br><span class="line">	])</span><br><span class="line">); <span class="comment">//[[&#x27;小明&#x27;, &#x27;小红&#x27;, &#x27;小刚&#x27;], [&#x27;男&#x27;, &#x27;女&#x27;, &#x27;男&#x27;], [12, 13, 14]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//unzipWith()   与zipWidth()一样，接收了一个迭代器的函数</span></span><br></pre></td></tr></table></figure>

<h2 id="collection"><a href="#collection" class="headerlink" title="collection"></a>collection</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//countBy() 按照一定规则统计数量，key循环次数，value为匹配到的数量</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(_.countBy([<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>], <span class="string">&quot;length&quot;</span>)); <span class="comment">//&#123;3: 2, 5: 1&#125;  按每个字符串的length进行统计，length为3的有两个数据。length为5的有1个数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//groupBy() 按照一定规则进行分组，key为循环次数，value为匹配到的数组</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(_.groupBy([<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>], <span class="string">&quot;length&quot;</span>)); <span class="comment">//&#123;3: [&quot;one&quot;, &quot;two&quot;], 5: [&quot;three&quot;]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//each()/forEach()  循环，与原生Array.forEach一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//eachRight()/forEachRight()    倒着循环</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//every()   与原生Array.every方法一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//filter()  过滤数组，与Array对象上的filter()方法一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//find()    查找数据，与Array对象上的find()方法一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//findLast()    与上面一样，区别在于它是从右往左查</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//flatMap()     生成一个扁平化的数组，与原生的flatMap()方法一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//flatMapDeep() 与上面一样，不过它可以递归</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//flatMapDepth()    与上面一样，它可以递归，并且可以指定递归的深度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//includes()    与Array对象上的includes()方法一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//invokeMap()   使用第二个参数（方法）去处理数组，返回处理后的结果（数组）</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">	_.invokeMap(</span><br><span class="line">		[</span><br><span class="line">			[<span class="number">5</span>, <span class="number">1</span>, <span class="number">7</span>],</span><br><span class="line">			[<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line">		],</span><br><span class="line">		<span class="string">&quot;sort&quot;</span></span><br><span class="line">	), <span class="comment">//[ [1, 5, 7],[1, 2, 3]]</span></span><br><span class="line"></span><br><span class="line">	_.invokeMap([<span class="number">123</span>, <span class="number">456</span>], <span class="built_in">String</span>.prototype.split, <span class="string">&quot;&quot;</span>) <span class="comment">//[[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;],[&quot;4&quot;, &quot;5&quot;, &quot;6&quot;]]</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//keyBy()   创建一个对象，里面的key由第二个参数决定。value为原数组里对应的那条数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> array = [</span><br><span class="line">	&#123; <span class="attr">dir</span>: <span class="string">&quot;left&quot;</span>, <span class="attr">code</span>: <span class="number">97</span> &#125;,</span><br><span class="line"></span><br><span class="line">	&#123; <span class="attr">dir</span>: <span class="string">&quot;right&quot;</span>, <span class="attr">code</span>: <span class="number">100</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = _.keyBy(array, <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">String</span>.fromCharCode(o.code); <span class="comment">//key为使用fromCharCode解析后的字符。value为它所在数组里的那条数据</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"></span><br><span class="line"><span class="comment">//key为dir，value为key所在原数组里的那条数据</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(_.keyBy(array, <span class="string">&quot;dir&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//orderBy() 排序，既能升序又能降序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> users = [</span><br><span class="line">	&#123; <span class="attr">user</span>: <span class="string">&quot;fred&quot;</span>, <span class="attr">age</span>: <span class="number">48</span> &#125;,</span><br><span class="line"></span><br><span class="line">	&#123; <span class="attr">user</span>: <span class="string">&quot;barney&quot;</span>, <span class="attr">age</span>: <span class="number">34</span> &#125;,</span><br><span class="line"></span><br><span class="line">	&#123; <span class="attr">user</span>: <span class="string">&quot;fred&quot;</span>, <span class="attr">age</span>: <span class="number">40</span> &#125;,</span><br><span class="line"></span><br><span class="line">	&#123; <span class="attr">user</span>: <span class="string">&quot;barney&quot;</span>, <span class="attr">age</span>: <span class="number">36</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">	_.orderBy(users, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;asc&quot;</span>), <span class="comment">//以age属性的值进行升序排序</span></span><br><span class="line"></span><br><span class="line">	_.orderBy(users, <span class="string">&quot;user&quot;</span>, <span class="string">&quot;desc&quot;</span>) <span class="comment">//以user属性的值进行降序排序</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//sortBy()      排序，只能升序</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">	_.sortBy(users, <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> o.user;</span><br><span class="line">	&#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//partition()   根据第2个参数把一个数组分拆成一个二维数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> users = [</span><br><span class="line">	&#123; <span class="attr">user</span>: <span class="string">&quot;barney&quot;</span>, <span class="attr">age</span>: <span class="number">36</span>, <span class="attr">active</span>: <span class="literal">false</span> &#125;,</span><br><span class="line"></span><br><span class="line">	&#123; <span class="attr">user</span>: <span class="string">&quot;fred&quot;</span>, <span class="attr">age</span>: <span class="number">40</span>, <span class="attr">active</span>: <span class="literal">true</span> &#125;,</span><br><span class="line"></span><br><span class="line">	&#123; <span class="attr">user</span>: <span class="string">&quot;pebbles&quot;</span>, <span class="attr">age</span>: <span class="number">1</span>, <span class="attr">active</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">	_.partition(users, <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">		<span class="comment">//active为true的放在一起，active为false的放在一起</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> o.active;</span><br><span class="line">	&#125;),</span><br><span class="line"></span><br><span class="line">	_.partition(users, &#123; <span class="attr">age</span>: <span class="number">1</span>, <span class="attr">active</span>: <span class="literal">false</span> &#125;) <span class="comment">//把第二个参数对应的数据放一起，其余的放一起</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//reduce()  与Array对象上的reduce()方法一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//reduceRight() 与Array对象上的reduceRight()方法一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//reject()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> users = [</span><br><span class="line">	&#123; <span class="attr">user</span>: <span class="string">&quot;barney&quot;</span>, <span class="attr">age</span>: <span class="number">36</span>, <span class="attr">active</span>: <span class="literal">false</span> &#125;,</span><br><span class="line"></span><br><span class="line">	&#123; <span class="attr">user</span>: <span class="string">&quot;fred&quot;</span>, <span class="attr">age</span>: <span class="number">40</span>, <span class="attr">active</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">	_.reject(users, <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> o.active; <span class="comment">//barney</span></span><br><span class="line">	&#125;),</span><br><span class="line"></span><br><span class="line">	_.reject(users, &#123; <span class="attr">age</span>: <span class="number">36</span>, <span class="attr">active</span>: <span class="literal">false</span> &#125;), <span class="comment">//fred</span></span><br><span class="line"></span><br><span class="line">	_.reject(users, [<span class="string">&quot;user&quot;</span>, <span class="string">&quot;fred&quot;</span>]), <span class="comment">//barney</span></span><br><span class="line"></span><br><span class="line">	_.reject(users, <span class="string">&quot;age&quot;</span>) <span class="comment">//[]</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//sample()  从数组中随机取一个数据</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(_.sample([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>]));</span><br><span class="line"></span><br><span class="line"><span class="comment">//sampleSize()  获得 n 个随机数据</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(_.sampleSize([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>], <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//shuffle() 随机排序</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(_.shuffle([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>]));</span><br><span class="line"></span><br><span class="line"><span class="comment">//size()    返回集合长度</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">	_.size([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>]), <span class="comment">//5</span></span><br><span class="line"></span><br><span class="line">	_.size(&#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;), <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">	_.size(<span class="string">&quot;kaivon&quot;</span>) <span class="comment">//6</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//some()    与Array对象上的some()方法一样</span></span><br></pre></td></tr></table></figure>

<h2 id="function"><a href="#function" class="headerlink" title="function"></a>function</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//defer()   推迟调用函数，在第二次事件循环的时候调用</span></span><br><span class="line">_.defer(<span class="function"><span class="keyword">function</span> (<span class="params">text</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(text);</span><br><span class="line">&#125;, <span class="string">&quot;第二次事件循环&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;第一次事件循环&quot;</span>);</span><br><span class="line"><span class="comment">//delay()</span></span><br><span class="line">_.delay(</span><br><span class="line">	<span class="function"><span class="keyword">function</span> (<span class="params">text</span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(text);</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="number">1000</span>,</span><br><span class="line">	<span class="string">&quot;延迟一秒执行&quot;</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//flip()    调用函数时翻转参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn1 = _.flip(fn1);</span><br><span class="line">fn1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">//negate()  结果取反函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(_.filter([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], _.negate(fn2))); <span class="comment">//[1, 3, 5]</span></span><br><span class="line"><span class="comment">//once()    函数只能调用一次</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&quot;fn3&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> newFn3 = _.once(fn3);</span><br><span class="line">newFn3();</span><br><span class="line">newFn3();</span><br></pre></td></tr></table></figure>

<h2 id="Lang"><a href="#Lang" class="headerlink" title="Lang"></a>Lang</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//castArray()   强制转为数组，其实就是在外面加一层方括号</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">    _.castArray(<span class="string">&#x27;a&#x27;</span>), <span class="comment">//[&quot;a&quot;]</span></span><br><span class="line">    _.castArray(&#123;</span><br><span class="line">        <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">b</span>: <span class="number">2</span></span><br><span class="line">    &#125;), <span class="comment">//[&#123;a: 1, b: 2&#125;]</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//clone()   浅拷贝</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: &#123;</span><br><span class="line">        <span class="attr">c</span>: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = _.clone(obj1);</span><br><span class="line"><span class="built_in">console</span>.log(obj1, obj2);</span><br><span class="line">obj2.b.c = <span class="number">3</span>, <span class="built_in">console</span>.log(obj1, obj2);</span><br><span class="line"><span class="comment">//cloneDeep()   深拷贝</span></span><br><span class="line"><span class="keyword">var</span> obj3 = _.cloneDeep(obj1);</span><br><span class="line">obj3.b.c = <span class="number">4</span>, <span class="built_in">console</span>.log(obj1, obj3);</span><br><span class="line"><span class="comment">//conformsTo()  通过第二个参数来检测对象的属性值是否满足条件</span></span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    <span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">    _.conformsTo(object, &#123;</span><br><span class="line">        <span class="string">&#x27;b&#x27;</span>: <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> n &gt; <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;), <span class="comment">//true</span></span><br><span class="line">    _.conformsTo(object, &#123;</span><br><span class="line">        <span class="string">&#x27;b&#x27;</span>: <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> n &gt; <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;), <span class="comment">//false</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//ea()  比较两个值是否相等。与Object.is()这个方法一样</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">    _.eq(<span class="number">12</span>, <span class="number">12</span>), <span class="comment">//true</span></span><br><span class="line">    _.eq(&#123;</span><br><span class="line">        <span class="attr">a</span>: <span class="number">1</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">a</span>: <span class="number">1</span></span><br><span class="line">    &#125;), <span class="comment">//false</span></span><br><span class="line">    _.eq(<span class="literal">NaN</span>, <span class="literal">NaN</span>), <span class="comment">//true</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//gt()  第一个值是否大于第二个值</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">    _.gt(<span class="number">3</span>, <span class="number">1</span>), <span class="comment">//true</span></span><br><span class="line">    _.gt(<span class="number">3</span>, <span class="number">3</span>), <span class="comment">//false</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//gte() 第一个值是否大于等于第二个值</span></span><br><span class="line"><span class="comment">//lt()  小于</span></span><br><span class="line"><span class="comment">//lte() 小于等于</span></span><br><span class="line"><span class="comment">//isArray()</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">    _.isArray([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]), <span class="comment">//true</span></span><br><span class="line">    _.isArray(<span class="built_in">document</span>.body.children), <span class="comment">//false</span></span><br><span class="line">    _.isObject(&#123;&#125;), <span class="comment">//true</span></span><br><span class="line">    _.isObject(<span class="literal">null</span>), <span class="comment">//false</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//toArray()</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">    _.toArray(&#123;</span><br><span class="line">        <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">b</span>: <span class="number">2</span></span><br><span class="line">    &#125;), <span class="comment">//[1, 2]</span></span><br><span class="line">    _.toArray(<span class="string">&#x27;abc&#x27;</span>), <span class="comment">//[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line">    _.toArray(<span class="literal">null</span>), <span class="comment">//[]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="object"><a href="#object" class="headerlink" title="object"></a>object</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//assign()  合并对象，与Object.assign()方法一样</span></span><br><span class="line"><span class="comment">//assignIn()/extend()   与上面一样，不过它能继承原型身上的属性</span></span><br><span class="line"><span class="comment">//assignInWith()/extendWith()   与上面一样，接收一个比较器的函数做为参数</span></span><br><span class="line"><span class="comment">//assignWith()  也是接收一个比较器的函数做为参数</span></span><br><span class="line"><span class="comment">//at()  根据传入的属性创建一个数组</span></span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">	<span class="attr">a</span>: [</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">b</span>: &#123;</span><br><span class="line">				<span class="attr">c</span>: <span class="number">3</span>,</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="number">4</span>,</span><br><span class="line">	],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(_.at(object, [<span class="string">&quot;a[0].b.c&quot;</span>, <span class="string">&quot;a[1]&quot;</span>])); <span class="comment">//[3, 4]</span></span><br><span class="line"><span class="comment">//create()  与Object.create()一样</span></span><br><span class="line"><span class="comment">//defaults()    合并对象，与assign()一样，不过assign方法合并时遇到相同的属性，后面的会覆盖前面的。defaults刚好相反，前面的覆盖后面的</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">	_.defaults(</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">a</span>: <span class="number">3</span>,</span><br><span class="line">		&#125;</span><br><span class="line">	), <span class="comment">//&#123;a: 1, b: 2&#125;</span></span><br><span class="line">	_.assign(</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">a</span>: <span class="number">3</span>,</span><br><span class="line">		&#125;</span><br><span class="line">	) <span class="comment">//&#123;a: 3, b: 2&#125;</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//defaultsDeep()    与defaults一致，不过它会深递归</span></span><br><span class="line"><span class="comment">//toPairs()/entries()   把对象里可枚举的属性(不包括继承的)创建成一个数组，与Object.entities()的方法一样</span></span><br><span class="line"><span class="comment">//toPairsIn()/entriesIn()   与上面的一样，但它包括继承的属性</span></span><br><span class="line"><span class="comment">//findKey() 与前面讲的find方法一样，只不过它返回的是key</span></span><br><span class="line"><span class="keyword">var</span> users = &#123;</span><br><span class="line">	<span class="attr">barney</span>: &#123;</span><br><span class="line">		<span class="attr">age</span>: <span class="number">36</span>,</span><br><span class="line">		<span class="attr">active</span>: <span class="literal">true</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">fred</span>: &#123;</span><br><span class="line">		<span class="attr">age</span>: <span class="number">40</span>,</span><br><span class="line">		<span class="attr">active</span>: <span class="literal">false</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">pebbles</span>: &#123;</span><br><span class="line">		<span class="attr">age</span>: <span class="number">1</span>,</span><br><span class="line">		<span class="attr">active</span>: <span class="literal">true</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">	_.findKey(users, &#123;</span><br><span class="line">		<span class="attr">age</span>: <span class="number">1</span>,</span><br><span class="line">		<span class="attr">active</span>: <span class="literal">true</span>,</span><br><span class="line">	&#125;)</span><br><span class="line">); <span class="comment">//pebbles</span></span><br><span class="line"><span class="comment">//findLastKey() 与上面一样，只不过它从反方向开始遍历</span></span><br><span class="line"><span class="comment">//forIn()   与原生 的for...in循环一样，只不过它是一个函数，语法与forEach一样。它遍历的是自己的属性与继承的属性</span></span><br><span class="line"><span class="comment">//forInRight()  与上面一样，只不过是反方向遍历</span></span><br><span class="line"><span class="comment">//forOwn()  与forIn()一样，只不过forOwn只能遍历到自己的属性</span></span><br><span class="line"><span class="comment">//forOwnRight() 与上面一样，只不过是反方向遍历</span></span><br><span class="line"><span class="comment">//functions()/functionsIn() 这两个没有说？？？？？？</span></span><br><span class="line"><span class="comment">//get() 获取属性的值，与Object.defineProperty() 属性描述对象上的get方法一致</span></span><br><span class="line"><span class="comment">//set() 设置属性的值，与Object.defineProperty() 属性描述对象上的set方法一致</span></span><br><span class="line"><span class="comment">//setWith() 与上面的一样，只不过可以给一个参数决定返回的是对象还是数组</span></span><br><span class="line"><span class="built_in">console</span>.log(_.setWith(&#123;&#125;, <span class="string">&quot;[0][1]&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="built_in">Array</span>));</span><br><span class="line"><span class="comment">//has() 检查属性是否为对象的直接属性，与Object.hasOwnProperty()方法返回true一样</span></span><br><span class="line"><span class="comment">//hasIn()   检查属性是对象的直接属性还是继承属性，也与Object.hasOwnProperty()一样，true表示直接属性，false表示继承属性</span></span><br><span class="line"><span class="comment">//invert()  把对象的key与value颠倒，后面的属性会覆盖前面的属性</span></span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">	<span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">	<span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">	<span class="attr">c</span>: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(_.invert(object)); <span class="comment">//&#123;1: &quot;c&quot;, 2: &quot;b&quot;&#125;</span></span><br><span class="line"><span class="comment">//invertBy()    与上面一样，它遇到相同的值后不会覆盖，而是会把所有放在一个数组里。另外它多了一个遍历器方法</span></span><br><span class="line"><span class="comment">//invoke()  调用方法去处理取到的属性值</span></span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">	<span class="attr">a</span>: [</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">b</span>: &#123;</span><br><span class="line">				<span class="attr">c</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">	],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(_.invoke(object, <span class="string">&quot;a[0].b.c.slice&quot;</span>, <span class="number">1</span>, <span class="number">3</span>)); <span class="comment">//[2, 3]    用slice方法去截取a[0].b.c的1-3位</span></span><br><span class="line"><span class="comment">//keys()    把对象的key放到一个数组里，与Object.keys()的方法一样</span></span><br><span class="line"><span class="comment">//keysIn()  与上面一样，只不过它包含继承到的属性</span></span><br><span class="line"><span class="comment">//values()  把对象的value放到一个数组里，与Object.value()的方法一样</span></span><br><span class="line"><span class="comment">//valuesIn()    与上面一样，只不过它包含继承到的属性</span></span><br><span class="line"><span class="comment">//mapKeys() 修改对象的key，value不会变</span></span><br><span class="line"><span class="keyword">var</span> result = _.mapKeys(</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">		<span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="function"><span class="keyword">function</span> (<span class="params">value, key</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> key + value;</span><br><span class="line">	&#125;</span><br><span class="line">);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">//&#123;a1: 1, b2: 2&#125;</span></span><br><span class="line"><span class="comment">//mapValues()   与上个方法一样，只不过它修改的是value，key不会变</span></span><br><span class="line"><span class="comment">//merge()   它与assign一样，不过它遇到相同的属性名后并不会覆盖，它会合并</span></span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">	<span class="attr">a</span>: [</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">d</span>: <span class="number">4</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> other = &#123;</span><br><span class="line">	<span class="attr">a</span>: [</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">c</span>: <span class="number">3</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">e</span>: <span class="number">5</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(_.merge(object, other));</span><br><span class="line"><span class="comment">//mergeWith()   与上面的方法一致，不过多了接收一个比较器的函数做为参数</span></span><br><span class="line"><span class="comment">//omit()    删除对象里的属性</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">	_.omit(</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">			<span class="attr">b</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">			<span class="attr">c</span>: <span class="number">3</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">		[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;c&quot;</span>]</span><br><span class="line">	)</span><br><span class="line">); <span class="comment">//&#123;b: &quot;2&quot;&#125;</span></span><br><span class="line"><span class="comment">//_.omitBy  与上面一样，不过是接收一个迭代器的函数做为参数</span></span><br><span class="line"><span class="comment">//pick()    筛选对象里的属性</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">	_.pick(</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">			<span class="attr">b</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">			<span class="attr">c</span>: <span class="number">3</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">		[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;c&quot;</span>]</span><br><span class="line">	)</span><br><span class="line">); <span class="comment">//&#123;a: 1, c: 3&#125;</span></span><br><span class="line"><span class="comment">//pickBy()  与上面一样，不过是可接收一个迭代器的函数做为参数</span></span><br><span class="line"><span class="comment">//result()  获取对象属性，它与get一样。只不过它遇到函数的属性时会调用函数，并且把this指向对象本身</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	<span class="attr">a</span>: <span class="number">12</span>,</span><br><span class="line">	<span class="attr">b</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(_.result(obj, <span class="string">&quot;a&quot;</span>)); <span class="comment">//12</span></span><br><span class="line">_.result(obj, <span class="string">&quot;b&quot;</span>); <span class="comment">//12</span></span><br><span class="line"><span class="built_in">console</span>.log(_.get(obj, <span class="string">&quot;b&quot;</span>)); <span class="comment">//它只能取到这个函数，并不能执行</span></span><br><span class="line"><span class="comment">//toPairs() 把对象的key与value一起放到数组里</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.a = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">this</span>.b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.c = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(_.toPairs(<span class="keyword">new</span> Foo()));</span><br><span class="line"><span class="built_in">console</span>.log(_.toPairsIn(<span class="keyword">new</span> Foo()));</span><br><span class="line"><span class="comment">//unset()   删除属性</span></span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">	<span class="attr">a</span>: [</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">b</span>: &#123;</span><br><span class="line">				<span class="attr">c</span>: <span class="number">7</span>,</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">	],</span><br><span class="line">&#125;;</span><br><span class="line">_.unset(object, <span class="string">&quot;a[0].b.c&quot;</span>), <span class="built_in">console</span>.log(object);</span><br><span class="line"><span class="comment">//update()  这个与set一样，不过它可以接收一个函数的参数</span></span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">	<span class="attr">a</span>: <span class="number">10</span>,</span><br><span class="line">&#125;;</span><br><span class="line">_.update(object, <span class="string">&quot;a&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> n * n;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(object); <span class="comment">///&#123;a: 100&#125;</span></span><br><span class="line"><span class="comment">//updateWith()  与上面的一样，不过可以接收一个路径的参数，决定生成的属性放在哪里</span></span><br><span class="line"><span class="keyword">var</span> object = &#123;&#125;;</span><br><span class="line">_.updateWith(</span><br><span class="line">	object,</span><br><span class="line">	<span class="string">&quot;[a][b]&quot;</span>,</span><br><span class="line">	<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="built_in">Object</span></span><br><span class="line">);</span><br><span class="line"><span class="built_in">console</span>.log(object);</span><br></pre></td></tr></table></figure>

<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//camelCase()   转换字符串为驼峰格式</span></span><br><span class="line"><span class="built_in">console</span>.log(_.camelCase(<span class="string">&quot;kaivon_chen&quot;</span>), _.camelCase(<span class="string">&quot;kaivon chen&quot;</span>));</span><br><span class="line"><span class="comment">//capitalize()  首字母为大写</span></span><br><span class="line"><span class="built_in">console</span>.log(_.capitalize(<span class="string">&quot;kaivon&quot;</span>)); <span class="comment">//Kaivon</span></span><br><span class="line"><span class="comment">//endsWith()    查检结尾的字符</span></span><br><span class="line"><span class="built_in">console</span>.log(_.endsWith(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;c&quot;</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="comment">//escape()  把特殊字符转义成真正的HTML实体字符</span></span><br><span class="line"><span class="built_in">console</span>.log(_.escape(<span class="string">&quot;ka&lt;iv&gt;on&quot;</span>)); <span class="comment">//ka&lt;iv&gt;on</span></span><br><span class="line"><span class="comment">//unescape()    与上面相反</span></span><br><span class="line"><span class="built_in">console</span>.log(_.unescape(<span class="string">&quot;ka&lt;iv&gt;on&quot;</span>)); <span class="comment">//ka&lt;iv&gt;on</span></span><br><span class="line"><span class="comment">//kebabCase()   转换字符为加-的形式</span></span><br><span class="line"><span class="built_in">console</span>.log(_.kebabCase(<span class="string">&quot;k a i&quot;</span>)); <span class="comment">//k-a-i</span></span><br><span class="line"><span class="comment">//lowerCase()/toLower() 转小写</span></span><br><span class="line"><span class="comment">//upperCase()/toUpper() 转大写</span></span><br><span class="line"><span class="comment">//lowerFirst()  首字符转小写</span></span><br><span class="line"><span class="comment">//upperFirst()  首字符转大写</span></span><br><span class="line"><span class="comment">//pad() 填充字符串到指定的长度(左右填充)</span></span><br><span class="line"><span class="built_in">console</span>.log(_.pad(<span class="string">&quot;abc&quot;</span>, <span class="number">8</span>, <span class="string">&quot;-&quot;</span>)); <span class="comment">//--abc---</span></span><br><span class="line"><span class="comment">//padEnd()</span></span><br><span class="line"><span class="built_in">console</span>.log(_.padEnd(<span class="string">&quot;abc&quot;</span>, <span class="number">8</span>, <span class="string">&quot;-&quot;</span>));</span><br><span class="line"><span class="comment">//padStart()</span></span><br><span class="line"><span class="built_in">console</span>.log(_.padStart(<span class="string">&quot;abc&quot;</span>, <span class="number">8</span>, <span class="string">&quot;-&quot;</span>));</span><br><span class="line"><span class="comment">//parseInt()    把字符串类型的数字转成数字，</span></span><br><span class="line"><span class="comment">//repeat()  重复字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(_.repeat(<span class="string">&quot;kaivon&quot;</span>, <span class="number">2</span>)); <span class="comment">//kaivonkaivon</span></span><br><span class="line"><span class="comment">//replace() 替换字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(_.replace(<span class="string">&quot;kaivon&quot;</span>, <span class="string">&quot;von&quot;</span>, <span class="string">&quot;***&quot;</span>)); <span class="comment">//kai***</span></span><br><span class="line"><span class="comment">//snakeCase()   转换字符串为_的形式</span></span><br><span class="line"><span class="built_in">console</span>.log(_.snakeCase(<span class="string">&quot;k a i&quot;</span>)); <span class="comment">//k_a_i</span></span><br><span class="line"><span class="comment">//split()   分隔字符串为数组，与原生String.split()一样</span></span><br><span class="line"><span class="comment">//startCase()   转换字符串为+空格的形式，并且首字符大写</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">	_.startCase(<span class="string">&quot;kaivon-chen&quot;</span>), <span class="comment">//Kaivon Chen</span></span><br><span class="line">	_.startCase(<span class="string">&quot;kaivonChen&quot;</span>), <span class="comment">//Kaivon Chen</span></span><br><span class="line">	_.startCase(<span class="string">&quot;kaivon_chen&quot;</span>) <span class="comment">//Kaivon Chen</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//startsWith()  检查字符串的开始字符</span></span><br><span class="line"><span class="built_in">console</span>.log(_.startsWith(<span class="string">&quot;kaivon&quot;</span>, <span class="string">&quot;k&quot;</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="comment">//template()    编译模板</span></span><br><span class="line"><span class="keyword">var</span> compiled = _.template(<span class="string">&quot;hello &lt;%= user %&gt;!&quot;</span>); <span class="comment">//user为一个占位符</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">	compiled(&#123;</span><br><span class="line">		<span class="attr">user</span>: <span class="string">&quot;kaivon&quot;</span>,</span><br><span class="line">	&#125;)</span><br><span class="line">); <span class="comment">//拿到数据后，给user赋值，它就能正确解析出内容了</span></span><br><span class="line"><span class="comment">//trim()    去除首尾空格，或者指定字符</span></span><br><span class="line"><span class="built_in">console</span>.log(_.trim(<span class="string">&quot;kaivon-&quot;</span>, <span class="string">&quot;-&quot;</span>)); <span class="comment">//kaivon</span></span><br><span class="line"><span class="comment">//trimEnd() 去除后面的空格，或者指定字符</span></span><br><span class="line"><span class="comment">//trimStart()   与上面的一样，只不过去除的是左边的</span></span><br><span class="line"><span class="comment">//truncate()</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">	_.truncate(<span class="string">&quot;Hi kaivon! How are you feeling today? I am felling great!&quot;</span>)</span><br><span class="line">); <span class="comment">//Hi kaivon! How are you feel...</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">	_.truncate(<span class="string">&quot;Hi kaivon! How are you feeling today? I am felling great!&quot;</span>, &#123;</span><br><span class="line">		<span class="comment">//&#x27;length&#x27;: 10, //限制固定的字符个数</span></span><br><span class="line">		<span class="attr">separator</span>: <span class="regexp">/!/</span>, <span class="comment">//加个正则，遇到第一个空格后就加三个点</span></span><br><span class="line">	&#125;)</span><br><span class="line">);</span><br><span class="line"><span class="comment">//words()   把字符串的单词拆分成数组</span></span><br><span class="line"><span class="built_in">console</span>.log(_.words(<span class="string">&quot;kaivon chen&quot;</span>)); <span class="comment">//[&quot;kaivon&quot;, &quot;chen&quot;]</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>js工具库</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>lodash</tag>
      </tags>
  </entry>
  <entry>
    <title>mock的基本语法</title>
    <url>/135xyq.github.io/2021/04/07/js%E5%B7%A5%E5%85%B7%E5%BA%93-mock%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="mock"><a href="#mock" class="headerlink" title="mock"></a><a href="https://github.com/nuysoft/Mock/wiki">mock</a></h1><hr>
<h2 id="mock-语法规范"><a href="#mock-语法规范" class="headerlink" title="mock 语法规范"></a>mock 语法规范</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        </span><br><span class="line"><span class="comment">//1. 属性值是字符串 String</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">Mock.mock(&#123;</span><br><span class="line">                </span><br><span class="line"><span class="string">&#x27;data1|1-4&#x27;</span>: <span class="string">&#x27;谢永强&#x27;</span>,     <span class="comment">//随机重复1-4次</span></span><br><span class="line">                </span><br><span class="line"><span class="string">&#x27;data2|3&#x27;</span>: <span class="string">&#x27;好帅&#x27;</span>,    <span class="comment">//固定重置3次</span></span><br><span class="line">            </span><br><span class="line">&#125;)</span><br><span class="line">        </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//2. 属性值是数字 Number</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">Mock.mock(&#123;</span><br><span class="line">                </span><br><span class="line"><span class="string">&#x27;number1|+1&#x27;</span>: <span class="number">100</span>,  <span class="comment">//整数，自动加1并且初始值为100</span></span><br><span class="line">                </span><br><span class="line"><span class="string">&#x27;number2|1-100&#x27;</span>: <span class="number">12</span>,    <span class="comment">//整数，1-100之间的随机数，包括1和100（1=&lt;数字&lt;=100）  12用来确定是数据为数字类型</span></span><br><span class="line">                </span><br><span class="line"><span class="string">&#x27;number3|1-100.5&#x27;</span>: <span class="number">12</span>,  <span class="comment">//小数，整数部分为为1-100间随机数，包括1和100；小数部分为固定5位随机数</span></span><br><span class="line">                </span><br><span class="line"><span class="string">&#x27;number4|1-100.1-10&#x27;</span>: <span class="number">12</span>,   <span class="comment">//小数，整数部分为为1-100间随机数，包括1和100；小数部分为1-10个随机数（位数随机，数字也随机）</span></span><br><span class="line">                </span><br><span class="line"><span class="string">&#x27;number5|123.1-10&#x27;</span>: <span class="number">12</span>, <span class="comment">//数字123后面随机添加1-10位小数</span></span><br><span class="line">                </span><br><span class="line"><span class="string">&#x27;number6|123.10&#x27;</span>: <span class="number">12</span>,   <span class="comment">//数字123后面固定添加10位小数，但小数的值是随机的</span></span><br><span class="line">            </span><br><span class="line">&#125;)</span><br><span class="line">        </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//3. 属性值是布尔型 Boolean</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">Mock.mock(&#123;</span><br><span class="line">                </span><br><span class="line"><span class="string">&#x27;b1|1&#x27;</span>: <span class="literal">false</span>,  <span class="comment">//随机生成一个布尔值，true与false的概率各为一半</span></span><br><span class="line">                </span><br><span class="line"><span class="string">&#x27;b2|1-5&#x27;</span>: <span class="literal">true</span>, <span class="comment">//随机生成一个布尔值，值为value的概率是min / (min + max)，值为!value的概率是max / (min + max)</span></span><br><span class="line">            </span><br><span class="line">&#125;)</span><br><span class="line">        </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//4. 属性值是对象 Object</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">Mock.mock(&#123;</span><br><span class="line">                </span><br><span class="line"><span class="string">&#x27;num1|1-3&#x27;</span>: &#123; <span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span>, <span class="attr">c</span>: <span class="number">30</span>, <span class="attr">d</span>: <span class="number">40</span> &#125;, <span class="comment">//随机选取对象里1-3个属性</span></span><br><span class="line">                </span><br><span class="line"><span class="string">&#x27;num2|2&#x27;</span>: &#123; <span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span>, <span class="attr">c</span>: <span class="number">30</span>, <span class="attr">d</span>: <span class="number">40</span> &#125;,   <span class="comment">//随机选取对象里2个属性</span></span><br><span class="line">            </span><br><span class="line">&#125;)</span><br><span class="line">        </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//属性值是数组 Array</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">Mock.mock(&#123;</span><br><span class="line">                </span><br><span class="line"><span class="string">&#x27;arr1|1&#x27;</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>],    <span class="comment">//随机选取数组里1个数据</span></span><br><span class="line">                </span><br><span class="line"><span class="string">&#x27;arr2|1-3&#x27;</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>],  <span class="comment">//通过重复属性值生成一个新数组，min&lt;=重复次数&lt;=max</span></span><br><span class="line">            </span><br><span class="line">&#125;)</span><br><span class="line">        </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//6. 属性值是函数 Function</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">Mock.mock(&#123;</span><br><span class="line">                </span><br><span class="line"><span class="string">&#x27;result&#x27;</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span> &#125;  <span class="comment">//把函数的返回值当作属性的结果</span></span><br><span class="line">            </span><br><span class="line">&#125;)</span><br><span class="line">        </span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//7. 属性值是正则表达式 RegExp</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">Mock.mock(&#123;</span><br><span class="line">                </span><br><span class="line"><span class="string">&#x27;reg1&#x27;</span>: <span class="regexp">/[a-z][A-Z][0-9]/</span>,</span><br><span class="line">                </span><br><span class="line"><span class="string">&#x27;reg2&#x27;</span>: <span class="regexp">/\w\W\s\S\d\D/</span>,</span><br><span class="line">                </span><br><span class="line"><span class="string">&#x27;reg3&#x27;</span>: <span class="regexp">/\d&#123;5,10&#125;/</span></span><br><span class="line">            </span><br><span class="line">&#125;)</span><br><span class="line">        </span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Mock.Random</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">var</span> Random = Mock.Random;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// console.log(Random);</span></span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//1、Basics  基础类里的方法，共7个</span></span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.boolean()      随机一个布尔值</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">Random.boolean(),</span><br><span class="line">            </span><br><span class="line">Random.boolean(<span class="number">1</span>, <span class="number">9</span>, <span class="literal">true</span>),</span><br><span class="line">            </span><br><span class="line">Random.boolean(<span class="number">1</span>, <span class="number">2</span>, <span class="literal">false</span>),</span><br><span class="line">        </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.natural()      随机一个自然数（大于等于 0 的整数）</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">Random.natural(),</span><br><span class="line">            </span><br><span class="line">Random.natural(<span class="number">100</span>),</span><br><span class="line">            </span><br><span class="line">Random.natural(<span class="number">0</span>, <span class="number">50</span>),</span><br><span class="line">        </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.integer()  随机一个整数（包含负数）</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">Random.integer(),</span><br><span class="line">            </span><br><span class="line">Random.integer(-<span class="number">100</span>),</span><br><span class="line">            </span><br><span class="line">Random.integer(-<span class="number">50</span>, <span class="number">50</span>),</span><br><span class="line">        </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.float()    随机一个小数</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">Random.float(),</span><br><span class="line">            </span><br><span class="line">Random.float(<span class="number">0</span>),</span><br><span class="line">            </span><br><span class="line">Random.float(-<span class="number">10</span>, <span class="number">10</span>),</span><br><span class="line">            </span><br><span class="line">Random.float(-<span class="number">10</span>, <span class="number">10</span>, <span class="number">3</span>),</span><br><span class="line">            </span><br><span class="line">Random.float(-<span class="number">10</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">5</span>),</span><br><span class="line">        </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.character()    //随机一个字符</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">Random.character(),</span><br><span class="line">            </span><br><span class="line">Random.character(<span class="string">&#x27;abc123&#x27;</span>),</span><br><span class="line">            </span><br><span class="line">Random.character(<span class="string">&#x27;lower&#x27;</span>),</span><br><span class="line">            </span><br><span class="line">Random.character(<span class="string">&#x27;symbol&#x27;</span>),</span><br><span class="line">        </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.string()   随机一个字符串</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">Random.string(),</span><br><span class="line">            </span><br><span class="line">Random.string(<span class="number">5</span>),</span><br><span class="line">            </span><br><span class="line">Random.string(<span class="number">7</span>, <span class="number">10</span>),</span><br><span class="line">            </span><br><span class="line">Random.string(<span class="string">&#x27;symbol&#x27;</span>, <span class="number">5</span>),</span><br><span class="line">            </span><br><span class="line">Random.string(<span class="string">&#x27;abc123&#x27;</span>, <span class="number">1</span>, <span class="number">3</span>),</span><br><span class="line">        </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.range()    随机一个整数数据的数组</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">Random.range(<span class="number">7</span>),</span><br><span class="line">            </span><br><span class="line">Random.range(<span class="number">3</span>, <span class="number">7</span>),</span><br><span class="line">            </span><br><span class="line">Random.range(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">        </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        </span><br><span class="line"><span class="keyword">var</span> Random = Mock.Random;</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//2、Date    日期类里的方法，共4个</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.date()     随机一个日期</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">Random.date(),</span><br><span class="line">            </span><br><span class="line">Random.date(<span class="string">&#x27;yyyy-MM--dd : HH-m-ss&#x27;</span>),</span><br><span class="line">        </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.time()     随机一个时间</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">Random.time(),</span><br><span class="line">            </span><br><span class="line">Random.time(<span class="string">&#x27;A HH:mm:ss:SS&#x27;</span>),</span><br><span class="line">        </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.datetime() 随机一个日期+时间</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">Random.datetime(),</span><br><span class="line">        </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.now()  返回当前的日期和时间字符串</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//week 定到这个周的第一天</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">Random.now(),</span><br><span class="line">            </span><br><span class="line">Random.now(<span class="string">&#x27;minute&#x27;</span>),</span><br><span class="line">        </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//3、Image   图片类里的方法，花2个</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.image()    生成一个随机的图片地址</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">Random.image(),</span><br><span class="line">            </span><br><span class="line">Random.image(<span class="string">&#x27;200x100&#x27;</span>),</span><br><span class="line">            </span><br><span class="line">Random.image(<span class="string">&#x27;200x100&#x27;</span>, <span class="string">&#x27;#ffcc33&#x27;</span>, <span class="string">&#x27;#FFF&#x27;</span>, <span class="string">&#x27;png&#x27;</span>, <span class="string">&#x27;kaivon&#x27;</span>),</span><br><span class="line">        </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.dataImage()    //生成一段随机的 Base64 图片编码</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line"><span class="comment">//Random.dataImage(),</span></span><br><span class="line">            </span><br><span class="line">Random.dataImage(<span class="string">&#x27;200x100&#x27;</span>),</span><br><span class="line">        </span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Color 颜色类里的方法，共5个</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.color()    随机一个16进制的颜色</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">Random.color(),</span><br><span class="line">        </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.hex()</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">Random.hex(),</span><br><span class="line">        </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.rgb()</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">Random.rgb(),   <span class="comment">//随机生成一个rgb格式的颜色</span></span><br><span class="line">        </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.rgba()</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">Random.rgba(),  <span class="comment">//随机生成一个rgba格式的颜色</span></span><br><span class="line">        </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.hsl()</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">Random.hsl(),   <span class="comment">//随机生成一个hsl格式(色相、饱和度、亮度)的颜色</span></span><br><span class="line">        </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//5、Text    文本类里的方法，共8个</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.paragraph()    随机生成一段文本</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.paragraph());</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.paragraph(<span class="number">2</span>));</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.paragraph(<span class="number">1</span>, <span class="number">3</span>));</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.cparagraph()   随机生成一段中文文本。</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.cparagraph());</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.cparagraph(<span class="number">2</span>));</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.cparagraph(<span class="number">1</span>, <span class="number">3</span>));</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.sentence() 随机生成一个句子，句子首字母大写</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.sentence());</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.sentence(<span class="number">5</span>));</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.sentence(<span class="number">1</span>, <span class="number">5</span>));</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.csentence()    随机生成一段中文文本</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.csentence());</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.csentence(<span class="number">5</span>));</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.csentence(<span class="number">1</span>, <span class="number">5</span>));</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.word()     随机生成一个单词</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.word());</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.word(<span class="number">5</span>));</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.word(<span class="number">1</span>, <span class="number">5</span>));</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.cword()    随机生成一个汉字</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.cword());</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.cword(<span class="number">5</span>));</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.cword(<span class="number">1</span>, <span class="number">5</span>));</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.cword(<span class="string">&#x27;零一二三四五六七八九十&#x27;</span>, <span class="number">3</span>));</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.cword(<span class="string">&#x27;零一二三四五六七八九十&#x27;</span>, <span class="number">5</span>, <span class="number">7</span>));</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.title()    随机生成一个标题</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.title());</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.title(<span class="number">3</span>));</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.title(<span class="number">1</span>, <span class="number">5</span>));</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.ctitle()   随机生成一句中文标题</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.ctitle());</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.ctitle(<span class="number">3</span>));</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.ctitle(<span class="number">1</span>, <span class="number">5</span>));</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//6、Name    名字类里的方法，共6个</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.first()    随机生成一个常见的英文名</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.first())</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.last()     随机生成一个常见的英文姓</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.last());</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.name()     随机生成一个常见的英文姓名</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.name(<span class="literal">true</span>)); <span class="comment">//是否添加一个中间值</span></span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.cfirst()   //随机生成一个常见的中文名</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.cfirst());</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.clast()    //随机生成一个常见的中文姓</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.clast());</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.cname()    随机生成一个常见的中文姓名</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.cname());</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//7、Web Web类里的方法，共6个</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.url()  //随机生成一个 URL</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.url());</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.url(<span class="string">&#x27;http&#x27;</span>));    <span class="comment">//指定协议</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.url(<span class="string">&#x27;http&#x27;</span>, <span class="string">&#x27;kaivon.cn&#x27;</span>));   <span class="comment">//指定域名</span></span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.protocol()     随机生成一个 URL 协议</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.protocol());</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.domain()   随机生成一个域名</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.domain());</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.tld()  随机生成一个顶级域名</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.tld());</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.email()    随机生成一个邮件地址</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.email());</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.email(<span class="string">&#x27;kaivon.cn&#x27;</span>)); <span class="comment">//指定@后的域名</span></span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.ip()   随机生成一个 IP 地址</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.ip());</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//8、Address 地址类里的方法，共5个</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.region()   随机生成一个（中国）大区</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.region());</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.province() 随机生成一个（中国）省（或直辖市、自治区、特别行政区）</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.province());</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.city()     随机生成一个（中国）市</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.city());</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.city(<span class="literal">true</span>)); <span class="comment">//是否生成所属的省</span></span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.county()       随机生成一个（中国）县</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.county());</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.county(<span class="literal">true</span>));   <span class="comment">//指示是否生成所属的省、市</span></span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.zip()      随机生成一个邮政编码</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.zip());</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//9、Helper  帮助类里的方法，共5个</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.capitalize()   //把字符串的第一个字母转换为大写</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.capitalize(<span class="string">&#x27;kaivon&#x27;</span>));</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.upper()    //把字符串转换为大写</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.upper(<span class="string">&#x27;kaivon&#x27;</span>));</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.lower()    //把字符串转换为小写</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.lower(<span class="string">&#x27;KAI&#x27;</span>));</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.pick()     //从数组中随机选取一个元素</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.pick([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]));</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.shuffle()  //打乱数组中元素的顺序</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.shuffle([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]));</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//10、Miscellaneous  其它类里的方法，共3个</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.guid()     随机生成一个 GUID</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.guid());</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Random.id()       随机生成一个 18 位身份证</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.id());</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">            </span><br><span class="line">Mock.mock(<span class="string">&#x27;@EMAIL&#x27;</span>),</span><br><span class="line">            </span><br><span class="line">Mock.mock(<span class="string">&#x27;@CITY(true)&#x27;</span>),</span><br><span class="line">            </span><br><span class="line">Mock.mock(<span class="string">&#x27;@cword(&quot;谢永强好帅&quot;, 1, 3)&#x27;</span>),</span><br><span class="line">        </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line"><span class="comment">//扩展方法</span></span><br><span class="line">        </span><br><span class="line">Random.extend(&#123;</span><br><span class="line">            </span><br><span class="line"><span class="attr">constellation</span>: <span class="function"><span class="keyword">function</span> (<span class="params">date</span>) </span>&#123;</span><br><span class="line">                </span><br><span class="line"><span class="keyword">var</span> constellations = [<span class="string">&#x27;白羊座&#x27;</span>, <span class="string">&#x27;金牛座&#x27;</span>, <span class="string">&#x27;双子座&#x27;</span>, <span class="string">&#x27;巨蟹座&#x27;</span>, <span class="string">&#x27;狮子座&#x27;</span>, <span class="string">&#x27;处女座&#x27;</span>, <span class="string">&#x27;天秤座&#x27;</span>, <span class="string">&#x27;天蝎座&#x27;</span>, <span class="string">&#x27;射手座&#x27;</span>, <span class="string">&#x27;摩羯座&#x27;</span>, <span class="string">&#x27;水瓶座&#x27;</span>, <span class="string">&#x27;双鱼座&#x27;</span>];</span><br><span class="line">                </span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.pick(constellations)</span><br><span class="line">            </span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">&#125;);</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Random.constellation());</span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(Mock.mock(<span class="string">&#x27;@constellation&#x27;</span>))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>js工具库</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>mock</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器本地存储</title>
    <url>/135xyq.github.io/2021/04/05/js%E5%B7%A5%E5%85%B7%E5%BA%93-%E6%9C%AC%E5%9C%B0%E5%8C%96%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<h1 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h1><hr>
<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><h4 id="cookie：可读可写-依托与http协议"><a href="#cookie：可读可写-依托与http协议" class="headerlink" title="cookie：可读可写,依托与http协议"></a>cookie：可读可写,依托与http协议</h4><ol>
<li>cookie不可跨域</li>
<li>cookie存储在浏览器里面</li>
<li>cookie有大小和数量的限制（超过部分删除）<ol>
<li>数量在50个左右</li>
<li>大小在4KB左右</li>
<li>cookie的存储时间非常灵活</li>
<li>cookie不光可以服务器设置，客户端也可以设置</li>
</ol>
</li>
</ol>
<h4 id="前端设置cookie："><a href="#前端设置cookie：" class="headerlink" title="前端设置cookie："></a>前端设置cookie：</h4><p>document.cookie (键值对形式)只能设置一次cookie</p>
<h3 id="cookie的属性："><a href="#cookie的属性：" class="headerlink" title="cookie的属性："></a>cookie的属性：</h3><ol>
<li>name：cookie的名字（唯一性）</li>
<li>value: cookie的值（字符串）</li>
<li>domain ： 设置cookie在哪个域下是有效的</li>
<li>path ： cookie的路径</li>
<li>expires : cookie的过期时间（默认是session在浏览器关闭时删除）具体时间点<br><code>document.cookie = &#39;margin = 20px;expires = &#39; + new Date(2021, 7, 3);</code></li>
<li>max-age : cookie的有效期（以秒为单位的时间段），存活时间<br><code>document.cookie = &#39;margin = 20px;max-age = 10&#39;;  //存活时间为10秒</code></li>
<li>HttpOnly ：有这个标记的cookie前端啊无法获取</li>
<li>Secure : 设置cookie只能通过HTTPS协议传输</li>
<li>SameSite ：设置cookie在跨域请求时不能被发送</li>
</ol>
<h2 id="Web-Storage：不依托于http协议"><a href="#Web-Storage：不依托于http协议" class="headerlink" title="Web Storage：不依托于http协议"></a>Web Storage：不依托于http协议</h2><p>不能跨域 </p>
<h4 id="localStorage：在所有域名下都有效，页面关闭还存在"><a href="#localStorage：在所有域名下都有效，页面关闭还存在" class="headerlink" title="localStorage：在所有域名下都有效，页面关闭还存在"></a>localStorage：在所有域名下都有效，页面关闭还存在</h4><h4 id="sessionStorage：仅在当前窗口有效，页面关闭不存在"><a href="#sessionStorage：仅在当前窗口有效，页面关闭不存在" class="headerlink" title="sessionStorage：仅在当前窗口有效，页面关闭不存在"></a>sessionStorage：仅在当前窗口有效，页面关闭不存在</h4><p>localStorage和sessionStorage都继承自对象Storage</p>
<h3 id="属性和方法："><a href="#属性和方法：" class="headerlink" title="属性和方法："></a>属性和方法：</h3><ol>
<li>length：本地存储的数量</li>
<li>key()：通过索引找到存储的数据，（排序不规范，和添加顺序不一样）</li>
<li>getItem（）：通过键名取到本地存储的数据（取到的是一个字符串）<br><code>console.log(localStorage.getItem(&#39;color&#39;));</code></li>
<li>setItem（）：设置一个本地存储数据</li>
</ol>
<p><code>localStorage.setItem(&#39;name&#39;, &#39;xyq&#39;);</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">var</span> color = &#123;</span><br><span class="line">            <span class="string">&quot;c1&quot;</span>: <span class="string">&quot;red&quot;</span>,</span><br><span class="line">            <span class="string">&quot;c2&quot;</span>: <span class="string">&quot;green&quot;</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">localStorage</span>.setItem(<span class="string">&#x27;color&#x27;</span>, <span class="built_in">JSON</span>.stringify(color));</span><br><span class="line"><span class="comment">//   添加对象</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li><code>removeItem（）：//删除一个本地存储数据</code></li>
<li><code>clearItem（）：//清空本地存储</code></li>
<li> <code>localStorage.clear();//全部清空</code></li>
</ol>
<h4 id="storage事件："><a href="#storage事件：" class="headerlink" title="storage事件："></a>storage事件：</h4><p>调用所有同域下其他窗口的storage事件，不过它本身触发storage即当前窗口是不会触发这个事件的`</p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>本地存储</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>本地化存储</tag>
      </tags>
  </entry>
  <entry>
    <title>moment工具库的简单使用</title>
    <url>/135xyq.github.io/2021/04/08/js%E5%B7%A5%E5%85%B7%E5%BA%93-moment%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="moment-官网"><a href="#moment-官网" class="headerlink" title="moment 官网"></a><a href="http://momentjs.cn/">moment</a> <a href="https://momentjs.com/">官网</a></h1><hr>
<h2 id="解析方法"><a href="#解析方法" class="headerlink" title="解析方法"></a>解析方法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解析</span></span><br><span class="line"><span class="comment">//moment()</span></span><br><span class="line"><span class="built_in">console</span>.log(moment()); <span class="comment">//moment(String)</span></span><br><span class="line"><span class="built_in">console</span>.log(moment(<span class="string">&quot;2013-02-08&quot;</span>)); <span class="comment">//返回2013年2月8号的日期对象</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">	moment(<span class="string">&quot;2013-039&quot;</span>), <span class="comment">//返回2013年的第39天，2013年2月8号</span></span><br><span class="line">	moment(<span class="string">&quot;2013050&quot;</span>), <span class="comment">//返回2013年的第50天，2013年2月19号</span></span><br><span class="line">	moment(<span class="string">&quot;2013W065&quot;</span>), <span class="comment">//返回2013年的第6个星期的第5天，2013年2月8号（W表示星期）</span></span><br><span class="line">	moment(<span class="string">&quot;2013-02-08T09&quot;</span>) <span class="comment">//返回2013年2月8号9点（T表示时间）</span></span><br><span class="line">);</span><br><span class="line"><span class="built_in">console</span>.log(moment(<span class="string">&quot;kaivon&quot;</span>)); <span class="comment">//警告，同时照样能返回那个对象，不过对象里的参数的值是不正确的 //moment(String) 带格式</span></span><br><span class="line"><span class="built_in">console</span>.log(moment(<span class="string">&quot;12-25-1995&quot;</span>, <span class="string">&quot;MM-DD-YYYY&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(moment(<span class="string">&quot;12/25/1995&quot;</span>, <span class="string">&quot;LL&quot;</span>)); <span class="comment">//moment(String) 多个格式</span></span><br><span class="line"><span class="built_in">console</span>.log(moment(<span class="string">&quot;29-06-1995&quot;</span>, [<span class="string">&quot;MM-DD-YYYY&quot;</span>, <span class="string">&quot;DD-MM&quot;</span>, <span class="string">&quot;DD-MM-YYYY&quot;</span>])); <span class="comment">//moment(String) 特殊格式</span></span><br><span class="line"><span class="built_in">console</span>.log(moment(<span class="string">&quot;2010-01-01T05:06:07&quot;</span>, moment.ISO_8601)); <span class="comment">//moment(Object)</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">	moment(&#123;</span><br><span class="line">		<span class="attr">year</span>: <span class="number">2010</span>,</span><br><span class="line">		<span class="attr">month</span>: <span class="number">3</span>,</span><br><span class="line">		<span class="attr">day</span>: <span class="number">5</span>,</span><br><span class="line">		<span class="attr">hour</span>: <span class="number">15</span>,</span><br><span class="line">		<span class="attr">minute</span>: <span class="number">10</span>,</span><br><span class="line">		<span class="attr">second</span>: <span class="number">3</span>,</span><br><span class="line">		<span class="attr">millisecond</span>: <span class="number">123</span>,</span><br><span class="line">	&#125;)</span><br><span class="line">); <span class="comment">//注意：这里的月份也是从0开始，此时对应的是4月 //moment(Number)</span></span><br><span class="line"><span class="built_in">console</span>.log(moment(<span class="number">1318781876406</span>)); <span class="comment">//这个参数为毫秒数 //unix()</span></span><br><span class="line"><span class="built_in">console</span>.log(moment.unix(<span class="number">1318781876406</span> / <span class="number">1000</span>)); <span class="comment">//这个参数为秒数 //moment(Date)</span></span><br><span class="line"><span class="built_in">console</span>.log(moment(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2011</span>, <span class="number">9</span>, <span class="number">16</span>))); <span class="comment">//moment(Number[])  参数为一个数组 [year, month, day, hour, minute, second, millisecond]</span></span><br><span class="line"><span class="built_in">console</span>.log(moment([<span class="number">2010</span>, <span class="number">1</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">25</span>, <span class="number">50</span>, <span class="number">125</span>])); <span class="comment">//注意月份是从0开始的，这里对应的是2月 //moment(JSONDate)</span></span><br><span class="line"><span class="built_in">console</span>.log(moment(<span class="string">&quot;/Date(1198908717056-0700)/&quot;</span>)); <span class="comment">//前面一串数字为时间戳，-后面的是时区 //moment(Moment) 参数为一个moment对象，用于克隆</span></span><br><span class="line"><span class="keyword">var</span> a = moment([<span class="number">2012</span>]);</span><br><span class="line"><span class="keyword">var</span> b = moment(a);</span><br><span class="line"><span class="built_in">console</span>.log(a.valueOf() === b.valueOf()); <span class="comment">//clone()   也可以使用clone去克隆</span></span><br><span class="line"><span class="keyword">var</span> a = moment([<span class="number">2008</span>]);</span><br><span class="line"><span class="keyword">var</span> b = a.clone();</span><br><span class="line"><span class="built_in">console</span>.log(a, b); <span class="comment">/*</span></span><br><span class="line"><span class="comment">            GMT 世界时，格林尼治标准时间 </span></span><br><span class="line"><span class="comment">            UTC 协调世界时，世界统一时间、世界标准时间</span></span><br><span class="line"><span class="comment">         */</span> <span class="comment">//utc()</span></span><br><span class="line"><span class="built_in">console</span>.log(moment().format()); <span class="comment">//GMT //默认为本地当前时间，东八区的时间（+08:00）</span></span><br><span class="line"><span class="built_in">console</span>.log(moment.utc().format()); <span class="comment">//UTC       //UTC的时间（世界标准时间，位于0时区，时区用Z表示，它与北京时间相差8个小时） //isValid()</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">	moment([<span class="number">2015</span>, <span class="number">25</span>, <span class="number">35</span>]).isValid(), <span class="comment">//false</span></span><br><span class="line">	moment([<span class="number">2015</span>, <span class="number">10</span>, <span class="number">35</span>]).invalidAt() <span class="comment">//2</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="赋值取值方法"><a href="#赋值取值方法" class="headerlink" title="赋值取值方法"></a>赋值取值方法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(moment().seconds() === <span class="keyword">new</span> <span class="built_in">Date</span>().getSeconds()); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(moment.utc().seconds() === <span class="keyword">new</span> <span class="built_in">Date</span>().getUTCSeconds()); <span class="comment">//true //millisecond()/milliseconds()  获取或设置毫秒</span></span><br><span class="line"><span class="built_in">console</span>.log(moment().millisecond());</span><br><span class="line"><span class="built_in">console</span>.log(moment().milliseconds());</span><br><span class="line"><span class="built_in">console</span>.log(moment().millisecond(<span class="number">100</span>).valueOf());</span><br><span class="line"><span class="built_in">console</span>.log(moment().milliseconds(<span class="number">100</span>).valueOf()); <span class="comment">//second()/seconds()    获取/设置秒 //minute()/minutes()    获取/设置分 //hour()/hours()        获取/设置小时 //date()/dates()        获取/设置日期 //day()/days()          获取/设置星期</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">	moment().day(), <span class="comment">//1</span></span><br><span class="line">	moment().day(<span class="string">&quot;Sunday&quot;</span>) <span class="comment">//设置星期的时候可以传入一个星期的英文单词</span></span><br><span class="line">); <span class="comment">//weekday() 根据语言环境获获取/设置星期，根据语言环境获取或设置星期几</span></span><br><span class="line">moment.locale(<span class="string">&quot;zh-cn&quot;</span>); <span class="comment">//把当前的语言环境设置为中文</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">	moment().weekday(), <span class="comment">//0</span></span><br><span class="line">	moment().weekday(<span class="number">0</span>) <span class="comment">//0 //英文下是周日，中文下是周一</span></span><br><span class="line">); <span class="comment">//dayOfYear()   获取或设置年份的日期（今天是今年的第几天）</span></span><br><span class="line"><span class="built_in">console</span>.log(moment().dayOfYear()); <span class="comment">//111</span></span><br><span class="line"><span class="built_in">console</span>.log(moment().dayOfYear(<span class="number">1</span>)); <span class="comment">//week()/weeks()    获取或设置年份的星期（当前星期是今年的第几个星期）</span></span><br><span class="line"><span class="built_in">console</span>.log(moment().week()); <span class="comment">//17</span></span><br><span class="line"><span class="built_in">console</span>.log(moment([<span class="number">2021</span>, <span class="number">4</span>, <span class="number">20</span>]).week()); <span class="comment">//20 //month()/months()  获取或设置月份，设置时范围为0-11，还支持月份名称</span></span><br><span class="line"><span class="built_in">console</span>.log(moment().month()); <span class="comment">//3</span></span><br><span class="line"><span class="built_in">console</span>.log(moment().month(<span class="string">&quot;July&quot;</span>)); <span class="comment">//3 //quarter()/quarters()  获取或设置季度</span></span><br><span class="line"><span class="built_in">console</span>.log(moment().quarter()); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(moment().quarter(<span class="number">4</span>)); <span class="comment">//2 //year()/years()    获取或设置年份</span></span><br><span class="line"><span class="built_in">console</span>.log(moment().year());</span><br><span class="line"><span class="built_in">console</span>.log(moment().year(<span class="number">2088</span>)); <span class="comment">//weekYear()</span></span><br><span class="line"><span class="built_in">console</span>.log(moment([<span class="number">2020</span>, <span class="number">0</span>, <span class="number">1</span>]).weekYear());</span><br><span class="line"><span class="built_in">console</span>.log(moment([<span class="number">2020</span>, <span class="number">11</span>, <span class="number">31</span>]).weekYear()); <span class="comment">//weeksInYear() 根据语言环境获取当前 moment 年份的周数</span></span><br><span class="line"><span class="built_in">console</span>.log(moment().weeksInYear()); <span class="comment">//52 //get() 获取日期</span></span><br><span class="line"><span class="built_in">console</span>.log(moment().get(<span class="string">&quot;year&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(moment().get(<span class="string">&quot;M&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(moment().get(<span class="string">&quot;date&quot;</span>)); <span class="comment">//set() 设置日期</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">	moment().set(<span class="string">&quot;year&quot;</span>, <span class="number">2030</span>),</span><br><span class="line">	moment().set(<span class="string">&quot;month&quot;</span>, <span class="number">8</span>),</span><br><span class="line">	moment().set(&#123;</span><br><span class="line">		<span class="attr">year</span>: <span class="number">2008</span>,</span><br><span class="line">		<span class="attr">month</span>: <span class="number">7</span>,</span><br><span class="line">		<span class="attr">date</span>: <span class="number">8</span>,</span><br><span class="line">	&#125;)</span><br><span class="line">); <span class="comment">//max() 对比多个日期，返回最大的那个日期 //min() 对比多个日期，返回最小的那个日期</span></span><br><span class="line"><span class="keyword">var</span> a = moment(<span class="string">&quot;2019-10-15&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> b = moment(&#123;</span><br><span class="line">	<span class="attr">year</span>: <span class="number">2010</span>,</span><br><span class="line">	<span class="attr">month</span>: <span class="number">3</span>,</span><br><span class="line">	<span class="attr">date</span>: <span class="number">5</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> c = moment([<span class="number">2020</span>, <span class="number">10</span>, <span class="number">20</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(moment.max(a, b, c)); <span class="comment">//c</span></span><br><span class="line"><span class="built_in">console</span>.log(moment.min(a, b, c)); <span class="comment">//b</span></span><br></pre></td></tr></table></figure>

<h2 id="查询方法"><a href="#查询方法" class="headerlink" title="查询方法"></a>查询方法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//isBefore()    检查一个时间是否在另一个时间之前，默认是都转成毫秒数进行计算</span></span><br><span class="line"><span class="built_in">console</span>.log(moment(<span class="string">&quot;2010-10-20&quot;</span>).isBefore()); <span class="comment">//true  没给参数默认为现在的时间</span></span><br><span class="line"><span class="built_in">console</span>.log(moment(<span class="string">&quot;2010-10-20&quot;</span>).isBefore(<span class="string">&quot;2010-10-19&quot;</span>)); <span class="comment">//false 第一个日期是否在第二个日期之前</span></span><br><span class="line"><span class="built_in">console</span>.log(moment(<span class="string">&quot;2009-10-20&quot;</span>).isBefore(<span class="string">&quot;2010-10-19&quot;</span>, <span class="string">&quot;year&quot;</span>)); <span class="comment">//false 二个参数为对比的单位，可以给的有year month week isoWeek day hour minute second</span></span><br><span class="line"><span class="built_in">console</span>.log(moment(<span class="string">&quot;2010-10-20&quot;</span>).isBefore(<span class="string">&quot;2008-12-31&quot;</span>, <span class="string">&quot;month&quot;</span>)); <span class="comment">//false //isSame()  检查两个时间是否相同</span></span><br><span class="line"><span class="built_in">console</span>.log(moment(<span class="string">&quot;2010-10-20&quot;</span>).isSame(<span class="string">&quot;2010-10-20&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(moment(<span class="string">&quot;2010-10-20&quot;</span>).isSame(<span class="string">&quot;2010-12-20&quot;</span>, <span class="string">&quot;year&quot;</span>)); <span class="comment">//isAfter() 检查一个时间是否在另一个时间之后</span></span><br><span class="line"><span class="built_in">console</span>.log(moment(<span class="string">&quot;2010-10-20&quot;</span>).isAfter(<span class="string">&quot;2010-09-19&quot;</span>)); <span class="comment">//true //isSameOrBefore()  检查一个时间是否在另一个时间之前或者与之相同（&lt;=）</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">	moment(<span class="string">&quot;2010-10-20&quot;</span>).isSameOrBefore(<span class="string">&quot;2010-10-21&quot;</span>), <span class="comment">//true</span></span><br><span class="line">	moment(<span class="string">&quot;2010-10-20&quot;</span>).isSameOrBefore(<span class="string">&quot;2010-10-20&quot;</span>), <span class="comment">//true</span></span><br><span class="line">	moment(<span class="string">&quot;2010-11-20&quot;</span>).isSameOrBefore(<span class="string">&quot;2010-10-20&quot;</span>) <span class="comment">//false</span></span><br><span class="line">); <span class="comment">//isSameOrAfter() 检查一个时间是否在另一个时间之后或者与之相同（&gt;=）</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">	moment(<span class="string">&quot;2010-11-20&quot;</span>).isSameOrAfter(<span class="string">&quot;2010-10-21&quot;</span>), <span class="comment">//true</span></span><br><span class="line">	moment(<span class="string">&quot;2010-10-20&quot;</span>).isSameOrAfter(<span class="string">&quot;2010-10-20&quot;</span>), <span class="comment">//true</span></span><br><span class="line">	moment(<span class="string">&quot;2010-10-19&quot;</span>).isSameOrAfter(<span class="string">&quot;2010-10-20&quot;</span>) <span class="comment">//false</span></span><br><span class="line">); <span class="comment">//isBetween()   检查一个时间是否在其他两个时间之间</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">	moment(<span class="string">&quot;2010-10-20&quot;</span>).isBetween(<span class="string">&quot;2010-10-19&quot;</span>, <span class="string">&quot;2010-10-25&quot;</span>), <span class="comment">//true</span></span><br><span class="line">	moment(<span class="string">&quot;2010-10-20&quot;</span>).isBetween(<span class="string">&quot;2010-10-19&quot;</span>, <span class="literal">undefined</span>), <span class="comment">//true undefined等于moment(),就是当前的时间</span></span><br><span class="line">	moment(<span class="string">&quot;2010-10-20&quot;</span>).isBetween(<span class="string">&quot;2009-10-19&quot;</span>, <span class="string">&quot;2012-01-01&quot;</span>, <span class="string">&quot;year&quot;</span>), <span class="comment">//true //第四个参数为包容性，第三个参数为null，表示对比单位为默认毫秒数</span></span><br><span class="line">	moment(<span class="string">&quot;2016-10-30&quot;</span>).isBetween(<span class="string">&quot;2016-10-30&quot;</span>, <span class="string">&quot;2016-12-30&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;(]&quot;</span>) <span class="comment">//false</span></span><br><span class="line">); <span class="comment">//isLeapYear()  检测是否为闰年</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">	moment().isLeapYear(), <span class="comment">//true</span></span><br><span class="line">	moment([<span class="number">2019</span>]).isLeapYear() <span class="comment">//false</span></span><br><span class="line">); <span class="comment">//isMoment() 检测变量是否为moment对象</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">	moment.isMoment(), <span class="comment">//false</span></span><br><span class="line">	moment.isMoment(<span class="keyword">new</span> <span class="built_in">Date</span>()), <span class="comment">//false</span></span><br><span class="line">	moment.isMoment(moment()) <span class="comment">//true</span></span><br><span class="line">); <span class="comment">//isDate()  检测变量是否为原生的Date对象</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">	moment.isDate(), <span class="comment">//false</span></span><br><span class="line">	moment.isDate(<span class="keyword">new</span> <span class="built_in">Date</span>()), <span class="comment">//true</span></span><br><span class="line">	moment.isDate(moment()) <span class="comment">//false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="国际化、自定义方法"><a href="#国际化、自定义方法" class="headerlink" title="国际化、自定义方法"></a>国际化、自定义方法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置语言环境 (全局)</span></span><br><span class="line"><span class="comment">//moment.locale(&#x27;zh-cn&#x27;);</span></span><br><span class="line"><span class="built_in">console</span>.log(moment.locale()); <span class="comment">//en //返回当前的语言环境</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">	moment().weekday(<span class="number">0</span>), <span class="comment">//根据语言环境获取或设置（传参）星期几。英文环境为星期天，中文环境为星期一</span></span><br><span class="line">	moment().format(<span class="string">&quot;LLLL&quot;</span>), <span class="comment">//格式化时间，参数为本地化格式。英文环境与中文环境都不同</span></span><br><span class="line">	moment().month()</span><br><span class="line">); <span class="comment">//设置语言环境 (局部)</span></span><br><span class="line"><span class="keyword">var</span> myMoment = moment();</span><br><span class="line">myMoment.locale(<span class="string">&quot;ar-dz&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(moment().format(<span class="string">&quot;LLLL&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(myMoment.format(<span class="string">&quot;LLLL&quot;</span>)); <span class="comment">/* moment.locale(&#x27;ru&#x27;); //months()/weekdays()</span></span><br><span class="line"><span class="comment">        moment.locale(&#x27;zh-hk&#x27;); */</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">	moment.months(),</span><br><span class="line">	moment.monthsShort(),</span><br><span class="line">	moment.weekdays(),</span><br><span class="line">	moment.weekdaysShort(),</span><br><span class="line">	moment.weekdaysMin()</span><br><span class="line">); <span class="comment">//localeData()</span></span><br><span class="line"><span class="built_in">console</span>.log(moment.localeData(), moment.localeData().monthsShort()); <span class="comment">//自定义</span></span><br><span class="line">moment.updateLocale(<span class="string">&quot;zh-cn&quot;</span>, &#123;</span><br><span class="line">	<span class="comment">//设置月份名称</span></span><br><span class="line">	<span class="attr">months</span>: <span class="string">&quot;一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月&quot;</span>.split(</span><br><span class="line">		<span class="string">&quot;_&quot;</span></span><br><span class="line">	), <span class="comment">//设置月分名称的缩写</span></span><br><span class="line">	<span class="attr">monthsShort</span>: <span class="string">&quot;1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月&quot;</span>.split(</span><br><span class="line">		<span class="string">&quot;_&quot;</span></span><br><span class="line">	), <span class="comment">//设置星期名称</span></span><br><span class="line">	<span class="attr">weekdays</span>: <span class="string">&quot;星期日_星期一_星期二_星期三_星期四_星期五_星期六&quot;</span>.split(<span class="string">&quot;_&quot;</span>), <span class="comment">//设置星期名称的缩写</span></span><br><span class="line">	<span class="attr">weekdaysShort</span>: <span class="string">&quot;周日_周一_周二_周三_周四_周五_周六&quot;</span>.split(<span class="string">&quot;_&quot;</span>), <span class="comment">//设置星期名称的最小缩写</span></span><br><span class="line">	<span class="attr">weekdaysMin</span>: <span class="string">&quot;日_一_二_三_四_五_六&quot;</span>.split(<span class="string">&quot;_&quot;</span>), <span class="comment">//设置长日期格式，是个对象</span></span><br><span class="line">	<span class="attr">longDateFormat</span>: &#123;</span><br><span class="line">		<span class="attr">LT</span>: <span class="string">&quot;Ah点mm分&quot;</span>,</span><br><span class="line">		<span class="attr">LTS</span>: <span class="string">&quot;Ah点m分s秒&quot;</span>,</span><br><span class="line">		<span class="attr">L</span>: <span class="string">&quot;YYYY-MM-DD&quot;</span>,</span><br><span class="line">		<span class="attr">LL</span>: <span class="string">&quot;YYYY年MMMD日&quot;</span>,</span><br><span class="line">		<span class="attr">LLL</span>: <span class="string">&quot;YYYY年MMMD日Ah点mm分&quot;</span>,</span><br><span class="line">		<span class="attr">LLLL</span>: <span class="string">&quot;YYYY年MMMD日ddddAh点mm分&quot;</span>,</span><br><span class="line">		<span class="attr">l</span>: <span class="string">&quot;YYYY-MM-DD&quot;</span>,</span><br><span class="line">		<span class="attr">ll</span>: <span class="string">&quot;YYYY年MMMD日&quot;</span>,</span><br><span class="line">		<span class="attr">lll</span>: <span class="string">&quot;YYYY年MMMD日Ah点mm分&quot;</span>,</span><br><span class="line">		<span class="attr">llll</span>: <span class="string">&quot;YYYY年MMMD日ddddAh点mm分&quot;</span>,</span><br><span class="line">	&#125;, <span class="comment">//设置相对时间，from()与to()的方法返回的值就是从这里取的</span></span><br><span class="line">	<span class="attr">relativeTime</span>: &#123;</span><br><span class="line">		<span class="attr">future</span>: <span class="string">&quot;%s内&quot;</span>,</span><br><span class="line">		<span class="attr">past</span>: <span class="string">&quot;%s前&quot;</span>,</span><br><span class="line">		<span class="attr">s</span>: <span class="string">&quot;几秒&quot;</span>,</span><br><span class="line">		<span class="attr">m</span>: <span class="string">&quot;1 分钟&quot;</span>,</span><br><span class="line">		<span class="attr">mm</span>: <span class="string">&quot;%d 分钟&quot;</span>,</span><br><span class="line">		<span class="attr">h</span>: <span class="string">&quot;1 小时&quot;</span>,</span><br><span class="line">		<span class="attr">hh</span>: <span class="string">&quot;%d 小时&quot;</span>,</span><br><span class="line">		<span class="attr">d</span>: <span class="string">&quot;1 天&quot;</span>,</span><br><span class="line">		<span class="attr">dd</span>: <span class="string">&quot;%d 天&quot;</span>,</span><br><span class="line">		<span class="attr">M</span>: <span class="string">&quot;1 个月&quot;</span>,</span><br><span class="line">		<span class="attr">MM</span>: <span class="string">&quot;%d 个月&quot;</span>,</span><br><span class="line">		<span class="attr">y</span>: <span class="string">&quot;1 年&quot;</span>,</span><br><span class="line">		<span class="attr">yy</span>: <span class="string">&quot;%d 年&quot;</span>,</span><br><span class="line">	&#125;, <span class="comment">//设置时间段，参数：小时,分钟,大小写</span></span><br><span class="line">	<span class="attr">meridiem</span>: <span class="function"><span class="keyword">function</span> (<span class="params">hour, minute, isLower</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">const</span> hm = hour * <span class="number">100</span> + minute;</span><br><span class="line">		<span class="keyword">if</span> (hm &lt; <span class="number">600</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;凌晨&quot;</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (hm &lt; <span class="number">900</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;早上&quot;</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (hm &lt; <span class="number">1130</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;上午&quot;</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (hm &lt; <span class="number">1230</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;中午&quot;</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (hm &lt; <span class="number">1800</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;下午&quot;</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;晚上&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;, <span class="comment">//设置日历</span></span><br><span class="line">	<span class="attr">calendar</span>: &#123;</span><br><span class="line">		<span class="attr">sameDay</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">this</span>.minutes() === <span class="number">0</span> ? <span class="string">&quot;[今天]Ah[点整]&quot;</span> : <span class="string">&quot;[今天]LT&quot;</span>;</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="attr">nextDay</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">this</span>.minutes() === <span class="number">0</span> ? <span class="string">&quot;[明天]Ah[点整]&quot;</span> : <span class="string">&quot;[明天]LT&quot;</span>;</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="attr">lastDay</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">this</span>.minutes() === <span class="number">0</span> ? <span class="string">&quot;[昨天]Ah[点整]&quot;</span> : <span class="string">&quot;[昨天]LT&quot;</span>;</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="attr">nextWeek</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="keyword">let</span> startOfWeek, prefix;</span><br><span class="line">			startOfWeek = moment().startOf(<span class="string">&quot;week&quot;</span>);</span><br><span class="line">			prefix = <span class="built_in">this</span>.diff(startOfWeek, <span class="string">&quot;days&quot;</span>) &gt;= <span class="number">7</span> ? <span class="string">&quot;[下]&quot;</span> : <span class="string">&quot;[本####]&quot;</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">this</span>.minutes() === <span class="number">0</span></span><br><span class="line">				? prefix + <span class="string">&quot;dddAh点整&quot;</span></span><br><span class="line">				: prefix + <span class="string">&quot;dddAh点mm&quot;</span>;</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="attr">lastWeek</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="keyword">let</span> startOfWeek, prefix;</span><br><span class="line">			startOfWeek = moment().startOf(<span class="string">&quot;week&quot;</span>);</span><br><span class="line">			prefix = <span class="built_in">this</span>.unix() &lt; startOfWeek.unix() ? <span class="string">&quot;[上]&quot;</span> : <span class="string">&quot;[本]&quot;</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">this</span>.minutes() === <span class="number">0</span></span><br><span class="line">				? prefix + <span class="string">&quot;dddAh点整&quot;</span></span><br><span class="line">				: prefix + <span class="string">&quot;dddAh点mm&quot;</span>;</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="attr">sameElse</span>: <span class="string">&quot;LL&quot;</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">week</span>: &#123;</span><br><span class="line">		<span class="attr">dow</span>: <span class="number">1</span>, <span class="comment">//星期的第一天是周1</span></span><br><span class="line">		<span class="attr">doy</span>: <span class="number">4</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">	<span class="string">&quot;今天是：&quot;</span> + moment().format(<span class="string">&quot;MMMM&quot;</span>) + <span class="string">&quot; &quot;</span> + moment().format(<span class="string">&quot;dddd&quot;</span>)</span><br><span class="line">);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;今天是：&quot;</span> + moment().format(<span class="string">&quot;MMM&quot;</span>) + <span class="string">&quot; &quot;</span> + moment().format(<span class="string">&quot;ddd&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(moment().format(<span class="string">&quot;LLLL&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(moment([<span class="number">2008</span>]).from());</span><br><span class="line"><span class="built_in">console</span>.log(moment().calendar(moment([<span class="number">2020</span>, <span class="number">3</span>, <span class="number">15</span>])));</span><br></pre></td></tr></table></figure>

<h2 id="时长方法"><a href="#时长方法" class="headerlink" title="时长方法"></a>时长方法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//时长</span></span><br><span class="line"><span class="built_in">console</span>.log(moment.duration());</span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">	moment.duration(<span class="number">100</span>), <span class="comment">//给一个参数表示为毫秒</span></span><br><span class="line">	moment.duration(<span class="number">2</span>, <span class="string">&quot;seconds&quot;</span>), <span class="comment">//时长为2s</span></span><br><span class="line">	moment.duration(<span class="number">3</span>, <span class="string">&quot;minutes&quot;</span>), <span class="comment">//时长为3min</span></span><br><span class="line">	moment.duration(<span class="number">1</span>, <span class="string">&quot;M&quot;</span>), <span class="comment">//参数也可以是一个对象</span></span><br><span class="line">	moment.duration(&#123;</span><br><span class="line">		<span class="attr">seconds</span>: <span class="number">1</span>,</span><br><span class="line">		<span class="attr">minutes</span>: <span class="number">2</span>,</span><br><span class="line">		<span class="attr">hours</span>: <span class="number">3</span>,</span><br><span class="line">		<span class="attr">days</span>: <span class="number">4</span>,</span><br><span class="line">		<span class="attr">weeks</span>: <span class="number">5</span>,</span><br><span class="line">		<span class="attr">months</span>: <span class="number">6</span>,</span><br><span class="line">		<span class="attr">years</span>: <span class="number">7</span>,</span><br><span class="line">	&#125;), <span class="comment">//ASP.NET 风格的时间跨度</span></span><br><span class="line">	moment.duration(<span class="string">&quot;23:59:59&quot;</span>) <span class="comment">//时:分:秒</span></span><br><span class="line">); <span class="comment">//clone() 克隆一个时长对象</span></span><br><span class="line"><span class="keyword">var</span> d1 = moment.duration();</span><br><span class="line"><span class="keyword">var</span> d2 = d1.clone();</span><br><span class="line">d1.add(<span class="number">1</span>, <span class="string">&quot;second&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(d1, d2);</span><br><span class="line">moment.locale(<span class="string">&quot;zh-cn&quot;</span>); <span class="comment">//humanize()    显示一段时长</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">	moment.duration(<span class="number">1</span>, <span class="string">&quot;minutes&quot;</span>).humanize(),</span><br><span class="line">	moment.duration(<span class="number">24</span>, <span class="string">&quot;hours&quot;</span>).humanize(),</span><br><span class="line">	moment.duration(<span class="number">1</span>, <span class="string">&quot;minutes&quot;</span>).humanize(<span class="literal">true</span>), <span class="comment">//1 分钟内</span></span><br><span class="line">	moment.duration(-<span class="number">1</span>, <span class="string">&quot;minutes&quot;</span>).humanize(<span class="literal">true</span>) <span class="comment">//1 分钟前</span></span><br><span class="line">); <span class="comment">//milliseconds()    此方法会计算溢出 //asMilliseconds()</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">	moment.duration(<span class="number">500</span>).milliseconds(), <span class="comment">//500</span></span><br><span class="line">	moment.duration(<span class="number">1500</span>).milliseconds(), <span class="comment">//500</span></span><br><span class="line">	moment.duration(<span class="number">15000</span>).milliseconds(), <span class="comment">//0 //moment.duration(1500)</span></span><br><span class="line">	moment.duration(<span class="number">500</span>).asMilliseconds(), <span class="comment">//500</span></span><br><span class="line">	moment.duration(<span class="number">1500</span>).asMilliseconds(), <span class="comment">//1500</span></span><br><span class="line">	moment.duration(<span class="number">15000</span>).asMilliseconds() <span class="comment">//15000</span></span><br><span class="line">); <span class="comment">//seconds() //asSeconds()</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">	moment.duration(<span class="number">500</span>).seconds(), <span class="comment">//0</span></span><br><span class="line">	moment.duration(<span class="number">1500</span>).seconds(), <span class="comment">//1</span></span><br><span class="line">	moment.duration(<span class="number">15000</span>).seconds(), <span class="comment">//15</span></span><br><span class="line">	moment.duration(<span class="number">500</span>).asSeconds(), <span class="comment">//0.5</span></span><br><span class="line">	moment.duration(<span class="number">1500</span>).asSeconds(), <span class="comment">//1.5</span></span><br><span class="line">	moment.duration(<span class="number">15000</span>).asSeconds() <span class="comment">//15</span></span><br><span class="line">); <span class="comment">//add() 增加时长，这个方法可以添加多种类型的参数</span></span><br><span class="line"><span class="keyword">var</span> a = moment.duration(<span class="number">1</span>, <span class="string">&quot;d&quot;</span>); <span class="comment">//时长为1天</span></span><br><span class="line"><span class="keyword">var</span> b = moment.duration(<span class="number">2</span>, <span class="string">&quot;d&quot;</span>); <span class="comment">//时长为2天</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">	a.add(b).days(),</span><br><span class="line">	moment.duration().add(<span class="number">1</span>, <span class="string">&quot;d&quot;</span>).days() <span class="comment">// 1</span></span><br><span class="line">); <span class="comment">//subtract()    减少时长</span></span><br><span class="line"><span class="keyword">var</span> a = moment.duration(<span class="number">3</span>, <span class="string">&quot;d&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> b = moment.duration(<span class="number">2</span>, <span class="string">&quot;d&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">	a.subtract(b).days(), <span class="comment">//1</span></span><br><span class="line">	moment.duration(<span class="number">5</span>, <span class="string">&quot;d&quot;</span>).subtract(<span class="number">1</span>, <span class="string">&quot;d&quot;</span>).days() <span class="comment">//4</span></span><br><span class="line">); <span class="comment">//duration(x.diff(y))   获取两个时长的差值</span></span><br><span class="line"><span class="keyword">var</span> a = moment([<span class="number">2018</span>, <span class="number">10</span>, <span class="number">21</span>, <span class="number">10</span>, <span class="number">05</span>]);</span><br><span class="line"><span class="keyword">var</span> b = moment([<span class="number">2018</span>, <span class="number">10</span>, <span class="number">21</span>, <span class="number">10</span>, <span class="number">06</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(moment.duration(b.diff(a))); <span class="comment">//as()</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">	moment.duration(<span class="number">1000</span>).as(<span class="string">&quot;milliseconds&quot;</span>), <span class="comment">//1000</span></span><br><span class="line">	moment.duration(<span class="number">1000</span>).as(<span class="string">&quot;seconds&quot;</span>) <span class="comment">//1</span></span><br><span class="line">); <span class="comment">//get()</span></span><br><span class="line"><span class="keyword">var</span> d = moment.duration(&#123;</span><br><span class="line">	<span class="attr">seconds</span>: <span class="number">1</span>,</span><br><span class="line">	<span class="attr">minutes</span>: <span class="number">2</span>,</span><br><span class="line">	<span class="attr">hours</span>: <span class="number">3</span>,</span><br><span class="line">	<span class="attr">days</span>: <span class="number">4</span>,</span><br><span class="line">	<span class="attr">months</span>: <span class="number">5</span>,</span><br><span class="line">	<span class="attr">years</span>: <span class="number">6</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(d);</span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">	d.get(<span class="string">&quot;seconds&quot;</span>),</span><br><span class="line">	d.get(<span class="string">&quot;minutes&quot;</span>),</span><br><span class="line">	d.get(<span class="string">&quot;hours&quot;</span>),</span><br><span class="line">	d.get(<span class="string">&quot;days&quot;</span>),</span><br><span class="line">	d.get(<span class="string">&quot;months&quot;</span>),</span><br><span class="line">	d.get(<span class="string">&quot;years&quot;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>js工具库</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>moment</tag>
      </tags>
  </entry>
  <entry>
    <title>less的基本介绍</title>
    <url>/135xyq.github.io/2021/04/03/less-less/</url>
    <content><![CDATA[<h1 id="什么是Less？"><a href="#什么是Less？" class="headerlink" title="什么是Less？"></a>什么是Less？</h1><p><strong>Less</strong>是一种更加简洁的样式代码，它非常像CSS，但又不太一样，它让编写样式变得更容易</p>
<p><strong>Less代码虽好，但它无法被浏览器识别</strong>，因此需要一个工具将其转换为血统纯正的css代码</p>
<p>由于<strong>node环境具有读写文件的能力</strong>，于是在node环境中可以轻松的完成文件的转换</p>
<p><code>npm</code>上有一个包叫做<code>less</code>，它运行在node环境中，通过它可以完成对Less代码的转换</p>
<p><strong>可以看出，node环境在前端工程化中，充当了一个辅助的角色，它并不直接运行前端代码，而是让我们编写前端代码更加舒适便利，在后续的课程中，你还会不断的体会到这一点</strong></p>
<p><strong>转换代码，称之为编译(compile)，转换代码的工具，称之为编译器(compiler)</strong></p>
<h1 id="体验Less"><a href="#体验Less" class="headerlink" title="体验Less"></a>体验Less</h1><ol>
<li><p>新建<code>index.less</code>文件，编写下面的<code>less</code>代码</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@green:</span> <span class="number">#008c8c</span>;</span><br><span class="line"><span class="selector-class">.list</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">@green</span>;</span><br><span class="line">  <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">1em</span>;</span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">      <span class="attribute">background</span>: <span class="variable">@green</span>;</span><br><span class="line">      <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>npm</code>下载<code>less</code></p>
<p><code>less</code>包提供了一个<code>cli</code>工具<code>lessc</code>，你可以有两种方案使用它</p>
<p><strong>方案一：全局安装less</strong></p>
<p>这种方案可以让你在任何终端目录使用<code>lessc</code>命令，但不利于版本控制</p>
<p><strong>方案二：本地安装less</strong></p>
<p>这种方案会把<code>less</code>安装到工程目录的<code>node_modules</code>中，你无法全局使用<code>lessc</code>命令，但可以在当前工程目录中使用<code>npx lessc</code>运行该命令</p>
<blockquote>
<p>npx是npm提供的一个小工具，它可以运行当前项目中安装到node_modules的cli命令</p>
<p>如果配置<code>package.json</code>脚本，无须使用<code>npx</code></p>
<p>如果可以，应该尽量使用本地安装，而非全局安装</p>
</blockquote>
<p>如果可以，应该尽量使用本地安装，而非全局安装</p>
</li>
<li><p>使用<code>lessc</code>命令，对编写的<code>less</code>文件进行编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将 index.less 编译成为 index.css</span></span><br><span class="line">lessc index.less index.css</span><br></pre></td></tr></table></figure></li>
<li><p>新建一个页面，引用编译结果<code>index.css</code></p>
</li>
</ol>
<blockquote>
<p>目前，编写less代码会遇到一点小麻烦，就是每次编写后，都需要运行命令进行编译</p>
<p>这个麻烦只是暂时的，将来很快就可以解决</p>
</blockquote>
<h1 id="Less的核心语法"><a href="#Less的核心语法" class="headerlink" title="Less的核心语法"></a>Less的核心语法</h1><blockquote>
<p>Less官网：<a href="https://lesscss.org/">https://lesscss.org/</a></p>
<p>Less民间中文网：<a href="https://less.bootcss.com/">https://less.bootcss.com/</a></p>
</blockquote>
<p>Less提供了非常多的功能，帮助我们更加轻松的编写css代码</p>
<p>其中，我们最常用的功能有下面3个：</p>
<ul>
<li><a href="https://less.bootcss.com/#%E5%8F%98%E9%87%8F%EF%BC%88variables%EF%BC%89">变量</a></li>
<li><a href="https://less.bootcss.com/#%E5%B5%8C%E5%A5%97%EF%BC%88nesting%EF%BC%89">嵌套</a></li>
<li><a href="https://less.bootcss.com/#%E6%B7%B7%E5%90%88%EF%BC%88mixins%EF%BC%89">混合</a></li>
</ul>
<p>另外，你需要关注Less的特殊<a href="https://less.bootcss.com/#%E6%B3%A8%E9%87%8A%EF%BC%88comments%EF%BC%89">注释</a></p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>less</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>less</tag>
      </tags>
  </entry>
  <entry>
    <title>express的使用</title>
    <url>/135xyq.github.io/2022/03/13/node-express-express%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="express"><a href="#express" class="headerlink" title="express"></a><a href="https://www.expressjs.com.cn/4x/api.html#express">express</a></h1><h2 id="使用express方法创建一个express应用"><a href="#使用express方法创建一个express应用" class="headerlink" title="使用express方法创建一个express应用"></a>使用express方法创建一个express应用</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express(); <span class="comment">// 创建一个express应用</span></span><br><span class="line"><span class="comment">// app用来处理请求的函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(app);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">9527</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;listen port 9527!&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server.on(<span class="string">&#x27;listening&#x27;</span>, <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>等价于：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = express(); <span class="comment">// 创建一个express应用</span></span><br><span class="line"><span class="comment">// app用来处理请求的函数</span></span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">9527</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;listen port 9527&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="配置请求响应函数"><a href="#配置请求响应函数" class="headerlink" title="配置请求响应函数"></a>配置请求响应函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">&#x27;/abc&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;请求头：&#x27;</span>, req.headers); <span class="comment">//请求头</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;请求路径:&#x27;</span>, req.path); <span class="comment">//请求路径</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;请求参数:&#x27;</span>, req.query); <span class="comment">//请求参数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送响应</span></span><br><span class="line">    res.send(<span class="string">&#x27;&lt;h1&gt;ab435c&lt;/h1&gt;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a><a href="https://www.expressjs.com.cn/4x/api.html#router">基本使用</a></h3><p>当匹配到请求时，会交给第一个处理函数处理，函数中要<strong>手动交给</strong>后续的中间件处理。</p>
<p>如果已经没有后续中间件，express发现响应没有结束，express会响应404。</p>
<p>如果中间件发生了错误，不会停止服务器（相当于调用了next（错误处理对象）），会寻找后续的错误处理中间件，如果没有会响应500</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">9527</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;server is listening port 9527&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/news&#x27;</span>, <span class="function">(<span class="params">rep, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;第一个处理函数！&#x27;</span>);</span><br><span class="line">        next(); <span class="comment">//需要手动移交</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function">(<span class="params">rep, resp, next</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;第二个处理函数！&#x27;</span>);</span><br><span class="line">        next();</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/news&#x27;</span>, <span class="function">(<span class="params">rep, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;第三个处理函数！&#x27;</span>);</span><br><span class="line">    res.send(<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>处理遇到的报错</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">9527</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;server is listening port 9527&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/news&#x27;</span>, <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;第一个处理函数！&#x27;</span>);</span><br><span class="line">        next(); <span class="comment">//需要手动移交</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;第二个处理函数抛出错误！&#x27;</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;报错了！&#x27;</span>);</span><br><span class="line">        next();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function">(<span class="params">error, req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//上一个中间件抛出错误，下一个中间件要捕获错误，需要传入error错误参数</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;第三个处理函数！&#x27;</span>);</span><br><span class="line">        res.send(<span class="string">&#x27;123&#x27;</span>);</span><br><span class="line">        next();</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="自带中间件"><a href="#自带中间件" class="headerlink" title="自带中间件"></a>自带中间件</h3><h4 id="express-static"><a href="#express-static" class="headerlink" title="express.static"></a><a href="https://www.expressjs.com.cn/4x/api.html#express.static">express.static</a></h4><p>静态服务器</p>
<p>参数一：静态资源的目录</p>
<p>当请求时，会根据请求路径(req.path)，从指定的目录中寻找是否存在该文件，如果存在，直接响应文件内容，而不再移交给后续的中间件;<br>如果不存在文件，则直接移交给后续的中间件处理;<br>默认情况下，如果映射的结果是一个目录，则会自动使用index.html文件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">9527</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;server is listening port 9527&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> root = path.resolve(__dirname, <span class="string">&#x27;../public&#x27;</span>)</span><br><span class="line">app.use(express.static(root));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="express-json"><a href="#express-json" class="headerlink" title="express.json"></a><a href="https://www.expressjs.com.cn/4x/api.html#express.json">express.json</a></h4><p>解析JSON格式的消息体</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(express.json())</span><br></pre></td></tr></table></figure>


<h4 id="express-urlencoded"><a href="#express-urlencoded" class="headerlink" title="express.urlencoded"></a><a href="https://www.expressjs.com.cn/4x/api.html#express.urlencoded">express.urlencoded</a></h4><p>解析application/x-www-form-urlencoded形式消息体。<br>使用之后可以获取请求体中的数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">app.use(express.urlencoded(&#123;</span><br><span class="line">    <span class="attr">extended</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">&#x27;/api/student&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.body)</span><br><span class="line">    res.send(<span class="string">&#x27;api/student post&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="express路由"><a href="#express路由" class="headerlink" title="express路由"></a><a href="https://www.expressjs.com.cn/4x/api.html#router">express路由</a></h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">9527</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;server is listening port 9527&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个路由</span></span><br><span class="line"><span class="keyword">const</span> router = express.Router();</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.send(<span class="string">&#x27;获取学生列表！&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">router.get(<span class="string">&#x27;/:id&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.send(<span class="string">&#x27;获取单个学生的信息！&#x27;</span>, id);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.put(<span class="string">&#x27;/:id&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.send(<span class="string">&#x27;修改学生的信息！&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.post(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.send(<span class="string">&#x27;新增一个学生！&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.delete(<span class="string">&#x27;/:id&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.send(<span class="string">&#x27;删除一个学生！&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">&#x27;/api/student&#x27;</span>, router)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>node</category>
        <category>express</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>node</tag>
        <tag>express</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql的函数和分组</title>
    <url>/135xyq.github.io/2022/03/05/node-mysql-%E5%87%BD%E6%95%B0%E5%92%8C%E5%88%86%E7%BB%84/</url>
    <content><![CDATA[<h1 id="函数和分组"><a href="#函数和分组" class="headerlink" title="函数和分组"></a>函数和分组</h1><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a><a href="https://www.runoob.com/mysql/mysql-functions.html">内置函数</a></h3><h4 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h4><table>
<thead>
<tr>
<th align="left">函数名</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ABS(x)</td>
<td align="left">返回 x 的绝对值</td>
<td align="left">返回 -1 的绝对值：<code>SELECT ABS(-1) -- 返回1</code></td>
</tr>
<tr>
<td align="left">ACOS(x)</td>
<td align="left">求 x 的反余弦值（单位为弧度），x 为一个数值</td>
<td align="left"><code>SELECT ACOS(0.25);</code></td>
</tr>
<tr>
<td align="left">ASIN(x)</td>
<td align="left">求反正弦值（单位为弧度），x 为一个数值</td>
<td align="left"><code>SELECT ASIN(0.25);</code></td>
</tr>
<tr>
<td align="left">ATAN(x)</td>
<td align="left">求反正切值（单位为弧度），x 为一个数值</td>
<td align="left"><code>SELECT ATAN(2.5);</code></td>
</tr>
<tr>
<td align="left">ATAN2(n, m)</td>
<td align="left">求反正切值（单位为弧度）</td>
<td align="left"><code>SELECT ATAN2(-0.8, 2);</code></td>
</tr>
<tr>
<td align="left">AVG(expression)</td>
<td align="left">返回一个表达式的平均值，expression 是一个字段</td>
<td align="left">返回 Products 表中Price 字段的平均值：<code>SELECT AVG(Price) AS AveragePrice FROM Products;</code></td>
</tr>
<tr>
<td align="left">CEIL(x)</td>
<td align="left">返回大于或等于 x 的最小整数</td>
<td align="left"><code>SELECT CEIL(1.5) -- 返回2</code></td>
</tr>
<tr>
<td align="left">CEILING(x)</td>
<td align="left">返回大于或等于 x 的最小整数</td>
<td align="left"><code>SELECT CEILING(1.5); -- 返回2</code></td>
</tr>
<tr>
<td align="left">COS(x)</td>
<td align="left">求余弦值(参数是弧度)</td>
<td align="left"><code>SELECT COS(2);</code></td>
</tr>
<tr>
<td align="left">COT(x)</td>
<td align="left">求余切值(参数是弧度)</td>
<td align="left"><code>SELECT COT(6);</code></td>
</tr>
<tr>
<td align="left">COUNT(expression)</td>
<td align="left">返回查询的记录总数，expression 参数是一个字段或者 * 号</td>
<td align="left">返回 Products 表中 products 字段总共有多少条记录：<code>SELECT COUNT(ProductID) AS NumberOfProducts FROM Products;</code></td>
</tr>
<tr>
<td align="left">DEGREES(x)</td>
<td align="left">将弧度转换为角度</td>
<td align="left"><code>SELECT DEGREES(3.1415926535898) -- 180</code></td>
</tr>
<tr>
<td align="left">n DIV m</td>
<td align="left">整除，n 为被除数，m 为除数</td>
<td align="left">计算 10 除于 5：<code>SELECT 10 DIV 5;  -- 2</code></td>
</tr>
<tr>
<td align="left">EXP(x)</td>
<td align="left">返回 e 的 x 次方</td>
<td align="left">计算 e 的三次方：<code>SELECT EXP(3) -- 20.085536923188</code></td>
</tr>
<tr>
<td align="left">FLOOR(x)</td>
<td align="left">返回小于或等于 x 的最大整数</td>
<td align="left">小于或等于 1.5 的整数：<code>SELECT FLOOR(1.5) -- 返回1</code></td>
</tr>
<tr>
<td align="left">GREATEST(expr1, expr2, expr3, …)</td>
<td align="left">返回列表中的最大值</td>
<td align="left">返回以下数字列表中的最大值：<code>SELECT GREATEST(3, 12, 34, 8, 25); -- 34</code>返回以下字符串列表中的最大值：<code>SELECT GREATEST(&quot;Google&quot;, &quot;Runoob&quot;, &quot;Apple&quot;);   -- Runoob</code></td>
</tr>
<tr>
<td align="left">LEAST(expr1, expr2, expr3, …)</td>
<td align="left">返回列表中的最小值</td>
<td align="left">返回以下数字列表中的最小值：<code>SELECT LEAST(3, 12, 34, 8, 25); -- 3</code>返回以下字符串列表中的最小值：<code>SELECT LEAST(&quot;Google&quot;, &quot;Runoob&quot;, &quot;Apple&quot;);   -- Apple</code></td>
</tr>
<tr>
<td align="left">LN</td>
<td align="left">返回数字的自然对数，以 e 为底。</td>
<td align="left">返回 2 的自然对数：<code>SELECT LN(2);  -- 0.6931471805599453</code></td>
</tr>
<tr>
<td align="left">LOG(x) 或 LOG(base, x)</td>
<td align="left">返回自然对数(以 e 为底的对数)，如果带有 base 参数，则 base 为指定带底数。</td>
<td align="left"><code>SELECT LOG(20.085536923188) -- 3 SELECT LOG(2, 4); -- 2</code></td>
</tr>
<tr>
<td align="left">LOG10(x)</td>
<td align="left">返回以 10 为底的对数</td>
<td align="left"><code>SELECT LOG10(100) -- 2</code></td>
</tr>
<tr>
<td align="left">LOG2(x)</td>
<td align="left">返回以 2 为底的对数</td>
<td align="left">返回以 2 为底 6 的对数：<code>SELECT LOG2(6);  -- 2.584962500721156</code></td>
</tr>
<tr>
<td align="left">MAX(expression)</td>
<td align="left">返回字段 expression 中的最大值</td>
<td align="left">返回数据表 Products 中字段 Price 的最大值：<code>SELECT MAX(Price) AS LargestPrice FROM Products;</code></td>
</tr>
<tr>
<td align="left">MIN(expression)</td>
<td align="left">返回字段 expression 中的最小值</td>
<td align="left">返回数据表 Products 中字段 Price 的最小值：<code>SELECT MIN(Price) AS MinPrice FROM Products;</code></td>
</tr>
<tr>
<td align="left">MOD(x,y)</td>
<td align="left">返回 x 除以 y 以后的余数</td>
<td align="left">5 除于 2 的余数：<code>SELECT MOD(5,2) -- 1</code></td>
</tr>
<tr>
<td align="left">PI()</td>
<td align="left">返回圆周率(3.141593）</td>
<td align="left"><code>SELECT PI() --3.141593</code></td>
</tr>
<tr>
<td align="left">POW(x,y)</td>
<td align="left">返回 x 的 y 次方</td>
<td align="left">2 的 3 次方：<code>SELECT POW(2,3) -- 8</code></td>
</tr>
<tr>
<td align="left">POWER(x,y)</td>
<td align="left">返回 x 的 y 次方</td>
<td align="left">2 的 3 次方：<code>SELECT POWER(2,3) -- 8</code></td>
</tr>
<tr>
<td align="left">RADIANS(x)</td>
<td align="left">将角度转换为弧度</td>
<td align="left">180 度转换为弧度：<code>SELECT RADIANS(180) -- 3.1415926535898</code></td>
</tr>
<tr>
<td align="left">RAND()</td>
<td align="left">返回 0 到 1 的随机数</td>
<td align="left"><code>SELECT RAND() --0.93099315644334</code></td>
</tr>
<tr>
<td align="left">ROUND(x)</td>
<td align="left">返回离 x 最近的整数</td>
<td align="left"><code>SELECT ROUND(1.23456) --1</code></td>
</tr>
<tr>
<td align="left">SIGN(x)</td>
<td align="left">返回 x 的符号，x 是负数、0、正数分别返回 -1、0 和 1</td>
<td align="left"><code>SELECT SIGN(-10) -- (-1)</code></td>
</tr>
<tr>
<td align="left">SIN(x)</td>
<td align="left">求正弦值(参数是弧度)</td>
<td align="left"><code>SELECT SIN(RADIANS(30)) -- 0.5</code></td>
</tr>
<tr>
<td align="left">SQRT(x)</td>
<td align="left">返回x的平方根</td>
<td align="left">25 的平方根：<code>SELECT SQRT(25) -- 5</code></td>
</tr>
<tr>
<td align="left">SUM(expression)</td>
<td align="left">返回指定字段的总和</td>
<td align="left">计算 OrderDetails 表中字段 Quantity 的总和：<code>SELECT SUM(Quantity) AS TotalItemsOrdered FROM OrderDetails;</code></td>
</tr>
<tr>
<td align="left">TAN(x)</td>
<td align="left">求正切值(参数是弧度)</td>
<td align="left"><code>SELECT TAN(1.75);  -- -5.52037992250933</code></td>
</tr>
<tr>
<td align="left">TRUNCATE(x,y)</td>
<td align="left">返回数值 x 保留到小数点后 y 位的值（与 ROUND 最大的区别是不会进行四舍五入）</td>
<td align="left"><code>SELECT TRUNCATE(1.23456,3) -- 1.234</code></td>
</tr>
</tbody></table>
<h4 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h4><table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ASCII(s)</td>
<td align="left">返回字符串 s 的第一个字符的 ASCII 码。</td>
<td align="left">返回 CustomerName 字段第一个字母的 ASCII 码：<code>SELECT ASCII(CustomerName) AS NumCodeOfFirstChar FROM Customers;</code></td>
</tr>
<tr>
<td align="left">CHAR_LENGTH(s)</td>
<td align="left">返回字符串 s 的字符数</td>
<td align="left">返回字符串 RUNOOB 的字符数<code>SELECT CHAR_LENGTH(&quot;RUNOOB&quot;) AS LengthOfString;</code></td>
</tr>
<tr>
<td align="left">CHARACTER_LENGTH(s)</td>
<td align="left">返回字符串 s 的字符数</td>
<td align="left">返回字符串 RUNOOB 的字符数<code>SELECT CHARACTER_LENGTH(&quot;RUNOOB&quot;) AS LengthOfString;</code></td>
</tr>
<tr>
<td align="left">CONCAT(s1,s2…sn)</td>
<td align="left">字符串 s1,s2 等多个字符串合并为一个字符串</td>
<td align="left">合并多个字符串<code>SELECT CONCAT(&quot;SQL &quot;, &quot;Runoob &quot;, &quot;Gooogle &quot;, &quot;Facebook&quot;) AS ConcatenatedString;</code></td>
</tr>
<tr>
<td align="left">CONCAT_WS(x, s1,s2…sn)</td>
<td align="left">同 CONCAT(s1,s2,…) 函数，但是每个字符串之间要加上 x，x 可以是分隔符</td>
<td align="left">合并多个字符串，并添加分隔符：<code>SELECT CONCAT_WS(&quot;-&quot;, &quot;SQL&quot;, &quot;Tutorial&quot;, &quot;is&quot;, &quot;fun!&quot;)AS ConcatenatedString;</code></td>
</tr>
<tr>
<td align="left">FIELD(s,s1,s2…)</td>
<td align="left">返回第一个字符串 s 在字符串列表(s1,s2…)中的位置</td>
<td align="left">返回字符串 c 在列表值中的位置：<code>SELECT FIELD(&quot;c&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;);</code></td>
</tr>
<tr>
<td align="left">FIND_IN_SET(s1,s2)</td>
<td align="left">返回在字符串s2中与s1匹配的字符串的位置</td>
<td align="left">返回字符串 c 在指定字符串中的位置：<code>SELECT FIND_IN_SET(&quot;c&quot;, &quot;a,b,c,d,e&quot;);</code></td>
</tr>
<tr>
<td align="left">FORMAT(x,n)</td>
<td align="left">函数可以将数字 x 进行格式化 “#,###.##”, 将 x 保留到小数点后 n 位，最后一位四舍五入。</td>
<td align="left">格式化数字 “#,###.##” 形式：<code>SELECT FORMAT(250500.5634, 2);     -- 输出 250,500.56</code></td>
</tr>
<tr>
<td align="left">INSERT(s1,x,len,s2)</td>
<td align="left">字符串 s2 替换 s1 的 x 位置开始长度为 len 的字符串</td>
<td align="left">从字符串第一个位置开始的 6 个字符替换为 runoob：<code>SELECT INSERT(&quot;google.com&quot;, 1, 6, &quot;runoob&quot;);  -- 输出：runoob.com</code></td>
</tr>
<tr>
<td align="left">LOCATE(s1,s)</td>
<td align="left">从字符串 s 中获取 s1 的开始位置</td>
<td align="left">获取 b 在字符串 abc 中的位置：<code>SELECT LOCATE(&#39;st&#39;,&#39;myteststring&#39;);  -- 5</code>返回字符串 abc 中 b 的位置：<code>SELECT LOCATE(&#39;b&#39;, &#39;abc&#39;) -- 2</code></td>
</tr>
<tr>
<td align="left">LCASE(s)</td>
<td align="left">将字符串 s 的所有字母变成小写字母</td>
<td align="left">字符串 RUNOOB 转换为小写：<code>SELECT LCASE(&#39;RUNOOB&#39;) -- runoob</code></td>
</tr>
<tr>
<td align="left">LEFT(s,n)</td>
<td align="left">返回字符串 s 的前 n 个字符</td>
<td align="left">返回字符串 runoob 中的前两个字符：<code>SELECT LEFT(&#39;runoob&#39;,2) -- ru</code></td>
</tr>
<tr>
<td align="left">LOWER(s)</td>
<td align="left">将字符串 s 的所有字母变成小写字母</td>
<td align="left">字符串 RUNOOB 转换为小写：<code>SELECT LOWER(&#39;RUNOOB&#39;) -- runoob</code></td>
</tr>
<tr>
<td align="left">LPAD(s1,len,s2)</td>
<td align="left">在字符串 s1 的开始处填充字符串 s2，使字符串长度达到 len</td>
<td align="left">将字符串 xx 填充到 abc 字符串的开始处：<code>SELECT LPAD(&#39;abc&#39;,5,&#39;xx&#39;) -- xxabc</code></td>
</tr>
<tr>
<td align="left">LTRIM(s)</td>
<td align="left">去掉字符串 s 开始处的空格</td>
<td align="left">去掉字符串 RUNOOB开始处的空格：<code>SELECT LTRIM(&quot;    RUNOOB&quot;) AS LeftTrimmedString;-- RUNOOB</code></td>
</tr>
<tr>
<td align="left">MID(s,n,len)</td>
<td align="left">从字符串 s 的 n 位置截取长度为 len 的子字符串，同 SUBSTRING(s,n,len)</td>
<td align="left">从字符串 RUNOOB 中的第 2 个位置截取 3个 字符：<code>SELECT MID(&quot;RUNOOB&quot;, 2, 3) AS ExtractString; -- UNO</code></td>
</tr>
<tr>
<td align="left">POSITION(s1 IN s)</td>
<td align="left">从字符串 s 中获取 s1 的开始位置</td>
<td align="left">返回字符串 abc 中 b 的位置：<code>SELECT POSITION(&#39;b&#39; in &#39;abc&#39;) -- 2</code></td>
</tr>
<tr>
<td align="left">REPEAT(s,n)</td>
<td align="left">将字符串 s 重复 n 次</td>
<td align="left">将字符串 runoob 重复三次：<code>SELECT REPEAT(&#39;runoob&#39;,3) -- runoobrunoobrunoob</code></td>
</tr>
<tr>
<td align="left">REPLACE(s,s1,s2)</td>
<td align="left">将字符串 s2 替代字符串 s 中的字符串 s1</td>
<td align="left">将字符串 abc 中的字符 a 替换为字符 x：<code>SELECT REPLACE(&#39;abc&#39;,&#39;a&#39;,&#39;x&#39;) --xbc</code></td>
</tr>
<tr>
<td align="left">REVERSE(s)</td>
<td align="left">将字符串s的顺序反过来</td>
<td align="left">将字符串 abc 的顺序反过来：<code>SELECT REVERSE(&#39;abc&#39;) -- cba</code></td>
</tr>
<tr>
<td align="left">RIGHT(s,n)</td>
<td align="left">返回字符串 s 的后 n 个字符</td>
<td align="left">返回字符串 runoob 的后两个字符：<code>SELECT RIGHT(&#39;runoob&#39;,2) -- ob</code></td>
</tr>
<tr>
<td align="left">RPAD(s1,len,s2)</td>
<td align="left">在字符串 s1 的结尾处添加字符串 s2，使字符串的长度达到 len</td>
<td align="left">将字符串 xx 填充到 abc 字符串的结尾处：<code>SELECT RPAD(&#39;abc&#39;,5,&#39;xx&#39;) -- abcxx</code></td>
</tr>
<tr>
<td align="left">RTRIM(s)</td>
<td align="left">去掉字符串 s 结尾处的空格</td>
<td align="left">去掉字符串 RUNOOB 的末尾空格：<code>SELECT RTRIM(&quot;RUNOOB     &quot;) AS RightTrimmedString;   -- RUNOOB</code></td>
</tr>
<tr>
<td align="left">SPACE(n)</td>
<td align="left">返回 n 个空格</td>
<td align="left">返回 10 个空格：<code>SELECT SPACE(10);</code></td>
</tr>
<tr>
<td align="left">STRCMP(s1,s2)</td>
<td align="left">比较字符串 s1 和 s2，如果 s1 与 s2 相等返回 0 ，如果 s1&gt;s2 返回 1，如果 s1&lt;s2 返回 -1</td>
<td align="left">比较字符串：<code>SELECT STRCMP(&quot;runoob&quot;, &quot;runoob&quot;);  -- 0</code></td>
</tr>
<tr>
<td align="left">SUBSTR(s, start, length)</td>
<td align="left">从字符串 s 的 start 位置截取长度为 length 的子字符串</td>
<td align="left">从字符串 RUNOOB 中的第 2 个位置截取 3个 字符：<code>SELECT SUBSTR(&quot;RUNOOB&quot;, 2, 3) AS ExtractString; -- UNO</code></td>
</tr>
<tr>
<td align="left">SUBSTRING(s, start, length)</td>
<td align="left">从字符串 s 的 start 位置截取长度为 length 的子字符串</td>
<td align="left">从字符串 RUNOOB 中的第 2 个位置截取 3个 字符：<code>SELECT SUBSTRING(&quot;RUNOOB&quot;, 2, 3) AS ExtractString; -- UNO</code></td>
</tr>
<tr>
<td align="left">SUBSTRING_INDEX(s, delimiter, number)</td>
<td align="left">返回从字符串 s 的第 number 个出现的分隔符 delimiter 之后的子串。 如果 number 是正数，返回第 number 个字符左边的字符串。 如果 number 是负数，返回第(number 的绝对值(从右边数))个字符右边的字符串。</td>
<td align="left"><code>SELECT SUBSTRING_INDEX(&#39;a*b&#39;,&#39;*&#39;,1) -- a SELECT SUBSTRING_INDEX(&#39;a*b&#39;,&#39;*&#39;,-1)  -- b SELECT SUBSTRING_INDEX(SUBSTRING_INDEX(&#39;a*b*c*d*e&#39;,&#39;*&#39;,3),&#39;*&#39;,-1)  -- c</code></td>
</tr>
<tr>
<td align="left">TRIM(s)</td>
<td align="left">去掉字符串 s 开始和结尾处的空格</td>
<td align="left">去掉字符串 RUNOOB 的首尾空格：<code>SELECT TRIM(&#39;    RUNOOB    &#39;) AS TrimmedString;</code></td>
</tr>
<tr>
<td align="left">UCASE(s)</td>
<td align="left">将字符串转换为大写</td>
<td align="left">将字符串 runoob 转换为大写：<code>SELECT UCASE(&quot;runoob&quot;); -- RUNOOB</code></td>
</tr>
<tr>
<td align="left">UPPER(s)</td>
<td align="left">将字符串转换为大写</td>
<td align="left">将字符串 runoob 转换为大写：<code>SELECT UPPER(&quot;runoob&quot;); -- RUNOOB</code></td>
</tr>
</tbody></table>
<h4 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h4><table>
<thead>
<tr>
<th align="left">函数名</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ADDDATE(d,n)</td>
<td align="left">计算起始日期 d 加上 n 天的日期</td>
<td align="left"><code>SELECT ADDDATE(&quot;2017-06-15&quot;, INTERVAL 10 DAY); -&gt;2017-06-25</code></td>
</tr>
<tr>
<td align="left">ADDTIME(t,n)</td>
<td align="left">n 是一个时间表达式，时间 t 加上时间表达式 n</td>
<td align="left">加 5 秒：<code>SELECT ADDTIME(&#39;2011-11-11 11:11:11&#39;, 5); -&gt;2011-11-11 11:11:16 (秒)</code>添加 2 小时, 10 分钟, 5 秒:<code>SELECT ADDTIME(&quot;2020-06-15 09:34:21&quot;, &quot;2:10:5&quot;);  -&gt; 2020-06-15 11:44:26</code></td>
</tr>
<tr>
<td align="left">CURDATE()</td>
<td align="left">返回当前日期</td>
<td align="left"><code>SELECT CURDATE(); -&gt; 2018-09-19</code></td>
</tr>
<tr>
<td align="left">CURRENT_DATE()</td>
<td align="left">返回当前日期</td>
<td align="left"><code>SELECT CURRENT_DATE(); -&gt; 2018-09-19</code></td>
</tr>
<tr>
<td align="left">CURRENT_TIME</td>
<td align="left">返回当前时间</td>
<td align="left"><code>SELECT CURRENT_TIME(); -&gt; 19:59:02</code></td>
</tr>
<tr>
<td align="left">CURRENT_TIMESTAMP()</td>
<td align="left">返回当前日期和时间</td>
<td align="left"><code>SELECT CURRENT_TIMESTAMP() -&gt; 2018-09-19 20:57:43</code></td>
</tr>
<tr>
<td align="left">CURTIME()</td>
<td align="left">返回当前时间</td>
<td align="left"><code>SELECT CURTIME(); -&gt; 19:59:02</code></td>
</tr>
<tr>
<td align="left">DATE()</td>
<td align="left">从日期或日期时间表达式中提取日期值</td>
<td align="left"><code>SELECT DATE(&quot;2017-06-15&quot;);     -&gt; 2017-06-15</code></td>
</tr>
<tr>
<td align="left">DATEDIFF(d1,d2)</td>
<td align="left">计算日期 d1-&gt;d2 之间相隔的天数</td>
<td align="left"><code>SELECT DATEDIFF(&#39;2001-01-01&#39;,&#39;2001-02-02&#39;) -&gt; -32</code></td>
</tr>
<tr>
<td align="left">DATE_ADD(d，INTERVAL expr type)</td>
<td align="left">计算起始日期 d 加上一个时间段后的日期，type 值可以是：MICROSECONDSECONDMINUTEHOURDAYWEEKMONTHQUARTERYEARSECOND_MICROSECONDMINUTE_MICROSECONDMINUTE_SECONDHOUR_MICROSECONDHOUR_SECONDHOUR_MINUTEDAY_MICROSECONDDAY_SECONDDAY_MINUTEDAY_HOURYEAR_MONTH</td>
<td align="left"><code>SELECT DATE_ADD(&quot;2017-06-15&quot;, INTERVAL 10 DAY);     -&gt; 2017-06-25 SELECT DATE_ADD(&quot;2017-06-15 09:34:21&quot;, INTERVAL 15 MINUTE); -&gt; 2017-06-15 09:49:21 SELECT DATE_ADD(&quot;2017-06-15 09:34:21&quot;, INTERVAL -3 HOUR); -&gt;2017-06-15 06:34:21 SELECT DATE_ADD(&quot;2017-06-15 09:34:21&quot;, INTERVAL -3 MONTH); -&gt;2017-04-15</code></td>
</tr>
<tr>
<td align="left">DATE_FORMAT(d,f)</td>
<td align="left">按表达式 f的要求显示日期 d</td>
<td align="left"><code>SELECT DATE_FORMAT(&#39;2011-11-11 11:11:11&#39;,&#39;%Y-%m-%d %r&#39;) -&gt; 2011-11-11 11:11:11 AM</code></td>
</tr>
<tr>
<td align="left">DATE_SUB(date,INTERVAL expr type)</td>
<td align="left">函数从日期减去指定的时间间隔。</td>
<td align="left">Orders 表中 OrderDate 字段减去 2 天：<code>SELECT OrderId,DATE_SUB(OrderDate,INTERVAL 2 DAY) AS OrderPayDate FROM Orders</code></td>
</tr>
<tr>
<td align="left">DAY(d)</td>
<td align="left">返回日期值 d 的日期部分</td>
<td align="left"><code>SELECT DAY(&quot;2017-06-15&quot;);   -&gt; 15</code></td>
</tr>
<tr>
<td align="left">DAYNAME(d)</td>
<td align="left">返回日期 d 是星期几，如 Monday,Tuesday</td>
<td align="left"><code>SELECT DAYNAME(&#39;2011-11-11 11:11:11&#39;) -&gt;Friday</code></td>
</tr>
<tr>
<td align="left">DAYOFMONTH(d)</td>
<td align="left">计算日期 d 是本月的第几天</td>
<td align="left"><code>SELECT DAYOFMONTH(&#39;2011-11-11 11:11:11&#39;) -&gt;11</code></td>
</tr>
<tr>
<td align="left">DAYOFWEEK(d)</td>
<td align="left">日期 d 今天是星期几，1 星期日，2 星期一，以此类推</td>
<td align="left"><code>SELECT DAYOFWEEK(&#39;2011-11-11 11:11:11&#39;) -&gt;6</code></td>
</tr>
<tr>
<td align="left">DAYOFYEAR(d)</td>
<td align="left">计算日期 d 是本年的第几天</td>
<td align="left"><code>SELECT DAYOFYEAR(&#39;2011-11-11 11:11:11&#39;) -&gt;315</code></td>
</tr>
<tr>
<td align="left">EXTRACT(type FROM d)</td>
<td align="left">从日期 d 中获取指定的值，type 指定返回的值。 type可取值为： MICROSECONDSECONDMINUTEHOURDAYWEEKMONTHQUARTERYEARSECOND_MICROSECONDMINUTE_MICROSECONDMINUTE_SECONDHOUR_MICROSECONDHOUR_SECONDHOUR_MINUTEDAY_MICROSECONDDAY_SECONDDAY_MINUTEDAY_HOURYEAR_MONTH</td>
<td align="left"><code>SELECT EXTRACT(MINUTE FROM &#39;2011-11-11 11:11:11&#39;)  -&gt; 11</code></td>
</tr>
<tr>
<td align="left">FROM_DAYS(n)</td>
<td align="left">计算从 0000 年 1 月 1 日开始 n 天后的日期</td>
<td align="left"><code>SELECT FROM_DAYS(1111) -&gt; 0003-01-16</code></td>
</tr>
<tr>
<td align="left">HOUR(t)</td>
<td align="left">返回 t 中的小时值</td>
<td align="left"><code>SELECT HOUR(&#39;1:2:3&#39;) -&gt; 1</code></td>
</tr>
<tr>
<td align="left">LAST_DAY(d)</td>
<td align="left">返回给给定日期的那一月份的最后一天</td>
<td align="left"><code>SELECT LAST_DAY(&quot;2017-06-20&quot;); -&gt; 2017-06-30</code></td>
</tr>
<tr>
<td align="left">LOCALTIME()</td>
<td align="left">返回当前日期和时间</td>
<td align="left"><code>SELECT LOCALTIME() -&gt; 2018-09-19 20:57:43</code></td>
</tr>
<tr>
<td align="left">LOCALTIMESTAMP()</td>
<td align="left">返回当前日期和时间</td>
<td align="left"><code>SELECT LOCALTIMESTAMP() -&gt; 2018-09-19 20:57:43</code></td>
</tr>
<tr>
<td align="left">MAKEDATE(year, day-of-year)</td>
<td align="left">基于给定参数年份 year 和所在年中的天数序号 day-of-year 返回一个日期</td>
<td align="left"><code>SELECT MAKEDATE(2017, 3); -&gt; 2017-01-03</code></td>
</tr>
<tr>
<td align="left">MAKETIME(hour, minute, second)</td>
<td align="left">组合时间，参数分别为小时、分钟、秒</td>
<td align="left"><code>SELECT MAKETIME(11, 35, 4); -&gt; 11:35:04</code></td>
</tr>
<tr>
<td align="left">MICROSECOND(date)</td>
<td align="left">返回日期参数所对应的微秒数</td>
<td align="left"><code>SELECT MICROSECOND(&quot;2017-06-20 09:34:00.000023&quot;); -&gt; 23</code></td>
</tr>
<tr>
<td align="left">MINUTE(t)</td>
<td align="left">返回 t 中的分钟值</td>
<td align="left"><code>SELECT MINUTE(&#39;1:2:3&#39;) -&gt; 2</code></td>
</tr>
<tr>
<td align="left">MONTHNAME(d)</td>
<td align="left">返回日期当中的月份名称，如 November</td>
<td align="left"><code>SELECT MONTHNAME(&#39;2011-11-11 11:11:11&#39;) -&gt; November</code></td>
</tr>
<tr>
<td align="left">MONTH(d)</td>
<td align="left">返回日期d中的月份值，1 到 12</td>
<td align="left"><code>SELECT MONTH(&#39;2011-11-11 11:11:11&#39;) -&gt;11</code></td>
</tr>
<tr>
<td align="left">NOW()</td>
<td align="left">返回当前日期和时间</td>
<td align="left"><code>SELECT NOW() -&gt; 2018-09-19 20:57:43</code></td>
</tr>
<tr>
<td align="left">PERIOD_ADD(period, number)</td>
<td align="left">为 年-月 组合日期添加一个时段</td>
<td align="left"><code>SELECT PERIOD_ADD(201703, 5);    -&gt; 201708</code></td>
</tr>
<tr>
<td align="left">PERIOD_DIFF(period1, period2)</td>
<td align="left">返回两个时段之间的月份差值</td>
<td align="left"><code>SELECT PERIOD_DIFF(201710, 201703); -&gt; 7</code></td>
</tr>
<tr>
<td align="left">QUARTER(d)</td>
<td align="left">返回日期d是第几季节，返回 1 到 4</td>
<td align="left"><code>SELECT QUARTER(&#39;2011-11-11 11:11:11&#39;) -&gt; 4</code></td>
</tr>
<tr>
<td align="left">SECOND(t)</td>
<td align="left">返回 t 中的秒钟值</td>
<td align="left"><code>SELECT SECOND(&#39;1:2:3&#39;) -&gt; 3</code></td>
</tr>
<tr>
<td align="left">SEC_TO_TIME(s)</td>
<td align="left">将以秒为单位的时间 s 转换为时分秒的格式</td>
<td align="left"><code>SELECT SEC_TO_TIME(4320) -&gt; 01:12:00</code></td>
</tr>
<tr>
<td align="left">STR_TO_DATE(string, format_mask)</td>
<td align="left">将字符串转变为日期</td>
<td align="left"><code>SELECT STR_TO_DATE(&quot;August 10 2017&quot;, &quot;%M %d %Y&quot;); -&gt; 2017-08-10</code></td>
</tr>
<tr>
<td align="left">SUBDATE(d,n)</td>
<td align="left">日期 d 减去 n 天后的日期</td>
<td align="left"><code>SELECT SUBDATE(&#39;2011-11-11 11:11:11&#39;, 1) -&gt;2011-11-10 11:11:11 (默认是天)</code></td>
</tr>
<tr>
<td align="left">SUBTIME(t,n)</td>
<td align="left">时间 t 减去 n 秒的时间</td>
<td align="left"><code>SELECT SUBTIME(&#39;2011-11-11 11:11:11&#39;, 5) -&gt;2011-11-11 11:11:06 (秒)</code></td>
</tr>
<tr>
<td align="left">SYSDATE()</td>
<td align="left">返回当前日期和时间</td>
<td align="left"><code>SELECT SYSDATE() -&gt; 2018-09-19 20:57:43</code></td>
</tr>
<tr>
<td align="left">TIME(expression)</td>
<td align="left">提取传入表达式的时间部分</td>
<td align="left"><code>SELECT TIME(&quot;19:30:10&quot;); -&gt; 19:30:10</code></td>
</tr>
<tr>
<td align="left">TIME_FORMAT(t,f)</td>
<td align="left">按表达式 f 的要求显示时间 t</td>
<td align="left"><code>SELECT TIME_FORMAT(&#39;11:11:11&#39;,&#39;%r&#39;) 11:11:11 AM</code></td>
</tr>
<tr>
<td align="left">TIME_TO_SEC(t)</td>
<td align="left">将时间 t 转换为秒</td>
<td align="left"><code>SELECT TIME_TO_SEC(&#39;1:12:00&#39;) -&gt; 4320</code></td>
</tr>
<tr>
<td align="left">TIMEDIFF(time1, time2)</td>
<td align="left">计算时间差值</td>
<td align="left"><code>mysql&gt; SELECT TIMEDIFF(&quot;13:10:11&quot;, &quot;13:10:10&quot;); -&gt; 00:00:01 mysql&gt; SELECT TIMEDIFF(&#39;2000:01:01 00:00:00&#39;,    -&gt;                 &#39;2000:01:01 00:00:00.000001&#39;);        -&gt; &#39;-00:00:00.000001&#39; mysql&gt; SELECT TIMEDIFF(&#39;2008-12-31 23:59:59.000001&#39;,    -&gt;                 &#39;2008-12-30 01:01:01.000002&#39;);        -&gt; &#39;46:58:57.999999&#39;</code></td>
</tr>
<tr>
<td align="left">TIMESTAMP(expression, interval)</td>
<td align="left">单个参数时，函数返回日期或日期时间表达式；有2个参数时，将参数加和</td>
<td align="left"><code>mysql&gt; SELECT TIMESTAMP(&quot;2017-07-23&quot;,  &quot;13:10:11&quot;); -&gt; 2017-07-23 13:10:11 mysql&gt; SELECT TIMESTAMP(&#39;2003-12-31&#39;);        -&gt; &#39;2003-12-31 00:00:00&#39; mysql&gt; SELECT TIMESTAMP(&#39;2003-12-31 12:00:00&#39;,&#39;12:00:00&#39;);        -&gt; &#39;2004-01-01 00:00:00&#39;</code></td>
</tr>
<tr>
<td align="left">TIMESTAMPDIFF(unit,datetime_expr1,datetime_expr2)</td>
<td align="left">计算时间差，返回 datetime_expr2 − datetime_expr1 的时间差</td>
<td align="left"><code>mysql&gt; SELECT TIMESTAMPDIFF(DAY,&#39;2003-02-01&#39;,&#39;2003-05-01&#39;);   // 计算两个时间相隔多少天        -&gt; 89 mysql&gt; SELECT TIMESTAMPDIFF(MONTH,&#39;2003-02-01&#39;,&#39;2003-05-01&#39;);   // 计算两个时间相隔多少月        -&gt; 3 mysql&gt; SELECT TIMESTAMPDIFF(YEAR,&#39;2002-05-01&#39;,&#39;2001-01-01&#39;);    // 计算两个时间相隔多少年        -&gt; -1 mysql&gt; SELECT TIMESTAMPDIFF(MINUTE,&#39;2003-02-01&#39;,&#39;2003-05-01 12:05:55&#39;);  // 计算两个时间相隔多少分钟        -&gt; 128885</code></td>
</tr>
<tr>
<td align="left">TO_DAYS(d)</td>
<td align="left">计算日期 d 距离 0000 年 1 月 1 日的天数</td>
<td align="left"><code>SELECT TO_DAYS(&#39;0001-01-01 01:01:01&#39;) -&gt; 366</code></td>
</tr>
<tr>
<td align="left">WEEK(d)</td>
<td align="left">计算日期 d 是本年的第几个星期，范围是 0 到 53</td>
<td align="left"><code>SELECT WEEK(&#39;2011-11-11 11:11:11&#39;) -&gt; 45</code></td>
</tr>
<tr>
<td align="left">WEEKDAY(d)</td>
<td align="left">日期 d 是星期几，0 表示星期一，1 表示星期二</td>
<td align="left"><code>SELECT WEEKDAY(&quot;2017-06-15&quot;); -&gt; 3</code></td>
</tr>
<tr>
<td align="left">WEEKOFYEAR(d)</td>
<td align="left">计算日期 d 是本年的第几个星期，范围是 0 到 53</td>
<td align="left"><code>SELECT WEEKOFYEAR(&#39;2011-11-11 11:11:11&#39;) -&gt; 45</code></td>
</tr>
<tr>
<td align="left">YEAR(d)</td>
<td align="left">返回年份</td>
<td align="left"><code>SELECT YEAR(&quot;2017-06-15&quot;); -&gt; 2017</code></td>
</tr>
<tr>
<td align="left">YEARWEEK(date, mode)</td>
<td align="left">返回年份及第几周（0到53），mode 中 0 表示周天，1表示周一，以此类推</td>
<td align="left"><code>SELECT YEARWEEK(&quot;2017-06-15&quot;); -&gt; 201724</code></td>
</tr>
</tbody></table>
<h4 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h4><table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">AVG(col)</td>
<td align="center">返回指定列的平均值</td>
</tr>
<tr>
<td align="center">COUNT(col)</td>
<td align="center">返回指定列非null值的个数</td>
</tr>
<tr>
<td align="center">MIN(col)</td>
<td align="center">返回指定列的最小值</td>
</tr>
<tr>
<td align="center">MAX(col)</td>
<td align="center">返回指定列的最大值</td>
</tr>
<tr>
<td align="center">SUM(col)</td>
<td align="center">返回指定列的所有值之和</td>
</tr>
</tbody></table>
<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>分组后只能查询分组的列和聚合列。</p>
<h2 id="语句的运行顺序："><a href="#语句的运行顺序：" class="headerlink" title="语句的运行顺序："></a>语句的运行顺序：</h2><ol>
<li>from</li>
<li>join…on…</li>
<li>where</li>
<li>group by</li>
<li>select</li>
<li>having</li>
<li>order by</li>
<li>limit</li>
</ol>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>node</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>node</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql的数据库操作</title>
    <url>/135xyq.github.io/2022/03/05/node-mysql-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a><a href="https://www.runoob.com/mysql/mysql-tutorial.html">数据库设计</a></h1><h2 id="管理数据库"><a href="#管理数据库" class="headerlink" title="管理数据库"></a>管理数据库</h2><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">craete database 数据库名;</span><br></pre></td></tr></table></figure>

<h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop database 数据库名;</span><br></pre></td></tr></table></figure>

<h3 id="使用数据库"><a href="#使用数据库" class="headerlink" title="使用数据库"></a>使用数据库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use 数据库名;</span><br></pre></td></tr></table></figure>

<h2 id="管理表"><a href="#管理表" class="headerlink" title="管理表"></a>管理表</h2><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE table_name (column_name column_type);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table student1 (</span><br><span class="line">    stuno int not null AUTO_INCREMENT,</span><br><span class="line">    name varchar(100) not null,</span><br><span class="line">    sex bit default 0,</span><br><span class="line">    birthday  date not null,</span><br><span class="line">    primary key(`stuno`)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>如果你不想字段为 NULL 可以设置字段的属性为 NOT NULL， 在操作数据库时如果输入该字段的数据为NULL ，就会报错。</li>
<li>AUTO_INCREMENT定义列为自增的属性，一般用于主键，数值会自动加1。</li>
<li>PRIMARY KEY关键字用于定义列为主键。 您可以使用多列来定义主键，列间以逗号分隔。</li>
<li>ENGINE 设置存储引擎，CHARSET 设置编码。</li>
</ul>
<h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO table_name ( field1, field2,...fieldN )</span><br><span class="line">                       VALUES</span><br><span class="line">                       ( value1, value2,...valueN );</span><br></pre></td></tr></table></figure>



<h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE table_name ;</span><br></pre></td></tr></table></figure>


<h2 id="主键和外键"><a href="#主键和外键" class="headerlink" title="主键和外键"></a>主键和外键</h2><h3 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h3><p>每张表都要有主键。</p>
<h4 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h4><ol>
<li>唯一</li>
<li>不能更改</li>
<li>无业务含义</li>
</ol>
<h3 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h3><p>另一个表的主键，连接另一个表。</p>
<h2 id="表关系"><a href="#表关系" class="headerlink" title="表关系"></a>表关系</h2><h3 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h3><p>一个A对应一个B，一个B对应一个A。<br>将一个表的主键同时设置为外键。</p>
<h3 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h3><p>一个A对应一个B，一个B对应一个A，A和B是一对多，B和A是多对一。</p>
<p>在多的那一端设置外键，对应另一张表的主键</p>
<h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><p>一个A对应多个B，一个B对应多个A。</p>
<p>需要新建一个关系表，关系表至少包含两个外键，分别对应到两张表。</p>
<h2 id="三大设计范式"><a href="#三大设计范式" class="headerlink" title="三大设计范式"></a>三大设计范式</h2><ol>
<li>要求数据库表的每一列是不可分割的原子数据项</li>
<li>非主键列必须依赖主键列</li>
<li>非主键列必须直接依赖主键列</li>
</ol>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>node</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>node</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql的数据库介绍</title>
    <url>/135xyq.github.io/2022/03/05/node-mysql-%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="数据库分类"><a href="#数据库分类" class="headerlink" title="数据库分类"></a>数据库分类</h2><h3 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>以表和表的关联构成的数据库。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>能表达复杂的数据关系；<br>强大的查询语言，能精确查找想要的数据。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>读写性能比较差；<br>数据结构比较死板。</p>
<h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><p>存储结构复杂的数据</p>
<h4 id="代表"><a href="#代表" class="headerlink" title="代表"></a>代表</h4><p>oracle、MySQL、sql  server</p>
<h3 id="非关系型数据库"><a href="#非关系型数据库" class="headerlink" title="非关系型数据库"></a>非关系型数据库</h3><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>极其简单的结构存储数据。</p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>格式灵活；<br>读写效率高。</p>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>难以表达复杂的数据结构；<br>对于复杂查询效率不好。</p>
<h4 id="用途-1"><a href="#用途-1" class="headerlink" title="用途"></a>用途</h4><p>存储结构简单的数据</p>
<h4 id="代表-1"><a href="#代表-1" class="headerlink" title="代表"></a>代表</h4><p>MongoDB、Redis、Membase</p>
<h3 id="面向对象数据库"><a href="#面向对象数据库" class="headerlink" title="面向对象数据库"></a>面向对象数据库</h3>]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>node</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>node</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql的数据库表的操作</title>
    <url>/135xyq.github.io/2022/03/05/node-mysql-%E8%A1%A8%E8%AE%B0%E5%BD%95%E7%9A%84%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9/</url>
    <content><![CDATA[<h1 id="数据库表的操作"><a href="#数据库表的操作" class="headerlink" title="数据库表的操作"></a><a href="https://www.runoob.com/mysql/mysql-where-clause.html">数据库表的操作</a></h1><h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO table_name ( field1, field2,...fieldN ) VALUES  ( value1, value2,...valueN );</span><br></pre></td></tr></table></figure>

<p>一次增加一条数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into student(stuno,name,sex,age) values(100,&#x27;xyq&#x27;,1,21);</span><br></pre></td></tr></table></figure>
<p>一次增加多条数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into student(stuno,name,sex,age) values(100,&#x27;xyq&#x27;,1,21),(101,&#x27;hsz&#x27;,0,20),(102,&#x27;csh&#x27;,1,21);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM table_name [WHERE Clause]</span><br></pre></td></tr></table></figure>

<h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE table_name SET field1=new-value1, field2=new-value2</span><br><span class="line">[WHERE Clause]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 将学号为100的用户名改为 谢永强</span><br><span class="line">update student set name =  &#x27;谢永强&#x27; where stuno = 100;</span><br></pre></td></tr></table></figure>


<h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><h3 id="单表基本查询"><a href="#单表基本查询" class="headerlink" title="单表基本查询"></a>单表基本查询</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT column_name,column_name</span><br><span class="line">FROM table_name</span><br><span class="line">[WHERE Clause]</span><br><span class="line">[LIMIT N][ OFFSET M] </span><br></pre></td></tr></table></figure>

<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><ul>
<li>as: 查询结果s定个别名；</li>
<li>*  : 查询所有列；</li>
<li>case: 对查询结果进一步处理</li>
<li>distinct:去重</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select name,case ismale when 1 then &#x27;男&#x27; else &#x27;女&#x27; end as &#x27;性别&#x27;, salary as &#x27;工资&#x27; from employee;</span><br></pre></td></tr></table></figure>

<h4 id="where"><a href="#where" class="headerlink" title="where"></a><a href="https://www.runoob.com/mysql/mysql-where-clause.html">where</a></h4><ul>
<li>in 在某个范围中</li>
</ul>
<h4 id="order-by-desc-降序-asc-降序"><a href="#order-by-desc-降序-asc-降序" class="headerlink" title="order by :desc 降序 asc 降序"></a>order by :desc 降序 asc 降序</h4><h4 id="limit：m-n-跳过n条数据，取出m条数据"><a href="#limit：m-n-跳过n条数据，取出m条数据" class="headerlink" title="limit：m,n 跳过n条数据，取出m条数据"></a>limit：m,n 跳过n条数据，取出m条数据</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询工资最高的女员工</span><br><span class="line"></span><br><span class="line">select * from employee  where ismale = 0  order by salary desc limit 0,1;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="联表查询"><a href="#联表查询" class="headerlink" title="联表查询"></a>联表查询</h3><ul>
<li>INNER JOIN（内连接,或等值连接）：获取两个表中字段匹配关系的记录。</li>
<li>LEFT JOIN（左连接）：获取左表所有记录，即使右表没有对应匹配的记录。</li>
<li>RIGHT JOIN（右连接）： 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。</li>
</ul>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>node</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>node</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>node的全局对象</title>
    <url>/135xyq.github.io/2022/02/25/node-node%E6%A0%B8%E5%BF%83-%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="全局对象"><a href="#全局对象" class="headerlink" title="全局对象"></a>全局对象</h1><h2 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h2><p>隔一段时间执行，返回值是一个对象</p>
<h2 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a>setInterval</h2><p>隔一段时间循环,返回值是一个对象</p>
<h2 id="setImmediate"><a href="#setImmediate" class="headerlink" title="setImmediate"></a>setImmediate</h2><p>立即执行 类似setTimeout 0</p>
<h2 id="console"><a href="#console" class="headerlink" title="console"></a>console</h2><p>控制台输出</p>
<h2 id="dirname"><a href="#dirname" class="headerlink" title="__dirname"></a>__dirname</h2><p>获取当前模块所在的目录（不是global里面的属性）</p>
<h2 id="filename"><a href="#filename" class="headerlink" title="__filename"></a>__filename</h2><p>获取当前模块的文件路径 (不是global里面的属性)</p>
<h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p>类型化数组 (继承自UInt8Array)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> buffer = Buffer.from(<span class="string">&#x27;abcdefg&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(buffer)</span><br><span class="line"></span><br><span class="line">结果：&lt;Buffer <span class="number">61</span> <span class="number">62</span> <span class="number">63</span> <span class="number">64</span> <span class="number">65</span> <span class="number">66</span> <span class="number">67</span>&gt;</span><br></pre></td></tr></table></figure>

<h2 id="process"><a href="#process" class="headerlink" title="process"></a>process</h2><h3 id="cwd-方法"><a href="#cwd-方法" class="headerlink" title="cwd 方法"></a>cwd 方法</h3><p>运行node命令，命令行所在的路径（当前进程的工作目录）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(process.cwd()); <span class="comment">//获取当前执行的语句</span></span><br><span class="line"></span><br><span class="line">结果：D:\学习\前端\前端代码\study</span><br></pre></td></tr></table></figure>

<h3 id="exit-方法"><a href="#exit-方法" class="headerlink" title="exit 方法"></a>exit 方法</h3><p>强制退出node进程，参数为0表示成功退出，为1表示有错误 ，默认为0</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;执行了！&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">process.exit()</span><br><span class="line"></span><br><span class="line">结果：不会输出 <span class="string">&#x27;执行了！&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="argv"><a href="#argv" class="headerlink" title="argv"></a>argv</h3><p>String[] ,获取命令行的所有参数</p>
<h3 id="platform"><a href="#platform" class="headerlink" title="platform"></a>platform</h3><p>获取当前的操作系统</p>
<h3 id="kill-pid-方法"><a href="#kill-pid-方法" class="headerlink" title="kill(pid) 方法"></a>kill(pid) 方法</h3><p>根据进程Id关闭进程</p>
<h3 id="env-对象"><a href="#env-对象" class="headerlink" title="env 对象"></a>env 对象</h3><p>获取环境变量对象</p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>node</category>
        <category>node核心</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>node的内置模块</title>
    <url>/135xyq.github.io/2022/02/25/node-node%E6%A0%B8%E5%BF%83-%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h1 id="内置模块"><a href="#内置模块" class="headerlink" title="内置模块"></a>内置模块</h1><h2 id="OS-操作系统"><a href="#OS-操作系统" class="headerlink" title="OS 操作系统"></a><a href="http://nodejs.cn/api/os.html">OS</a> 操作系统</h2><h3 id="EOL-常量"><a href="#EOL-常量" class="headerlink" title="EOL 常量"></a>EOL 常量</h3><p>一行结束的分隔符，会输出换行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">&#x27;os&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(os.EOL)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="arch-方法"><a href="#arch-方法" class="headerlink" title="arch 方法"></a>arch 方法</h3><p>获取CPU架构名 </p>
<h3 id="cpus-方法"><a href="#cpus-方法" class="headerlink" title="cpus 方法"></a>cpus 方法</h3><p>获取cpu内核，返回值为数组</p>
<h3 id="freemem-方法"><a href="#freemem-方法" class="headerlink" title="freemem 方法"></a>freemem 方法</h3><p>当前的空闲内存，返回值为整数(多少字节)</p>
<h3 id="homedir-方法"><a href="#homedir-方法" class="headerlink" title="homedir 方法"></a>homedir 方法</h3><p>用户目录</p>
<h3 id="hostname"><a href="#hostname" class="headerlink" title="hostname"></a>hostname</h3><p>主机名</p>
<h3 id="tmpdir-方法"><a href="#tmpdir-方法" class="headerlink" title="tmpdir 方法"></a>tmpdir 方法</h3><p>操作系统的临时目录</p>
<h2 id="path"><a href="#path" class="headerlink" title="path"></a><a href="http://nodejs.cn/api/path.html">path</a></h2><h3 id="basename-方法"><a href="#basename-方法" class="headerlink" title="basename 方法"></a>basename 方法</h3><p>文件名,第一个参数是文件路径，第二个参数是文件扩展名(可省略)(如果匹配上后缀名，输出就省去后缀名，匹配不上就不省略)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(path.basename(<span class="string">&#x27;dsgn/afsa/sdfas/a.js&#x27;</span>))</span><br><span class="line"></span><br><span class="line">输出：a.js</span><br></pre></td></tr></table></figure>

<h3 id="sep-属性"><a href="#sep-属性" class="headerlink" title="sep  属性"></a>sep  属性</h3><p>操作系统分隔符,window是\，Linux是 / </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(path.sep); <span class="comment">//分割符</span></span><br><span class="line"></span><br><span class="line">输出:\</span><br></pre></td></tr></table></figure>

<h3 id="delimiter-属性"><a href="#delimiter-属性" class="headerlink" title="delimiter 属性"></a>delimiter 属性</h3><p>路径定界符      ; 用于 Window   : 用于 POSIX</p>
<h3 id="dirname-方法"><a href="#dirname-方法" class="headerlink" title="dirname 方法"></a>dirname 方法</h3><p>返回目录名，参数为路径(string)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(path.dirname(<span class="string">&#x27;abc/def/fh/a.js&#x27;</span>));</span><br><span class="line"></span><br><span class="line">输出：abc/def/fh</span><br></pre></td></tr></table></figure>

<h3 id="extname-方法"><a href="#extname-方法" class="headerlink" title="extname 方法"></a>extname 方法</h3><p>获取后缀名 ，参数为文件路径</p>
<h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p>把多段路径拼接成一个路径</p>
<h3 id="resolve-方法"><a href="#resolve-方法" class="headerlink" title="resolve 方法"></a>resolve 方法</h3><p>转换为绝对路径 </p>
<h2 id="url"><a href="#url" class="headerlink" title="url"></a><a href="http://nodejs.cn/api/url.html">url</a></h2><p>是一个类</p>
<h2 id="util"><a href="#util" class="headerlink" title="util"></a><a href="http://nodejs.cn/api/util.html">util</a></h2><h3 id="callbackify-方法"><a href="#callbackify-方法" class="headerlink" title="callbackify 方法"></a>callbackify 方法</h3><p>把一个异步函数转为回调函数形式</p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>node</category>
        <category>node核心</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>node的文件流</title>
    <url>/135xyq.github.io/2022/03/05/node-node%E6%A0%B8%E5%BF%83-%E6%96%87%E4%BB%B6%E6%B5%81/</url>
    <content><![CDATA[<h1 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h1><p>流是指数据的流动，数据从一个地方缓慢的流动到一个地方。流是有方向的</p>
<p>流的分类：</p>
<ul>
<li>可读流：Readable  数据从源头流向内存；</li>
<li>可写流：Writable  数据从内存流向源头；</li>
<li>双工流：Duplex  数据既可以从源头流向内存，又可以从内存流向源头；</li>
</ul>
<h2 id="文件可读流"><a href="#文件可读流" class="headerlink" title="文件可读流"></a>文件可读流</h2><h3 id="fs-craeteReadStream-path-options"><a href="#fs-craeteReadStream-path-options" class="headerlink" title="fs.craeteReadStream(path,[options])"></a>fs.craeteReadStream(path,[options])</h3><p>创建一个文件可读流，用于读取文件内容</p>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>path:读取文件路径<br>options：配置</p>
<ul>
<li>ecoding：编码方式，默认为null,读出内容为buffer</li>
<li>start：起始字节</li>
<li>end：结束字节</li>
<li>highWaterMark：每次读取字节数，默认为 64*1024字节</li>
<li>autoClose：读完后自动关闭，默认值为true</li>
</ul>
<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>Readable的子类ReadStream</p>
<h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>通过返回值得到的ReadStream的绑定，<code> .on(事件种类，函数)</code></p>
<h5 id="open"><a href="#open" class="headerlink" title="open"></a>open</h5><p>文件打开事件，文件被打开时触发</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> rs = fs.createReadStream(filename, &#123;</span><br><span class="line">    <span class="attr">encoding</span>: <span class="string">&#x27;utf-8&#x27;</span>,</span><br><span class="line">    <span class="attr">highWaterMark</span>: <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件打开事件</span></span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">&#x27;open&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;文件被打开了!&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="close"><a href="#close" class="headerlink" title="close"></a>close</h5><p>文件关闭后触发</p>
<p>文件关闭的两种方法：</p>
<ol>
<li>可读流.close();  手动关闭</li>
<li>文件读完后自动关闭</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">test.txt:  I am a Chinese!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建文件可读流</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rs = fs.createReadStream(filename, &#123;</span><br><span class="line">    <span class="attr">encoding</span>: <span class="string">&#x27;utf-8&#x27;</span>,</span><br><span class="line">    <span class="attr">highWaterMark</span>: <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件关闭事件</span></span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">&#x27;close&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;文件关闭!&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">rs.close();</span><br><span class="line"></span><br><span class="line">输出：文件关闭！</span><br></pre></td></tr></table></figure>

<h5 id="error"><a href="#error" class="headerlink" title="error"></a>error</h5><p>读取文件出现错误</p>
<h5 id="data"><a href="#data" class="headerlink" title="data"></a>data</h5><p>读取到一部分数据后触发，注册data后才会开始读取文件，每次读取highWaterMark指定的数量，回调函数中会附带读到的数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> filename = path.resolve(__dirname, <span class="string">&#x27;./test.txt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建文件可读流</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rs = fs.createReadStream(filename, &#123;</span><br><span class="line">    <span class="attr">encoding</span>: <span class="string">&#x27;utf-8&#x27;</span>,</span><br><span class="line">    <span class="attr">highWaterMark</span>: <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件读取事件</span></span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">chunk</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;文件内容：&#x27;</span>, chunk)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">文件内容： I</span><br><span class="line">文件内容：  </span><br><span class="line">文件内容： a</span><br><span class="line">文件内容： m</span><br><span class="line">文件内容：  </span><br><span class="line">文件内容： a</span><br><span class="line">文件内容：  </span><br><span class="line">文件内容： C</span><br><span class="line">文件内容： h</span><br><span class="line">文件内容： i</span><br><span class="line">文件内容： n</span><br><span class="line">文件内容： e</span><br><span class="line">文件内容： s</span><br><span class="line">文件内容： e</span><br><span class="line">文件内容： !</span><br></pre></td></tr></table></figure>


<h5 id="end"><a href="#end" class="headerlink" title="end"></a>end</h5><p>全部数据读取完毕！</p>
<h4 id="rs-pause"><a href="#rs-pause" class="headerlink" title="rs.pause()"></a>rs.pause()</h4><p>暂停读取，会触发pause事件</p>
<h4 id="rs-resume"><a href="#rs-resume" class="headerlink" title="rs.resume()"></a>rs.resume()</h4><p>恢复读取，会触发resume事件</p>
<h2 id="文件可写流"><a href="#文件可写流" class="headerlink" title="文件可写流"></a>文件可写流</h2><h3 id="fs-craeteWriteStream-path-options"><a href="#fs-craeteWriteStream-path-options" class="headerlink" title="fs.craeteWriteStream(path,[options])"></a>fs.craeteWriteStream(path,[options])</h3><h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h4><p>path: 路径<br>options:配置</p>
<ul>
<li>flags: 操作文件的方式，w:覆盖文件；a:追加文件；</li>
<li>ecoding: 编码方式，默认UTF-8</li>
<li>start：起始字节</li>
<li>highWaterMark：每次最多写入的字节数</li>
</ul>
<h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><p>Writable的子类WriteStream</p>
<h4 id="事件-1"><a href="#事件-1" class="headerlink" title="事件"></a>事件</h4><p><code> .on(事件种类，函数)</code></p>
<h5 id="open-1"><a href="#open-1" class="headerlink" title="open"></a>open</h5><p>打开文件</p>
<h5 id="error-1"><a href="#error-1" class="headerlink" title="error"></a>error</h5><p>读取文件出错</p>
<h5 id="close-1"><a href="#close-1" class="headerlink" title="close"></a>close</h5><p>关闭文件</p>
<h4 id="ws-write-data"><a href="#ws-write-data" class="headerlink" title="ws.write(data)"></a>ws.write(data)</h4><p>写入一组数据，data：字符串或buffer</p>
<p>返回值为boolean值：</p>
<ul>
<li>true：写入通道没有被填满，接下来的数据可以直接写入，无需排队；</li>
<li>false：写入通道已被填满，接下来的数据将进入写入队列；<br>当写入队列排满后再清空时，会触发drain事件。</li>
</ul>
<h4 id="ws-end-data"><a href="#ws-end-data" class="headerlink" title="ws.end([data])"></a>ws.end([data])</h4><p>需要手动调用；<br>结束写入，将自动关闭文件；<br>data是可选的，表示关闭前的最后一次写入内容；</p>
<h2 id="rs-pipe-ws"><a href="#rs-pipe-ws" class="headerlink" title="rs.pipe(ws)"></a>rs.pipe(ws)</h2><p>将可读流连接到可写流，可解决背压问题；返回值为ws</p>
<h3 id="文件复制"><a href="#文件复制" class="headerlink" title="文件复制"></a>文件复制</h3><h4 id="使用pipe"><a href="#使用pipe" class="headerlink" title="使用pipe"></a>使用pipe</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">from</span> = path.resolve(__dirname, <span class="string">&#x27;./test.png&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> to = path.resolve(__dirname, <span class="string">&#x27;./testCopy.png&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rs = fs.createReadStream(<span class="keyword">from</span>);</span><br><span class="line"><span class="keyword">const</span> ws = fs.createWriteStream(to);</span><br><span class="line"></span><br><span class="line">rs.pipe(ws);</span><br></pre></td></tr></table></figure>

<h4 id="手写，使用可读流和可写流"><a href="#手写，使用可读流和可写流" class="headerlink" title="手写，使用可读流和可写流"></a>手写，使用可读流和可写流</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">from</span> = path.resolve(__dirname, <span class="string">&#x27;./test.png&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> to = path.resolve(__dirname, <span class="string">&#x27;./testCopy.png&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rs = fs.createReadStream(<span class="keyword">from</span>);</span><br><span class="line"><span class="keyword">const</span> ws = fs.createWriteStream(to);</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">chunk</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> flag = ws.write(chunk);</span><br><span class="line">    <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">        <span class="comment">// 写入队列即将排满</span></span><br><span class="line">        rs.pause(); <span class="comment">//暂停</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ws.on(<span class="string">&#x27;drain&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    rs.resume(); <span class="comment">//继续读</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    ws.end(); <span class="comment">//结束写入</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;复制完成！&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="使用readFile和writeFile"><a href="#使用readFile和writeFile" class="headerlink" title="使用readFile和writeFile"></a>使用readFile和writeFile</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">from</span> = path.resolve(__dirname, <span class="string">&#x27;./test.png&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> to = path.resolve(__dirname, <span class="string">&#x27;./testCopy.png&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fileContent = fs.promises.readFile(<span class="keyword">from</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    fs.promises.writeFile(to, data).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;复制完成！&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>node</category>
        <category>node核心</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>node</tag>
        <tag>文件操作</tag>
      </tags>
  </entry>
  <entry>
    <title>node的文件IO</title>
    <url>/135xyq.github.io/2022/03/05/node-node%E6%A0%B8%E5%BF%83-%E6%96%87%E4%BB%B6IO/</url>
    <content><![CDATA[<h1 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h1><h2 id="fs文件系统"><a href="#fs文件系统" class="headerlink" title="fs文件系统"></a><a href="http://nodejs.cn/api/fs.html">fs文件系统</a></h2><p>内置模块</p>
<h3 id="readFile-path-options-callback"><a href="#readFile-path-options-callback" class="headerlink" title="readFile(path,[, options], callback)"></a>readFile(path,[, options], callback)</h3><p>异步地读取文件的全部内容，有回调函数。得到的是字节，可以使用toString(‘utf-8’)将其编码成正常字符串;还可以在第二个参数进行配置如‘utf-8’,直接可以得到字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.txt  :  I am a Chinese.</span></span><br><span class="line"></span><br><span class="line">读取test.txt文件内容</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> filename = path.resolve(__dirname, <span class="string">&#x27;./test.txt&#x27;</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(filename, <span class="function">(<span class="params">error, content</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(content);</span><br><span class="line">    <span class="built_in">console</span>.log(content.toString(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">输出：&lt;Buffer <span class="number">49</span> <span class="number">20</span> <span class="number">61</span> 6d <span class="number">20</span> <span class="number">61</span> <span class="number">20</span> <span class="number">20</span> <span class="number">43</span> <span class="number">68</span> <span class="number">69</span> 6e <span class="number">65</span> <span class="number">73</span> <span class="number">65</span> 2e&gt;</span><br><span class="line">	I am a  Chinese.</span><br></pre></td></tr></table></figure>

<h3 id="fs-promises-readFile-path-options"><a href="#fs-promises-readFile-path-options" class="headerlink" title="fs.promises.readFile(path[, options])"></a>fs.promises.readFile(path[, options])</h3><p>异步地读取文件的全部内容，返回promise</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// test.txt  :  I am a Chinese.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> filename = path.resolve(__dirname, <span class="string">&#x27;./test.txt&#x27;</span>);</span><br><span class="line"></span><br><span class="line">fs.promises.readFile(filename, <span class="string">&#x27;utf-8&#x27;</span>).then(<span class="function">(<span class="params">resp</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(resp)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">输出：   I am a Chinese.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="fs-readFileSync-path-options"><a href="#fs-readFileSync-path-options" class="headerlink" title="fs.readFileSync(path[, options])"></a>fs.readFileSync(path[, options])</h3><p>同步返回 path 的内容。(会导致JS运行阻塞，影响性能)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.txt  :  I am a Chinese.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> filename = path.resolve(__dirname, <span class="string">&#x27;./test.txt&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fs.readFileSync(filename, <span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">输出： I am a Chinese.</span><br></pre></td></tr></table></figure>

<h3 id="fs-promises-writeFile-file-data-options"><a href="#fs-promises-writeFile-file-data-options" class="headerlink" title="fs.promises.writeFile(file, data[, options])"></a>fs.promises.writeFile(file, data[, options])</h3><p>写文件,默认会覆盖原来的内容；可以设置配置参数flag的值为 </p>
<ul>
<li> a : 追加 ，在原有内容后面追加</li>
<li> w: 写；覆盖原有内容</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//test.txt:  I am a Chinese.</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> filename = path.resolve(__dirname, <span class="string">&#x27;./test.txt&#x27;</span>);</span><br><span class="line"></span><br><span class="line">fs.promises.writeFile(filename, <span class="string">&#x27;I am xyq!&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// test.txt: I am xyq!</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="fs-stat-path-options"><a href="#fs-stat-path-options" class="headerlink" title="fs.stat(path[, options])"></a>fs.stat(path[, options])</h3><p>获取文件或目录的信息</p>
<ul>
<li>size: 占用字节</li>
<li>atime：上次访问时间</li>
<li>mtime：上次文件内容被修改时间</li>
<li>ctime：上次文件状态被修改时间</li>
<li>birthtime：文件创建时间</li>
<li>isDirectory()：判断是否是目录</li>
<li>isFile()：判断是否是文件</li>
</ul>
<h3 id="fs-readdir"><a href="#fs-readdir" class="headerlink" title="fs.readdir"></a>fs.readdir</h3><p>获取目录中的文件和子目录</p>
<h3 id="fs-mkdir"><a href="#fs-mkdir" class="headerlink" title="fs.mkdir"></a>fs.mkdir</h3><p>创建目录</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在当前目录创建1-5,5个目录</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    fs.promises.mkdir(path.resolve(__dirname) + <span class="string">`/<span class="subst">$&#123;i&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="fs-exists"><a href="#fs-exists" class="headerlink" title="fs.exists"></a>fs.exists</h3><p>判断文件或目录是否存在</p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>node</category>
        <category>node核心</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>node</tag>
        <tag>文件操作</tag>
      </tags>
  </entry>
  <entry>
    <title>node的网络通信</title>
    <url>/135xyq.github.io/2022/03/05/node-node%E6%A0%B8%E5%BF%83-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h1 id="net-http-https"><a href="#net-http-https" class="headerlink" title="net,http,https"></a>net,http,https</h1><h2 id="net模块"><a href="#net模块" class="headerlink" title="net模块"></a>net模块</h2><h3 id="创建客户端"><a href="#创建客户端" class="headerlink" title="创建客户端"></a>创建客户端</h3><p><strong>响应头和响应体应该使用两个换行隔开</strong></p>
<h4 id="createConnection-options-callback"><a href="#createConnection-options-callback" class="headerlink" title="createConnection(options,callback);"></a>createConnection(options,callback);</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">&#x27;net&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> socket = net.createConnection(&#123;</span><br><span class="line">    <span class="attr">host</span>: <span class="string">&#x27;xyq135.com&#x27;</span>,</span><br><span class="line">    <span class="attr">port</span>: <span class="number">80</span></span><br><span class="line">&#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;连接成功！&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><p>options：配置参数</p>
<ul>
<li>host：主机名</li>
<li>prot：端口号</li>
</ul>
<p>callback:监听函数</p>
<p>callback:处理函数</p>
<h5 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h5><p>返回值为：socket，是一个特殊的文件，<br>在node中变现为<strong>双工流</strong>对象：通过向流写入内容来发送数据，通过监听流的内容获取数据</p>
<h3 id="创建服务端"><a href="#创建服务端" class="headerlink" title="创建服务端"></a>创建服务端</h3><h4 id="net-createServer"><a href="#net-createServer" class="headerlink" title="net.createServer()"></a>net.createServer()</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">&#x27;net&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = net.createServer();</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">9527</span>);</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">&#x27;listening&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;server正在监听9527&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">&#x27;connection&#x27;</span>, <span class="function"><span class="params">socket</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;有客户端连接！&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h5><p>server对象。</p>
<h6 id="server-listen-port"><a href="#server-listen-port" class="headerlink" title="server.listen(port)"></a>server.listen(port)</h6><p>监听每个端口</p>
<h6 id="server-on-‘listening’-gt"><a href="#server-on-‘listening’-gt" class="headerlink" title="server.on(‘listening’,()=&gt;{})"></a>server.on(‘listening’,()=&gt;{})</h6><p>开始监听端口后触发的事件</p>
<h6 id="server-on-‘connection’-socket-gt"><a href="#server-on-‘connection’-socket-gt" class="headerlink" title="server.on(‘connection’,socket=&gt;{})"></a>server.on(‘connection’,socket=&gt;{})</h6><p>某个连接到来时触发该事件。<br>事件监听函数会获得<strong>socket对象</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">&#x27;net&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = net.createServer();</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">9527</span>);</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">&#x27;listening&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;server正在监听9527&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">&#x27;connection&#x27;</span>, <span class="function"><span class="params">socket</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;有客户端连接！&#x27;</span>)</span><br><span class="line">    socket.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">chunk</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;客户端请求：&#x27;</span>, chunk.toString(<span class="string">&#x27;utf-8&#x27;</span>));</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    socket.write(<span class="string">`HTTP/1.1 200 OK</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">&lt;head&gt;&lt;title&gt;404 Not Found&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">&lt;center&gt;&lt;h1&gt;404 Not Found&lt;/h1&gt;&lt;/center&gt;</span></span><br><span class="line"><span class="string">&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">&lt;!-- a padding to disable MSIE and Chrome friendly error page --&gt;</span></span><br><span class="line"><span class="string">&lt;!-- a padding to disable MSIE and Chrome friendly error page --&gt;</span></span><br><span class="line"><span class="string">&lt;!-- a padding to disable MSIE and Chrome friendly error page --&gt;</span></span><br><span class="line"><span class="string">&lt;!-- a padding to disable MSIE and Chrome friendly error page --&gt;</span></span><br><span class="line"><span class="string">&lt;!-- a padding to disable MSIE and Chrome friendly error page --&gt;</span></span><br><span class="line"><span class="string">&lt;!-- a padding to disable MSIE and Chrome friendly error page --&gt;</span></span><br><span class="line"><span class="string">`</span>)<span class="comment">//响应给客户端的数据</span></span><br><span class="line"></span><br><span class="line">    socket.end();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>




<h2 id="http模块"><a href="#http模块" class="headerlink" title="http模块"></a>http模块</h2><h3 id="http-request-url-options-callback"><a href="#http-request-url-options-callback" class="headerlink" title="http.request(url[, options][, callback])"></a><a href="http://nodejs.cn/api/http.html#httprequestoptions-callback">http.request(url[, options][, callback])</a></h3><p>发送请求</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> request = http.request(<span class="string">&quot;http://nodejs.cn/api/http.html#httprequestoptions-callback&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">&#125;, <span class="function"><span class="params">resp</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;状态码:&#x27;</span>, resp.statusCode);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;响应头:&#x27;</span>, resp.headers);</span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    resp.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">chunk</span> =&gt;</span> &#123;</span><br><span class="line">        result += chunk.toString(<span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    resp.on(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;响应体：&#x27;</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">request.end();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>方法返回结果为可写流，需要使用request.write()写入请求体，使用request.end()结束写入。</p>
<h3 id="http-createServer-options-requestListener"><a href="#http-createServer-options-requestListener" class="headerlink" title="http.createServer([options][, requestListener])"></a><a href="http://nodejs.cn/api/http.html#httpcreateserveroptions-requestlistener">http.createServer([options][, requestListener])</a></h3><p>创建服务器</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;有请求来了!&#x27;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;请求地址:&#x27;</span>, req.url);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;请求方法:&#x27;</span>, req.method);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;请求头:&#x27;</span>, req.headers);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> body = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    req.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">chunk</span> =&gt;</span> &#123;</span><br><span class="line">        body += chunk.toString(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    req.on(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;请求体:&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(body);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置响应头信息</span></span><br><span class="line">    res.setHeader(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;xyq&#x27;</span>);</span><br><span class="line">    res.setHeader(<span class="string">&#x27;lover&#x27;</span>, <span class="string">&#x27;hsz&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置响应码</span></span><br><span class="line">    res.statusCode = <span class="number">404</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置响应体</span></span><br><span class="line">    res.write(<span class="string">&#x27;I love you!&#x27;</span>);</span><br><span class="line">    res.end();</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8080</span>)</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">&#x27;listening&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;正在监听8080&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<p>客户端：</p>
<ul>
<li>请求：<a href="http://nodejs.cn/api/http.html#class-httpclientrequest">ClientRequest</a>对象</li>
<li>响应：<a href="http://nodejs.cn/api/http.html#class-httpincomingmessage">IncomingMessage</a>对象</li>
</ul>
<p>服务端</p>
<ul>
<li>请求：<a href="http://nodejs.cn/api/http.html#class-httpincomingmessage">IncomingMessage</a>对象</li>
<li>响应：<a href="http://nodejs.cn/api/http.html#class-httpserverresponse">ServerResponse</a>对象</li>
</ul>
<p>静态资源服务器(使用简单的readFile读取文件)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(handleServer);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">9000</span>);</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">&#x27;listening&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;server listening 9000!&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理服务器函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>req </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>res </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">handleServer</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> requestUrl = req.url; <span class="comment">//客户端请求的地址</span></span><br><span class="line">    <span class="keyword">const</span> fileContent = <span class="keyword">await</span> getFileContent(requestUrl);</span><br><span class="line">    <span class="keyword">if</span> (!fileContent) &#123;</span><br><span class="line">        <span class="comment">// 文件存在</span></span><br><span class="line">        res.write(fileContent)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 文件不存在</span></span><br><span class="line">        res.statusCode = <span class="number">404</span>;</span><br><span class="line">        res.write(<span class="string">&#x27;sources is not exit!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    res.end();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取文件状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getState</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> fs.promises.stat(filename)</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 要处理的文件内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>requestUrl 路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getFileContent</span>(<span class="params">requestUrl</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> urlObj = url.parse(requestUrl);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> filename;</span><br><span class="line">    filename = path.resolve(__dirname, <span class="string">&#x27;public&#x27;</span>, urlObj.pathname.substr(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">let</span> stat = <span class="keyword">await</span> getState(filename);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stat) &#123;</span><br><span class="line">        <span class="comment">// 文件不存在</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stat.isDirectory()) &#123;</span><br><span class="line">        <span class="comment">// 是一个目录</span></span><br><span class="line">        <span class="comment">// 则继续请求目录下的index.html文件</span></span><br><span class="line">        filename = path.resolve(__dirname, <span class="string">&#x27;public&#x27;</span>, urlObj.pathname.substr(<span class="number">1</span>), <span class="string">&#x27;index.html&#x27;</span>);</span><br><span class="line">        stat = <span class="keyword">await</span> getState(filename);</span><br><span class="line">        <span class="keyword">if</span> (!stat) &#123;</span><br><span class="line">            <span class="comment">// 文件不存在</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 文件存在，返回文件的内容</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> fs.promises.readFile(filename);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 文件存在</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> fs.promises.readFile(filename);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>搭建静态资源服务器(通过流来读取)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(handleServer);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">9000</span>);</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">&#x27;listening&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;server listening 9000!&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理服务器函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>req </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>res </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">handleServer</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> requestUrl = req.url; <span class="comment">//客户端请求的地址</span></span><br><span class="line">    <span class="keyword">const</span> fileContent = <span class="keyword">await</span> getFileContent(requestUrl, res);</span><br><span class="line">    <span class="keyword">if</span> (!fileContent) &#123;</span><br><span class="line">        <span class="comment">// 文件不存在</span></span><br><span class="line">        res.statusCode = <span class="number">404</span>;</span><br><span class="line">        res.write(<span class="string">&#x27;sources is not exit!&#x27;</span>);</span><br><span class="line">        res.end();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取文件状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getState</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> fs.promises.stat(filename)</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 要处理的文件内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>requestUrl 路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getFileContent</span>(<span class="params">requestUrl, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> urlObj = url.parse(requestUrl);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> filename;</span><br><span class="line">    filename = path.resolve(__dirname, <span class="string">&#x27;public&#x27;</span>, urlObj.pathname.substr(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">let</span> stat = <span class="keyword">await</span> getState(filename);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!stat) &#123;</span><br><span class="line">        <span class="comment">// 文件不存在</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stat.isDirectory()) &#123;</span><br><span class="line">        <span class="comment">// 是一个目录</span></span><br><span class="line">        <span class="comment">// 则继续请求目录下的index.html文件</span></span><br><span class="line">        filename = path.resolve(__dirname, <span class="string">&#x27;public&#x27;</span>, urlObj.pathname.substr(<span class="number">1</span>), <span class="string">&#x27;index.html&#x27;</span>);</span><br><span class="line">        stat = <span class="keyword">await</span> getState(filename);</span><br><span class="line">        <span class="keyword">if</span> (!stat) &#123;</span><br><span class="line">            <span class="comment">// 文件不存在</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 文件存在，直接写入</span></span><br><span class="line">            readFileStream(filename, res);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 文件存在</span></span><br><span class="line">        readFileStream(filename, res);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过获取文件名和写入流来将文件内容写入</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>filename </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>res </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFileStream</span>(<span class="params">filename, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> rs = fs.createReadStream(filename);</span><br><span class="line"></span><br><span class="line">    rs.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">chunk</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> flag = res.write(chunk);</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            <span class="comment">// 写入队列即将排满</span></span><br><span class="line">            rs.pause();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    res.on(<span class="string">&#x27;drain&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        rs.resume();</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    rs.on(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        res.end();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="https协议"><a href="#https协议" class="headerlink" title="https协议"></a>https协议</h2><p>https协议保证数据在传输过程中不被窃取或篡改。</p>
<h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><h4 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h4><p>产生一个秘钥，既可以加密，又可以解密。</p>
<p>常用算法：DE3、3DES、AES、Blowfish </p>
<h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h4><p>产生一堆秘钥，一个用于加密，一个用于解密。<br>一个公钥，一个私钥。</p>
<p>常用算法：RSA、Elgamal、Rabin、D-H、ECC。</p>
<p>https的默认端口是443。</p>
<h2 id="https模块"><a href="#https模块" class="headerlink" title="https模块"></a>https模块</h2>]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>node</category>
        <category>node核心</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>node</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>node服务器处理常见场景</title>
    <url>/135xyq.github.io/2022/03/17/node-%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF-%E5%B8%B8%E8%A7%81%E6%83%85%E5%86%B5/</url>
    <content><![CDATA[<h1 id="常用的场景"><a href="#常用的场景" class="headerlink" title="常用的场景"></a>常用的场景</h1><h2 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h2><p>常用的express中间件<a href="https://log4js-node.github.io/log4js-node/">log4</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置</span></span><br><span class="line">log4js.configure(&#123;</span><br><span class="line">    <span class="comment">// 出口</span></span><br><span class="line">    <span class="attr">appenders</span>: &#123;</span><br><span class="line">        <span class="attr">sql</span>: &#123;</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;dateFile&#x27;</span>, <span class="comment">//file普通文件，dateFile日期文件在备份时会在文件名中加入日期</span></span><br><span class="line">            <span class="attr">filename</span>: path.resolve(__dirname, <span class="string">&#x27;logs&#x27;</span>, <span class="string">&#x27;sql&#x27;</span>, <span class="string">&#x27;logging.log&#x27;</span>), <span class="comment">//写入文件地址</span></span><br><span class="line">            <span class="attr">maxLogSize</span>: <span class="number">2</span> ** <span class="number">20</span>, <span class="comment">// 一个文件写入的最大字节数，超过之后会自动备份到其他文件</span></span><br><span class="line">            <span class="attr">keepFileExt</span>: <span class="literal">true</span>, <span class="comment">//保留备份文件的后缀名</span></span><br><span class="line">            <span class="comment">// daysToKeep: 0, // 文件会保留多少天，默认为0，一直保留</span></span><br><span class="line">            <span class="comment">// 写入的格式</span></span><br><span class="line">            <span class="attr">layout</span>: &#123;</span><br><span class="line">                <span class="attr">type</span>: <span class="string">&#x27;pattern&#x27;</span>, <span class="comment">//pattern是自定义样式</span></span><br><span class="line">                <span class="attr">pattern</span>: <span class="string">&#x27;%c: %d&#123;yyyy-MM-dd hh:mm:ss&#125; %p  %m%n&#x27;</span> <span class="comment">//写入文件的格式</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">default</span>: &#123;</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;stdout&#x27;</span>, <span class="comment">//标准控制台输出</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 分类</span></span><br><span class="line">    <span class="attr">categories</span>: &#123;</span><br><span class="line">        <span class="attr">sql</span>: &#123;</span><br><span class="line">            <span class="attr">appenders</span>: [<span class="string">&quot;sql&quot;</span>], <span class="comment">//该出口使用出口sql的配置</span></span><br><span class="line">            <span class="attr">level</span>: <span class="string">&#x27;all&#x27;</span>, <span class="comment">//级别配置</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">default</span>: &#123;</span><br><span class="line">            <span class="attr">appenders</span>: [<span class="string">&quot;default&quot;</span>], <span class="comment">//该出口使用出口default的配置</span></span><br><span class="line">            <span class="attr">level</span>: <span class="string">&#x27;all&#x27;</span>, <span class="comment">//级别配置</span></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//程序要退出时运行shutdown记录完日志</span></span><br><span class="line">process.on(<span class="string">&#x27;exit&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    log4js.shutdown();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sqlLogger = log4js.getLogger(<span class="string">&#x27;sql&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> logger = log4js.getLogger();</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    sqlLogger,</span><br><span class="line">    logger,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><h3 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;img&quot;</span> <span class="attr">multiple</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span>&gt;</span>上传<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> inputFile = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;[name=img&#x27;</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">upload</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> formData = <span class="keyword">new</span> FormData(); <span class="comment">//构建一个form-data格式的消息体</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">for</span> (<span class="keyword">const</span> img <span class="keyword">of</span> inputFile.files) &#123;</span></span><br><span class="line"><span class="javascript">                formData.append(<span class="string">&#x27;img&#x27;</span>, img, img.name);</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">            fetch(<span class="string">&#x27;/api/upload&#x27;</span>, &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="attr">body</span>: formData,</span></span><br><span class="line"><span class="javascript">                &#125;)</span></span><br><span class="line"><span class="javascript">                .then(<span class="function">(<span class="params">resp</span>) =&gt;</span> resp.text())</span></span><br><span class="line"><span class="javascript">                .then(<span class="function">(<span class="params">resp</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(resp)</span></span><br><span class="line"><span class="javascript">                &#125;)</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.querySelector(<span class="string">&#x27;button&#x27;</span>).onclick = upload;</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>使用express中间件<a href="https://github.com/expressjs/multer/blob/master/doc/README-zh-cn.md">multer</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件上传</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> multer = <span class="built_in">require</span>(<span class="string">&#x27;multer&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> getMsg = <span class="built_in">require</span>(<span class="string">&#x27;../getSendResult&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = express.Router();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 要存储的文件地址和文件名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> storage = multer.diskStorage(&#123;</span><br><span class="line">    <span class="attr">destination</span>: <span class="function"><span class="keyword">function</span>(<span class="params">req, file, cb</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> distName = path.resolve(__dirname, <span class="string">&#x27;../../public/upload&#x27;</span>);</span><br><span class="line">        cb(<span class="literal">null</span>, distName)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">filename</span>: <span class="function"><span class="keyword">function</span>(<span class="params">req, file, cb</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 文件名等于时间戳-xyqihsz后缀名</span></span><br><span class="line">        <span class="keyword">const</span> filename = <span class="built_in">Date</span>.now() + <span class="string">&#x27;-xyqihsz&#x27;</span> + path.extname(file.originalname);</span><br><span class="line">        cb(<span class="literal">null</span>, filename)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fileFilter</span>(<span class="params">req, file, cb</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 允许上传的文件类型</span></span><br><span class="line">    <span class="keyword">const</span> whiteList = [<span class="string">&#x27;.jpg&#x27;</span>, <span class="string">&#x27;.png&#x27;</span>, <span class="string">&#x27;.jpeg&#x27;</span>, <span class="string">&#x27;.gif&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span> (whiteList.includes(path.extname(file.originalname))) &#123;</span><br><span class="line">        cb(<span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//处理异常</span></span><br><span class="line">        cb(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`you upload file extname &#x27;<span class="subst">$&#123;path.extname(file.originalname)&#125;</span>&#x27; is not support!`</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> upload = multer(&#123;</span><br><span class="line">    storage,</span><br><span class="line">    <span class="attr">limits</span>: &#123;</span><br><span class="line">        <span class="attr">fileSize</span>: <span class="number">150</span> * <span class="number">1024</span>,</span><br><span class="line">    &#125;, <span class="comment">//限制文件大小</span></span><br><span class="line">    fileFilter</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">router.post(<span class="string">&#x27;/&#x27;</span>, upload.single(<span class="string">&#x27;img&#x27;</span>), <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.send(getMsg.getResult(&#123;</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;upload/&#x27;</span> + req.file.filename,</span><br><span class="line">    &#125;))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件下载</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = express.Router();</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">&#x27;/:filename&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> filePath = path.resolve(__dirname, <span class="string">&#x27;../../public/downloadResource/&#x27;</span>, req.params.filename);</span><br><span class="line">    <span class="comment">// filePath下载文件的路径，req.params.filename下载时默认保存的文件名</span></span><br><span class="line">    res.download(filePath, req.params.filename);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router;</span><br></pre></td></tr></table></figure>

<h2 id="图片加水印"><a href="#图片加水印" class="headerlink" title="图片加水印"></a>图片加水印</h2><p>使用<a href="https://github.com/oliver-moran/jimp/tree/master/packages/jimp">jimp</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> jimp = <span class="built_in">require</span>(<span class="string">&#x27;jimp&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给一张图片加水印</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>waterFile 水印图片地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>originFile 原图片地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>targetFile 加完水印后图片的存储地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>proportion 水印占原图的比例，是多少分之一</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>marginProportion 水印距离原图边界占原图的比例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">mark</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    waterFile,</span></span></span><br><span class="line"><span class="params"><span class="function">    originFile,</span></span></span><br><span class="line"><span class="params"><span class="function">    targetFile,</span></span></span><br><span class="line"><span class="params"><span class="function">    proportion = <span class="number">10</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    marginProportion = <span class="number">0.01</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [water, origin] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">        jimp.read(waterFile),</span><br><span class="line">        jimp.read(originFile),</span><br><span class="line">    ]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对水印图片进行缩放</span></span><br><span class="line">    <span class="keyword">const</span> curProportion = origin.bitmap.width / water.bitmap.width;</span><br><span class="line">    water.scale(curProportion / proportion);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算位置</span></span><br><span class="line">    <span class="keyword">const</span> right = origin.bitmap.width * marginProportion;</span><br><span class="line">    <span class="keyword">const</span> bottom = origin.bitmap.height * marginProportion;</span><br><span class="line">    <span class="keyword">const</span> x = origin.bitmap.width - right - water.bitmap.width;</span><br><span class="line">    <span class="keyword">const</span> y = origin.bitmap.height - bottom - water.bitmap.height;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入水印</span></span><br><span class="line">    origin.composite(water, x, y, &#123;</span><br><span class="line">        <span class="attr">mode</span>: jimp.BLEND_SOURCE_OVER,</span><br><span class="line">        <span class="attr">opacitySource</span>: <span class="number">0.3</span>,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> origin.write(targetFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="生成二维码"><a href="#生成二维码" class="headerlink" title="生成二维码"></a>生成二维码</h2><p>使用<a href="https://github.com/soldair/node-qrcode#nodejs">qr-code</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成二维码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> QrCode = <span class="built_in">require</span>(<span class="string">&#x27;qrcode&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> qrCodePath = path.resolve(__dirname, <span class="string">&#x27;../public/img&#x27;</span>, <span class="string">&#x27;qrcode.jpg&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">QrCode.toFile(qrCodePath, <span class="string">&#x27;hsz my all!&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">color</span>: &#123;</span><br><span class="line">        <span class="attr">dark</span>: <span class="string">&#x27;#0ff&#x27;</span>,</span><br><span class="line">        <span class="attr">light</span>: <span class="string">&#x27;#000&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>node</category>
        <category>常用场景</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>node</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>node数据驱动中的mysql驱动程序</title>
    <url>/135xyq.github.io/2022/03/06/node-%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E5%92%8CORM-mysql%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="mysql驱动程序"><a href="#mysql驱动程序" class="headerlink" title="mysql驱动程序"></a>mysql驱动程序</h1><h2 id="驱动程序"><a href="#驱动程序" class="headerlink" title="驱动程序"></a>驱动程序</h2><p>驱动程序是连接内存和其他存储介质的桥梁</p>
<p>mysql驱动程序是连接内存数据和mysql数据的桥梁</p>
<h2 id="驱动程序mysql2的使用-npm-github"><a href="#驱动程序mysql2的使用-npm-github" class="headerlink" title="驱动程序mysql2的使用    npm     github"></a>驱动程序mysql2的使用    <a href="https://www.npmjs.com/package/mysql2">npm</a>     <a href="https://github.com/sidorares/node-mysql2">github</a></h2><h3 id="使用createConnection创建一个连接"><a href="#使用createConnection创建一个连接" class="headerlink" title="使用createConnection创建一个连接"></a>使用createConnection创建一个连接</h3><h4 id="createConnection-配置参数"><a href="#createConnection-配置参数" class="headerlink" title="createConnection 配置参数"></a>createConnection 配置参数</h4><ul>
<li>host：主机名</li>
<li>user：用户名</li>
<li>password：用户密码</li>
<li>database：连接的数据库</li>
<li>mutipleStatements:是否允许一次运行多条SQL语句</li>
</ul>
<h4 id="connection-query-的使用"><a href="#connection-query-的使用" class="headerlink" title="connection.query()的使用"></a>connection.query()的使用</h4><p>第一个参数：mysql语句<br>第二个参数：回调函数（第一个参数错误信息，第二个参数为结果）</p>
<h4 id="回调操作"><a href="#回调操作" class="headerlink" title="回调操作"></a>回调操作</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">&#x27;mysql2&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; createConnection &#125; = <span class="built_in">require</span>(<span class="string">&#x27;mysql2/promise&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个数据库连接</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> connection = mysql.createConnection(&#123;</span><br><span class="line">    <span class="attr">host</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">    <span class="attr">user</span>: <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">    <span class="attr">password</span>: <span class="string">&#x27;xyq2386152296&#x27;</span>,</span><br><span class="line">    <span class="attr">database</span>: <span class="string">&#x27;my_mysql_test&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//简单使用</span></span><br><span class="line"></span><br><span class="line">connection.query(</span><br><span class="line">    <span class="string">&#x27;select * from company&#x27;</span>,</span><br><span class="line">    <span class="function">(<span class="params">error, result</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;error: &#x27;</span>, error);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;result: &#x27;</span>, result)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">connection.end();<span class="comment">//关闭连接</span></span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="attr">error</span>:<span class="literal">null</span></span><br><span class="line"><span class="attr">result</span>:</span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;腾讯科技&#x27;</span>,</span><br><span class="line">    <span class="attr">location</span>: <span class="string">&#x27;广东省深圳市腾讯大厦&#x27;</span>,</span><br><span class="line">    <span class="attr">buildDate</span>: <span class="number">2009</span>-<span class="number">07</span>-09T16:<span class="number">00</span>:<span class="number">00</span>.000Z</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;渡一教育&#x27;</span>,</span><br><span class="line">    <span class="attr">location</span>: <span class="string">&#x27;黑龙江哈尔滨&#x27;</span>,</span><br><span class="line">    <span class="attr">buildDate</span>: <span class="number">2004</span>-<span class="number">02</span>-09T16:<span class="number">00</span>:<span class="number">00</span>.000Z</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;蚂蚁金服&#x27;</span>,</span><br><span class="line">    <span class="attr">location</span>: <span class="string">&#x27;中国杭州市西湖区西溪路556号蚂蚁Z空间&#x27;</span>,</span><br><span class="line">    <span class="attr">buildDate</span>: <span class="number">2010</span>-<span class="number">04</span>-03T16:<span class="number">00</span>:<span class="number">00</span>.000Z</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">&#x27;mysql2/promise&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql.createConnection(&#123;</span><br><span class="line">    <span class="attr">host</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">    <span class="attr">user</span>: <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">    <span class="attr">password</span>: <span class="string">&#x27;xyq2386152296&#x27;</span>,</span><br><span class="line">    <span class="attr">database</span>: <span class="string">&#x27;my_mysql_test&#x27;</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">resp</span> =&gt;</span> &#123;</span><br><span class="line">    resp.query(<span class="string">&#x27;select * from company&#x27;</span>).then(<span class="function"><span class="params">resp</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(resp[<span class="number">0</span>]);<span class="comment">// 返回值为数组，第一项为error或data </span></span><br><span class="line">    &#125;);</span><br><span class="line">    resp.end();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;腾讯科技&#x27;</span>,</span><br><span class="line">    <span class="attr">location</span>: <span class="string">&#x27;广东省深圳市腾讯大厦&#x27;</span>,</span><br><span class="line">    <span class="attr">buildDate</span>: <span class="number">2009</span>-<span class="number">07</span>-09T16:<span class="number">00</span>:<span class="number">00</span>.000Z</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;渡一教育&#x27;</span>,</span><br><span class="line">    <span class="attr">location</span>: <span class="string">&#x27;黑龙江哈尔滨&#x27;</span>,</span><br><span class="line">    <span class="attr">buildDate</span>: <span class="number">2004</span>-<span class="number">02</span>-09T16:<span class="number">00</span>:<span class="number">00</span>.000Z</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;蚂蚁金服&#x27;</span>,</span><br><span class="line">    <span class="attr">location</span>: <span class="string">&#x27;中国杭州市西湖区西溪路556号蚂蚁Z空间&#x27;</span>,</span><br><span class="line">    <span class="attr">buildDate</span>: <span class="number">2010</span>-<span class="number">04</span>-03T16:<span class="number">00</span>:<span class="number">00</span>.000Z</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="使用语句操作，不使用query防止进行SQL注入，危害数据库安全，使用execute"><a href="#使用语句操作，不使用query防止进行SQL注入，危害数据库安全，使用execute" class="headerlink" title="使用语句操作，不使用query防止进行SQL注入，危害数据库安全，使用execute"></a>使用语句操作，不使用query防止进行SQL注入，危害数据库安全，使用<a href="https://github.com/sidorares/node-mysql2#using-prepared-statements">execute</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用execute防止SQL注入</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">&#x27;mysql2&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个数据库连接</span></span><br><span class="line">    <span class="keyword">const</span> connection = mysql.createConnection(&#123;</span><br><span class="line">        <span class="attr">host</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">        <span class="attr">user</span>: <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">        <span class="attr">password</span>: <span class="string">&#x27;xyq2386152296&#x27;</span>,</span><br><span class="line">        <span class="attr">database</span>: <span class="string">&#x27;my_mysql_test&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> sql = <span class="string">`select * from company where id = ?`</span></span><br><span class="line">    connection.execute(sql, [id], <span class="function">(<span class="params">error, result</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    connection.end();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="excute参数"><a href="#excute参数" class="headerlink" title="excute参数"></a>excute参数</h5><p>第一个参数SQL语句，每一个需要传递的参数，需要使用 ？ 占位，（当使用模糊查询时，可以使用 like concat(‘%’,?,‘%’））；<br>第二个参数依次表示SQL语句中使用？占位的数据。</p>
<h3 id="使用createPool创建一个连接池"><a href="#使用createPool创建一个连接池" class="headerlink" title="使用createPool创建一个连接池"></a>使用<a href="https://github.com/sidorares/node-mysql2#using-connection-pools">createPool</a>创建一个连接池</h3><p>每次开启的数据库连接不能超过规定的数量，超过的部分需要排队，等候连接池中的空闲连接。 防止数据库连接过多卡顿。不用手动关闭连接，会自动管理。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用createPool连接池</span></span><br><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">&#x27;mysql2&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个数据库连接</span></span><br><span class="line"><span class="keyword">const</span> pool = mysql.createPool(&#123;</span><br><span class="line">    <span class="attr">host</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">    <span class="attr">user</span>: <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">    <span class="attr">password</span>: <span class="string">&#x27;xyq2386152296&#x27;</span>,</span><br><span class="line">    <span class="attr">database</span>: <span class="string">&#x27;my_mysql_test&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> sql = <span class="string">`select * from company where id = ?`</span></span><br><span class="line">    pool.execute(sql, [id], <span class="function">(<span class="params">error, result</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="number">1</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h5><ul>
<li>waitForConnections：当连接池满的时候，新来一个连接是否等待，如果不等待则直接报错，默认为true；</li>
<li>connectionLimit: 连接池中最大的连接数量，默认为10 ；</li>
<li>queueLimit: 新来连接的排队长度，如果为0表示不限制长度；</li>
</ul>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>node</category>
        <category>数据驱动和ORM</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>node</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>node数据驱动中的sequelize模型的增删改</title>
    <url>/135xyq.github.io/2022/03/07/node-%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E5%92%8CORM-%E6%A8%A1%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9/</url>
    <content><![CDATA[<h1 id="sequelized的增删改"><a href="#sequelized的增删改" class="headerlink" title="sequelized的增删改"></a>sequelized的增删改</h1><h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><h3 id="使用模型的build方法新增"><a href="#使用模型的build方法新增" class="headerlink" title="使用模型的build方法新增"></a>使用模型的build方法新增</h3><p>不调用ins.save()，不会执行SQL语句，还可以通过ins更改属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Admin = <span class="built_in">require</span>(<span class="string">&#x27;./models/Admin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ins = Admin.build(&#123;</span><br><span class="line">    <span class="attr">loginId</span>: <span class="string">&#x27;xyq&#x27;</span>,</span><br><span class="line">    <span class="attr">loginPwd</span>: <span class="string">&#x27;123456&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;谢永强&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ins.save().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;新增成功！&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="使用模型的create方法新增"><a href="#使用模型的create方法新增" class="headerlink" title="使用模型的create方法新增"></a>使用模型的create方法新增</h3><p>异步函数。<br>相当于执行完build后再执行ins.save()。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Admin = <span class="built_in">require</span>(<span class="string">&#x27;./models/Admin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Admin.create(&#123;</span><br><span class="line">    <span class="attr">loginId</span>: <span class="string">&#x27;hsz&#x27;</span>,</span><br><span class="line">    <span class="attr">loginPwd</span>: <span class="string">&#x27;123&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;筱&#x27;</span></span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;新增成功！&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><h3 id="先得到实例再删除"><a href="#先得到实例再删除" class="headerlink" title="先得到实例再删除"></a>先得到实例再删除</h3><p>会执行两条SQL语句，一条查询，一条删除。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除一个管理员</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>adminId 管理员的id</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">adminId</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ins = <span class="keyword">await</span> Admin.findByPk(adminId);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ins) &#123;</span><br><span class="line"> 	ins.destroy();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;管理员不存在！&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="通过模型调用destory方法删除"><a href="#通过模型调用destory方法删除" class="headerlink" title="通过模型调用destory方法删除"></a>通过模型调用destory方法删除</h3><p>只会执行一条SQL语句。<br>通过where来匹配要删除的数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除一个管理员</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>adminId 管理员的id</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">adminId</span>) </span>&#123;</span><br><span class="line">    Admin.destroy(&#123;</span><br><span class="line">        <span class="attr">where</span>: &#123;</span><br><span class="line">            <span class="attr">id</span>: adminId,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><h3 id="通过得到实例再更新数据"><a href="#通过得到实例再更新数据" class="headerlink" title="通过得到实例再更新数据"></a>通过得到实例再更新数据</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*更新一个管理员信息</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;int&#125;</span> </span>id 管理员id</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;object&#125;</span> </span>adminObj 管理员信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">id, adminObj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ins = <span class="keyword">await</span> Admin.findByPk(id);</span><br><span class="line">    ins.loginId = adminObj.loginId;</span><br><span class="line">    ins.save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通过模型中update方法来更新"><a href="#通过模型中update方法来更新" class="headerlink" title="通过模型中update方法来更新"></a>通过模型中update方法来更新</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *更新一个管理员信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;int&#125;</span> </span>id 管理员id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;object&#125;</span> </span>adminObj 管理员信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.updateAdmin = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">id, adminObj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> Admin.update(adminObj, &#123;</span><br><span class="line">        <span class="attr">where</span>: &#123;</span><br><span class="line">            id,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>node</category>
        <category>数据驱动和ORM</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>node</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>node数据驱动中sequelize中模型的定义和同步</title>
    <url>/135xyq.github.io/2022/03/06/node-%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E5%92%8CORM-%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%90%8C%E6%AD%A5/</url>
    <content><![CDATA[<h1 id="sequelize中的模型定义和同步"><a href="#sequelize中的模型定义和同步" class="headerlink" title="sequelize中的模型定义和同步"></a>sequelize中的<a href="https://demopark.github.io/sequelize-docs-Zh-CN/core-concepts/model-basics.html">模型定义</a>和同步</h1><h2 id="创建数据库连接"><a href="#创建数据库连接" class="headerlink" title="创建数据库连接"></a><a href="https://demopark.github.io/sequelize-docs-Zh-CN/core-concepts/getting-started.html">创建数据库连接</a></h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Sequelize &#125; = <span class="built_in">require</span>(<span class="string">&#x27;sequelize&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sequelize = <span class="keyword">new</span> Sequelize(<span class="string">&#x27;my_school_db&#x27;</span>, <span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;xyq2386152296&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">host</span>: <span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">    <span class="attr">dialect</span>: <span class="string">&#x27;mysql&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试连接</span></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> sequelize.authenticate();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Connection has been established successfully.&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">&#x27;Unable to connect to the database:&#x27;</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<h2 id="模型的定义"><a href="#模型的定义" class="headerlink" title="模型的定义"></a><a href="https://demopark.github.io/sequelize-docs-Zh-CN/core-concepts/model-basics.html">模型的定义</a></h2><p>模型是代表数据库中表的抽象. 在 Sequelize 中,它是一个 Model 的扩展类.<br>该模型告诉 Sequelize 有关它代表的实体的几件事,例如数据库中表的名称以及它具有的列(及其数据类型).<br>Sequelize 中的模型有一个名称. 此名称不必与它在数据库中表示的表的名称相同.</p>
<h3 id="使用-sequelize-define"><a href="#使用-sequelize-define" class="headerlink" title="使用 sequelize.define:"></a>使用 sequelize.define:</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Sequelize, DataTypes &#125; = <span class="built_in">require</span>(<span class="string">&#x27;sequelize&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> sequelize = <span class="keyword">new</span> Sequelize(<span class="string">&#x27;sqlite::memory:&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> User = sequelize.define(<span class="string">&#x27;User&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// 在这里定义模型属性</span></span><br><span class="line">  <span class="attr">firstName</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: DataTypes.STRING,</span><br><span class="line">    <span class="attr">allowNull</span>: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">lastName</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: DataTypes.STRING</span><br><span class="line">    <span class="comment">// allowNull 默认为 true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  <span class="comment">// 这是其他模型参数</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// `sequelize.define` 会返回模型</span></span><br><span class="line"><span class="built_in">console</span>.log(User === sequelize.models.User); <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="扩展-Model"><a href="#扩展-Model" class="headerlink" title="扩展 Model"></a>扩展 Model</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Sequelize, DataTypes, Model &#125; = <span class="built_in">require</span>(<span class="string">&#x27;sequelize&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> sequelize = <span class="keyword">new</span> Sequelize(<span class="string">&#x27;sqlite::memory:&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Model</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">User.init(&#123;</span><br><span class="line">  <span class="comment">// 在这里定义模型属性</span></span><br><span class="line">  <span class="attr">firstName</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: DataTypes.STRING,</span><br><span class="line">    <span class="attr">allowNull</span>: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">lastName</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: DataTypes.STRING</span><br><span class="line">    <span class="comment">// allowNull 默认为 true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  <span class="comment">// 这是其他模型参数</span></span><br><span class="line">  sequelize, <span class="comment">// 我们需要传递连接实例</span></span><br><span class="line">  <span class="attr">modelName</span>: <span class="string">&#x27;User&#x27;</span> <span class="comment">// 我们需要选择模型名称</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义的模型是类本身</span></span><br><span class="line"><span class="built_in">console</span>.log(User === sequelize.models.User); <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><ul>
<li>模型名.sync() - 如果表不存在,则创建该表(如果已经存在,则不执行任何操作)</li>
<li>模型名.sync({ force: true }) - 将创建表,如果表已经存在,则将其首先删除</li>
<li>模型名.sync({ alter: true }) - 这将检查数据库中表的当前状态(它具有哪些列,它们的数据类型等),然后在表中进行必要的更改以使其与模型匹配.</li>
</ul>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>node</category>
        <category>数据驱动和ORM</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>node</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>node中的日志记录</title>
    <url>/135xyq.github.io/2022/03/09/node-%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E5%92%8CORM-%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a><a href="https://log4js-node.github.io/log4js-node/appenders.html">日志记录</a></h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 日志配置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> log4js = <span class="built_in">require</span>(<span class="string">&#x27;log4js&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置</span></span><br><span class="line">log4js.configure(&#123;</span><br><span class="line">    <span class="comment">// 出口</span></span><br><span class="line">    <span class="attr">appenders</span>: &#123;</span><br><span class="line">        <span class="attr">sql</span>: &#123;</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;dateFile&#x27;</span>, <span class="comment">//file普通文件，dateFile日期文件在备份时会在文件名中加入日期</span></span><br><span class="line">            <span class="attr">filename</span>: path.resolve(__dirname, <span class="string">&#x27;logs&#x27;</span>, <span class="string">&#x27;sql&#x27;</span>, <span class="string">&#x27;logging.log&#x27;</span>), <span class="comment">//写入文件地址</span></span><br><span class="line">            <span class="attr">maxLogSize</span>: <span class="number">2</span> ** <span class="number">20</span>, <span class="comment">// 一个文件写入的最大字节数，超过之后会自动备份到其他文件</span></span><br><span class="line">            <span class="attr">keepFileExt</span>: <span class="literal">true</span>, <span class="comment">//保留备份文件的后缀名</span></span><br><span class="line">            <span class="comment">// daysToKeep: 0, // 文件会保留多少天，默认为0，一直保留</span></span><br><span class="line">            <span class="comment">// 写入的格式</span></span><br><span class="line">            <span class="attr">layout</span>: &#123;</span><br><span class="line">                <span class="attr">type</span>: <span class="string">&#x27;pattern&#x27;</span>, <span class="comment">//pattern是自定义样式</span></span><br><span class="line">                <span class="attr">pattern</span>: <span class="string">&#x27;%c: %d&#123;yyyy-MM-dd hh:mm:ss&#125; %p  %m%n&#x27;</span> <span class="comment">//写入文件的格式</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">default</span>: &#123;</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;stdout&#x27;</span>, <span class="comment">//标准控制台输出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 分类</span></span><br><span class="line">    <span class="attr">categories</span>: &#123;</span><br><span class="line">        <span class="attr">sql</span>: &#123;</span><br><span class="line">            <span class="attr">appenders</span>: [<span class="string">&quot;sql&quot;</span>], <span class="comment">//该出口使用出口sql的配置</span></span><br><span class="line">            <span class="attr">level</span>: <span class="string">&#x27;all&#x27;</span>, <span class="comment">//级别配置</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">default</span>: &#123;</span><br><span class="line">            <span class="attr">appenders</span>: [<span class="string">&quot;default&quot;</span>], <span class="comment">//该出口使用出口default的配置</span></span><br><span class="line">            <span class="attr">level</span>: <span class="string">&#x27;all&#x27;</span>, <span class="comment">//级别配置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//程序要退出时运行shutdown记录完日志</span></span><br><span class="line">process.on(<span class="string">&#x27;exit&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    log4js.shutdown();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sqlLogger = log4js.getLogger(<span class="string">&#x27;sql&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> logger = log4js.getLogger();</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    sqlLogger,</span><br><span class="line">    logger</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>node</category>
        <category>数据驱动和ORM</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>cookie的简介</title>
    <url>/135xyq.github.io/2022/03/14/node-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%80%9A%E4%BF%A1-cookie/</url>
    <content><![CDATA[<h1 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h1><h2 id="一个不大不小的问题"><a href="#一个不大不小的问题" class="headerlink" title="一个不大不小的问题"></a>一个不大不小的问题</h2><p>假设服务器有一个接口，通过请求这个接口，可以添加一个管理员</p>
<p>但是，不是任何人都有权力做这种操作的</p>
<p>那么服务器如何知道请求接口的人是有权力的呢？</p>
<p>答案是：只有登录过的管理员才能做这种操作</p>
<p>可问题是，客户端和服务器的传输使用的是http协议，http协议是无状态的，什么叫无状态，就是<strong>服务器不知道这一次请求的人，跟之前登录请求成功的人是不是同一个人</strong></p>
<p><img src="/images/node/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B9%8B%E9%97%B4-cookie-1.png" alt="1"></p>
<p><img src="/images/node/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B9%8B%E9%97%B4-cookie-2.png" alt="1"></p>
<p>由于http协议的无状态，服务器<strong>忘记</strong>了之前的所有请求，它无法确定这一次请求的客户端，就是之前登录成功的那个客户端。</p>
<blockquote>
<p>你可以把服务器想象成有着严重脸盲症的东哥，他没有办法分清楚跟他说话的人之前做过什么</p>
</blockquote>
<p>于是，服务器想了一个办法</p>
<p>它按照下面的流程来认证客户端的身份</p>
<ol>
<li>客户端登录成功后，服务器会给客户端一个出入证（令牌 token）</li>
<li>后续客户端的每次请求，都必须要附带这个出入证（令牌 token）</li>
</ol>
<p><img src="/images/node/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B9%8B%E9%97%B4-cookie-3.png" alt="1"></p>
<p>服务器发扬了认证不认人的优良传统，就可以很轻松的识别身份了。</p>
<p>但是，用户不可能只在一个网站登录，于是客户端会收到来自各个网站的出入证，因此，就要求客户端要有一个类似于卡包的东西，能够具备下面的功能：</p>
<ol>
<li><strong>能够存放多个出入证</strong>。这些出入证来自不同的网站，也可能是一个网站有多个出入证，分别用于出入不同的地方</li>
<li><strong>能够自动出示出入证</strong>。客户端在访问不同的网站时，能够自动的把对应的出入证附带请求发送出去。</li>
<li><strong>正确的出示出入证</strong>。客户端不能将肯德基的出入证发送给麦当劳。</li>
<li><strong>管理出入证的有效期</strong>。客户端要能够自动的发现那些已经过期的出入证，并把它从卡包内移除。</li>
</ol>
<p>能够满足上面所有要求的，就是cookie</p>
<p>cookie类似于一个卡包，专门用于存放各种出入证，并有着一套机制来自动管理这些证件。</p>
<p>卡包内的每一张卡片，称之为<strong>一个cookie</strong>。</p>
<h2 id="cookie的组成"><a href="#cookie的组成" class="headerlink" title="cookie的组成"></a>cookie的组成</h2><p>cookie是浏览器中特有的一个概念，它就像浏览器的专属卡包，管理着各个网站的身份信息。</p>
<p>每个cookie就相当于是属于某个网站的一个卡片，它记录了下面的信息：</p>
<ul>
<li>key：键，比如「身份编号」</li>
<li>value：值，比如筱的身份编号「14563D1550F2F76D69ECBF4DD54ABC95」，这有点像卡片的条形码，当然，它可以是任何信息</li>
<li>domain：域，表达这个cookie是属于哪个网 站的，比如<code>xyq135.com</code>，表示这个cookie是属于<code>xyq135.com</code>这个网站的</li>
<li>path：路径，表达这个cookie是属于该网站的哪个基路径的，就好比是同一家公司不同部门会颁发不同的出入证。比如<code>/news</code>，表示这个cookie属于<code>/news</code>这个路径的。</li>
<li>secure：是否使用安全传输</li>
<li>expire：过期时间，表示该cookie在什么时候过期</li>
</ul>
<p>当浏览器向服务器发送一个请求的时候，它会瞄一眼自己的卡包，看看哪些卡片适合附带捎给服务器</p>
<p>如果一个cookie<strong>同时满足</strong>以下条件，则这个cookie会被附带到请求中</p>
<ul>
<li>cookie没有过期</li>
<li>cookie中的域和这次请求的域是匹配的<ul>
<li>比如cookie中的域是<code>yuanjin.tech</code>，则可以匹配的请求域是<code>yuanjin.tech</code>、<code>www.yuanjin.tech</code>、<code>blogs.yuanjin.tech</code>等等</li>
<li>比如cookie中的域是<code>www.yuanjin.tech</code>，则只能匹配<code>www.yuanjin.tech</code>这样的请求域</li>
<li>cookie是不在乎端口的，只要域匹配即可</li>
</ul>
</li>
<li>cookie中的path和这次请求的path是匹配的<ul>
<li>比如cookie中的path是<code>/news</code>，则可以匹配的请求路径可以是<code>/news</code>、<code>/news/detail</code>、<code>/news/a/b/c</code>等等，但不能匹配<code>/blogs</code></li>
<li>如果cookie的path是<code>/</code>，可以想象，能够匹配所有的路径</li>
</ul>
</li>
<li>验证cookie的安全传输<ul>
<li>如果cookie的secure属性是true，则请求协议必须是<code>https</code>，否则不会发送该cookie</li>
<li>如果cookie的secure属性是false，则请求协议可以是<code>http</code>，也可以是<code>https</code></li>
</ul>
</li>
</ul>
<p>如果一个cookie满足了上述的所有条件，则浏览器会把它自动加入到这次请求中</p>
<p>具体加入的方式是，<strong>浏览器会将符合条件的cookie，自动放置到请求头中</strong>，例如，当我在浏览器中访问百度的时候，它在请求头中附带了下面的cookie：</p>
<p><img src="/images/node/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B9%8B%E9%97%B4-cookie-4.png" alt="1"></p>
<p>看到打马赛克的地方了吗？这部分就是通过请求头<code>cookie</code>发送到服务器的，它的格式是<code>键=值; 键=值; 键=值; ...</code>，每一个键值对就是一个符合条件的cookie。</p>
<p><strong>cookie中包含了重要的身份信息，永远不要把你的cookie泄露给别人！！！</strong>否则，他人就拿到了你的证件，有了证件，就具备了为所欲为的可能性。</p>
<h2 id="如何设置cookie"><a href="#如何设置cookie" class="headerlink" title="如何设置cookie"></a>如何设置cookie</h2><p>由于cookie是保存在浏览器端的，同时，很多证件又是服务器颁发的</p>
<p>所以，cookie的设置有两种模式：</p>
<ul>
<li>服务器响应：这种模式是非常普遍的，当服务器决定给客户端颁发一个证件时，它会在响应的消息中包含cookie，浏览器会自动的把cookie保存到卡包中</li>
<li>客户端自行设置：这种模式少见一些，不过也有可能会发生，比如用户关闭了某个广告，并选择了「以后不要再弹出」，此时就可以把这种小信息直接通过浏览器的JS代码保存到cookie中。后续请求服务器时，服务器会看到客户端不想要再次弹出广告的cookie，于是就不会再发送广告过来了。</li>
</ul>
<h2 id="服务器端设置cookie"><a href="#服务器端设置cookie" class="headerlink" title="服务器端设置cookie"></a>服务器端设置cookie</h2><p>服务器可以通过设置响应头，来告诉浏览器应该如何设置cookie</p>
<p>响应头按照下面的格式设置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">set-cookie:</span> <span class="string">cookie1</span></span><br><span class="line"><span class="attr">set-cookie:</span> <span class="string">cookie2</span></span><br><span class="line"><span class="attr">set-cookie:</span> <span class="string">cookie3</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>

<p>通过这种模式，就可以在一次响应中设置多个cookie了，具体设置多少个cookie，设置什么cookie，根据你的需要自行处理</p>
<p>其中，每个cookie的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">键=值; path=?; domain=?; expire=?; max-age=?; secure; httponly</span><br></pre></td></tr></table></figure>

<p>每个cookie除了键值对是必须要设置的，其他的属性都是可选的，并且顺序不限</p>
<p>当这样的响应头到达客户端后，<strong>浏览器会自动的将cookie保存到卡包中，如果卡包中已经存在一模一样的卡片（其他key、path、domain相同），则会自动的覆盖之前的设置</strong>。</p>
<p>下面，依次说明每个属性值：</p>
<ul>
<li><strong>path</strong>：设置cookie的路径。如果不设置，浏览器会将其自动设置为当前请求的路径。比如，浏览器请求的地址是<code>/login</code>，服务器响应了一个<code>set-cookie: a=1</code>，浏览器会将该cookie的path设置为请求的路径<code>/login</code></li>
<li><strong>domain</strong>：设置cookie的域。如果不设置，浏览器会自动将其设置为当前的请求域，比如，浏览器请求的地址是<code>http://www.yuanjin.tech</code>，服务器响应了一个<code>set-cookie: a=1</code>，浏览器会将该cookie的domain设置为请求的域<code>www.yuanjin.tech</code><ul>
<li>这里值得注意的是，如果服务器响应了一个无效的域，浏览器是不认的</li>
<li>什么是无效的域？就是响应的域连根域都不一样。比如，浏览器请求的域是<code>yuanjin.tech</code>，服务器响应的cookie是<code>set-cookie: a=1; domain=baidu.com</code>，这样的域浏览器是不认的。</li>
<li>如果浏览器连这样的情况都允许，就意味着张三的服务器，有权利给用户一个cookie，用于访问李四的服务器，这会造成很多安全性的问题</li>
</ul>
</li>
<li><strong>expire</strong>：设置cookie的过期时间。这里必须是一个有效的GMT时间，即格林威治标准时间字符串，比如<code>Fri, 17 Apr 2020 09:35:59 GMT</code>，表示格林威治时间的<code>2020-04-17 09:35:59</code>，即北京时间的<code>2020-04-17 17:35:59</code>。当客户端的时间达到这个时间点后，会自动销毁该cookie。</li>
<li><strong>max-age</strong>：设置cookie的相对有效期。expire和max-age通常仅设置一个即可。比如设置<code>max-age</code>为<code>1000</code>，浏览器在添加cookie时，会自动设置它的<code>expire</code>为当前时间加上1000秒，作为过期时间。<ul>
<li>如果不设置expire，又没有设置max-age，则表示会话结束后过期。</li>
<li>对于大部分浏览器而言，关闭所有浏览器窗口意味着会话结束。</li>
</ul>
</li>
<li><strong>secure</strong>：设置cookie是否是安全连接。如果设置了该值，则表示该cookie后续只能随着<code>https</code>请求发送。如果不设置，则表示该cookie会随着所有请求发送。</li>
<li><strong>httponly</strong>：设置cookie是否仅能用于传输。如果设置了该值，表示该cookie仅能用于传输，而不允许在客户端通过JS获取，这对防止跨站脚本攻击（XSS）会很有用。 </li>
</ul>
<p>下面来一个例子，客户端通过<code>post</code>请求服务器<code>http://yuanjin.tech/login</code>，并在消息体中给予了账号和密码，服务器验证登录成功后，在响应头中加入了以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set-cookie: token=123456; path=/; max-age=3600; httponly</span><br></pre></td></tr></table></figure>

<p>当该响应到达浏览器后，浏览器会创建下面的cookie：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">key:</span> <span class="string">token</span></span><br><span class="line"><span class="attr">value:</span> <span class="number">123456</span></span><br><span class="line"><span class="attr">domain:</span> <span class="string">yuanjin.tech</span></span><br><span class="line"><span class="attr">path:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">expire:</span> <span class="number">2020-04-17 18:55:00</span> <span class="comment">#假设当前时间是2020-04-17 17:55:00</span></span><br><span class="line"><span class="attr">secure:</span> <span class="literal">false</span>  <span class="comment">#任何请求都可以附带这个cookie，只要满足其他要求</span></span><br><span class="line"><span class="attr">httponly:</span> <span class="literal">true</span> <span class="comment">#不允许JS获取该cookie</span></span><br></pre></td></tr></table></figure>

<p>于是，随着浏览器后续对服务器的请求，只要满足要求，这个cookie就会被附带到请求头中传给服务器：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cookie:</span> <span class="string">token=123456;</span> <span class="string">其他cookie...</span></span><br></pre></td></tr></table></figure>

<p>现在，还剩下最后一个问题，就是如何删除浏览器的一个cookie呢？</p>
<p>如果要删除浏览器的cookie，只需要让服务器响应一个同样的域、同样的路径、同样的key，只是时间过期的cookie即可</p>
<p><strong>所以，删除cookie其实就是修改cookie</strong></p>
<p>下面的响应会让浏览器删除<code>token</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cookie:</span> <span class="string">token=;</span> <span class="string">domain=yuanjin.tech;</span> <span class="string">path=/;</span> <span class="string">max-age=-1</span></span><br></pre></td></tr></table></figure>

<p>浏览器按照要求修改了cookie后，会发现cookie已经过期，于是自然就会删除了。</p>
<blockquote>
<p>无论是修改还是删除，都要注意cookie的域和路径，因为完全可能存在域或路径不同，但key相同的cookie</p>
<p>因此无法仅通过key确定是哪一个cookie</p>
</blockquote>
<h2 id="客户端设置cookie"><a href="#客户端设置cookie" class="headerlink" title="客户端设置cookie"></a>客户端设置cookie</h2><p>既然cookie是存放在浏览器端的，所以浏览器向JS公开了接口，让其可以设置cookie</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">&quot;键=值; path=?; domain=?; expire=?; max-age=?; secure&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>可以看出，在客户端设置cookie，和服务器设置cookie的格式一样，只是有下面的不同</p>
<ul>
<li>没有httponly。因为httponly本来就是为了限制在客户端访问的，既然你是在客户端配置，自然失去了限制的意义。</li>
<li>path的默认值。在服务器端设置cookie时，如果没有写path，使用的是请求的path。而在客户端设置cookie时，也许根本没有请求发生。因此，path在客户端设置时的默认值是当前网页的path</li>
<li>domain的默认值。和path同理，客户端设置时的默认值是当前网页的domain</li>
<li>其他：一样</li>
<li>删除cookie：和服务器也一样，修改cookie的过期时间即可</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上，就是cookie原理部分的内容。</p>
<p>如果把它用于登录场景，就是如下的流程：</p>
<p><strong>登录请求</strong></p>
<ol>
<li>浏览器发送请求到服务器，附带账号密码</li>
<li>服务器验证账号密码是否正确，如果不正确，响应错误，如果正确，在响应头中设置cookie，附带登录认证信息（至于登录认证信息是设么样的，如何设计，要考虑哪些问题，就是另一个话题了，可以百度 jwt）</li>
<li>客户端收到cookie，浏览器自动记录下来</li>
</ol>
<p><strong>后续请求</strong></p>
<ol>
<li>浏览器发送请求到服务器，希望添加一个管理员，并将cookie自动附带到请求中</li>
<li>服务器先获取cookie，验证cookie中的信息是否正确，如果不正确，不予以操作，如果正确，完成正常的业务流程</li>
</ol>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>node</category>
        <category>服务器和客户端通信</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>node</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>htpp中的缓存</title>
    <url>/135xyq.github.io/2022/03/17/node-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%80%9A%E4%BF%A1-http%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h1 id="缓存的基本原理"><a href="#缓存的基本原理" class="headerlink" title="缓存的基本原理"></a>缓存的基本原理</h1><p>在一个C/S结构中，最基本的缓存分为两种：</p>
<ul>
<li>客户端缓存</li>
<li>服务器缓存</li>
</ul>
<p><strong>本文仅讨论客户端缓存</strong></p>
<p>所谓<strong>客户端缓存</strong>，顾名思义，是将某一次的响应结果保存在客户端（比如浏览器）中，而后续的请求仅需要从缓存中读取即可，极大的降低了服务器的处理压力。</p>
<p>客户端缓存的原理如下：</p>
<img src="/images/node/服务器与客户端通信-http缓存1.jpg" alt="image-20200430202446870" style="zoom: 33%;" />

<blockquote>
<p>这只是一个简易的原理图，实际情况可能有差异</p>
</blockquote>
<p>这里就设计到一个缓存策略的问题，这些问题包括：</p>
<ul>
<li>哪些资源需要加入到缓存，哪些不需要？</li>
<li>缓存的时间是多久呢？</li>
<li>如果服务器的资源有改动，客户端如何更新缓存呢？</li>
<li>如果缓存过期了，可是服务器上的资源并没有发生变动，又该如何处理呢？</li>
<li>…….</li>
</ul>
<p>要回答这些问题，就必须要清楚<code>http</code>中关于缓存的协议</p>
<p>理解了http的缓存协议，自然就能回答上面的问题了。</p>
<h2 id="来自服务器的缓存指令"><a href="#来自服务器的缓存指令" class="headerlink" title="来自服务器的缓存指令"></a>来自服务器的缓存指令</h2><p>当客户端发出一个<code>get</code>请求到服务器，服务器可能有以下的内心活动：「你请求的这个资源，我很少会改动它，干脆你把它缓存起来吧，以后就不要来烦我了」</p>
<p>为了表达这个美好的愿望，服务器在<strong>响应头</strong>中加入了以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cache-Control: max-age=3600</span><br><span class="line">ETag: W/&quot;121-171ca289ebf&quot;</span><br><span class="line">Date: Thu, 30 Apr 2020 12:39:56 GMT</span><br><span class="line">Last-Modified: Thu, 30 Apr 2020 08:16:31 GMT</span><br></pre></td></tr></table></figure>

<p>这个响应头表达了下面的信息：</p>
<ul>
<li><code>Cache-Control: max-age=3600</code>，我希望你把这个资源缓存起来，缓存时间是3600秒（1小时）</li>
<li><code>ETag: W/&quot;121-171ca289ebf&quot;</code>，这个资源的编号是<code>W/&quot;121-171ca289ebf&quot;</code></li>
<li><code>Date: Thu, 30 Apr 2020 12:39:56 GMT</code>，我给你响应这个资源的服务器时间是格林威治时间<code>2020-04-30 12:39:56</code></li>
<li><code>Last-Modified: Thu, 30 Apr 2020 08:16:31 GMT</code>，这个资源的上一次修改时间是格林威治时间<code>2020-04-30 08:16:31</code></li>
</ul>
<p>这个美好的缓存愿望，就这样通过响应头传递给客户端了</p>
<p>如果客户端是其他应用程序，可能并不会理会服务器的愿望，也就是说，可能根本不会缓存任何东西。</p>
<p>但是凑巧客户端是一个浏览器，它和服务器一直以来都是相亲相爱的小伙伴，当它看到服务器的这个响应头表达的美好愿望后，立即忙起来：</p>
<ul>
<li>浏览器把这次请求得到的响应体缓存到本地文件中</li>
<li>浏览器标记这次请求的请求方法和请求路径</li>
<li>浏览器标记这次缓存的时间是3600秒</li>
<li>浏览器记录服务器的响应时间是格林威治时间<code>2020-04-30 12:39:56</code></li>
<li>浏览器记录服务器给予的资源编号<code>W/&quot;121-171ca289ebf&quot;</code></li>
<li>浏览器记录资源的上一次修改时间是格林威治时间<code>2020-04-30 08:16:31</code></li>
</ul>
<p>这一次的记录非常重要，它为以后浏览器要不要去请求服务器提供了各种依据。</p>
<img src="/images/node/服务器与客户端通信-http缓存2.jpg" alt="image-20200430210430455" style="zoom:33%;" />

<h2 id="来自客户端的缓存指令"><a href="#来自客户端的缓存指令" class="headerlink" title="来自客户端的缓存指令"></a>来自客户端的缓存指令</h2><p>当客户端收拾好行李，准备再次请求<code>GET /index.js</code>时，它突然想起了一件事：我需要的东西在不在缓存里呢？</p>
<p>此时，客户端会到缓存中去寻找是否有缓存的资源</p>
<p>寻找的过程如下：</p>
<ol>
<li>缓存中是否有匹配的请求方法和路径？</li>
<li>如果有，该缓存资源是否还有效呢？</li>
</ol>
<p>以上两个验证会导致浏览器产生不同的行为</p>
<img src="/images/node/服务器与客户端通信-http缓存3.jpg" alt="image-20200430212052228" style="zoom:50%;" />

<img src="/images/node/服务器与客户端通信-http缓存4.jpg" alt="image-20200430214301507" style="zoom:33%;" />

<p>要验证是否有匹配的缓存非常简单，只需要验证当前的请求方法<code>GET</code>和当前的请求路径<code>/index.js</code>是否有对应的缓存存在即可</p>
<p>如果没有，就直接请求服务器，就和第一次请求服务器时一样，这种情况没有什么好讨论的</p>
<p>关键在于验证缓存是否有效</p>
<p>如何验证呢？</p>
<p>非常简单，就是把<code>max-age + Date</code>，得到一个过期时间，看看这个过期时间是否大于当前时间，如果是，则表示缓存还没有过期，仍然有效，如果不是，则表示缓存失效。</p>
<h3 id="缓存有效"><a href="#缓存有效" class="headerlink" title="缓存有效"></a>缓存有效</h3><p>当浏览器发现缓存有效时，完全不会请求服务器，直接使用缓存即可得到结果</p>
<p>此时，如果你断开网络，会发现资源仍然可用</p>
<p>这种情况会极大的降低服务器压力，但当服务器更改了资源后，浏览器是不知道的，只要缓存有效，它就会直接使用缓存</p>
<h3 id="缓存无效"><a href="#缓存无效" class="headerlink" title="缓存无效"></a>缓存无效</h3><p>当浏览器发现缓存已经过期，它<strong>并不会简单的把缓存删除</strong>，而是抱着一丝希望，想问问服务器，我<strong>这个缓存还能继续使用吗</strong>？</p>
<p>于是，浏览器向服务器发出了一个<strong>带缓存的请求</strong></p>
<p>所谓带缓存的请求，无非就是加入了以下的请求头：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">If-Modified-Since: Thu, 30 Apr 2020 08:16:31 GMT</span><br><span class="line">If-None-Match: W/&quot;121-171ca289ebf&quot;</span><br></pre></td></tr></table></figure>

<p>它们表达了下面的信息：</p>
<ul>
<li><code>If-Modified-Since: Thu, 30 Apr 2020 08:16:31 GMT</code>，亲，你曾经告诉我，这个资源的上一次修改时间是格林威治时间<code>2020-04-30 08:16:31</code>，请问这个资源在这个时间之后有发生变动吗？</li>
<li><code>If-None-Match: W/&quot;121-171ca289ebf&quot;</code>，亲，你曾经告诉我，这个资源的编号是<code>W/&quot;121-171ca289ebf</code>，请问这个资源的编号发生变动了吗？</li>
</ul>
<p>其实，这两个问题可以合并为一个问题：快说！资源到底变了没有！</p>
<p>之所以要发两个信息，是为了兼容不同的服务器，因为有些服务器只认<code>If-Modified-Since</code>，有些服务器只认<code>If-None-Match</code>，有些服务器两个都认</p>
<blockquote>
<p>目前的很多服务器，只要发现<code>If-None-Match</code>存在，就不会去看``If-Modified-Since`</p>
<p><code>If-Modified-Since</code>是<code>http1.0</code>版本的规范，<code>If-None-Match</code>是<code>http1.1</code>的规范</p>
</blockquote>
<p>此时，问题又抛给了服务器，接下来，就是服务器的表演时间了</p>
<p>服务器可能会产生两个情况：</p>
<ul>
<li>缓存已经失效</li>
<li>缓存仍然有效</li>
</ul>
<p>如果是第一种情况——<strong>缓存已经失效</strong>，那么非常简单，服务器再次给予一个正常的响应（响应码<code>200</code> 带响应体），同时可以附带上新的缓存指令，这就回到了上一节——来自服务器的缓存指令</p>
<p>这样一来，客户端就会重新缓存新的内容</p>
<p>但如果服务器觉得<strong>缓存仍然有效</strong>，它可以通过一种极其简单的方式告诉客户端：</p>
<ul>
<li>响应码为<code>304 Not Modified</code></li>
<li>无响应体</li>
<li>响应头带上新的缓存指令，见上一节——来自服务器的缓存指令</li>
</ul>
<p>这样一来，就相当于告诉客户端：「你的缓存资源仍然可用，我给你一个新的缓存时间，你那边更新一下就可以了」</p>
<p>于是，客户端就继续happy的使用缓存了</p>
<p>这样一来，可以最大程度的减少网络传输，因为如果资源还有效，服务器就不会传输消息体</p>
<p>它们完整的交互过程如下：</p>
<img src="/images/node/服务器与客户端通信-http缓存5.jpg" alt="image-20200430225326001" style="zoom:33%;" />

<h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>上面描述了客户端缓存的基本概念和过程</p>
<p>但其中仍然有不少细节值得我们注意</p>
<h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>在上述的讲解中，<code>Cache-Control</code>是服务器向客户端响应的一个消息头，它提供了一个<code>max-age</code>用于指定缓存时间。</p>
<p>实际上，<code>Cache-Control</code>还可以设置下面一个或多个值：</p>
<ul>
<li><code>public</code>：指示服务器资源是公开的。比如有一个页面资源，所有人看到的都是一样的。这个值对于浏览器而言没有什么意义，但可能在某些场景可能有用。本着「我告知，你随意」的原则，<code>http</code>协议中很多时候都是客户端或服务器告诉另一端详细的信息，至于另一端用不用，完全看它自己。</li>
<li><code>private</code>：指示服务器资源是私有的。比如有一个页面资源，每个用户看到的都不一样。这个值对于浏览器而言没有什么意义，但可能在某些场景可能有用。本着「我告知，你随意」的原则，<code>http</code>协议中很多时候都是客户端或服务器告诉另一端详细的信息，至于另一端用不用，完全看它自己。</li>
<li><code>no-cache</code>：告知客户端，你可以缓存这个资源，但是不要<strong>直接</strong>使用它。当你缓存之后，后续的每一次请求都需要附带缓存指令，让服务器告诉你这个资源有没有过期。见：「来自客户端的缓存指令 -  缓存无效」</li>
<li><code>no-store</code>：告知客户端，不要对这个资源做任何的缓存，之后的每一次请求都按照正常的普通请求进行。若设置了这个值，浏览器将不会对该资源做出任何的缓存处理。</li>
<li><code>max-age</code>：不再赘述</li>
</ul>
<p>比如，<code>Cache-Control: public, max-age=3600</code>表示这是一个公开资源，请缓存1个小时。</p>
<h3 id="Expire"><a href="#Expire" class="headerlink" title="Expire"></a>Expire</h3><p>在<code>http1.0</code>版本中，是通过<code>Expire</code>响应头来指定过期时间点的，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Expire: Thu, 30 Apr 2020 23:38:38 GMT</span><br></pre></td></tr></table></figure>

<p>到了<code>http1.1</code>版本，已更改为通过<code>Cache-Control</code>的<code>max-age</code>来记录了。</p>
<h3 id="记录缓存时的有效期"><a href="#记录缓存时的有效期" class="headerlink" title="记录缓存时的有效期"></a>记录缓存时的有效期</h3><p>浏览器会按照服务器响应头的要求，自动记录缓存到本地文件，并设置各种相关信息</p>
<p>在这些信息中，<strong>有效期</strong>尤为关键，它决定了这个缓存可以使用多久</p>
<p>浏览器会根据服务器不同的响应情况，设置不同的有效期</p>
<p>具体的有效期设置，按照下面的流程进行：</p>
<img src="/images/node/服务器与客户端通信-http缓存6.jpg" alt="image-20200501075337464" style="zoom:33%;" />

<p>例如，当<code>max-age</code>设置为0时，缓存立即过期</p>
<p>虽然立即过期，但缓存仍然被记录下来，后续的请求通过缓存指令发送到服务器，来确认资源是否被更改。</p>
<p>因此，<code>Cache-Control: max-age=0</code>类似于<code>Cache-Control: no-cache</code></p>
<h3 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a>Pragma</h3><p>这是<code>http1.0</code>版本的消息头</p>
<p>当该消息头出现在请求中时，是向服务器表达：不要考虑任何缓存，给我一个正常的结果。</p>
<p>在<code>http1.1</code>版本中，可以在<strong>请求头</strong>中加入<code>Cache-Control: no-cache</code>实现同样的含义。</p>
<blockquote>
<p>是的，<code>Cache-Control</code>可以出现在请求头中</p>
</blockquote>
<p>在<code>Chrome</code>浏览器中调试时，如果勾选了<code>Disable cache</code>，则发送的请求中会附带该信息</p>
<p><img src="/images/node/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%80%9A%E4%BF%A1-http%E7%BC%93%E5%AD%987.jpg" alt="image-20200501080330131"></p>
<h3 id="Vary"><a href="#Vary" class="headerlink" title="Vary"></a>Vary</h3><p>有的时候，是否有缓存，不仅仅是判断请求方法和请求路径是否匹配，可能还要判断头部信息是否匹配。</p>
<p>此时，就可以使用<code>Vary</code>字段来指定要区分的消息头</p>
<p>比如，当使用<code>GET /personal.html</code>请求服务器时，请求头中<code>cookie</code>的值不一样，得到的页面也不一样</p>
<p>如果还按照之前的做法，仅仅匹配请求方法和请求路径，如果<code>cookie</code>变动，你可能得到的仍然是之前的页面。</p>
<p>正确的做法如下：</p>
<img src="/images/node/服务器与客户端通信-http缓存8.jpg" alt="image-20200501082103089" style="zoom:33%;" />

<h3 id="使用版本号或hash"><a href="#使用版本号或hash" class="headerlink" title="使用版本号或hash"></a>使用版本号或hash</h3><p>如果你是一个前端工程师，使用过<code>vue</code>或其他基于<code>webpack</code>搭建的工程</p>
<p>你会发现打包的结果中很多文件名类似于这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">app.68297cd8.css</span><br></pre></td></tr></table></figure>

<p>文件的中间部分使用了<code>hash</code>值</p>
<p>这样做的好处是，可以让客户端大胆的、长时间的缓存该文件，减轻服务器的压力</p>
<p>当文件改动后，它的文件<code>hash</code>值也会随之而变，比如变成了<code>app.446fccb8.css</code></p>
<p>这样一来，客户端要请求新的文件时，就会发现路径从<code>/app.68297cd8.css</code>变成了<code>app.446fccb8.css</code>，由于之前的缓存路径无法匹配到，因此就会发送新的请求来获取新资源了。</p>
<p>以上是现代流行的做法。</p>
<p>而在古老的年代，还没有构建工具出现时，人们使用的办法是在资源路径后面加入版本号来获取新版本的文件</p>
<p>比如，页面中引入了一个css资源<code>app.css</code>，它可能的引入方式是：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;/app.css?v=1.0.0&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样一来，缓存的路径是<code>/app.css?v=1.0.0</code></p>
<p>当服务器的版本发生变化时，可以给予新的版本号，让html中的路径发生变动</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;/app.css?v=1.0.1&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>由于新的路径无法命中缓存，于是浏览器就会发送新的普通请求来获取这个资源</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后，通过客户端和服务器两位大佬的视角，来总结一下以上内容</p>
<h3 id="服务器视角"><a href="#服务器视角" class="headerlink" title="服务器视角"></a>服务器视角</h3><p>服务器无法知道客户端到底有没有像浏览器那样缓存文件，它只管根据请求的情况来决定如何响应</p>
<p><img src="/images/node/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%80%9A%E4%BF%A1-http%E7%BC%93%E5%AD%989.jpg" alt="image-20200501083702987"></p>
<p>很多后端语言搭建的服务器都会自带自己的默认缓存规则，当然也支持不同程度的修改</p>
<h3 id="浏览器视角"><a href="#浏览器视角" class="headerlink" title="浏览器视角"></a>浏览器视角</h3><p>浏览器在发出请求时会判断要不要使用缓存</p>
<img src="/images/node/服务器与客户端通信-http缓存10.jpg" alt="image-20200501084258712" style="zoom:50%;" />

<p>当收到服务器响应时，会自动根据缓存指令进行处理</p>
<img src="/images/node/服务器与客户端通信-http缓存11.jpg" alt="image-20200501084559394" style="zoom:50%;" />

]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>node</category>
        <category>服务器和客户端通信</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>node</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>jwt的简介</title>
    <url>/135xyq.github.io/2022/03/15/node-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%80%9A%E4%BF%A1-jwt/</url>
    <content><![CDATA[<h1 id="jwt"><a href="#jwt" class="headerlink" title="jwt"></a>jwt</h1><p>随着前后端分离的发展，以及数据中心的建立，越来越多的公司会创建一个中心服务器，服务于各种产品线。</p>
<p>而这些产品线上的产品，它们可能有着各种终端设备，包括但不仅限于浏览器、桌面应用、移动端应用、平板应用、甚至智能家居</p>
<p><img src="/images/node/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%AE%A2%E6%9C%8D%E7%AB%AF%E4%B9%8B%E9%97%B4-jwt-1.png" alt="image-20200422163727151"></p>
<blockquote>
<p>实际上，不同的产品线通常有自己的服务器，产品内部的数据一般和自己的服务器交互。</p>
<p>但中心服务器仍然有必要存在，因为同一家公司的产品总是会存在共享的数据，比如用户数据</p>
</blockquote>
<p>这些设备与中心服务器之间会进行http通信</p>
<p>一般来说，中心服务器至少承担着认证和授权的功能，例如登录：各种设备发送消息到中心服务器，然后中心服务器响应一个身份令牌（参见<a href="http://www.yuanjin.tech/article/98">cookie原理详解</a>）</p>
<p>当这种结构出现后，就出现一个问题：它们之间还能使用传统的cookie方式传递令牌信息吗？</p>
<p>其实，也是可以的🐶，因为cookie在传输中无非是一个消息头而已，只不过浏览器对这个消息头有特殊处理罢了。</p>
<p>但浏览器之外的设备肯定不喜欢cookie，因为浏览器有着对cookie完善的管理机制，但是在其他设备上，就需要开发者自己手动处理了</p>
<p>jwt的出现就是为了解决这个问题</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>jwt全称<code>Json Web Token</code>，强行翻译过来就是<code>json格式的互联网令牌</code></p>
<p>它要解决的问题，就是为多种终端设备，提供<strong>统一的、安全的</strong>令牌格式</p>
<p><img src="/images/node/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%AE%A2%E6%9C%8D%E7%AB%AF%E4%B9%8B%E9%97%B4-jwt-2.png" alt="image-20200422165350268"></p>
<p>因此，jwt只是一个令牌格式而已，你可以把它存储到cookie，也可以存储到localstorage，没有任何限制！</p>
<p>同样的，对于传输，你可以使用任何传输方式来传输jwt，一般来说，我们会使用消息头来传输它</p>
<p>比如，当登录成功后，服务器可以给客户端响应一个jwt：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">...</span><br><span class="line">set-cookie:token=jwt令牌</span><br><span class="line">authorization:jwt令牌</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#123;..., token:jwt令牌&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，jwt令牌可以出现在响应的任何一个地方，客户端和服务器自行约定即可。</p>
<blockquote>
<p>当然，它也可以出现在响应的多个地方，比如为了充分利用浏览器的cookie，同时为了照顾其他设备，也可以让jwt出现在<code>set-cookie</code>和<code>authorization或body</code>中，尽管这会增加额外的传输量。</p>
</blockquote>
<p>当客户端拿到令牌后，它要做的只有一件事：存储它。</p>
<p>你可以存储到任何位置，比如手机文件、PC文件、localstorage、cookie</p>
<p>当后续请求发生时，你只需要将它作为请求的一部分发送到服务器即可。</p>
<p>虽然jwt没有明确要求应该如何附带到请求中，但通常我们会使用如下的格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /api/resources HTTP/1.1</span><br><span class="line">...</span><br><span class="line">authorization: bearer jwt令牌</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这种格式是OAuth2附带token的一种规范格式</p>
<p>至于什么是OAuth2，那是另一个话题了</p>
</blockquote>
<p>这样一来，服务器就能够收到这个令牌了，通过对令牌的验证，即可知道该令牌是否有效。</p>
<p>它们的完整交互流程是非常简单清晰的</p>
<p><img src="/images/node/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%AE%A2%E6%9C%8D%E7%AB%AF%E4%B9%8B%E9%97%B4-jwt-3.png" alt="image-20200422172837190"></p>
<h2 id="令牌的组成"><a href="#令牌的组成" class="headerlink" title="令牌的组成"></a>令牌的组成</h2><p>为了保证令牌的安全性，jwt令牌由三个部分组成，分别是：</p>
<ol>
<li>header：令牌头部，记录了整个令牌的类型和签名算法</li>
<li>payload：令牌负荷，记录了保存的主体信息，比如你要保存的用户信息就可以放到这里</li>
<li>signature：令牌签名，按照头部固定的签名算法对整个令牌进行签名，该签名的作用是：保证令牌不被伪造和篡改</li>
</ol>
<p>它们组合而成的完整格式是：<code>header.payload.signature</code></p>
<p>比如，一个完整的jwt令牌如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmb28iOiJiYXIiLCJpYXQiOjE1ODc1NDgyMTV9.BCwUy3jnUQ_E6TqCayc7rCHkx-vxxdagUwPOWqwYCFc</span><br></pre></td></tr></table></figure>

<p>它各个部分的值分别是：</p>
<ul>
<li><code>header：eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</code></li>
<li><code>payload：eyJmb28iOiJiYXIiLCJpYXQiOjE1ODc1NDgyMTV9</code></li>
<li><code>signature: BCwUy3jnUQ_E6TqCayc7rCHkx-vxxdagUwPOWqwYCFc</code></li>
</ul>
<p>下面分别对每个部分进行说明</p>
<h3 id="header"><a href="#header" class="headerlink" title="header"></a>header</h3><p>它是令牌头部，记录了整个令牌的类型和签名算法</p>
<p>它的格式是一个<code>json</code>对象，如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;alg&quot;</span>:<span class="string">&quot;HS256&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;typ&quot;</span>:<span class="string">&quot;JWT&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该对象记录了：</p>
<ul>
<li>alg：signature部分使用的签名算法，通常可以取两个值<ul>
<li>HS256：一种对称加密算法，使用同一个秘钥对signature加密解密</li>
<li>RS256：一种非对称加密算法，使用私钥加密，公钥解密</li>
</ul>
</li>
<li>typ：整个令牌的类型，固定写<code>JWT</code>即可</li>
</ul>
<p>设置好了<code>header</code>之后，就可以生成<code>header</code>部分了</p>
<p>具体的生成方式及其简单，就是把<code>header</code>部分使用<code>base64 url</code>编码即可</p>
<blockquote>
<p><code>base64 url</code>不是一个加密算法，而是一种编码方式，它是在<code>base64</code>算法的基础上对<code>+</code>、<code>=</code>、<code>/</code>三个字符做出特殊处理的算法</p>
<p>而<code>base64</code>是使用64个可打印字符来表示一个二进制数据，具体的做法参考<a href="https://baike.baidu.com/item/base64/8545775?fr=aladdin">百度百科</a></p>
</blockquote>
<p>浏览器提供了<code>btoa</code>函数，可以完成这个操作：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.btoa(<span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">  <span class="string">&quot;alg&quot;</span>:<span class="string">&quot;HS256&quot;</span>,</span><br><span class="line">  <span class="string">&quot;typ&quot;</span>:<span class="string">&quot;JWT&quot;</span></span><br><span class="line">&#125;))</span><br><span class="line"><span class="comment">// 得到字符串：eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</span></span><br></pre></td></tr></table></figure>

<p>同样的，浏览器也提供了<code>atob</code>函数，可以对其进行解码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.atob(<span class="string">&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9&quot;</span>)</span><br><span class="line"><span class="comment">// 得到字符串：&#123;&quot;alg&quot;:&quot;HS256&quot;,&quot;typ&quot;:&quot;JWT&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>nodejs中没有提供这两个函数，可以安装第三方库<code>atob</code>和<code>bota</code>搞定</p>
<p>或者，手动搞定</p>
</blockquote>
<h3 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h3><p>这部分是jwt的主体信息，它仍然是一个JSON对象，它可以包含以下内容：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  	<span class="attr">&quot;ss&quot;</span>:<span class="string">&quot;发行者&quot;</span>,</span><br><span class="line">	<span class="attr">&quot;iat&quot;</span>:<span class="string">&quot;发布时间&quot;</span>,</span><br><span class="line">	<span class="attr">&quot;exp&quot;</span>:<span class="string">&quot;到期时间&quot;</span>,</span><br><span class="line">	<span class="attr">&quot;sub&quot;</span>:<span class="string">&quot;主题&quot;</span>,</span><br><span class="line">	<span class="attr">&quot;aud&quot;</span>:<span class="string">&quot;听众&quot;</span>,</span><br><span class="line">	<span class="attr">&quot;nbf&quot;</span>:<span class="string">&quot;在此之前不可用&quot;</span>	,</span><br><span class="line">  	<span class="attr">&quot;jti&quot;</span>:<span class="string">&quot;JWT ID&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上属性可以全写，也可以一个都不写，它只是一个规范，就算写了，也需要你在将来验证这个jwt令牌时手动处理才能发挥作用</p>
<p>上述属性表达的含义分别是：</p>
<ul>
<li>ss：发行该jwt的是谁，可以写公司名字，也可以写服务名称</li>
<li>iat：该jwt的发放时间，通常写当前时间的时间戳</li>
<li>exp：该jwt的到期时间，通常写时间戳</li>
<li>sub：该jwt是用于干嘛的</li>
<li>aud：该jwt是发放给哪个终端的，可以是终端类型，也可以是用户名称，随意一点</li>
<li>nbf：一个时间点，在该时间点到达之前，这个令牌是不可用的</li>
<li>jti：jwt的唯一编号，设置此项的目的，主要是为了防止重放攻击（重放攻击是在某些场景下，用户使用之前的令牌发送到服务器，被服务器正确的识别，从而导致不可预期的行为发生）</li>
</ul>
<p>当用户登陆成功之后，我可能需要把用户的一些信息写入到jwt令牌中，比如用户id、账号等等</p>
<p>其实很简单，payload这一部分只是一个json对象而已，你可以向对象中加入任何想要加入的信息</p>
<p>比如，下面的json对象仍然是一个有效的payload</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;foo&quot;</span>:<span class="string">&quot;bar&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;iat&quot;</span>:<span class="number">1587548215</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>foo: bar</code>是我们自定义的信息，<code>iat: 1587548215</code>是jwt规范中的信息</p>
<p>最终，payload部分和header一样，需要通过<code>base64 url</code>编码得到：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.btoa(<span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">  <span class="string">&quot;foo&quot;</span>:<span class="string">&quot;bar&quot;</span>,</span><br><span class="line">  <span class="string">&quot;iat&quot;</span>:<span class="number">1587548215</span></span><br><span class="line">&#125;))</span><br><span class="line"><span class="comment">// 得到字符串：eyJmb28iOiJiYXIiLCJpYXQiOjE1ODc1NDgyMTV9</span></span><br></pre></td></tr></table></figure>

<h3 id="signature"><a href="#signature" class="headerlink" title="signature"></a>signature</h3><p>这一部分是jwt的签名，正是它的存在，保证了整个jwt不被篡改</p>
<p>这部分的生成，是对前面两个部分的编码结果，按照头部指定的方式进行加密</p>
<p>比如：头部指定的加密方法是<code>HS256</code>，前面两部分的编码结果是<code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmb28iOiJiYXIiLCJpYXQiOjE1ODc1NDgyMTV9</code></p>
<p>则第三部分就是用对称加密算法<code>HS256</code>对字符串<code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmb28iOiJiYXIiLCJpYXQiOjE1ODc1NDgyMTV9</code>进行加密，当然你得指定一个秘钥，比如<code>shhhhh</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">HS256(<span class="string">`eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmb28iOiJiYXIiLCJpYXQiOjE1ODc1NDgyMTV9`</span>, <span class="string">&quot;shhhhh&quot;</span>)</span><br><span class="line"><span class="comment">// 得到：BCwUy3jnUQ_E6TqCayc7rCHkx-vxxdagUwPOWqwYCFc</span></span><br></pre></td></tr></table></figure>

<p>最终，将三部分组合在一起，就得到了完整的jwt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmb28iOiJiYXIiLCJpYXQiOjE1ODc1NDgyMTV9.BCwUy3jnUQ_E6TqCayc7rCHkx-vxxdagUwPOWqwYCFc</span><br></pre></td></tr></table></figure>

<p>由于签名使用的秘钥保存在服务器，这样一来，客户端就无法伪造出签名，因为它拿不到秘钥。</p>
<p>换句话说，之所以说无法伪造jwt，就是因为第三部分的存在。</p>
<p>而前面两部分并没有加密，只是一个编码结果而已，可以认为几乎是明文传输</p>
<blockquote>
<p>这不会造成太大的问题，因为既然用户登陆成功了，它当然有权力查看自己的用户信息</p>
<p>甚至在某些网站，用户的基本信息可以被任何人查看</p>
<p>你要保证的，是不要把敏感的信息存放到jwt中，比如密码</p>
</blockquote>
<p>jwt的<code>signature</code>可以保证令牌不被伪造，那如何保证令牌不被篡改呢？</p>
<p>比如，某个用户登陆成功了，获得了jwt，但他人为的篡改了<code>payload</code>，比如把自己的账户余额修改为原来的两倍，然后重新编码出<code>payload</code>发送到服务器</p>
<h2 id="令牌的验证"><a href="#令牌的验证" class="headerlink" title="令牌的验证"></a>令牌的验证</h2><p><img src="/images/node/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%AE%A2%E6%9C%8D%E7%AB%AF%E4%B9%8B%E9%97%B4-jwt-4.png" alt="image-20200422172837190"></p>
<p>令牌在服务器组装完成后，会以任意的方式发送到客户端</p>
<p>客户端会把令牌保存起来，后续的请求会将令牌发送给服务器</p>
<p>而服务器需要验证令牌是否正确，如何验证呢？</p>
<p>首先，服务器要验证这个令牌是否被篡改过，验证方式非常简单，就是对<code>header+payload</code>用同样的秘钥和加密算法进行重新加密</p>
<p>然后把加密的结果和传入jwt的<code>signature</code>进行对比，如果完全相同，则表示前面两部分没有动过，就是自己颁发的，如果不同，肯定是被篡改过了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">传入的header.传入的payload.传入的signature</span><br><span class="line">新的signature = header中的加密算法(传入的header.传入的payload, 秘钥)</span><br><span class="line">验证：新的signature == 传入的signature</span><br></pre></td></tr></table></figure>

<p>当令牌验证为没有被篡改后，服务器可以进行其他验证：比如是否过期、听众是否满足要求等等，这些就视情况而定了</p>
<p>注意：这些验证都需要服务器手动完成，可以借助第三方库来完成这些操作</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>jwt本质上是一种令牌格式。它和终端设备无关，同样和服务器无关，甚至与如何传输无关，它只是规范了令牌的格式而已</li>
<li>jwt由三部分组成：header、payload、signature。主体信息在payload</li>
<li>jwt难以被篡改和伪造。这是因为有第三部分的签名存在。</li>
</ul>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>node</category>
        <category>服务器和客户端通信</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>node</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>websocket的应用</title>
    <url>/135xyq.github.io/2022/03/18/node-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%80%9A%E4%BF%A1-websocket/</url>
    <content><![CDATA[<h1 id="三种连接"><a href="#三种连接" class="headerlink" title="三种连接"></a>三种连接</h1><h2 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h2><ol>
<li>客户端连接服务器（TCP / IP），三次握手，建立了连接通道</li>
<li>客户端和服务器通过socket接口发送消息和接收消息，任何一端在任何时候，都可以向另一端发送任何消息</li>
<li>有一端断开了，通道销毁</li>
</ol>
<h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><ol>
<li>客户端连接服务器（TCP / IP），三次握手，建立了连接通道</li>
<li>客户端发送一个http格式的消息（消息头 消息体），服务器响应http格式的消息（消息头 消息体）</li>
<li>客户端或服务器断开，通道销毁</li>
</ol>
<p>实时性的问题</p>
<ol>
<li>轮询</li>
<li>长连接</li>
</ol>
<h2 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h2><p>专门用于解决实时传输的问题</p>
<ol>
<li>客户端连接服务器（TCP / IP），三次握手，建立了连接通道</li>
<li>客户端发送一个http格式的消息（特殊格式），服务器也响应一个http格式的消息（特殊格式），称之为http握手</li>
<li>双发自由通信，通信格式按照websocket的要求进行</li>
<li>客户端或服务器断开，通道销毁</li>
</ol>
<p>在websocket的http握手阶段，服务器响应头中需要包含如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: [key]</span><br></pre></td></tr></table></figure>

<p>其中，<code>Sec-WebSocket-Accept</code>的值来自于以下算法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">base64(sha1(Sec-WebSocket-Key) + <span class="string">&quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot;</span>) </span><br></pre></td></tr></table></figure>

<p>在<code>node</code>中可以使用以下代码获得：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&quot;crypto&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> hash = crypto.createHash(<span class="string">&quot;sha1&quot;</span>);</span><br><span class="line">hash.update(requestKey + <span class="string">&quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> key = hash.digest(<span class="string">&quot;base64&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>其中，<code>requestKey</code>来自于请求头中的<code>Sec-WebSocket-Key</code></p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>node</category>
        <category>服务器和客户端通信</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>node</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>跨域处理</title>
    <url>/135xyq.github.io/2022/03/14/node-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%80%9A%E4%BF%A1-%E8%B7%A8%E5%9F%9F%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h1><h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><p>同源：端口、主机名、协议完全相同。<br>浏览器不允许使用非同源的数据。</p>
<h3 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h3><ol>
<li>浏览器生成一个script元素，访问数据接口；</li>
<li>服务器响应一段js代码，调用某个函数，并把响应的数据传入。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>会影响服务器的正常响应格式</li>
<li>只能使用GET请求</li>
</ol>
<h2 id="cros"><a href="#cros" class="headerlink" title="cros"></a>cros</h2><blockquote>
<p>阅读本文，你需要首先知道：</p>
<ol>
<li>浏览器的同源策略</li>
<li>跨域问题</li>
<li>JSONP原理</li>
<li>cookie原理</li>
</ol>
</blockquote>
<p>JSONP并不是一个好的跨域解决方案，它至少有着下面两个严重问题：</p>
<ol>
<li><strong>会打乱服务器的消息格式</strong>：JSONP要求服务器响应一段JS代码，但在非跨域的情况下，服务器又需要响应一个正常的JSON格式</li>
<li><strong>只能完成GET请求</strong>：JSONP的原理会要求浏览器端生成一个<code>script</code>元素，而<code>script</code>元素发出的请求只能是<code>get</code>请求</li>
</ol>
<p>所以，CORS是一种更好的跨域解决方案。</p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><code>CORS</code>是基于<code>http1.1</code>的一种跨域解决方案，它的全称是<strong>C</strong>ross-<strong>O</strong>rigin <strong>R</strong>esource <strong>S</strong>haring，跨域资源共享。</p>
<p>它的总体思路是：<strong>如果浏览器要跨域访问服务器的资源，需要获得服务器的允许</strong></p>
<p><img src="/images/node/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B9%8B%E9%97%B4-cors%E8%AF%B7%E6%B1%82.png"></p>
<p>而要知道，一个请求可以附带很多信息，从而会对服务器造成不同程度的影响</p>
<p>比如有的请求只是获取一些新闻，有的请求会改动服务器的数据</p>
<p>针对不同的请求，CORS规定了三种不同的交互模式，分别是：</p>
<ul>
<li><strong>简单请求</strong></li>
<li><strong>需要预检的请求</strong></li>
<li><strong>附带身份凭证的请求</strong></li>
</ul>
<p>这三种模式从上到下层层递进，请求可以做的事越来越多，要求也越来越严格。</p>
<p>下面分别说明三种请求模式的具体规范。</p>
<h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3><p>当浏览器端运行了一段ajax代码（无论是使用XMLHttpRequest还是fetch api），浏览器会首先判断它属于哪一种请求模式</p>
<h4 id="简单请求的判定"><a href="#简单请求的判定" class="headerlink" title="简单请求的判定"></a>简单请求的判定</h4><p>当请求<strong>同时满足</strong>以下条件时，浏览器会认为它是一个简单请求：</p>
<ol>
<li><p><strong>请求方法属于下面的一种：</strong></p>
<ul>
<li>get</li>
<li>post</li>
<li>head</li>
</ul>
</li>
<li><p><strong>请求头仅包含安全的字段，常见的安全字段如下：</strong></p>
<ul>
<li><code>Accept</code></li>
<li><code>Accept-Language</code></li>
<li><code>Content-Language</code></li>
<li><code>Content-Type</code></li>
<li><code>DPR</code></li>
<li><code>Downlink</code></li>
<li><code>Save-Data</code></li>
<li><code>Viewport-Width</code></li>
<li><code>Width</code></li>
</ul>
</li>
<li><p><strong>请求头如果包含<code>Content-Type</code>，仅限下面的值之一：</strong></p>
<ul>
<li><code>text/plain</code></li>
<li><code>multipart/form-data</code></li>
<li><code>application/x-www-form-urlencoded</code></li>
</ul>
</li>
</ol>
<p>如果以上三个条件同时满足，浏览器判定为简单请求。</p>
<p>下面是一些例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单请求</span></span><br><span class="line">fetch(<span class="string">&quot;http://crossdomain.com/api/news&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求方法不满足要求，不是简单请求</span></span><br><span class="line">fetch(<span class="string">&quot;http://crossdomain.com/api/news&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>:<span class="string">&quot;PUT&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加入了额外的请求头，不是简单请求</span></span><br><span class="line">fetch(<span class="string">&quot;http://crossdomain.com/api/news&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">headers</span>:&#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单请求</span></span><br><span class="line">fetch(<span class="string">&quot;http://crossdomain.com/api/news&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&quot;post&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// content-type不满足要求，不是简单请求</span></span><br><span class="line">fetch(<span class="string">&quot;http://crossdomain.com/api/news&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&quot;post&quot;</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="string">&quot;content-type&quot;</span>: <span class="string">&quot;application/json&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="简单请求的交互规范"><a href="#简单请求的交互规范" class="headerlink" title="简单请求的交互规范"></a>简单请求的交互规范</h4><p>当浏览器判定某个<strong>ajax跨域请求</strong>是<strong>简单请求</strong>时，会发生以下的事情</p>
<ol>
<li><strong>请求头中会自动添加<code>Origin</code>字段</strong></li>
</ol>
<p>比如，在页面<code>http://my.com/index.html</code>中有以下代码造成了跨域</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单请求</span></span><br><span class="line">fetch(<span class="string">&quot;http://crossdomain.com/api/news&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>请求发出后，请求头会是下面的格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /api/news/ HTTP/1.1</span><br><span class="line">Host: crossdomain.com</span><br><span class="line">Connection: keep-alive</span><br><span class="line">...</span><br><span class="line">Referer: http://my.com/index.html</span><br><span class="line">Origin: http://my.com</span><br></pre></td></tr></table></figure>

<p>看到最后一行没，<code>Origin</code>字段会告诉服务器，是哪个源地址在跨域请求</p>
<ol start="2">
<li><strong>服务器响应头中应包含<code>Access-Control-Allow-Origin</code></strong></li>
</ol>
<p>当服务器收到请求后，如果允许该请求跨域访问，需要在响应头中添加<code>Access-Control-Allow-Origin</code>字段</p>
<p>该字段的值可以是：</p>
<ul>
<li>*：表示我很开放，什么人我都允许访问</li>
<li>具体的源：比如<code>http://my.com</code>，表示我就允许你访问</li>
</ul>
<blockquote>
<p>实际上，这两个值对于客户端<code>http://my.com</code>而言，都一样，因为客户端才不会管其他源服务器允不允许，就关心自己是否被允许</p>
<p>当然，服务器也可以维护一个可被允许的源列表，如果请求的<code>Origin</code>命中该列表，才响应<code>*</code>或具体的源</p>
<p><strong>为了避免后续的麻烦，强烈推荐响应具体的源</strong></p>
</blockquote>
<p>假设服务器做出了以下的响应：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Tue, 21 Apr 2020 08:03:35 GMT</span><br><span class="line">...</span><br><span class="line">Access-Control-Allow-Origin: http://my.com</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">消息体中的数据</span><br></pre></td></tr></table></figure>

<p>当浏览器看到服务器允许自己访问后，高兴的像一个两百斤的孩子，于是，它就把响应顺利的交给js，以完成后续的操作</p>
<p>下图简述了整个交互过程</p>
<p><img src="/images/node/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B9%8B%E9%97%B4-cors%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82.png"></p>
<h3 id="需要预检的请求"><a href="#需要预检的请求" class="headerlink" title="需要预检的请求"></a>需要预检的请求</h3><p>简单的请求对服务器的威胁不大，所以允许使用上述的简单交互即可完成。</p>
<p>但是，如果浏览器不认为这是一种简单请求，就会按照下面的流程进行：</p>
<ol>
<li><strong>浏览器发送预检请求，询问服务器是否允许</strong></li>
<li><strong>服务器允许</strong></li>
<li><strong>浏览器发送真实请求</strong></li>
<li><strong>服务器完成真实的响应</strong></li>
</ol>
<p>比如，在页面<code>http://my.com/index.html</code>中有以下代码造成了跨域</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需要预检的请求</span></span><br><span class="line">fetch(<span class="string">&quot;http://crossdomain.com/api/user&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>:<span class="string">&quot;POST&quot;</span>, <span class="comment">// post 请求</span></span><br><span class="line">  <span class="attr">headers</span>:&#123;  <span class="comment">// 设置请求头</span></span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&quot;content-type&quot;</span>: <span class="string">&quot;application/json&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">body</span>: <span class="built_in">JSON</span>.stringify(&#123; <span class="attr">name</span>: <span class="string">&quot;袁小进&quot;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;) <span class="comment">// 设置请求体</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>浏览器发现它不是一个简单请求，则会按照下面的流程与服务器交互</p>
<ol>
<li><strong>浏览器发送预检请求，询问服务器是否允许</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OPTIONS /api/user HTTP/1.1</span><br><span class="line">Host: crossdomain.com</span><br><span class="line">...</span><br><span class="line">Origin: http://my.com</span><br><span class="line">Access-Control-Request-Method: POST</span><br><span class="line">Access-Control-Request-Headers: a, b, content-type</span><br></pre></td></tr></table></figure>

<p>可以看出，这并非我们想要发出的真实请求，请求中不包含我们的响应头，也没有消息体。</p>
<p>这是一个预检请求，它的目的是询问服务器，是否允许后续的真实请求。</p>
<p>预检请求<strong>没有请求体</strong>，它包含了后续真实请求要做的事情</p>
<p>预检请求有以下特征：</p>
<ul>
<li>请求方法为<code>OPTIONS</code></li>
<li>没有请求体</li>
<li>请求头中包含<ul>
<li><code>Origin</code>：请求的源，和简单请求的含义一致</li>
<li><code>Access-Control-Request-Method</code>：后续的真实请求将使用的请求方法</li>
<li><code>Access-Control-Request-Headers</code>：后续的真实请求会改动的请求头</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>服务器允许</strong></li>
</ol>
<p>服务器收到预检请求后，可以检查预检请求中包含的信息，如果允许这样的请求，需要响应下面的消息格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Tue, 21 Apr 2020 08:03:35 GMT</span><br><span class="line">...</span><br><span class="line">Access-Control-Allow-Origin: http://my.com</span><br><span class="line">Access-Control-Allow-Methods: POST</span><br><span class="line">Access-Control-Allow-Headers: a, b, content-type</span><br><span class="line">Access-Control-Max-Age: 86400</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>对于预检请求，不需要响应任何的消息体，只需要在响应头中添加：</p>
<ul>
<li><code>Access-Control-Allow-Origin</code>：和简单请求一样，表示允许的源</li>
<li><code>Access-Control-Allow-Methods</code>：表示允许的后续真实的请求方法</li>
<li><code>Access-Control-Allow-Headers</code>：表示允许改动的请求头</li>
<li><code>Access-Control-Max-Age</code>：告诉浏览器，多少秒内，对于同样的请求源、方法、头，都不需要再发送预检请求了</li>
</ul>
<ol start="3">
<li><strong>浏览器发送真实请求</strong></li>
</ol>
<p>预检被服务器允许后，浏览器就会发送真实请求了，上面的代码会发生下面的请求数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /api/user HTTP/1.1</span><br><span class="line">Host: crossdomain.com</span><br><span class="line">Connection: keep-alive</span><br><span class="line">...</span><br><span class="line">Referer: http://my.com/index.html</span><br><span class="line">Origin: http://my.com</span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;: &quot;袁小进&quot;, &quot;age&quot;: 18 &#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>服务器响应真实请求</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Tue, 21 Apr 2020 08:03:35 GMT</span><br><span class="line">...</span><br><span class="line">Access-Control-Allow-Origin: http://my.com</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">添加用户成功</span><br></pre></td></tr></table></figure>



<p>可以看出，当完成预检之后，后续的处理与简单请求相同</p>
<p>下图简述了整个交互过程</p>
<p><img src="/images/node/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B9%8B%E9%97%B4-cors%E9%9C%80%E8%A6%81%E9%A2%84%E8%A7%81%E7%9A%84%E8%AF%B7%E6%B1%82.png"></p>
<h3 id="附带身份凭证的请求"><a href="#附带身份凭证的请求" class="headerlink" title="附带身份凭证的请求"></a>附带身份凭证的请求</h3><p>默认情况下，ajax的跨域请求并不会附带cookie，这样一来，某些需要权限的操作就无法进行</p>
<p>不过可以通过简单的配置就可以实现附带cookie</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// xhr</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fetch api</span></span><br><span class="line">fetch(url, &#123;</span><br><span class="line">  <span class="attr">credentials</span>: <span class="string">&quot;include&quot;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这样一来，该跨域的ajax请求就是一个<em>附带身份凭证的请求</em></p>
<p>当一个请求需要附带cookie时，无论它是简单请求，还是预检请求，都会在请求头中添加<code>cookie</code>字段</p>
<p>而服务器响应时，需要明确告知客户端：服务器允许这样的凭据</p>
<p>告知的方式也非常的简单，只需要在响应头中添加：<code>Access-Control-Allow-Credentials: true</code>即可</p>
<p>对于一个附带身份凭证的请求，若服务器没有明确告知，浏览器仍然视为跨域被拒绝。</p>
<p>另外要特别注意的是：**对于附带身份凭证的请求，服务器不得设置 <code>Access-Control-Allow-Origin 的值为*</code>**。这就是为什么不推荐使用*的原因</p>
<h3 id="一个额外的补充"><a href="#一个额外的补充" class="headerlink" title="一个额外的补充"></a>一个额外的补充</h3><p>在跨域访问时，JS只能拿到一些最基本的响应头，如：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其他头，则需要服务器设置本响应头。</p>
<p><code>Access-Control-Expose-Headers</code>头让服务器把允许浏览器访问的头放入白名单，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Access-Control-Expose-Headers: authorization, a, b</span><br></pre></td></tr></table></figure>

<p>这样JS就能够访问指定的响应头了。</p>
<h3 id="使用cors中间件处理跨域问题"><a href="#使用cors中间件处理跨域问题" class="headerlink" title="使用cors中间件处理跨域问题"></a>使用<a href="https://github.com/expressjs/cors">cors中间件</a>处理跨域问题</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> whiteList = [<span class="string">&quot;null&quot;</span>]; <span class="comment">//白名单</span></span><br><span class="line">app.use(</span><br><span class="line">    cors(&#123;</span><br><span class="line">        <span class="function"><span class="title">origin</span>(<span class="params">origin, callback</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (whiteList.includes(origin)) &#123;</span><br><span class="line">                callback(<span class="literal">null</span>, origin);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;not allowed&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">credentials</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>node</category>
        <category>服务器和客户端通信</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>node</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>react Hook 其他Hook</title>
    <url>/135xyq.github.io/2022/06/29/react-Hook-State%20Hook%20copy/</url>
    <content><![CDATA[<h1 id="其他-Hook"><a href="#其他-Hook" class="headerlink" title="其他 Hook"></a>其他 Hook</h1><h2 id="Reducer-Hook"><a href="#Reducer-Hook" class="headerlink" title="Reducer Hook"></a><a href="https://react.docschina.org/docs/hooks-reference.html#usereducer">Reducer Hook</a></h2><p>Flux：Facebook 出品的一个数据流框架</p>
<ol>
<li>规定了数据是单向流动的</li>
<li>数据存储在数据仓库中（目前，可以认为 state 就是一个存储数据的仓库）</li>
<li>action 是改变数据的唯一原因（本质上就是一个对象，action 有两个属性）<ol>
<li>type：字符串，动作的类型</li>
<li>payload：任意类型，动作发生后的附加信息</li>
<li>例如，如果是添加一个学生，action 可以描述为：<ol>
<li><code>&#123; type:&quot;addStudent&quot;, payload: &#123;学生对象的各种信息&#125; &#125;</code></li>
</ol>
</li>
<li>例如，如果要删除一个学生，action 可以描述为：<ol>
<li><code>&#123; type:&quot;deleteStudent&quot;, payload: 学生id &#125;</code></li>
</ol>
</li>
</ol>
</li>
<li>具体改变数据的是一个函数，该函数叫做 reducer<ol>
<li>该函数接收两个参数<ol>
<li>state：表示当前数据仓库中的数据</li>
<li>action：描述了如何去改变数据，以及改变数据的一些附加信息</li>
</ol>
</li>
<li>该函数必须有一个返回结果，用于表示数据仓库变化之后的数据<ol>
<li>Flux 要求，对象是不可变的，如果返回对象，必须创建新的对象</li>
</ol>
</li>
<li>reducer 必须是纯函数，不能有任何副作用</li>
</ol>
</li>
<li>如果要触发 reducer，不可以直接调用，而是应该调用一个辅助函数 dispatch<ol>
<li>该函数仅接收一个参数：action</li>
<li>该函数会间接去调用 reducer，以达到改变数据的目的</li>
</ol>
</li>
</ol>
<h2 id="Context-Hook"><a href="#Context-Hook" class="headerlink" title="Context Hook"></a><a href="https://react.docschina.org/docs/hooks-reference.html#usecontext">Context Hook</a></h2><p>获取上下文数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> value = useContext(MyContext);</span><br></pre></td></tr></table></figure>

<p>接收一个 context 对象（React.createContext 的返回值）并返回该 context 的当前值。当前的 context 值由上层组件中距离当前组件最近的 &lt;MyContext.Provider&gt; 的 value prop 决定。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useContext &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ctx = React.createContext();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> value = useContext(ctx);</span><br><span class="line">	<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>上下文数据为：&#123;value&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">ContextHookTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (</span><br><span class="line">		<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">			<span class="tag">&lt;<span class="name">ctx.Provider</span> <span class="attr">value</span>=<span class="string">&quot;xyq&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">				<span class="tag">&lt;<span class="name">Test</span> /&gt;</span></span></span><br><span class="line"><span class="xml">			<span class="tag">&lt;/<span class="name">ctx.Provider</span>&gt;</span></span></span><br><span class="line"><span class="xml">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Callback-Hook"><a href="#Callback-Hook" class="headerlink" title="Callback Hook"></a><a href="https://react.docschina.org/docs/hooks-reference.html#usecallback">Callback Hook</a></h2><p><code>useCallback</code></p>
<p>用于得到一个固定引用值的函数，通常用来进行性能优化</p>
<p>useCallback：</p>
<p>该函数有两个参数：</p>
<ol>
<li>函数，useCallback 会固定该函数的引用，只要依赖项没有发生变化，则始终返回之前函数的地址</li>
<li>数组，记录依赖项</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedCallback = useCallback(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	doSomething(a, b);</span><br><span class="line">&#125;, [a, b]);</span><br></pre></td></tr></table></figure>

<h2 id="Memo-Hook"><a href="#Memo-Hook" class="headerlink" title="Memo Hook"></a><a href="https://react.docschina.org/docs/hooks-reference.html#usememo">Memo Hook</a></h2><p>用于保持一些比较稳定的数据，通常用于性能优化</p>
<h2 id="Ref-Hook"><a href="#Ref-Hook" class="headerlink" title="Ref Hook"></a><a href="https://react.docschina.org/docs/hooks-reference.html#useref">Ref Hook</a></h2><p>useRef:</p>
<ol>
<li>一个参数：默认值</li>
<li>返回值：一个固定的对象，<code>&#123;current:值&#125;</code>， r 变更 <code>.current </code>属性不会引发组件重新渲染。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useRef &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">RefHookTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> inputRef = useRef();</span><br><span class="line">	<span class="keyword">return</span> (</span><br><span class="line">		<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">			<span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">			<span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">				<span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="xml">					console.log(inputRef.current.value);</span></span><br><span class="line"><span class="xml">				&#125;&#125;</span></span><br><span class="line"><span class="xml">			&gt;</span></span><br><span class="line"><span class="xml">				获取input数据</span></span><br><span class="line"><span class="xml">			<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将useRef当成一个固定对象使用</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; useRef, useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">RefHookTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> [n, setN] = useState(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">const</span> nRef = useRef(n);</span><br><span class="line">	useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">let</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">			setN(nRef.current - <span class="number">1</span>);</span><br><span class="line">			nRef.current--;</span><br><span class="line">			<span class="keyword">if</span> (nRef.current === <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="built_in">clearInterval</span>(timer);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">				<span class="built_in">clearInterval</span>(timer);</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;, <span class="number">1000</span>);</span><br><span class="line">	&#125;, []);</span><br><span class="line">	<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;n&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ImperativeHandle-Hook"><a href="#ImperativeHandle-Hook" class="headerlink" title="ImperativeHandle Hook"></a><a href="https://react.docschina.org/docs/hooks-reference.html#useimperativehandle">ImperativeHandle Hook</a></h2><p>useImperativeHandle 可以让你在使用 ref 时自定义暴露给父组件的实例值</p>
<p><code>useImperativeHandle(ref, createHandle, [deps])</code><br>参数一：Ref<br>参数二：一个函数，返回值可以通过ref获取<br>参数三：依赖列表，第一次运行之后，只有依赖项发生变化才会运行</p>
<p>index.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useImperativeHandle &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ImperativeHandleHookTest</span>(<span class="params">props, ref</span>) </span>&#123;</span><br><span class="line">	useImperativeHandle(ref, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			<span class="attr">method</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">				<span class="built_in">console</span>.log(<span class="string">&quot;ImperativeHandleHookTest里面的method方法！&quot;</span>);</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;),[];</span><br><span class="line">	<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>ImperativeHandleHookTest<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.forwardRef(ImperativeHandleHookTest);</span><br></pre></td></tr></table></figure>

<p>test.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useRef &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> ImperativeHandleHookTest <span class="keyword">from</span> <span class="string">&quot;./index&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> componentRef = useRef();</span><br><span class="line">	<span class="keyword">return</span> (</span><br><span class="line">		<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">			<span class="tag">&lt;<span class="name">ImperativeHandleHookTest</span> <span class="attr">ref</span>=<span class="string">&#123;componentRef&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">			<span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">				<span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="xml">					componentRef.current.method();</span></span><br><span class="line"><span class="xml">				&#125;&#125;</span></span><br><span class="line"><span class="xml">			&gt;</span></span><br><span class="line"><span class="xml">				调用ImperativeHandleHookTest里面的一个method方法</span></span><br><span class="line"><span class="xml">			<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="LayoutEffect-Hook"><a href="#LayoutEffect-Hook" class="headerlink" title="LayoutEffect Hook"></a><a href="https://react.docschina.org/docs/hooks-reference.html#uselayouteffect">LayoutEffect Hook</a></h2><p><code>useLayoutEffect</code><br>在浏览器渲染完之前运行，可能导致渲染阻塞</p>
<p><code>useLayoutEffect</code> ：完成了DOM改动，但还没呈现给用户，与类组件的<code>componentDidMount</code>和<code>componentDidUpdate</code>时间点一致<br><code>useEffect</code> 会在浏览器渲染完成，用户看到新的渲染结果后</p>
<p>应该尽量使用<code>useEffect</code>因为他不会导致渲染阻塞。</p>
<h2 id="DebugValue-Hook"><a href="#DebugValue-Hook" class="headerlink" title="DebugValue Hook"></a><a href="https://react.docschina.org/docs/hooks-reference.html#usedebugvalue">DebugValue Hook</a></h2><p><code>usedebugvalue</code>：<br>用于将自定义Hook的关联数据显示到调试栏</p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>react</category>
        <category>Hook</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>react基础 react起步、使用CDN引入、脚手架搭建</title>
    <url>/135xyq.github.io/2022/05/15/react-react%E5%9F%BA%E7%A1%80-CDN%E5%BC%95%E5%85%A5%E5%92%8C%E8%84%9A%E6%89%8B%E6%9E%B6%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="react起步、使用CDN引入、脚手架搭建"><a href="#react起步、使用CDN引入、脚手架搭建" class="headerlink" title="react起步、使用CDN引入、脚手架搭建"></a>react起步、使用CDN引入、脚手架搭建</h1><h2 id="CDN地址"><a href="#CDN地址" class="headerlink" title="CDN地址"></a>CDN地址</h2><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">crossorigin</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react@17/umd/react.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">crossorigin</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react-dom@17/umd/react-dom.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="生产环境"><a href="#生产环境" class="headerlink" title="生产环境"></a>生产环境</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">crossorigin</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react@17/umd/react.production.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">crossorigin</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react-dom@17/umd/react-dom.production.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="react库"><a href="#react库" class="headerlink" title="react库"></a><a href="https://unpkg.com/react@17/umd/react.development.js">react库</a></h2><h3 id="React-createElement"><a href="#React-createElement" class="headerlink" title="React.createElement()"></a>React.createElement()</h3><p>创建一个React元素，虚拟DOM，本质是一个对象。</p>
<ol>
<li>参数一：元素类型，如果是字符串，表示一个HTML元素（本质还是对象）;</li>
<li>参数二：元素的属性，是一个对象;</li>
<li>后续参数：元素的子节点</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> span = React.createElement(<span class="string">&#x27;span&#x27;</span>, &#123;&#125;, <span class="string">&#x27;一个span元素&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> h1 = React.createElement(<span class="string">&#x27;h1&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;第一个react样例&#x27;</span>,</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&#x27;test&#x27;</span></span><br><span class="line">&#125;, <span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27; world&#x27;</span>, span)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="react-dom库"><a href="#react-dom库" class="headerlink" title="react-dom库"></a><a href="https://unpkg.com/react-dom@17/umd/react-dom.development.js">react-dom库</a></h2><h3 id="ReactDOM-render"><a href="#ReactDOM-render" class="headerlink" title="ReactDOM.render()"></a>ReactDOM.render()</h3><p>将react元素渲染到指定的位置，将虚拟的DOM变成真实的DOM</p>
<ol>
<li>参数一： 要渲染的react元素</li>
<li>参数二：要渲染的位置，可以使用dom选择器选中</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> span = React.createElement(<span class="string">&#x27;span&#x27;</span>, &#123;&#125;, <span class="string">&#x27;一个span元素&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> h1 = React.createElement(<span class="string">&#x27;h1&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;第一个react样例&#x27;</span>,</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&#x27;test&#x27;</span></span><br><span class="line">&#125;, <span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27; world&#x27;</span>, span)</span><br><span class="line"></span><br><span class="line">ReactDOM.render(h1, <span class="built_in">document</span>.getElementById(<span class="string">&#x27;react&#x27;</span>))</span><br></pre></td></tr></table></figure>


<h2 id="JSX-JS扩展语法"><a href="#JSX-JS扩展语法" class="headerlink" title="JSX JS扩展语法"></a>JSX JS扩展语法</h2><p>要使用babel进行转义</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/babel-standalone/7.0.0-beta.3/babel.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/babel&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> h1 =</span></span><br><span class="line"><span class="javascript">    <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World <span class="tag">&lt;<span class="name">span</span>&gt;</span>span 标签<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span></span><br><span class="line"><span class="javascript">    ReactDOM.render(h1, <span class="built_in">document</span>.getElementById(<span class="string">&#x27;react&#x27;</span>))</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="使用脚手架来搭建react"><a href="#使用脚手架来搭建react" class="headerlink" title="使用脚手架来搭建react"></a>使用脚手架来搭建react</h2><p>官方脚手架：create-react-app<br>第三方：next.js、umijs</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx  create-react-app project_name</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>react</category>
        <category>react基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>JSX简介和语法</title>
    <url>/135xyq.github.io/2022/05/16/react-react%E5%9F%BA%E7%A1%80-JSX%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h1><h2 id="什么是-JSX"><a href="#什么是-JSX" class="headerlink" title="什么是 JSX"></a>什么是 JSX</h2><ul>
<li>  Facebook 起草的 JS 扩展语法</li>
<li>  本质是一个 JS 对象，会被 babel 编译，最终会被转换为 React.createElement</li>
<li>每个 JSX 表达式，有且仅有一个根节点<ul>
<li>  多个节点同级是可以使用 React.Fragment 或 &lt;&gt; 直接包裹</li>
</ul>
</li>
<li>  每个 JSX 元素必须结束（XML 规范）</li>
<li>  类名要写成className</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> h1 = (</span><br><span class="line">	<span class="xml"><span class="tag">&lt;<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line"><span class="xml">		<span class="tag">&lt;<span class="name">h1</span>&gt;</span> javascript <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span> 你好 <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> h1 = (</span><br><span class="line">	<span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">		<span class="tag">&lt;<span class="name">h1</span>&gt;</span> javascript <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span> 你好 <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;/&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="在-JSX-中嵌入表达式"><a href="#在-JSX-中嵌入表达式" class="headerlink" title="在 JSX 中嵌入表达式"></a>在 JSX 中嵌入表达式</h2><p>使用 {} 包裹要放置的表达式</p>
<ul>
<li>  在 JSX 中使用注释: {/* 注释内容 */}</li>
<li>将表达式作为内容的一部分<ul>
<li>  null、undefined、false 不会显示在页面上，结构上会存在</li>
<li>  普通对象，不可以作为子元素</li>
<li>  可以放置 React 元素对象</li>
<li>  可以放置数组（会遍历数组，将数组的每一项作为子元素添加进去）</li>
</ul>
</li>
<li>  将表达式作为元素属性</li>
<li>  属性使用小驼峰命名法</li>
<li>防止注入攻击<ul>
<li>  自动编码</li>
<li>  dangerouslySetInnerHTML:来实现类似innerHTML的功能</li>
</ul>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1234</span>,  b = <span class="number">4321</span>;</span><br><span class="line"><span class="keyword">const</span> h1 = (</span><br><span class="line">	<span class="xml"><span class="tag">&lt;<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line"><span class="xml">		<span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">			&#123;a&#125;*&#123;b&#125; = &#123;a * b&#125;</span></span><br><span class="line"><span class="xml">		<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> imgClassName = <span class="string">&quot;image&quot;</span></span><br><span class="line"><span class="keyword">const</span> imgUrl= <span class="string">&quot;http://qzapp.qlogo.cn/qzapp/101983660/F61F6EEE51E483105E9C9686BFFF61A2/100&quot;</span></span><br><span class="line"><span class="keyword">const</span> h1 = (</span><br><span class="line">	<span class="xml"><span class="tag">&lt;<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line"><span class="xml">		<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;imgUrl&#125;</span>  <span class="attr">className</span>=<span class="string">&#123;imgClassName&#125;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">			<span class="attr">marginLeft:</span>&#x27;<span class="attr">50px</span>&#x27;,</span></span></span><br><span class="line"><span class="tag"><span class="xml">			<span class="attr">width:</span>&quot;<span class="attr">220px</span>&quot;</span></span></span><br><span class="line"><span class="tag"><span class="xml">		&#125;&#125;/&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> divContent = <span class="string">&quot;&lt;h1&gt;测试dangerouslySetInnerHTML&lt;/h1&gt;&lt;p&gt;必须传入一个对象，将__html属性赋值为想要展示的html字符串&lt;/p&gt;&quot;</span></span><br><span class="line"><span class="keyword">const</span> div = (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">dangerouslySetInnerHTML</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">__html:divContent</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">    &#125;&#125;&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="元素的不可变性"><a href="#元素的不可变性" class="headerlink" title="元素的不可变性"></a>元素的不可变性</h2><ul>
<li>  虽然 JSX 元素是一个对象，但是该对象中的所有属性不可更改</li>
<li>  如果确实需要更改元素的属性，需要重新创建 JSX 元素</li>
</ul>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>react</category>
        <category>react基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>react Hook  State Hook</title>
    <url>/135xyq.github.io/2022/06/27/react-Hook-State%20Hook/</url>
    <content><![CDATA[<h1 id="State-Hook"><a href="#State-Hook" class="headerlink" title="State Hook"></a><a href="https://react.docschina.org/docs/hooks-state.html">State Hook</a></h1><p>State Hook 是一个在函数组件中使用的函数(useState),用于在函数组件中使用状态。</p>
<p>useState：</p>
<ul>
<li>有一个参数，表示状态的默认值</li>
<li>返回值是一个数组，该数组一定包含两项<ol>
<li>第一项：当前状态的值</li>
<li>第二项：改变状态的函数</li>
</ol>
</li>
</ul>
<p>一个函数组件可以有多个状态。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useState&#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">StateHookTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">const</span> [visible, setVisible] = useState(<span class="literal">true</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">			<span class="attr">display:visible</span>?&quot;<span class="attr">block</span>&quot;<span class="attr">:</span>&quot;<span class="attr">none</span>&quot;</span></span></span><br><span class="line"><span class="tag"><span class="xml">		&#125;&#125;&gt;</span></span></span><br><span class="line"><span class="xml">			<span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="xml">				setCount(count-1)</span></span><br><span class="line"><span class="xml">			&#125;&#125;&gt;-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">			<span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">			<span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="xml">				setCount(count+1)</span></span><br><span class="line"><span class="xml">			&#125;&#125;&gt;+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">		<span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">			<span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="xml">				setVisible(!visible)</span></span><br><span class="line"><span class="xml">			&#125;&#125;&gt;切换显示/隐藏<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">		<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;/&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 多个状态合并成一个对象</span></span><br><span class="line"><span class="keyword">import</span> React, &#123;useState&#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">StateHookTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> [data, setData] = useState(&#123;<span class="attr">count</span>:<span class="number">0</span>,<span class="attr">visible</span>:<span class="literal">true</span>&#125;);</span><br><span class="line">	<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">			<span class="attr">display:data.visible</span>?&quot;<span class="attr">block</span>&quot;<span class="attr">:</span>&quot;<span class="attr">none</span>&quot;</span></span></span><br><span class="line"><span class="tag"><span class="xml">		&#125;&#125;&gt;</span></span></span><br><span class="line"><span class="xml">			<span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="xml">				setData(&#123;</span></span><br><span class="line"><span class="xml">                    ...data,</span></span><br><span class="line"><span class="xml">                    count:data.count-1</span></span><br><span class="line"><span class="xml">                &#125;)</span></span><br><span class="line"><span class="xml">			&#125;&#125;&gt;-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">			<span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;data.count&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">			<span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="xml">				setData(&#123;</span></span><br><span class="line"><span class="xml">                    ...data,</span></span><br><span class="line"><span class="xml">                    count:data.count+1</span></span><br><span class="line"><span class="xml">                &#125;)</span></span><br><span class="line"><span class="xml">			&#125;&#125;&gt;+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">		<span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">			<span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="xml">				setData(&#123;</span></span><br><span class="line"><span class="xml">                    ...data,</span></span><br><span class="line"><span class="xml">                    visible:!data.visible</span></span><br><span class="line"><span class="xml">                &#125;)</span></span><br><span class="line"><span class="xml">			&#125;&#125;&gt;切换显示/隐藏<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">		<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;/&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：</p>
<ol>
<li>useState最好写在函数的起始位置，便于阅读</li>
<li>useState严禁出现在代码块（判断、循环）中</li>
<li>useState返回的第二个参数（函数）的引用不变（节约内存空间）</li>
<li>如果使用函数改变数据，若数据改变前后完全相等(使用Object.is比较)，不会导致重新渲染（优化效率）</li>
<li>使用函数改变数据，传入的值不会和原来的数据混合，会直接替换</li>
<li>实现强制刷新<ul>
<li>类组件：使用forceUpdate函数</li>
<li>函数组件：使用一个空对象的useState</li>
</ul>
</li>
<li>如果某些状态之间没有必然的联系，应该分化为不同的状态，最好不要合并成一个对象</li>
<li>函数组件中改变状态可能是异步的（在DOM事件中），多个状态会合并以提高效率，此时不能信任之前的状态，而应该使用回调函数的方式改变状态，如果状态变化要使用之前的状态，尽量传递函数</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useState&#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">StateHookTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">const</span> [visible, setVisible] = useState(<span class="literal">true</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">			<span class="attr">display:visible</span>?&quot;<span class="attr">block</span>&quot;<span class="attr">:</span>&quot;<span class="attr">none</span>&quot;</span></span></span><br><span class="line"><span class="tag"><span class="xml">		&#125;&#125;&gt;</span></span></span><br><span class="line"><span class="xml">			<span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="xml">                // 异步的，多个状态会合并，应该使用回调函数</span></span><br><span class="line"><span class="xml">				setCount(count=&gt;count-1)</span></span><br><span class="line"><span class="xml">				setCount(count=&gt;count-1)</span></span><br><span class="line"><span class="xml">			&#125;&#125;&gt;-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">			<span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">			<span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="xml">				setCount(count=&gt;count+1)</span></span><br><span class="line"><span class="xml">				setCount(count=&gt;count+1)</span></span><br><span class="line"><span class="xml">			&#125;&#125;&gt;+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">		<span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">			<span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="xml">				setVisible(!visible)</span></span><br><span class="line"><span class="xml">			&#125;&#125;&gt;切换显示/隐藏<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">		<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;/&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>react</category>
        <category>Hook</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>react基础 react组件事件</title>
    <url>/135xyq.github.io/2022/05/26/react-react%E5%9F%BA%E7%A1%80-%E7%BB%84%E4%BB%B6%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="组件事件"><a href="#组件事件" class="headerlink" title="组件事件"></a>组件事件</h1><p>在 react 中，组件的事件本质上就是一个属性。</p>
<p>会在特定的时间运行相对应的函数。</p>
<p>如果没有特殊处理，在事件处理函数中，this 指向 undefined</p>
<p>处理方法</p>
<ol>
<li>使用 bind 函数，绑定 this</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;Tick number=&#123;<span class="number">10</span>&#125; onOver=&#123;<span class="built_in">this</span>.handleOver.bind(<span class="built_in">this</span>)&#125;&gt;&lt;/Tick&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用箭头函数</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">handleOver = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>.setState(&#123;</span><br><span class="line">		<span class="attr">isOver</span>: <span class="literal">true</span>,</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Tick</span> <span class="attr">number</span>=<span class="string">&#123;10&#125;</span> <span class="attr">onOver</span>=<span class="string">&#123;this.handleOver&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Tick</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="内置组件"><a href="#内置组件" class="headerlink" title="内置组件"></a>内置组件</h2><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;button</span><br><span class="line">	onClick=&#123;<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&quot;点击了!&quot;</span>);</span><br><span class="line">	&#125;&#125;</span><br><span class="line">&gt;</span><br><span class="line">	点我</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&quot;点击了!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;button onClick=&#123;handleClick&#125;&gt;点我&lt;/button&gt;;</span><br></pre></td></tr></table></figure>

<h2 id="自定义组件"><a href="#自定义组件" class="headerlink" title="自定义组件"></a>自定义组件</h2><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 倒计时组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Tick</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">	<span class="comment">// // 初始化组件</span></span><br><span class="line">	<span class="comment">// state = &#123;</span></span><br><span class="line">	<span class="comment">// 	lastTime: this.props.number,</span></span><br><span class="line">	<span class="comment">// &#125;;</span></span><br><span class="line">	<span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(props);</span><br><span class="line">		<span class="comment">// 初始化组件</span></span><br><span class="line">		<span class="built_in">this</span>.state = &#123;</span><br><span class="line">			<span class="attr">lastTime</span>: props.number,</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">const</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">			<span class="built_in">this</span>.setState(&#123;</span><br><span class="line">				<span class="attr">lastTime</span>: <span class="built_in">this</span>.state.lastTime - <span class="number">1</span>,</span><br><span class="line">			&#125;);</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">this</span>.state.lastTime === <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="built_in">clearInterval</span>(timer);</span><br><span class="line">				<span class="comment">//倒计时完成</span></span><br><span class="line">				<span class="built_in">this</span>.props.onOver &amp;&amp; <span class="built_in">this</span>.props.onOver(); <span class="comment">//结束事件</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, <span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>倒计时：&#123;this.state.lastTime&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Tick <span class="keyword">from</span> <span class="string">&quot;./Tick&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">TickOver</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">	state = &#123;</span><br><span class="line">		<span class="attr">isOver</span>: <span class="literal">false</span>,</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">// 处理倒计时结束的事件</span></span><br><span class="line">	<span class="function"><span class="title">handleOver</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.setState(&#123;</span><br><span class="line">			<span class="attr">isOver</span>: <span class="literal">true</span>,</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="keyword">let</span> content = <span class="string">&quot;正在倒计时&quot;</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.state.isOver) &#123;</span><br><span class="line">			content = <span class="string">&quot;倒计时结束了&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> (</span><br><span class="line">			<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">				<span class="tag">&lt;<span class="name">Tick</span> <span class="attr">number</span>=<span class="string">&#123;10&#125;</span> <span class="attr">onOver</span>=<span class="string">&#123;this.handleOver.bind(this)&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Tick</span>&gt;</span></span></span><br><span class="line"><span class="xml">				<span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;content&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>react</category>
        <category>react基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>react基础 react组件和组件属性</title>
    <url>/135xyq.github.io/2022/05/18/react-react%E5%9F%BA%E7%A1%80-%E7%BB%84%E4%BB%B6%E5%92%8C%E7%BB%84%E4%BB%B6%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h1 id="组件和组件属性"><a href="#组件和组件属性" class="headerlink" title="组件和组件属性"></a>组件和组件属性</h1><p>包含内容、样式和功能的UI单元。</p>
<h2 id="创建一个组件"><a href="#创建一个组件" class="headerlink" title="创建一个组件"></a>创建一个组件</h2><p><strong>组件的名称首字母必须大写</strong></p>
<h3 id="函数组件"><a href="#函数组件" class="headerlink" title="函数组件"></a>函数组件</h3><p>返回一个React 元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>函数组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类组件"><a href="#类组件" class="headerlink" title="类组件"></a>类组件</h3><p>类必须继承自React.Component</p>
<p>必须包含一个render方法，用来渲染组件，返回React元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>类组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="组件的使用"><a href="#组件的使用" class="headerlink" title="组件的使用"></a>组件的使用</h2><ol>
<li>当成一个普通函数调用</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&#123;MyComponent()&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>作为一个DOM元素</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;MyComponent/&gt;</span><br></pre></td></tr></table></figure>


<h2 id="组件的属性"><a href="#组件的属性" class="headerlink" title="组件的属性"></a>组件的属性</h2><p>数据属于谁，谁才有权力改动</p>
<p>使用小驼峰命名</p>
<p>组件的属性不可以改变（只读属性）</p>
<ol>
<li>对于函数组件，属性会作为一个对象的一个属性，传递给函数的参数</li>
<li>对于类组件，属性会作为一个对象的属性，传递给类的构造函数的参数(会在构造函数中自动调用super(props)),可以通过this.props[属性名]获取参数</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>类组件：&#123;this.props.str&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;ClassComponent str=<span class="string">&quot;类组件参数&quot;</span>&gt;&lt;/ClassComponent&gt;</span><br></pre></td></tr></table></figure>


<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>函数组件:&#123;props.str&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;MyComponent str=<span class="string">&quot;函数参数&quot;</span>/&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>react</category>
        <category>react基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>react基础 react组件状态</title>
    <url>/135xyq.github.io/2022/05/19/react-react%E5%9F%BA%E7%A1%80-%E7%BB%84%E4%BB%B6%E7%8A%B6%E6%80%81/</url>
    <content><![CDATA[<h1 id="组件状态"><a href="#组件状态" class="headerlink" title="组件状态"></a>组件状态</h1><p>组件状态：组件可以自行维护的数据</p>
<p>组件状态仅在类组件有效</p>
<p>状态（state）:本质上是类组件的一个属性，是一个对象</p>
<h2 id="组件状态初始化"><a href="#组件状态初始化" class="headerlink" title="组件状态初始化"></a>组件状态初始化</h2><ol>
<li>在constructor中初始化</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="comment">// 初始化组件</span></span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">        <span class="attr">lastTime</span>:<span class="built_in">this</span>.props.number</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>直接初始化,使用JS Next语法</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 初始化组件</span></span><br><span class="line">state = &#123;</span><br><span class="line">    <span class="attr">lastTime</span>: <span class="built_in">this</span>.props.number,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="组件状态的改变"><a href="#组件状态的改变" class="headerlink" title="组件状态的改变"></a>组件状态的改变</h2><p>不能直接改变状态，因为React无法监控到状态发生了变化。</p>
<p>必须使用 this.setState({}) 改变状态</p>
<p>一旦调用this.setState会导致组件重新渲染</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="comment">// 初始化组件</span></span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">        <span class="attr">lastTime</span>:<span class="built_in">this</span>.props.number</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.timer = <span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 重新设置状态</span></span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">            <span class="attr">lastTime</span>:<span class="built_in">this</span>.state.lastTime - <span class="number">1</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h2><p>setState对状态的改变可能是异步的。</p>
<p>如果改变状态的代码处于某个HTML元素的事件中，则其时异步的，反之则为同步。</p>
<p>如果要获取状态的新值，需要在回调函数中获取。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 倒计时组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Tick</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 初始化组件</span></span><br><span class="line">	state = &#123;</span><br><span class="line">		<span class="attr">lastTime</span>: <span class="built_in">this</span>.props.number,</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(props);</span><br><span class="line">		<span class="comment">// // 初始化组件</span></span><br><span class="line">		<span class="comment">// this.state = &#123;</span></span><br><span class="line">		<span class="comment">//     lastTime:this.props.number</span></span><br><span class="line">		<span class="comment">// &#125;</span></span><br><span class="line">		<span class="built_in">this</span>.timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">			<span class="built_in">this</span>.setState(&#123;</span><br><span class="line">				<span class="attr">lastTime</span>:  <span class="built_in">this</span>.state.lastTime - <span class="number">1</span>,</span><br><span class="line">			&#125;,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                <span class="comment">// 这样才能正常获取到更改后的状态</span></span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">this</span>.state.lastTime === <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="built_in">clearInterval</span>(<span class="built_in">this</span>.timer);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;, <span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>倒计时：&#123;this.state.lastTime&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>setState的第一个参数也可以写成一个函数，函数的参数表示当前的状态，该函数的返回结果会覆盖（混合）原来的状态，该函数也是异步执行。</p>
<p>使用（第一个参数为函数）这一模式，当多次同步调用setState时，后一个状态的改变会等前一个状态改变完成后执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 倒计时组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Tick</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 初始化组件</span></span><br><span class="line">	state = &#123;</span><br><span class="line">		<span class="attr">lastTime</span>: <span class="built_in">this</span>.props.number,</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(props);</span><br><span class="line">		<span class="comment">// // 初始化组件</span></span><br><span class="line">		<span class="comment">// this.state = &#123;</span></span><br><span class="line">		<span class="comment">//     lastTime:this.props.number</span></span><br><span class="line">		<span class="comment">// &#125;</span></span><br><span class="line">		<span class="built_in">this</span>.timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">			<span class="built_in">this</span>.setState(&#123;</span><br><span class="line">				<span class="attr">lastTime</span>:  <span class="built_in">this</span>.state.lastTime - <span class="number">1</span>,</span><br><span class="line">			&#125;,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">this</span>.state.lastTime === <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="built_in">clearInterval</span>(<span class="built_in">this</span>.timer)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">console</span>.log(<span class="built_in">this</span>.state.lastTime);</span><br><span class="line">			&#125;);</span><br><span class="line">			<span class="built_in">this</span>.setState(<span class="function"><span class="params">current</span>=&gt;</span>&#123;</span><br><span class="line">				<span class="keyword">return</span> &#123;</span><br><span class="line">					<span class="attr">lastTime</span>:  current.lastTime - <span class="number">1</span>,</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;, <span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&quot;render&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>倒计时：&#123;this.state.lastTime&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 会先输出render，再输出倒计时。</span></span><br></pre></td></tr></table></figure>

<p>实践：</p>
<ol>
<li>尽量把所有的setState当作是异步的</li>
<li>永远不要信任setState调用之后的状态</li>
<li>如果要使用状态改变后的的状态，需要使用回调函数（setState的第二个参数）</li>
<li>如果新的状态要根据之前的状态进行计算，使用函数的方式改变状态（setState的第一个参数为函数）</li>
</ol>
<p>React会对异步的setState进行优化，将多次setState进行合并（将多次状态改变后完成后，再统一对state进行改变，然后触发render）</p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>react</category>
        <category>react基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>react基础 react表单组件</title>
    <url>/135xyq.github.io/2022/06/17/react-react%E5%9F%BA%E7%A1%80-%E8%A1%A8%E5%8D%95%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h1><p>受控组件：组件的使用者，有能力完全控制该组件的行为和内容。通常情况下，没有自己的状态，其内容完全受到属性的控制。</p>
<p>非受控组件：组件的使用者，没有能力控制组件的行为和内容，组件的内容和行为完全自行控制。</p>
<p>表单组件默认情况下是非受控组件，一旦设置了表单组件的 value 属性，则其变成受控组件（单选框和多选框需要设置 checked）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">FormTest</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">	state = &#123;</span><br><span class="line">		<span class="attr">loginId</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">		<span class="attr">loginPwd</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">		<span class="attr">sex</span>: <span class="string">&quot;male&quot;</span>,</span><br><span class="line">		<span class="attr">place</span>: <span class="string">&quot;hunan&quot;</span>,</span><br><span class="line">		<span class="attr">loveOptions</span>: [</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="attr">text</span>: <span class="string">&quot;足球&quot;</span>,</span><br><span class="line">				<span class="attr">value</span>: <span class="string">&quot;足球&quot;</span>,</span><br><span class="line">			&#125;,</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="attr">text</span>: <span class="string">&quot;篮球&quot;</span>,</span><br><span class="line">				<span class="attr">value</span>: <span class="string">&quot;篮球&quot;</span>,</span><br><span class="line">			&#125;,</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="attr">text</span>: <span class="string">&quot;唱歌&quot;</span>,</span><br><span class="line">				<span class="attr">value</span>: <span class="string">&quot;唱歌&quot;</span>,</span><br><span class="line">			&#125;,</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="attr">text</span>: <span class="string">&quot;睡觉&quot;</span>,</span><br><span class="line">				<span class="attr">value</span>: <span class="string">&quot;睡觉&quot;</span>,</span><br><span class="line">			&#125;,</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="attr">text</span>: <span class="string">&quot;其他&quot;</span>,</span><br><span class="line">				<span class="attr">value</span>: <span class="string">&quot;其他&quot;</span>,</span><br><span class="line">			&#125;,</span><br><span class="line">		],</span><br><span class="line">		<span class="attr">loves</span>: [<span class="string">&quot;足球&quot;</span>],</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">// 处理数据变化</span></span><br><span class="line">	onHandleChange = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">let</span> val = e.target.value;</span><br><span class="line">		<span class="keyword">let</span> name = e.target.name;</span><br><span class="line">		<span class="keyword">if</span> (e.target.type === <span class="string">&quot;checkbox&quot;</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (e.target.checked) &#123;</span><br><span class="line">				val = [...this.state.loves, val];</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				val = <span class="built_in">this</span>.state.loves.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> item !== val);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">this</span>.setState(&#123;</span><br><span class="line">			[name]: val,</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取所有的爱好</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="title">getAllLoves</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.state.loveOptions.map(<span class="function">(<span class="params">item</span>) =&gt;</span> (</span><br><span class="line">			<span class="xml"><span class="tag">&lt;<span class="name">label</span> <span class="attr">key</span>=<span class="string">&#123;item.value&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">				<span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">					<span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">					<span class="attr">name</span>=<span class="string">&quot;loves&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">					<span class="attr">value</span>=<span class="string">&#123;item.value&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">					<span class="attr">checked</span>=<span class="string">&#123;this.state.loves.includes(item.value)&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">					<span class="attr">onChange</span>=<span class="string">&#123;this.onHandleChange&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">				/&gt;</span></span></span><br><span class="line"><span class="xml">				&#123;item.text&#125;</span></span><br><span class="line"><span class="xml">			<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line">		));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="keyword">const</span> bs = <span class="built_in">this</span>.getAllLoves();</span><br><span class="line">		<span class="keyword">return</span> (</span><br><span class="line">			<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">				<span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">					<span class="tag">&lt;<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="xml">						用户名：</span></span><br><span class="line"><span class="xml">						<span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">							<span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">							<span class="attr">name</span>=<span class="string">&quot;loginId&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">							<span class="attr">value</span>=<span class="string">&#123;this.state.loginId&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">							<span class="attr">onChange</span>=<span class="string">&#123;this.onHandleChange&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">						/&gt;</span></span></span><br><span class="line"><span class="xml">					<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="xml">				<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">				<span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">					<span class="tag">&lt;<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="xml">						密码：</span></span><br><span class="line"><span class="xml">						<span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">							<span class="attr">type</span>=<span class="string">&quot;password&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">							<span class="attr">name</span>=<span class="string">&quot;loginPwd&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">							<span class="attr">value</span>=<span class="string">&#123;this.state.loginPwd&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">							<span class="attr">onChange</span>=<span class="string">&#123;this.onHandleChange&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">						/&gt;</span></span></span><br><span class="line"><span class="xml">					<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="xml">				<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">				<span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">					<span class="tag">&lt;<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="xml">						<span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">							<span class="attr">type</span>=<span class="string">&quot;radio&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">							<span class="attr">name</span>=<span class="string">&quot;sex&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">							<span class="attr">value</span>=<span class="string">&quot;male&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">							<span class="attr">checked</span>=<span class="string">&#123;this.state.sex</span> === <span class="string">&quot;male&quot;</span>&#125;</span></span></span><br><span class="line"><span class="tag"><span class="xml">							<span class="attr">onChange</span>=<span class="string">&#123;this.onHandleChange&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">						/&gt;</span></span></span><br><span class="line"><span class="xml">						男</span></span><br><span class="line"><span class="xml">					<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="xml">					<span class="tag">&lt;<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="xml">						<span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">							<span class="attr">type</span>=<span class="string">&quot;radio&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">							<span class="attr">name</span>=<span class="string">&quot;sex&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">							<span class="attr">value</span>=<span class="string">&quot;female&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">							<span class="attr">checked</span>=<span class="string">&#123;this.state.sex</span> === <span class="string">&quot;female&quot;</span>&#125;</span></span></span><br><span class="line"><span class="tag"><span class="xml">							<span class="attr">onChange</span>=<span class="string">&#123;this.onHandleChange&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">						/&gt;</span></span></span><br><span class="line"><span class="xml">						女</span></span><br><span class="line"><span class="xml">					<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="xml">				<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">				<span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">					<span class="tag">&lt;<span class="name">select</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">						<span class="attr">name</span>=<span class="string">&quot;place&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">						<span class="attr">value</span>=<span class="string">&#123;this.state.place&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">						<span class="attr">onChange</span>=<span class="string">&#123;this.onHandleChange&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">					&gt;</span></span></span><br><span class="line"><span class="xml">						<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;henan&quot;</span>&gt;</span>河南<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="xml">						<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;hunan&quot;</span>&gt;</span>湖南<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="xml">						<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;hubei&quot;</span>&gt;</span>湖北<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="xml">					<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span></span><br><span class="line"><span class="xml">				<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">				<span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;bs&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">				<span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">					<span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">						<span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="xml">							console.log(this.state);</span></span><br><span class="line"><span class="xml">						&#125;&#125;</span></span><br><span class="line"><span class="xml">					&gt;</span></span><br><span class="line"><span class="xml">						获取数据</span></span><br><span class="line"><span class="xml">					<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">				<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>react</category>
        <category>react基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>react基础 react组件生命周期</title>
    <url>/135xyq.github.io/2022/06/17/react-react%E5%9F%BA%E7%A1%80-%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h1 id="组件生命周期"><a href="#组件生命周期" class="headerlink" title="组件生命周期"></a>组件生命周期</h1><p>生命周期仅存在于类组件中，函数组件每次调用都是重新运行函数，旧的组件即刻被销毁。</p>
<h2 id="旧版生命周期"><a href="#旧版生命周期" class="headerlink" title="旧版生命周期"></a>旧版生命周期</h2><p>React &lt; 16.0.0</p>
<h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><ol>
<li>constructor: 初始化阶段，初始化属性和状态</li>
</ol>
<ul>
<li>同一个组件对象只会创建一次</li>
<li>不能再页面第一次挂载到页面之前调用setState，最好不要在构造函数中使用setSate</li>
</ul>
<h3 id="挂载阶段"><a href="#挂载阶段" class="headerlink" title="挂载阶段"></a>挂载阶段</h3><ol start="2">
<li>componentWillMount 组件即将被挂载到页面</li>
</ol>
<ul>
<li>正常情况下，和构造函数一样，只会运行一次</li>
<li>可以使用setSate，但是为了避免bug,不允许使用，因为在某些情况下，可能会被调用多次</li>
</ul>
<ol start="3">
<li>render: 组件渲染虚拟DOM</li>
</ol>
<ul>
<li>返回的React元素会被挂载到虚拟DOM树中，最终渲染到页面的真实DOM树中</li>
<li>render可能不只运行一次，只要重新渲染就会重新运行</li>
<li>严禁使用setState，可能会导致无限递归渲染</li>
</ul>
<ol start="4">
<li>componentDidMount: 虚拟DOM已经挂载到页面成为真实的DOM</li>
</ol>
<ul>
<li>只会运行一次</li>
<li>可以使用setSate</li>
<li>通常情况，会将网络请求、计时器等一开始需要操作，在该函数中实现</li>
</ul>
<h3 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h3><ol start="5">
<li>componentWillReceiveProps: 即将接收到新的属性值，组件的属性被改变</li>
</ol>
<ul>
<li>参数为新的属性对象</li>
<li>当前组件的属性还未改变</li>
</ul>
<ol start="6">
<li>shouldComponentUpdate: 指示react是否要重新渲染该组件，通过返回true和false来指定，默认情况下会返回true</li>
</ol>
<ul>
<li>可以用来优化效率</li>
<li>参数一：新的属性、参数二：新的状态</li>
</ul>
<ol start="7">
<li>componentWillUpdate: 组件即将被重新渲染</li>
</ol>
<ul>
<li>参数一：新的属性、参数二：新的状态</li>
</ul>
<ol start="8">
<li>componentDidUpdate: 组件已完成重新渲染</li>
</ol>
<ul>
<li>参数一：之前属性、参数二：之前状态</li>
<li>往往在该函数中使用dom操作，改变元素</li>
</ul>
<h3 id="销毁阶段"><a href="#销毁阶段" class="headerlink" title="销毁阶段"></a>销毁阶段</h3><ol start="9">
<li>componentWillUnmount 组件即将被销毁</li>
</ol>
<ul>
<li>通常在该函数中，销毁一些组件依赖的资源，比如计时器</li>
</ul>
<h2 id="新版生命周期"><a href="#新版生命周期" class="headerlink" title="新版生命周期"></a>新版生命周期</h2><p>React &gt;= 16.0.0</p>
<h3 id="初始化阶段-1"><a href="#初始化阶段-1" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><ol>
<li>constructor: 初始化阶段，初始化属性和状态</li>
</ol>
<ul>
<li>同一个组件对象只会创建一次</li>
<li>不能再页面第一次挂载到页面之前调用setState，最好不要在构造函数中使用setSate</li>
</ul>
<h3 id="挂载阶段-1"><a href="#挂载阶段-1" class="headerlink" title="挂载阶段"></a>挂载阶段</h3><ol start="2">
<li>static getDerivedStateFromProps </li>
</ol>
<ul>
<li>参数一：新的属性、参数二：新的状态</li>
<li>该函数是静态的</li>
<li>该函数的返回值会覆盖组件状态</li>
</ul>
<ol start="3">
<li>render: 组件渲染虚拟DOM</li>
</ol>
<ul>
<li>返回的React元素会被挂载到虚拟DOM树中，最终渲染到页面的真实DOM树中</li>
<li>render可能不只运行一次，只要重新渲染就会重新运行</li>
<li>严禁使用setState，可能会导致无限递归渲染</li>
</ul>
<ol start="4">
<li>componentDidMount: 虚拟DOM已经挂载到页面成为真实的DOM</li>
</ol>
<ul>
<li>只会运行一次</li>
<li>可以使用setSate</li>
<li>通常情况，会将网络请求、计时器等一开始需要操作，在该函数中实现</li>
</ul>
<h3 id="更新阶段-1"><a href="#更新阶段-1" class="headerlink" title="更新阶段"></a>更新阶段</h3><ol start="5">
<li>static getDerivedStateFromProps  每次运行render之前都会运行 </li>
</ol>
<ul>
<li>参数一：新的属性、参数二：新的状态</li>
<li>该函数是静态的</li>
<li>该函数的返回值会覆盖组件状态</li>
</ul>
<ol start="6">
<li>shouldComponentUpdate: 指示react是否要重新渲染该组件，通过返回true和false来指定，默认情况下会返回true</li>
</ol>
<ul>
<li>可以用来优化效率</li>
<li>参数一：新的属性、参数二：新的状态</li>
</ul>
<ol start="7">
<li>getSnapshotBeforeUpdate: 获取更新前的快照，真实的DOM构建完成，但还未实际渲染到页面中</li>
</ol>
<ul>
<li>在该函数中，通常用于实现一些附加的dom操作</li>
<li>该函数的返回值会作为componentDidUpdate的第三个参数</li>
</ul>
<ol start="8">
<li>componentDidUpdate: 组件已完成重新渲染</li>
</ol>
<ul>
<li>参数一：之前属性、参数二：之前状态</li>
<li>往往在该函数中使用dom操作，改变元素</li>
</ul>
<h3 id="销毁阶段-1"><a href="#销毁阶段-1" class="headerlink" title="销毁阶段"></a>销毁阶段</h3><ol start="9">
<li>componentWillUnmount 组件即将被销毁</li>
</ol>
<ul>
<li>通常在该函数中，销毁一些组件依赖的资源，比如计时器</li>
</ul>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>react</category>
        <category>react基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>react Hook Effect Hook</title>
    <url>/135xyq.github.io/2022/06/27/react-Hook-Effect%20Hook/</url>
    <content><![CDATA[<h1 id="Effect-Hook"><a href="#Effect-Hook" class="headerlink" title="Effect Hook"></a><a href="https://react.docschina.org/docs/hooks-effect.html">Effect Hook</a></h1><p>Effect Hook用于在函数组件中处理副作用。</p>
<p>副作用：</p>
<ol>
<li>Ajax请求</li>
<li>计时器</li>
<li>其他异步操作</li>
<li>更改真实DOM对象</li>
<li>本地存储</li>
<li>其他会对外部产生影响的操作</li>
</ol>
<p>useEffect：该函数接收一个函数作为参数，接收的函数就是需要副作用的函数。</p>
<ol>
<li>副作用函数运行时间：在页面完成真实的UI渲染之后，它的执行是异步的，不会阻塞浏览器<ul>
<li>与类组件componentDidMount和componentDidUpdate的区别：componentDidMount和componentDidUpdate更改了真实DOM，但是用户还没有看到UI更新，是同步的；useEffect中副作用函数，更改了真实DOM，并且用户看到了UI更新，是异步的。</li>
</ul>
</li>
<li>每个函数组件中可以多次使用useEffect，但不要放入循环和判断等代码块中</li>
<li>useEffect中副作用函数，可以有返回值,返回值也必须是函数，该函数叫做清理函数<ul>
<li>清理函数运行时间点：在每次运行副作用函数之前，首次渲染组件不会运行，组件被销毁时一定会运行</li>
</ul>
</li>
<li>useEffect可以传递第二个参数<ul>
<li>第二个参数是一个数组</li>
<li>数组中记录该副作用的依赖数据</li>
<li>当该组件重新渲染后，只有依赖数据与上一次不一样时，才会执行副作用</li>
<li>当传递依赖数据后，如果数据没有发生变化，副作用仅在第一次渲染后运行，清理函数仅在卸载组件后运行</li>
</ul>
</li>
<li>副作用函数中，如果使用了函数上下文中的变量，则由于闭包的影响，会导致副作用函数中变量不会实时变化。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">EffectHookTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> [n, setN] = useState(<span class="number">0</span>);</span><br><span class="line">    useEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.title = <span class="string">`计数器  <span class="subst">$&#123;n&#125;</span>`</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;清理函数：在每次运行副作用函数之前，首次渲染组件不会运行，组件被销毁时一定会运行&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,[n]);<span class="comment">//数组记录该副作用的依赖数据,当该组件重新渲染后，只有依赖数据与上一次不一样时，才会执行副作用</span></span><br><span class="line">	<span class="keyword">return</span> (</span><br><span class="line">		<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">			<span class="tag">&lt;<span class="name">span</span>&gt;</span>计数器：<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">			&#123;n&#125;</span></span><br><span class="line"><span class="xml">			<span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">				<span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="xml">					setN(n + 1);</span></span><br><span class="line"><span class="xml">				&#125;&#125;</span></span><br><span class="line"><span class="xml">			&gt;</span></span><br><span class="line"><span class="xml">				+</span></span><br><span class="line"><span class="xml">			<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>react</category>
        <category>Hook</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>react进阶 react Context上下文数据</title>
    <url>/135xyq.github.io/2022/06/20/react-react%E8%BF%9B%E9%98%B6-Context/</url>
    <content><![CDATA[<h1 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h1><p>上下文：做某一些事情的环境</p>
<p>React上下文的特点：</p>
<ol>
<li>当某个组件创建上下文后，上下文中的数据会被所有后代组件共享;</li>
<li>如果某个组件依赖了上下文，会导致该组件不再纯粹(数据仅来自于属性props)</li>
</ol>
<h2 id="旧版API"><a href="#旧版API" class="headerlink" title="旧版API"></a>旧版API</h2><p><strong>创建上下文</strong></p>
<p>只有类组件才能创建上下文</p>
<ol>
<li>给类组件书写一个静态属性<code>childContextTypes</code>,对上下文中的数据类型进行约束;</li>
<li>添加实例方法 <code>getChildContext</code>,该方法返回的对象就是上下文中的数据，该数据必须满足类型约束，该方法会在每次render之后运行</li>
</ol>
<p><strong>使用上下文中的数据</strong></p>
<p>要求：如果要使用上下文中的数据，组件中必须有一个静态属性<code>contextTypes</code>,该属性描述了需要获取的上下文中的数据类型</p>
<ol>
<li>可以在组件的构造函数中，通过构造函数的第二个参数，获取上下文数据</li>
<li>从组件的context属性中获取</li>
<li>在函数组件中通过第二个参数获取上下文数据</li>
</ol>
<p><strong>上下文中的数据变化</strong></p>
<p>上下文中的数据不可以直接变化，最终都是通过状态改变</p>
<p>后代组件想要修改上下文中的数据，可以通过调用上下文中的函数来修改。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">&quot;prop-types&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在函数组件使用上下文数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">props</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">context</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CompA</span>(<span class="params">props, context</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (</span><br><span class="line">		<span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">			CompA</span></span><br><span class="line"><span class="xml">			<span class="tag">&lt;<span class="name">h2</span>&gt;</span>name:&#123;context.name&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">			<span class="tag">&lt;<span class="name">h2</span>&gt;</span>age:&#123;context.age&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="xml">                context.onChange &amp;&amp; context.onChange(&quot;age&quot;,context.age+1)</span></span><br><span class="line"><span class="xml">            &#125;&#125;&gt;年龄加一<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">		<span class="tag">&lt;/&gt;</span></span></span><br><span class="line">	);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CompA.contextTypes = &#123;</span><br><span class="line">	<span class="attr">name</span>: PropTypes.string,</span><br><span class="line">	<span class="attr">age</span>: PropTypes.number,</span><br><span class="line">	<span class="attr">onChange</span>: PropTypes.func, <span class="comment">//提供后代组件修改上下文数据的函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在类组件终身使用上下文组件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompB</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">		<span class="attr">name</span>: PropTypes.string,</span><br><span class="line">		<span class="attr">age</span>: PropTypes.number,</span><br><span class="line">        <span class="attr">onChange</span>: PropTypes.func, <span class="comment">//提供后代组件修改上下文数据的函数</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> (</span><br><span class="line">			<span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">				<span class="tag">&lt;<span class="name">CompA</span>&gt;</span><span class="tag">&lt;/<span class="name">CompA</span>&gt;</span></span></span><br><span class="line"><span class="xml">				CompB</span></span><br><span class="line"><span class="xml">				<span class="tag">&lt;<span class="name">h2</span>&gt;</span>name:&#123;this.context.name&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">				<span class="tag">&lt;<span class="name">h2</span>&gt;</span>age:&#123;this.context.age&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="xml">                        this.context.onChange &amp;&amp; this.context.onChange(&quot;name&quot;,&quot;谢永强&quot;)</span></span><br><span class="line"><span class="xml">                    &#125;&#125;&gt;修改名字为中文名<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">			<span class="tag">&lt;/&gt;</span></span></span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">OldApi</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">	state = &#123;</span><br><span class="line">		<span class="attr">name</span>: <span class="string">&quot;xyq&quot;</span>,</span><br><span class="line">		<span class="attr">age</span>: <span class="number">21</span>,</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 *对上下文中的数据类型进行约束</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@static</span></span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@memberof <span class="variable">OldApi</span></span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">static</span> childContextTypes = &#123;</span><br><span class="line">		<span class="attr">name</span>: PropTypes.string,</span><br><span class="line">		<span class="attr">age</span>: PropTypes.number,</span><br><span class="line">		<span class="attr">onChange</span>: PropTypes.func, <span class="comment">//提供后代组件修改上下文数据的函数</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function"><span class="title">getChildContext</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			<span class="attr">name</span>: <span class="built_in">this</span>.state.name,</span><br><span class="line">			<span class="attr">age</span>: <span class="built_in">this</span>.state.age,</span><br><span class="line">			<span class="attr">onChange</span>: <span class="function">(<span class="params">key, newData</span>) =&gt;</span> &#123;</span><br><span class="line">				<span class="built_in">this</span>.setState(&#123;</span><br><span class="line">					[key]: newData,</span><br><span class="line">				&#125;);</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> (</span><br><span class="line">			<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">				<span class="tag">&lt;<span class="name">CompB</span>&gt;</span><span class="tag">&lt;/<span class="name">CompB</span>&gt;</span></span></span><br><span class="line"><span class="xml">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="新版API"><a href="#新版API" class="headerlink" title="新版API"></a>新版API</h2><p>旧版API存在效率问题，并且容易导致滥用</p>
<p><strong>创建上下文</strong></p>
<p>上下文是一个独立于组件的对象，该对象通过<code>React.createContext(默认值)</code>创建<br>返回的是一个包含两个属性的对象</p>
<ol>
<li>Provider属性：生产者。一个组件，该组件会创建一个上下文，该组件有一个value属性，通过value为其赋值，同一个Provider不要运用到多个组件中</li>
<li>Consumer属性：消费者。一个组件，它的子节点是一个函数（props.children需要传递一个函数），会将上下文数据作为函数的参数，会将函数的返回值渲染出来</li>
</ol>
<p><strong>使用上下文中的数据</strong></p>
<ol>
<li>在类组件中，可以直接通过this.context获取上下文数据，必须要有静态属性<code>contextType</code>,应该赋值为创建的上下文对象；也可以使用Consumer获取数据</li>
<li>在函数组件中，需要使用Consumer获取上下文数据</li>
</ol>
<ul>
<li>Consumer是一个组件</li>
<li>它的子节点是一个函数（props.children需要传递一个函数），会将上下文数据作为函数的参数，会将函数的返回值渲染出来</li>
</ul>
<p>如果上下文提供者(Context.Provider)中的value属性发生变化，会导致该上下文提高的所以后代元素全部重新渲染，无论孩子元素是否存在优化。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">&quot;prop-types&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ctx = React.createContext();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompA</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> contextType = ctx;</span><br><span class="line">	<span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">                CompA</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">h2</span>&gt;</span>name:&#123;this.context.name&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">h2</span>&gt;</span>age:&#123;this.context.age&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="xml">                    this.context.onChange &amp;&amp; this.context.onChange(&quot;age&quot;,this.context.age+1)</span></span><br><span class="line"><span class="xml">                &#125;&#125;&gt;年龄加一<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在类组件上使用上下文组件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompB</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">		<span class="attr">name</span>: PropTypes.string,</span><br><span class="line">		<span class="attr">age</span>: PropTypes.number,</span><br><span class="line">        <span class="attr">onChange</span>: PropTypes.func, <span class="comment">//提供后代组件修改上下文数据的函数</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> (</span><br><span class="line">			<span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">				<span class="tag">&lt;<span class="name">CompA</span>&gt;</span><span class="tag">&lt;/<span class="name">CompA</span>&gt;</span></span></span><br><span class="line"><span class="xml">				CompB</span></span><br><span class="line"><span class="xml">			<span class="tag">&lt;/&gt;</span></span></span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">NewApi</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">	state = &#123;</span><br><span class="line">		<span class="attr">name</span>: <span class="string">&quot;xyq&quot;</span>,</span><br><span class="line">		<span class="attr">age</span>: <span class="number">21</span>,</span><br><span class="line">        <span class="attr">onChange</span>: <span class="function">(<span class="params">key, newData</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">                [key]: newData,</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;,<span class="comment">//提供后代组件修改上下文数据的函数</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> Provider = ctx.Provider;</span><br><span class="line">		<span class="keyword">return</span> (</span><br><span class="line">			<span class="xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">value</span>=<span class="string">&#123;this.state&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">				<span class="tag">&lt;<span class="name">CompB</span>&gt;</span><span class="tag">&lt;/<span class="name">CompB</span>&gt;</span></span></span><br><span class="line"><span class="xml">			<span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span></span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">&quot;prop-types&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ctx = React.createContext();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CompA</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (</span><br><span class="line">		<span class="xml"><span class="tag">&lt;<span class="name">ctx.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="xml">			&#123;(value) =&gt; (</span></span><br><span class="line"><span class="xml">				<span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">					CompA</span></span><br><span class="line"><span class="xml">					<span class="tag">&lt;<span class="name">h2</span>&gt;</span>name:&#123;value.name&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">					<span class="tag">&lt;<span class="name">h2</span>&gt;</span>age:&#123;value.age&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">					<span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">						<span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">							<span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="xml">								value.onChange &amp;&amp;</span></span><br><span class="line"><span class="xml">									value.onChange(&quot;age&quot;, value.age + 1);</span></span><br><span class="line"><span class="xml">							&#125;&#125;</span></span><br><span class="line"><span class="xml">						&gt;</span></span><br><span class="line"><span class="xml">							年龄加一</span></span><br><span class="line"><span class="xml">						<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">					<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">				<span class="tag">&lt;/&gt;</span></span></span><br><span class="line">			)&#125;</span><br><span class="line">		&lt;/ctx.Consumer&gt;</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompB</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">		<span class="attr">name</span>: PropTypes.string,</span><br><span class="line">		<span class="attr">age</span>: PropTypes.number,</span><br><span class="line">		<span class="attr">onChange</span>: PropTypes.func, <span class="comment">//提供后代组件修改上下文数据的函数</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> (</span><br><span class="line">			<span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">				<span class="tag">&lt;<span class="name">CompA</span>&gt;</span><span class="tag">&lt;/<span class="name">CompA</span>&gt;</span></span></span><br><span class="line"><span class="xml">				CompB</span></span><br><span class="line"><span class="xml">			<span class="tag">&lt;/&gt;</span></span></span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">NewApi</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">	state = &#123;</span><br><span class="line">		<span class="attr">name</span>: <span class="string">&quot;xyq&quot;</span>,</span><br><span class="line">		<span class="attr">age</span>: <span class="number">21</span>,</span><br><span class="line">		<span class="attr">onChange</span>: <span class="function">(<span class="params">key, newData</span>) =&gt;</span> &#123;</span><br><span class="line">			<span class="built_in">this</span>.setState(&#123;</span><br><span class="line">				[key]: newData,</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;, <span class="comment">//提供后代组件修改上下文数据的函数</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="keyword">const</span> Provider = ctx.Provider;</span><br><span class="line">		<span class="keyword">return</span> (</span><br><span class="line">			<span class="xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">value</span>=<span class="string">&#123;this.state&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">				<span class="tag">&lt;<span class="name">CompB</span>&gt;</span><span class="tag">&lt;/<span class="name">CompB</span>&gt;</span></span></span><br><span class="line"><span class="xml">			<span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span></span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>react</category>
        <category>react进阶</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>react进阶 React内置的DOM组件中的事件</title>
    <url>/135xyq.github.io/2022/06/25/react-react%E8%BF%9B%E9%98%B6-React%E5%86%85%E7%BD%AE%E7%9A%84DOM%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="React内置的DOM组件中的事件"><a href="#React内置的DOM组件中的事件" class="headerlink" title="React内置的DOM组件中的事件"></a>React内置的DOM组件中的事件</h1><ol>
<li>给document注册事件</li>
<li>几乎所有的元素的事件处理，均在document的事件中处理<ol>
<li>一些不冒泡的事件，是直接在元素上监听</li>
<li>一些document上面没有的事件，直接在元素上监听</li>
</ol>
</li>
<li>在document的事件处理，React会根据虚拟DOM树的完成事件函数的调用</li>
<li>React的事件参数，并非真实的DOM事件参数，是React合成的一个对象，该对象类似于真实DOM的事件参数<ol>
<li>stopPropagation，阻止事件在虚拟DOM树中冒泡</li>
<li>nativeEvent，可以得到真实的DOM事件对象</li>
<li>为了提高执行效率，React使用事件对象池来处理事件对象</li>
</ol>
</li>
</ol>
<p><strong>注意事项</strong></p>
<ol>
<li>如果给真实的DOM注册事件，阻止了事件冒泡，则会导致react的相应事件无法触发</li>
<li>如果给真实的DOM注册事件，事件会先于React事件运行</li>
<li>通过React的事件中阻止事件冒泡，无法阻止真实的DOM事件冒泡</li>
<li>可以通过nativeEvent.stopImmediatePropagation()，阻止document上剩余事件的执行</li>
<li>在事件处理程序中，不要异步的使用事件对象，如果一定要使用，需要调用persist函数</li>
</ol>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>react</category>
        <category>react进阶</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>react进阶 react渲染原理</title>
    <url>/135xyq.github.io/2022/06/25/react-react%E8%BF%9B%E9%98%B6-react%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="渲染原理"><a href="#渲染原理" class="headerlink" title="渲染原理"></a>渲染原理</h1><h2 id="React元素："><a href="#React元素：" class="headerlink" title="React元素："></a>React元素：</h2><p>React Element，通过React.createElement创建（语法糖：JSX）</p>
<h2 id="React节点："><a href="#React节点：" class="headerlink" title="React节点："></a>React节点：</h2><p>专门用于渲染到UI界面的对象，React会通过React元素创建React节点<br>ReactDOM一定时通过React节点来进行渲染的</p>
<h3 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h3><ul>
<li>React DOM节点(ReactDOMComponent)：创建该节点的React元素是一个字符串</li>
<li>React 组件节点：创建该节点的React元素类型是一个函数或是一个类</li>
<li>React 文本节点：由字符串、数字创建</li>
<li>React 空节点：由null、undefined、false、true创建</li>
<li>React 数组节点：由一个数组创建</li>
</ul>
<h2 id="真实DOM"><a href="#真实DOM" class="headerlink" title="真实DOM"></a>真实DOM</h2><p>通过document.createElement创建的dom元素</p>
<h2 id="首次渲染-新节点渲染"><a href="#首次渲染-新节点渲染" class="headerlink" title="首次渲染(新节点渲染)"></a>首次渲染(新节点渲染)</h2><ol>
<li>根据参数的值创建节点</li>
<li>不同节点的操作有异</li>
</ol>
<ul>
<li>文本节点：通过<code>document.createTextNode</code>创建真实的文本节点</li>
<li>空节点：什么都不做</li>
<li>数组节点：遍历数组，将数组每一项递归创建节点</li>
<li>DOM节点：通过<code>document.createElement</code>创建真实的DOM对象，然后立即设置该真实DOM元素的各种属性，遍历React元素的children属性，递归创建节点</li>
<li>组件节点：<ul>
<li>函数组件：调用函数（该函数必须返回一个可以生成节点的内容），将该函数的返回结果递归创建节点</li>
<li>类组件：<ol>
<li>创建该类的实例</li>
<li>立即调用对象的生命周期方法：<code>static getDerivedStateFromProps</code></li>
<li>运行该对象的render方法，拿到节点对象（递归创建节点）</li>
<li>将该组件的<code>componentDidMount</code>加入到执行队列，在整个虚拟DOM树全部构建完毕，并且将真实的DOM对象加入到容器中后，执行该队列</li>
</ol>
</li>
</ul>
</li>
</ul>
<ol start="3">
<li>生成出虚拟DOM树，将该树保存起来</li>
<li>将之前生成的真实DOM对象加入到容器中</li>
</ol>
<h2 id="更新节点"><a href="#更新节点" class="headerlink" title="更新节点"></a>更新节点</h2><h3 id="更新的场景"><a href="#更新的场景" class="headerlink" title="更新的场景"></a>更新的场景</h3><ol>
<li>重新调用<code>ReactDOM.render</code>,完全重新生成节点树<ul>
<li>触发根节点更新</li>
</ul>
</li>
<li>在类组件的实例对象中调用<code>setSate</code> ，会导致该实例所在的节点更新</li>
</ol>
<h3 id="节点的更新"><a href="#节点的更新" class="headerlink" title="节点的更新"></a>节点的更新</h3><ul>
<li>如果调用<code>ReactDOM.render</code>,进入根节点对比更新</li>
<li>如果调用<code>setState</code><ol>
<li>运行生命周期函数 <code>static getDerivedStateFromProps</code></li>
<li>运行生命周期函数<code>shouldComponentUpdate</code>,如果该函数返回false，终止当前流程</li>
<li>运行render得到一个新的节点，进入该新节点的对比更新</li>
<li>将生命周期函数<code>getSnapshotBeforeUpdate</code>加入执行队列，等待将来执行</li>
<li>将生命周期函数<code>componentDidUpdate</code>加入执行队列，等待将来执行</li>
</ol>
</li>
</ul>
<p>后续步骤：(两种情况都要执行)</p>
<ol>
<li>更新虚拟DOM树</li>
<li>完成真实的DOM更新</li>
<li>依次调用执行队列中的<code>componentDidMount</code>函数</li>
<li>依次调用执行队列中的<code>getSnapshotBeforeUpdate</code>函数</li>
<li>依次调用执行队列中的<code>componentDidUpdate</code>函数</li>
</ol>
<h4 id="对比更新"><a href="#对比更新" class="headerlink" title="对比更新"></a>对比更新</h4><p>将新产生的节点，对比之前虚拟DOM中的节点，发现差异，完成更新。</p>
<p>React为了提高对比效率，做出如下假设</p>
<ol>
<li>假设节点不会出现层次的移动</li>
<li>不同的节点类型会生成不同的结构<ul>
<li>相同的节点类型：节点本身类型相同，如果由react元素生成，type值必须一致</li>
</ul>
</li>
<li>多个兄弟节点通过唯一标识(key)来确定对比的新节点</li>
</ol>
<p>key值的作用：用于通过旧节点，找到对应的新节点，如果某个旧节点有key值，则其更新时，会寻找相同层级中相同key值的节点进行对比。</p>
<p><strong>key值应该在一个范围内唯一（兄弟节点中），并且保持稳定</strong></p>
<h5 id="找到了对比的目标"><a href="#找到了对比的目标" class="headerlink" title="找到了对比的目标"></a>找到了对比的目标</h5><h6 id="判断节点类型是否一致"><a href="#判断节点类型是否一致" class="headerlink" title="判断节点类型是否一致"></a>判断节点类型是否一致</h6><ul>
<li><strong>一致</strong></li>
</ul>
<ol>
<li>根据不同的节点做不同的事情<ul>
<li>空节点：不做任何事</li>
<li>DOM节点：<ol>
<li>直接使用之前的真实DOM对象</li>
<li>将其属性的变化记录下来，等待将来统一完成更新（现在不会做真正的变化）</li>
<li>遍历该新React元素的子元素，递归对比更新</li>
</ol>
</li>
<li>文本节点：<ol>
<li>直接使用之前的真实DOM对象</li>
<li>将其nodeValue的变化记录下来，等待将来统一完成更新（现在不会做真正的变化）</li>
</ol>
</li>
<li>组件节点：<ul>
<li>函数组件：直接重新调用函数，得到一个节点对象，进入递归对比更新</li>
<li>类组价：<ol>
<li>重用之前的实例</li>
<li>调用生命周方法<code>getDerivedStateFromProps</code></li>
<li>调用声明周期方法<code>shouldComponentUpdate</code>,若该方法返回false，终止</li>
<li>运行render，得到新的节点对象，进入递归对比更新</li>
<li>将该对象的<code>getSnapshotBeforeUpdate</code>加入队列</li>
<li>将该对象的<code>componentDidUpdate</code>加入队列</li>
</ol>
</li>
</ul>
</li>
<li>数组节点：遍历数组，进行递归对比更新</li>
</ul>
</li>
</ol>
<ul>
<li><p><strong>不一致</strong><br>整体上，卸载旧的节点，全新创建新的节点<br>先完成挂载新节点，再卸载旧节点</p>
<ul>
<li><strong>创建新节点</strong>：<br>  进入新节点的挂载流程</li>
<li><strong>卸载旧节点</strong>：<ol>
<li><strong>文本节点、DOM节点、数组节点、空节点、函数组件节点</strong>：直接放弃该节点，如果节点有子节点，递归卸载节点</li>
<li><strong>类组件节点</strong>：<ol>
<li>直接放弃该节点</li>
<li>调用该节点的<code>componentWillUnMount</code>函数</li>
<li>递归卸载子节点</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h5 id="没有找到对比的目标"><a href="#没有找到对比的目标" class="headerlink" title="没有找到对比的目标"></a>没有找到对比的目标</h5><ul>
<li>创建新加入的节点</li>
<li>卸载多余的节点</li>
</ul>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>react</category>
        <category>react进阶</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>react进阶 react严格模式和Profiler</title>
    <url>/135xyq.github.io/2022/06/26/react-react%E8%BF%9B%E9%98%B6-%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E5%92%8CProfiler/</url>
    <content><![CDATA[<h1 id="严格模式和Profiler"><a href="#严格模式和Profiler" class="headerlink" title="严格模式和Profiler"></a>严格模式和Profiler</h1><h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a><a href="https://react.docschina.org/docs/strict-mode.html">严格模式</a></h2><p>StrictMode（<code>React.StrictMode</code>） 本质上是一个组件，该组件不进行UI渲染,作用：在渲染内部组件时，发现不合适的代码</p>
<ul>
<li>识别不安全的生命周期</li>
<li>关于使用过时字符串 ref API 的警告</li>
<li>关于使用废弃的 findDOMNode 方法的警告</li>
<li>检测意外的副作用<br>副作用：一个函数中，做了一些影响函数外部数据的事情<ol>
<li>异步处理</li>
<li>改变参数值</li>
<li>setState</li>
<li>本地存储</li>
<li>改变函数外部变量</li>
</ol>
</li>
</ul>
<p>相反的，如果一个函数没有副作用，则可以认为该函数是一个纯函数。<br>React要求，副作用代码仅出现在一下生命周期函数中：</p>
<ol>
<li>componentDidMount</li>
<li>componentDidUpdate </li>
<li>componentWillUnMount</li>
</ol>
<p>在严格模式下，虽然不能监控到具体的副作用代码，但他会将不能具有副作用的函数调用两遍，以便发现错误（仅在开发阶段这样处理）</p>
<ul>
<li>检测过时的 context API</li>
</ul>
<h2 id="Profiler"><a href="#Profiler" class="headerlink" title="Profiler"></a><a href="https://react.docschina.org/docs/profiler.html">Profiler</a></h2><p>性能分析工具</p>
<p>分析某一次或多次提交（更新），涉及到的组件的渲染时间</p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>react</category>
        <category>react进阶</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>react进阶 react进阶 纯组件、render props、插槽、错误边界</title>
    <url>/135xyq.github.io/2022/06/21/react-react%E8%BF%9B%E9%98%B6-%E7%BA%AF%E7%BB%84%E4%BB%B6%E3%80%81render%20props%E3%80%81%E6%8F%92%E6%A7%BD%E3%80%81%E9%94%99%E8%AF%AF%E8%BE%B9%E7%95%8C/</url>
    <content><![CDATA[<h1 id="PureComponent-和render-props和插槽"><a href="#PureComponent-和render-props和插槽" class="headerlink" title="PureComponent 和render props和插槽"></a>PureComponent 和render props和插槽</h1><h2 id="PureComponent"><a href="#PureComponent" class="headerlink" title="PureComponent"></a>PureComponent</h2><p>纯组件，用于避免不必要的渲染（运行render函数），提高效率</p>
<p>PureComponent是一个组件，如果一个组件继承自该组件，则该组件的shouldComponentUpdate会进行优化，会将组件的属性和状态进行浅比较，如果相等则不会重新渲染。</p>
<p>在函数组件中使用React.memo函数制作纯组件。</p>
<h2 id="render-props"><a href="#render-props" class="headerlink" title="render props"></a>render props</h2><p>用于解决某些组件的功能大致相同，仅仅是渲染界面不同。（可用高阶组件）</p>
<p>将一个函数作为一个组件的属性，其中函数的返回值作为渲染内容，通常该属性的名字为render(其他名字也行)</p>
<h2 id="Portals"><a href="#Portals" class="headerlink" title="Portals"></a>Portals</h2><p>将会变成虚拟DOM树和真实DOM树不一致</p>
<p>插槽：将一个React元素渲染到指定的DOM容器中</p>
<p>使用<code>ReactDOM.createPortal(React元素，真实的DOM容器)</code>,该容器返回一个React元素</p>
<p><strong>注意</strong></p>
<ol>
<li>React中的事件是包装过的</li>
<li>它的事件冒泡是根据虚拟DOM树来冒泡的，与真实的DOM树无关</li>
</ol>
<h2 id="错误边界"><a href="#错误边界" class="headerlink" title="错误边界"></a>错误边界</h2><p>默认情况下，若一个组件在<strong>渲染期间</strong>（render）发生错误，会导致整个组件树全部被卸载</p>
<p>错误边界：是一个组件，该组件会捕获到渲染期间（render）子组件发生的错误，并有能力阻止错误继续传播</p>
<p><strong>让某个组件捕获错误</strong></p>
<ol>
<li>编写生命周期函数 <code>getDerivedStateFromError</code><ol>
<li>静态函数</li>
<li>运行时间点：渲染子组件的过程中发生错误之后，在更新页面之前</li>
<li><strong>注意：只有子组件发生错误，才会运行该函数</strong></li>
<li>该函数返回一个对象，React会将该对象的属性覆盖掉当前组件的state</li>
<li>参数：错误对象</li>
<li>通常，该函数用于改变状态</li>
</ol>
</li>
<li>编写生命周期函数 <code>componentDidCatch</code><ol>
<li>实例方法</li>
<li>运行时间点：渲染子组件的过程中发生错误更新页面之后，由于其运行时间点比较靠后，因此不太会在该函数中改变状态</li>
<li>通常该函数用于记录错误消息</li>
</ol>
</li>
</ol>
<p><strong>细节</strong></p>
<p>某些错误，错误边界组件无法捕获</p>
<ol>
<li>自身的错误</li>
<li>异步的错误</li>
<li>事件中的错误</li>
</ol>
<p>总结：仅处理渲染子组件期间的同步错误</p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>react</category>
        <category>react进阶</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>react进阶 react属性默认值和属性类型检查</title>
    <url>/135xyq.github.io/2022/06/17/react-react%E8%BF%9B%E9%98%B6-%E5%B1%9E%E6%80%A7%E9%BB%98%E8%AE%A4%E5%80%BC%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5/</url>
    <content><![CDATA[<h1 id="属性默认值和类型检查"><a href="#属性默认值和类型检查" class="headerlink" title="属性默认值和类型检查"></a>属性默认值和类型检查</h1><h2 id="属性默认值"><a href="#属性默认值" class="headerlink" title="属性默认值"></a>属性默认值</h2><p>通过静态属性<code>defaultProps</code>告知 react 属性默认值</p>
<h3 id="函数组件"><a href="#函数组件" class="headerlink" title="函数组件"></a>函数组件</h3><p>混合属性默认值和属性传入值在调用函数之前完成</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">FunctionDefaultProps</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (</span><br><span class="line">		<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">			姓名:&#123;props.name&#125;, 年龄:&#123;props.age&#125;</span></span><br><span class="line"><span class="xml">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">	);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FunctionDefaultProps.defaultProps = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&quot;xyq&quot;</span>,</span><br><span class="line">	<span class="attr">age</span>: <span class="number">21</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="类组件"><a href="#类组件" class="headerlink" title="类组件"></a>类组件</h3><p>混合属性默认值和属性传入值在运行构造函数函数之前完成</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassDefaultProps</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> (</span><br><span class="line">			<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">				名字:&#123;this.props.name&#125;</span></span><br><span class="line"><span class="xml">				年龄:&#123;this.props.age&#125;</span></span><br><span class="line"><span class="xml">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ClassDefaultProps.defaultProps = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&quot;xyq&quot;</span>,</span><br><span class="line">	<span class="attr">age</span>: <span class="number">21</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassDefaultProps</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">		<span class="attr">name</span>: <span class="string">&quot;xyq&quot;</span>,</span><br><span class="line">		<span class="attr">age</span>: <span class="number">21</span>,</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> (</span><br><span class="line">			<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">				名字:&#123;this.props.name&#125;</span></span><br><span class="line"><span class="xml">				年龄:&#123;this.props.age&#125;</span></span><br><span class="line"><span class="xml">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h2><p>使用库：<code>prop-type</code><br>对组件调用静态属性<code>propTypes</code>告知 react 如何检查属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">PropTypes.any：<span class="comment">//任意类型</span></span><br><span class="line">PropTypes.array：<span class="comment">//数组类型</span></span><br><span class="line">PropTypes.bool：<span class="comment">//布尔类型</span></span><br><span class="line">PropTypes.func：<span class="comment">//函数类型</span></span><br><span class="line">PropTypes.number：<span class="comment">//数字类型</span></span><br><span class="line">PropTypes.object：<span class="comment">//对象类型</span></span><br><span class="line">PropTypes.string：<span class="comment">//字符串类型</span></span><br><span class="line">PropTypes.symbol：<span class="comment">//符号类型</span></span><br><span class="line"></span><br><span class="line">PropTypes.node：<span class="comment">//任何可以被渲染的内容，字符串、数字、React元素</span></span><br><span class="line">PropTypes.element：<span class="comment">//react元素</span></span><br><span class="line">PropTypes.elementType：<span class="comment">//react元素类型</span></span><br><span class="line">PropTypes.instanceOf(构造函数)：<span class="comment">//必须是指定构造函数的实例</span></span><br><span class="line">PropTypes.oneOf([xxx, xxx])：<span class="comment">//枚举</span></span><br><span class="line">PropTypes.oneOfType([xxx, xxx]);  <span class="comment">//属性类型必须是数组中的其中一个</span></span><br><span class="line">PropTypes.arrayOf(PropTypes.XXX)：<span class="comment">//必须是某一类型组成的数组</span></span><br><span class="line">PropTypes.objectOf(PropTypes.XXX)：<span class="comment">//对象由某一类型的值组成</span></span><br><span class="line">PropTypes.shape(对象): <span class="comment">//属性必须是对象，并且满足指定的对象要求，属性可以增加</span></span><br><span class="line">PropTypes.exact(&#123;...&#125;)：<span class="comment">//对象必须精确匹配传递的数据，属性不能多</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义属性检查，如果有错误，返回错误对象即可</span></span><br><span class="line">属性: <span class="function"><span class="keyword">function</span>(<span class="params">props, propName, componentName</span>) </span>&#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">&quot;prop-types&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">PropTypeUse</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">		<span class="attr">a</span>: PropTypes.string, <span class="comment">//必须是字符串</span></span><br><span class="line">		<span class="attr">b</span>: PropTypes.number.isRequired, <span class="comment">//必须是数字，且为必填属性</span></span><br><span class="line">		<span class="attr">c</span>: PropTypes.bool, <span class="comment">//必须是boolean值</span></span><br><span class="line">		<span class="attr">d</span>: PropTypes.node.isRequired, <span class="comment">//必须是可以被渲染的内容</span></span><br><span class="line">		<span class="attr">e</span>: PropTypes.shape(&#123;</span><br><span class="line">			<span class="attr">name</span>: PropTypes.string, <span class="comment">//必须是字符串</span></span><br><span class="line">			<span class="attr">age</span>: PropTypes.number, <span class="comment">//必须是数字</span></span><br><span class="line">			<span class="attr">sex</span>: PropTypes.oneOf([<span class="string">&quot;男&quot;</span>, <span class="string">&quot;女&quot;</span>]), <span class="comment">//必须是男或女</span></span><br><span class="line">		&#125;),</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.a&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>react</category>
        <category>react进阶</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>react进阶 react高阶组件和ref应用</title>
    <url>/135xyq.github.io/2022/06/18/react-react%E8%BF%9B%E9%98%B6-%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%E5%92%8Cref/</url>
    <content><![CDATA[<h1 id="高阶组件和ref"><a href="#高阶组件和ref" class="headerlink" title="高阶组件和ref"></a>高阶组件和ref</h1><h2 id="HOC-高阶组件"><a href="#HOC-高阶组件" class="headerlink" title="HOC 高阶组件"></a>HOC 高阶组件</h2><p>HOF:Higher-Order Function,高阶函数，以函数作为一个参数，返回一个参数<br>HOC:Higher-Order Component,高阶组件，以组件作为参数，返回一个组件</p>
<p>可以使用组件实现横切关注点。</p>
<p><strong>注意</strong></p>
<ol>
<li>不要在render中使用高阶组件</li>
<li>不要在高阶组件中更改传入的组件</li>
</ol>
<p>HocTestA</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">HocTestA</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>HocTestA<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>HocTestB</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">HocTestB</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>HocTestB<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WithTestHoc</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 高阶组件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>Comp 组件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns </span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">WithTest</span>(<span class="params">Comp</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">WithTestWrapper</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`组件<span class="subst">$&#123;Comp.name&#125;</span>被创建`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Comp</span> &#123;<span class="attr">...this.props</span>&#125;&gt;</span><span class="tag">&lt;/<span class="name">Comp</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> WithTest  <span class="keyword">from</span> <span class="string">&quot;./HOC/WithTestHoc&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> HocTestA <span class="keyword">from</span> <span class="string">&quot;./components/HocTestA&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> HocTestB <span class="keyword">from</span> <span class="string">&quot;./components/HocTestB&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TestA = WithTest(HocTestA);</span><br><span class="line"><span class="keyword">const</span> TestB = WithTest(HocTestB)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> (</span><br><span class="line">			<span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">			<span class="tag">&lt;<span class="name">TestA</span>&gt;</span><span class="tag">&lt;/<span class="name">TestA</span>&gt;</span></span></span><br><span class="line"><span class="xml">			<span class="tag">&lt;<span class="name">TestB</span>&gt;</span><span class="tag">&lt;/<span class="name">TestB</span>&gt;</span></span></span><br><span class="line"><span class="xml">			<span class="tag">&lt;/&gt;</span></span></span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a><a href="https://zh-hans.reactjs.org/docs/refs-and-the-dom.html#gatsby-focus-wrapper">ref</a></h2><p>reference：引用<br>直接使用dom中的某个方法，或使用组件中的某个方法。</p>
<ol>
<li>ref作用于内置的html组件，得到的将是真是的dom对象</li>
<li>ref作用于类组件，将得到类的实例</li>
<li>ref不能直接作用于函数组件，函数组件内部可以正常使用</li>
</ol>
<p>ref不推荐使用字串符赋值，推荐使用函数或对象<br><strong>字符串</strong> 要删除的使用方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Ref</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    onHandleClick = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 读取input的输入值</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.refs.text.value)</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> (</span><br><span class="line">			<span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">				<span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&quot;text&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.onHandleClick&#125;</span>&gt;</span>获取input的值<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">			<span class="tag">&lt;/&gt;</span></span></span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>对象</strong><br>通过<code>React.createRef</code>函数创建<br>对象结构</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">current</span>:<span class="literal">null</span>,<span class="comment">//刚创建时</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以通过current属性获取到引用的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Ref</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.input = React.createRef()</span><br><span class="line">    &#125;</span><br><span class="line">    onHandleClick = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 读取input的输入值</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.input.current.value)</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> (</span><br><span class="line">			<span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">				<span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;this.input&#125;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.onHandleClick&#125;</span>&gt;</span>获取input的值<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">			<span class="tag">&lt;/&gt;</span></span></span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>函数</strong></p>
<p>函数的调用时间：</p>
<ol>
<li>componentDidMount的时候会调用该函数</li>
</ol>
<ul>
<li>在componentDidMount事件中可以使用ref</li>
</ul>
<ol start="2">
<li>如果ref的值发生了变动（旧的函数被新的函数替代），分别调用旧的函数和新的函数，时间点出现在componentDidUpdate之前</li>
</ol>
<ul>
<li>旧的函数被调用时，传递参数为null</li>
<li>新的函数被调用时，传递参数为引用对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Ref</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.input = React.createRef()</span><br><span class="line">    &#125;</span><br><span class="line">    onHandleClick = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 读取input的输入值</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.input.value)</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> (</span><br><span class="line">			<span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">				<span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;el</span>=&gt;</span>this.input = el&#125; type=&quot;text&quot; /&gt;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.onHandleClick&#125;</span>&gt;</span>获取input的值<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">			<span class="tag">&lt;/&gt;</span></span></span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Ref</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.input = React.createRef()</span><br><span class="line">    &#125;</span><br><span class="line">    onHandleClick = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 读取input的输入值</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.input.value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getRef = <span class="function">(<span class="params">el</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.input = el</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> (</span><br><span class="line">			<span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">				<span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;this.getRef&#125;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.onHandleClick&#125;</span>&gt;</span>获取input的值<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">			<span class="tag">&lt;/&gt;</span></span></span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ref转发"><a href="#ref转发" class="headerlink" title="ref转发"></a><a href="https://zh-hans.reactjs.org/docs/forwarding-refs.html">ref转发</a></h3><p>forwardRef：</p>
<ol>
<li>参数：传递的只能是函数组件，不能是类组件，函数组件要有第二个参数来得到ref</li>
<li>返回值：返回一个新的组件</li>
</ol>
<p>高阶组件 WithTest</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">WithTest</span>(<span class="params">Comp</span>) </span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">WithTest</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">			<span class="keyword">const</span> &#123; forwardRef, ...rest &#125; = <span class="built_in">this</span>.props;</span><br><span class="line">			<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Comp</span> <span class="attr">ref</span>=<span class="string">&#123;forwardRef&#125;</span> &#123;<span class="attr">...rest</span>&#125;&gt;</span><span class="tag">&lt;/<span class="name">Comp</span>&gt;</span></span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> React.forwardRef(<span class="function">(<span class="params">props,ref</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WithTest</span> &#123;<span class="attr">...props</span>&#125; <span class="attr">forwardRef</span>=<span class="string">&#123;ref&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">WithTest</span>&gt;</span></span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>组件CompA</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> WithTest <span class="keyword">from</span> <span class="string">&#x27;./WithTest&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompA</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>CompA</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>  &#123;this.props.data&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>  WithTest(CompA)</span><br></pre></td></tr></table></figure>

<p>测试组件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> CompA <span class="keyword">from</span> <span class="string">&#x27;./CompA&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  compARef = React.createRef();</span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.compARef);<span class="comment">//可以得到组件CompA的实例对象</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">CompA</span> <span class="attr">data</span>=<span class="string">&quot;123456&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;this.compARef&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">CompA</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>react</category>
        <category>react进阶</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>redux redux中间件</title>
    <url>/135xyq.github.io/2022/07/15/react-redux-%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="Redux中间件（Middleware）"><a href="#Redux中间件（Middleware）" class="headerlink" title="Redux中间件（Middleware）"></a>Redux中间件（Middleware）</h1><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>中间件：类似于插件，可以在不影响原本功能、并且不改动原本代码的基础上，对其功能进行增强。在Redux中，中间件主要用于增强dispatch函数。</p>
<p>实现Redux中间件的基本原理，是更改仓库中的dispatch函数。</p>
<p>Redux中间件书写：</p>
<ul>
<li>中间件本身是一个函数，该函数接收一个store参数，表示创建的仓库，该仓库并非一个完整的仓库对象，仅包含getState，dispatch。该函数运行的时间，是在仓库创建之后运行。<ul>
<li>由于创建仓库后需要自动运行设置的中间件函数，因此，需要在创建仓库时，告诉仓库有哪些中间件</li>
<li>需要调用applyMiddleware函数，将函数的返回结果作为createStore的第二或第三个参数。</li>
</ul>
</li>
<li>中间件函数必须返回一个dispatch创建函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *基础写法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>store 最终仓库</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;function(*): function(*): void&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">middleware1</span>(<span class="params">store</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;store&quot;</span>,store);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">next</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;next&quot;</span>,next);<span class="comment">//下一个中间件的dispatch</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">action</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;中间件1&quot;</span>)</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;旧数据&quot;</span>,store.getState());</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;action&quot;</span>,action);</span><br><span class="line">            next(action);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;新数据&quot;</span>,store.getState());</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 箭头函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="variable">store</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;function(*): function(*): void&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> middleware2 = <span class="function"><span class="params">store</span>=&gt;</span><span class="function"><span class="params">next</span>=&gt;</span><span class="function"><span class="params">action</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;中间件2&quot;</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;旧数据&quot;</span>,store.getState());</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;action&quot;</span>,action);</span><br><span class="line">        next(action);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;新数据&quot;</span>,store.getState());</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>applyMiddleware函数，用于记录有哪些中间件，它会返回一个函数<ul>
<li>该函数用于记录创建仓库的方法，然后又返回一个函数</li>
</ul>
</li>
</ul>
<p>应用中间件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数一：reducer</span></span><br><span class="line"><span class="comment">// 参数二：仓库默认值</span></span><br><span class="line"><span class="comment">// 参数三：applyMiddleWare（中间件）</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer,<span class="number">10</span>,applyMiddleware(middleware1,middleware2));</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个函数的参数是使用的中间件</span></span><br><span class="line"><span class="comment">// 第二个函数的参数是创建仓库的方式</span></span><br><span class="line"><span class="comment">// 第三个参数的参数是创建仓库需要的参数</span></span><br><span class="line"><span class="keyword">const</span> store = applyMiddleware(middleware1,middleware2)(createStore)(reducer,<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<h2 id="常用中间件"><a href="#常用中间件" class="headerlink" title="常用中间件"></a>常用中间件</h2><h3 id="redux-logger"><a href="#redux-logger" class="headerlink" title="redux-logger"></a><a href="https://www.npmjs.com/package/redux-logger">redux-logger</a></h3><p>日志记录的中间件</p>
<p>一般写在使用中间件中最后一个，防止其他中间件干扰action</p>
<h3 id="redux-thunk"><a href="#redux-thunk" class="headerlink" title="redux-thunk"></a><a href="https://www.npmjs.com/package/redux-thunk">redux-thunk</a></h3><p>处理副作用</p>
<p>thunk 允许action是一个带有副作用的函数，当action是一个函数被分发时，thunk会阻止action继续向后移交。</p>
<p>thunk会传递三个参数：</p>
<ol>
<li>dispatch: 来自于store.dispatch</li>
<li>getState: 来自于store.getState</li>
<li>extra: 来自于用户设置的额外参数</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">&quot;redux&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> logger <span class="keyword">from</span> <span class="string">&quot;redux-logger&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">&quot;redux-thunk&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;add&quot;</span>:</span><br><span class="line">			<span class="keyword">return</span> state + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;del&quot;</span>:</span><br><span class="line">			<span class="keyword">return</span> state - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> state;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> action = &#123;</span><br><span class="line">    <span class="attr">type</span>:<span class="string">&quot;add&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setTimeoutTestAction</span>(<span class="params">dispatch,getState,extra</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;dispatch&quot;</span>,dispatch)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;getState&quot;</span>,getState)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;extra&quot;</span>,extra)</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        dispatch(action);<span class="comment">//三秒后触发action</span></span><br><span class="line">    &#125;,<span class="number">3000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer, <span class="number">10</span>, applyMiddleware(thunk, logger));</span><br><span class="line"></span><br><span class="line">store.dispatch(setTimeoutTestAction)</span><br></pre></td></tr></table></figure>


<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//手写thunk </span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个thunk中间件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>extra 额外参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns </span>一个thunk中间件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createThunkMiddleWare</span>(<span class="params">extra</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">store</span>=&gt;</span><span class="function"><span class="params">next</span>=&gt;</span><span class="function"><span class="params">action</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> action === <span class="string">&quot;function&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> action(store.dispatch,store.getState,extra);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next(action);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> thunk = createThunkMiddleWare();</span><br><span class="line">thunk.withExtraArgument = createThunkMiddleWare;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> thunk;</span><br></pre></td></tr></table></figure>


<h3 id="redux-saga"><a href="#redux-saga" class="headerlink" title="redux-saga"></a><a href="https://redux-saga-in-chinese.js.org/index.html">redux-saga</a></h3><p>在saga任务中，如果yield了一个普通数据，saga不作任何处理，仅仅将数据传递给yield表达式（把得到的数据放到next的参数中），因此，在saga中，yield一个普通数据没什么意义。</p>
<p>saga需要你在yield后面放上一些合适的saga指令（saga effects），如果放的是指令，saga中间件会根据不同的指令进行特殊处理，以控制整个任务的流程。</p>
<p>每个指令本质上就是一个函数，该函数调用后，会返回一个指令对象，saga会接收到该指令对象，进行各种处理</p>
<p><strong>一旦saga任务完成（生成器函数运行完成），则saga中间件一定结束</strong></p>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><strong>指令前面必须有yield,以确保该指令的返回结果被saga控制</strong></p>
<ul>
<li>take指令：【阻塞】监听某个action，如果action发生了，则会进行下一步处理，take指令仅监听一次。yield得到的是完整的action对象</li>
<li>all指令：【阻塞】该函数传入一个数组，数组中放入生成器，saga会等待所有的生成器全部完成后才会进一步处理</li>
<li>takeEvery指令：不断的监听某个action，当某个action到达之后，运行一个函数。takeEvery永远不会结束当前的生成器</li>
<li>delay指令：【阻塞】阻塞指定的毫秒数</li>
<li>put指令：用于重新触发action，相当于dispatch一个action</li>
<li>call指令：【可能阻塞】用于副作用（通常是异步）函数调用</li>
<li>apply指令：【可能阻塞】用于副作用（通常是异步）函数调用</li>
<li>select指令：用于得到当前仓库中的数据</li>
<li>cps指令：【可能阻塞】用于调用那些传统的回调方式的异步函数</li>
<li>fork：用于开启一个新的任务，该任务不会阻塞，该函数需要传递一个生成器函数，fork返回了一个对象，类型为Task</li>
<li>cancel：用于取消一个或多个任务，实际上，取消的实现原理，是利用generator.return。cancel可以不传递参数，如果不传递参数，则取消当前任务线。</li>
<li>takeLastest：功能和takeEvery一致，只不过，会自动取消掉之前开启的任务</li>
<li>cancelled：判断当前任务线是否被取消掉了</li>
<li>race：【阻塞】竞赛，可以传递多个指令，当其中任何一个指令结束后，会直接结束，与Promise.race类似。返回的结果，是最先完成的指令结果。并且，该函数会自动取消其他的任务</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; delay, put, take, takeEvery, &#125; <span class="keyword">from</span> <span class="string">&quot;redux-saga/effects&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123; numberActionTypes ,decrease&#125; <span class="keyword">from</span> <span class="string">&quot;../action/number&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">testTakeEvery</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> delay(<span class="number">3000</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;延时3秒输出&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> put(decrease());<span class="comment">//触发action</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>* <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> takeEvery(numberActionTypes.increase,testTakeEvery)</span><br><span class="line">    <span class="keyword">let</span> action2 = <span class="keyword">yield</span> take(numberActionTypes.decrease);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;decrease&quot;</span>,action2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>react</category>
        <category>redux</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>redux redux的基础使用</title>
    <url>/135xyq.github.io/2022/07/09/react-redux-%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h1><h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h2><ol>
<li>action是一个plain-object（平面对象）<ol>
<li>它的__proto__指向Object.prototype</li>
</ol>
</li>
<li>通常，使用payload属性表示附加数据（没有强制要求）</li>
<li>action中必须有type属性，该属性用于描述操作的类型<ol>
<li>但是，没有对type的类型做出要求</li>
</ol>
</li>
<li>在大型项目，由于操作类型非常多，为了避免硬编码（hard code），会将action的类型存放到一个或一些单独的文件中(样板代码)。</li>
<li>为了方面传递action，通常会使用action创建函数(action creator)来创建action<ol>
<li>action创建函数应为无副作用的纯函数<ol>
<li>不能以任何形式改动参数</li>
<li>不可以有异步</li>
<li>不可以对外部环境中的数据造成影响</li>
</ol>
</li>
</ol>
</li>
<li>为了方便利用action创建函数来分发（触发）action，redux提供了一个函数<code>bindActionCreators</code>，该函数用于增强action创建函数的功能，使它不仅可以创建action，并且创建后会自动完成分发。</li>
</ol>
<blockquote>
<p>actionTypes.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> INCRESE = <span class="built_in">Symbol</span>(<span class="string">&quot;increse&quot;</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DECREASE = <span class="built_in">Symbol</span>(<span class="string">&quot;descrease&quot;</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SET = <span class="built_in">Symbol</span>(<span class="string">&quot;set&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>actionCreate.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actionTYpes <span class="keyword">from</span> <span class="string">&quot;./actionTypes&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * increase action的创建函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;&#123;type: symbol&#125;</span></span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getIncreaseAction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">type</span>:actionTYpes.INCRESE,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * decrease action的创建函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;&#123;type: *&#125;</span></span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getDecreaseAction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        <span class="attr">type</span>:actionTYpes.DECREASE,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * set action 的创建函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="variable">newNumber</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;&#123;payload, type: *&#125;</span></span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getSetAction</span>(<span class="params">newNumber</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        <span class="attr">type</span>:actionTYpes.SET,</span><br><span class="line">        <span class="attr">payload</span>:newNumber</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>index.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createStore,bindActionCreators&#125; <span class="keyword">from</span> <span class="string">&quot;redux&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> createActions <span class="keyword">from</span> <span class="string">&quot;./actionCreate&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actionTypes <span class="keyword">from</span> <span class="string">&quot;./actionTypes&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * reducer本质上就是一个普通的函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>state 之前仓库中的数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>action 描述要做什么的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state,action</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 返回一个新的状态</span></span><br><span class="line">    <span class="keyword">if</span>(action.type === actionTypes.INCRESE)&#123;</span><br><span class="line">        <span class="keyword">return</span> state + <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (action.type === actionTypes.DECREASE)&#123;</span><br><span class="line">        <span class="keyword">return</span> state - <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(action.type === actionTypes.SET)&#123;</span><br><span class="line">        <span class="keyword">return</span> action.payload;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer,<span class="number">10</span>);</span><br><span class="line"><span class="keyword">const</span> boundActions = bindActionCreators(createActions,store.dispatch);</span><br><span class="line"><span class="built_in">console</span>.log(store.getState()); <span class="comment">//10</span></span><br><span class="line"></span><br><span class="line">boundActions.getDecreaseAction()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(store.getState());<span class="comment">//9</span></span><br><span class="line"></span><br><span class="line">boundActions.getIncreaseAction();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(store.getState());<span class="comment">//10</span></span><br><span class="line"></span><br><span class="line">boundActions.getSetAction(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(store.getState());<span class="comment">//3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h2><p>Store：用于保存数据</p>
<p>通过createStore方法创建的对象。</p>
<p>该对象的成员：</p>
<ul>
<li>dispatch：分发一个action</li>
<li>getState：得到仓库中当前的状态</li>
<li>replaceReducer：替换掉当前的reducer</li>
<li>subscribe：注册一个监听器，监听器是一个无参函数，该分发一个action之后，会运行注册的监听器。该函数会返回一个函数，用于取消监听</li>
</ul>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>react</category>
        <category>redux</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>react dva的使用</title>
    <url>/135xyq.github.io/2022/08/03/react-%E6%8F%92%E4%BB%B6-dva/</url>
    <content><![CDATA[<h1 id="dva"><a href="#dva" class="headerlink" title="dva"></a>dva</h1><blockquote>
<p>官方网站：<a href="https://dvajs.com/">https://dvajs.com</a><br>dva不仅仅是一个第三方库，更是一个框架，它主要整合了redux的相关内容，让我们处理数据更加容易，实际上，dva依赖了很多：react、react-router、redux、redux-saga、react-redux、connected-react-router等</p>
</blockquote>
<h2 id="dva的使用"><a href="#dva的使用" class="headerlink" title="dva的使用"></a>dva的使用</h2><ol>
<li><p>dva默认导出一个函数dva，通过调用该函数，可以得到一个dva对象</p>
</li>
<li><p>dva对象.router：路由方法，传入一个函数，该函数返回一个React节点，将来，应用程序启动后，会自动渲染该节点。</p>
</li>
<li><p>dva对象.start: 该方法用于启动dva应用程序，可以认为启动的就是react程序，该函数传入一个选择器，用于选中页面中的某个dom元素，react会将内容渲染到该元素内部。</p>
</li>
<li><p>dva对象.model: 该方法用于定义一个模型，该模型可以理解为redux的action、reducer、redux-saga副作用处理的整合，整合成一个对象，将该对象传入model方法即可。</p>
<ol>
<li>namespace：命名空间，该属性是一个字符串，字符串的值，会被作为仓库中的属性保存</li>
<li>state：该模型的默认状态</li>
<li>reducers: 该属性配置为一个对象，对象中的每个方法就是一个reducer，dva约定，方法的名字，就是匹配的action类型</li>
<li>effects: 处理副作用，底层是使用redux-saga实现的，该属性配置为一个对象，对象中的每个方法均处理一个副作用，方法的名字，就是匹配的action类型。<ol>
<li>函数的参数1：action</li>
<li>参数2：封装好的saga/effects对象</li>
</ol>
</li>
<li>subscriptions：配置为一个对象，该对象中可以写任意数量任意名称的属性，每个属性是一个函数，这些函数会在模型加入到仓库中后立即运行。</li>
</ol>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">namespace</span>:<span class="string">&quot;count&quot;</span>,</span><br><span class="line">    <span class="attr">state</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="attr">reducers</span>:&#123;</span><br><span class="line">        <span class="function"><span class="title">increase</span>(<span class="params">state</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> state + <span class="number">1</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">decrease</span>(<span class="params">state</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> state - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">effects</span>:&#123;</span><br><span class="line">        *<span class="function"><span class="title">asyncIncrease</span>(<span class="params">action,&#123;call,put&#125;</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">yield</span> call(delay,<span class="number">1000</span>)</span><br><span class="line">            <span class="keyword">yield</span> put(&#123;</span><br><span class="line">                <span class="attr">type</span>:<span class="string">&quot;increase&quot;</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        *<span class="function"><span class="title">asyncDecrease</span>(<span class="params">action,&#123;call,put&#125;</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">yield</span> call(delay,<span class="number">1000</span>)</span><br><span class="line">            <span class="keyword">yield</span> put(&#123;</span><br><span class="line">                <span class="attr">type</span>:<span class="string">&quot;decrease&quot;</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params">duration</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;,duration)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol start="5">
<li>在dva中同步路由到仓库<ol>
<li>在调用dva函数时，配置history对象</li>
<li>使用ConnectedRouter提供路由上下文</li>
</ol>
</li>
</ol>
<ol start="6">
<li>配置：<ol>
<li>history：同步到仓库的history对象</li>
<li>initialState：创建redux仓库时，使用的默认状态</li>
<li>onError: 当仓库的运行发生错误的时候，运行的函数</li>
<li>onAction: 可以配置redux中间件<ol>
<li>传入一个中间件对象</li>
<li>传入一个中间件数组</li>
</ol>
</li>
<li>onStateChange: 当仓库中的状态发生变化时运行的函数</li>
<li>onReducer：对模型中的reducer的进一步封装</li>
<li>onEffect：类似于对模型中的effect的进一步封装</li>
<li>extraReducers：用于配置额外的reducer，它是一个对象，对象的每一个属性是一个方法，每个方法就是一个需要合并的reducer，方法名即属性名。</li>
<li>extraEnhancers: 它是用于封装createStore函数的，dva会将原来的仓库创建函数作为参数传递，返回一个新的用于创建仓库的函数。函数必须放置到数组中。</li>
</ol>
</li>
</ol>
<h2 id="dva插件"><a href="#dva插件" class="headerlink" title="dva插件"></a>dva插件</h2><p>通过dva对象.use(插件)，来使用插件，插件本质上就是一个对象，该对象与配置对象相同，dva会在启动时，将传递的插件对象混合到配置中。</p>
<h3 id="dva-loading-加载中"><a href="#dva-loading-加载中" class="headerlink" title="dva-loading 加载中"></a>dva-loading 加载中</h3><p>该插件会在仓库中加入一个状态，名称为loading，它是一个对象，其中有以下属性</p>
<p>global：全局是否正在处理副作用（加载），只要有任何一个模型在处理副作用，则该属性为true<br>models：一个对象，对象中的属性名以及属性的值，表示哪个对应的模型是否在处理副作用中（加载中）<br>effects：一个对象，对象中的属性名以及属性的值，表示是哪个action触发了副作用</p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>react</category>
        <category>插件</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>react 路由 常用的路由组件</title>
    <url>/135xyq.github.io/2022/07/01/react-%E8%B7%AF%E7%94%B1-%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="路由组件"><a href="#路由组件" class="headerlink" title="路由组件"></a>路由组件</h1><p>React-Router库提供</p>
<h2 id="Router组件"><a href="#Router组件" class="headerlink" title="Router组件"></a><a href="https://reactrouter.com/docs/en/v6/getting-started/overview">Router组件</a></h2><p>本身不做任何展示，仅提供路由模式配置，另外，该组件会产生一个上下文，上下文提供一些常用的数据和方法，供其他组件使用。</p>
<ol>
<li>HashRouter：使用hash模式配置</li>
<li>BrowserRouter：使用BrowserHistory模式匹配</li>
</ol>
<h2 id="Route组件"><a href="#Route组件" class="headerlink" title="Route组件"></a><a href="https://reactrouter.com/docs/en/v6/getting-started/overview">Route组件</a></h2><p>根据不同的地址展示不同的组件</p>
<p>属性：</p>
<ol>
<li>path：匹配的路径（默认情况不区分大小写）<ul>
<li>设置caseSensitive为true来区分大小写</li>
<li>默认情况下，只匹配初始目录，如果要精确匹配，设置exact为true</li>
<li>如果不设置path，会匹配任何路径</li>
</ul>
</li>
<li>element：匹配成功后要显示的组件</li>
<li>children：<ul>
<li>传递React元素，无论是否匹配，一定会显示children，并且会忽略element属性</li>
<li>传递一个函数，该函数有多个参数，这些参数来自上下文，该函数返回react元素，则一定会显示返回的元素，并且会忽略element属性</li>
</ul>
</li>
</ol>
<p>Route组件可以写到任何位置，只需要保证是Router组件的后代元素即可。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; Route, Routes &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CompA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>组件A<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CompB</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>组件B<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CompC</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>组件C<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CompD</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CompE</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>404<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">TestStaticRouterComp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="xml">				<span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/a&quot;</span> <span class="attr">caseSensitive</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">CompA</span>/&gt;</span>&#125; &gt;<span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="xml">				<span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/a/b&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">CompB</span>/&gt;</span>&#125;&gt;<span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="xml">				<span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/c&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">CompC</span>/&gt;</span>&#125;&gt;<span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="xml">				<span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">CompD</span>/&gt;</span>&#125;&gt;<span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="xml">				<span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;*&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">CompE</span>/&gt;</span>&#125;&gt;<span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="xml">		<span class="tag">&lt;/<span class="name">Routes</span>&gt;</span></span></span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Switch组件"><a href="#Switch组件" class="headerlink" title="Switch组件"></a><a href="https://reactrouter.com/docs/en/v6/getting-started/overview">Switch组件</a></h2><p>写到Switch组件中的Route组件，当匹配到第一个Route后，会立即停止匹配。 </p>
<p>由于Switch组件会循环所有子元素，然后让每一个子元素去完成匹配，若匹配到，则渲染对应的组件，然后停止循环。因此不能在Switch的子元素中使用除Route外的其他组件</p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>react</category>
        <category>路由</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>react umi的使用</title>
    <url>/135xyq.github.io/2022/08/04/react-%E6%8F%92%E4%BB%B6-umi/</url>
    <content><![CDATA[<h1 id="umi"><a href="#umi" class="headerlink" title="umi"></a><a href="https://v3.umijs.org/zh-CN">umi</a></h1><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><h3 id="约定式路由"><a href="#约定式路由" class="headerlink" title="约定式路由"></a>约定式路由</h3><p>umi对路由的处理，主要通过两种方式：</p>
<ol>
<li><strong>约定式</strong>：使用约定好的文件夹和文件，来代表页面，umi会根据开发者书写的页面，生成路由配置。</li>
<li>配置式：直接书写路由配置文件</li>
</ol>
<h4 id="路由匹配"><a href="#路由匹配" class="headerlink" title="路由匹配"></a>路由匹配</h4><ul>
<li>umi约定，工程中的pages文件夹中存放的是页面。如果工程包含src目录，则src/pages是页面文件夹。</li>
<li>umi约定，页面的文件名，以及页面的文件路径，是该页面匹配的路由</li>
<li>umi约定，如果页面的文件名是index，则可以省略文件名（首页）(注意避免文件名和当前目录中的文件夹名称相同)</li>
<li>umi约定，如果src/layout目录存在，则该目录中的index.js表示的是全局的通用布局，布局中的children则会添加具体的页面。</li>
<li>umi约定，如果pages文件夹中包含_layout.js，则layout.js所在的目录以及其所有的子目录中的页面，共用该布局。</li>
<li>404约定，umi约定，pages/404.js，表示404页面，如果路由无匹配，则会渲染该页面。该约定在开发模式中无效，只有部署后生效。</li>
<li>使用$名称，会产生动态路由</li>
</ul>
<h4 id="路由跳转"><a href="#路由跳转" class="headerlink" title="路由跳转"></a>路由跳转</h4><ul>
<li>跳转链接： 导入<code>umi/link</code>，<code>umi/navlink</code></li>
<li>代码跳转： 导入<code>umi/router</code></li>
</ul>
<blockquote>
<p>导入模块时，@表示src目录</p>
</blockquote>
<h4 id="路由信息的获取"><a href="#路由信息的获取" class="headerlink" title="路由信息的获取"></a>路由信息的获取</h4><p>所有的页面、布局组件，都会通过属性，收到下面的属性</p>
<ul>
<li>match：等同于react-router的match</li>
<li>history：等同于react-router的history（history.location.query被封装成了一个对象，使用的是query-string库进行的封装）</li>
<li>location：等同于react-router的location（location.query被封装成了一个对象，使用的是query-string库进行的封装）</li>
<li>route：对应的是路由配置</li>
</ul>
<p>如果需要在普通组件中获取路由信息，则需要使用withRouter封装，可以通过<code>umi/withRouter</code>导入</p>
<h3 id="配置式路由"><a href="#配置式路由" class="headerlink" title="配置式路由"></a>配置式路由</h3><p>当使用了路由配置后，约定式路由全部失效。</p>
<p>两种方式书写umi配置：</p>
<ol>
<li>使用根目录下的文件<code>.umirc.js</code></li>
<li>使用根目录下的文件<code>config/config.js</code></li>
</ol>
<p>进行路由配置时，每个配置就是一个匹配规则，并且，每个配置是一个对象，对象中的某些属性，会直接形成Route组件的属性</p>
<p>注意：</p>
<ul>
<li>component配置项，需要填写页面组件的路径，路径相对于pages文件夹</li>
<li>如果配置项没有exact，则会自动添加exact为true</li>
<li>每一个路由配置，可以添加任何属性</li>
<li>Routes属性是一个数组，数组的每一项是一个组件路径，路径相对于项目根目录，当匹配到路由后，会转而渲染该属性指定的组件，并会将component组件作为children放到匹配的组件中</li>
</ul>
<p>路由配置中的信息，同样可以放到约定式路由中，方式是，为约定式路由添加第一个文档注释（注释的格式的YAML），需要将注释放到最开始的位置</p>
<p>YAML格式</p>
<ul>
<li>键值对，冒号后需要加上空格</li>
<li>如果某个属性有多个键或多个值，需要进行缩进（空格）</li>
</ul>
<h2 id="使用dva"><a href="#使用dva" class="headerlink" title="使用dva"></a>使用dva</h2><blockquote>
<p>官方插件集 umi-plugin-react</p>
</blockquote>
<p>dva插件和umi整合后，将模型分为两种：</p>
<ol>
<li>全局模型：所有页面通用，工程一开始启动后，模型就会挂载到仓库</li>
<li>局部模型：只能被某些页面使用，访问具体的页面时才会挂载到仓库</li>
</ol>
<h3 id="定义全局模型"><a href="#定义全局模型" class="headerlink" title="定义全局模型"></a>定义全局模型</h3><p>在<code>src/models</code>目录下定义的js文件都会被看作是全局模型，默认情况下，模型的命名空间和文件名一致。</p>
<h3 id="定义局部模型"><a href="#定义局部模型" class="headerlink" title="定义局部模型"></a>定义局部模型</h3><p>局部模型定义在pages文件夹或其子文件夹中，在哪个文件夹定义的模型，会被该文件夹中的所有页面以及子页面、以及该文件夹的祖先文件夹中的页面所共享。</p>
<p>局部模型的定义和全局模型的约定类似，需要创建一个models文件夹</p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>react</category>
        <category>插件</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>uniapp基础Api和插件安装</title>
    <url>/135xyq.github.io/2022/04/03/uniapp-uniappAPi/</url>
    <content><![CDATA[<h2 id="基础API"><a href="#基础API" class="headerlink" title="基础API"></a>基础API</h2><p><strong>参考地址</strong>：<a href="https://uniapp.dcloud.net.cn/api/README">https://uniapp.dcloud.net.cn/api/README</a></p>
<h3 id="API列表"><a href="#API列表" class="headerlink" title="API列表"></a>API列表</h3><ul>
<li><p><strong>网络请求</strong></p>
<ul>
<li><p>uni.request 发起网络请求</p>
<blockquote>
<p>为了解决uni.request网络请求API相对简单的问题，可使用@escook/request-miniprogram进行网路请求的处理</p>
<p>参考地址：<a href="https://www.npmjs.com/package/@escook/request-miniprogram">https://www.npmjs.com/package/@escook/request-miniprogram</a></p>
<p><strong>在小程序中，无法使用fetch及axios进行网络请求发送</strong></p>
</blockquote>
<p><strong>测试接口地址：<a href="https://study.duyiedu.com/api/herolist">https://study.duyiedu.com/api/herolist</a></strong></p>
</li>
</ul>
</li>
<li><p>上传、下载</p>
<ul>
<li>uni.unloadFile 上传文件  =&gt; <a href="https://uniapp.dcloud.net.cn/api/request/network-file">https://uniapp.dcloud.net.cn/api/request/network-file</a></li>
<li>uni.downloadFile 下载文件</li>
</ul>
</li>
<li><p>图片处理</p>
<ul>
<li>uni.chooseImage 从相册选择图片，或者拍照 =&gt;<a href="https://uniapp.dcloud.net.cn/api/media/image?id=chooseimage">https://uniapp.dcloud.net.cn/api/media/image?id=chooseimage</a></li>
<li>uni.previewImage 预览图片</li>
<li>uni.getImageInfo 获取图片信息</li>
</ul>
</li>
<li><p>数据缓存 =&gt; <a href="https://uniapp.dcloud.net.cn/api/storage/storage?id=setstorage">https://uniapp.dcloud.net.cn/api/storage/storage?id=setstorage</a></p>
<ul>
<li>uni.getStorage 异步获取本地数据缓存</li>
<li>uni.getStorageSync 同步获取本地数据缓存</li>
<li>uni.setStorage 异步设置本地数据缓存</li>
<li>uni.setStorageSync 同步设置本地数据缓存</li>
<li>uni.removeStorage 异步删除本地数据缓存</li>
<li>uni.reoveStorageSync 同步删除本地数据缓存</li>
</ul>
</li>
<li><p>交互反馈 =&gt; <a href="https://uniapp.dcloud.net.cn/api/ui/prompt?id=showtoast">https://uniapp.dcloud.net.cn/api/ui/prompt?id=showtoast</a></p>
<ul>
<li>uni.showToast 显示提示框</li>
<li>uni.showLoading 显示加载提示框</li>
<li>uni.hideToast 隐藏提示框</li>
<li>uni.hideLoading 隐藏加载提示框</li>
<li>uni.showModal 显示模态框</li>
<li>uni.showActionSheet 显示菜单列表</li>
</ul>
</li>
<li><p>路由</p>
<ul>
<li><p>uni.navigateTo 保留当前页面，跳转到应用内某个界面，使用uni.navigateBack 返回原页面</p>
</li>
<li><p>uni.redirectTo 关闭当前界面，跳转到应用内的某个界面</p>
</li>
<li><p>uni.reLaunch 关闭所有界面，打开应用内的某个界面</p>
</li>
<li><p>uni.switchTab 跳转到tab Bar页面</p>
</li>
</ul>
</li>
</ul>
<h2 id="页面布局相关"><a href="#页面布局相关" class="headerlink" title="页面布局相关"></a>页面布局相关</h2><p><strong>page</strong></p>
<blockquote>
<p>页面容器css属性</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">page:&#123;</span><br><span class="line">  height:<span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>尺寸单位</strong></p>
<p>可使用单位：px rpx,upx, rem vh  vw</p>
<p><strong>外部样式文件引入</strong></p>
<p>同vue使用相同    </p>
<h2 id="uniapp生命周期"><a href="#uniapp生命周期" class="headerlink" title="uniapp生命周期"></a>uniapp生命周期</h2><p><strong>参考地址：</strong><a href="https://uniapp.dcloud.net.cn/collocation/frame/lifecycle?id=%E5%BA%94%E7%94%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">https://uniapp.dcloud.net.cn/collocation/frame/lifecycle?id=%e5%ba%94%e7%94%a8%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f</a></p>
<h3 id="应用生命周期"><a href="#应用生命周期" class="headerlink" title="应用生命周期"></a>应用生命周期</h3><ul>
<li><p>onLaunch 初始化完成时触发（全局🈯️触发一次）</p>
</li>
<li><p>onShow uni-app启动，或从后台进入前台显示</p>
</li>
<li><p>onHide 当uni-app 应用从前台进入后台</p>
<blockquote>
<p>只能在App.vue里面进行监听，在其他界面监听无效</p>
</blockquote>
</li>
</ul>
<h3 id="页面生命周期"><a href="#页面生命周期" class="headerlink" title="页面生命周期"></a>页面生命周期</h3><ul>
<li>onLoad 监听页面加载（可获取上个界面传递的参数）</li>
<li>onShow 监听页面显示，每次出现在屏幕上都进行触发</li>
<li>onReady 监听页面初次渲染完成</li>
<li>onHide 监听页面隐藏</li>
<li>onUnload 监听页面卸载</li>
<li>onReachBottom 页面滚动到底部事件</li>
</ul>
<h3 id="组件生命周期"><a href="#组件生命周期" class="headerlink" title="组件生命周期"></a>组件生命周期</h3><ul>
<li>beofreCreate </li>
<li>created</li>
<li>boforeMount</li>
<li>mounted</li>
<li>boforeDestroy</li>
<li>destroyed</li>
</ul>
<hr>
<h2 id="uniApp特色"><a href="#uniApp特色" class="headerlink" title="uniApp特色"></a>uniApp特色</h2><h3 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h3><blockquote>
<p>条件编译是用特殊的注释作为标记，在编译时根据这些特殊的注释，将注释里面的代码编译到不同平台。</p>
</blockquote>
<p><strong>语法</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gsek7g2i93j31tm0hk41p.jpg" alt="image-20210712225857698"></p>
<p><strong>取值</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gsfadcxx6nj310a0u040t.jpg" alt="image-20210712230042343"></p>
<p><strong>条件编译支持的文件</strong></p>
<ul>
<li>.vue</li>
<li>.js</li>
<li>.css</li>
<li>pages.json</li>
<li>各预编译语言文件，如：.scss、.less、.stylus、.ts、.pug</li>
</ul>
<blockquote>
<p>​        条件编译是利用注释实现的，在不同语法里注释写法不一样，js使用 <code>// 注释</code>、css 使用 <code>/* 注释 */</code>、vue/nvue 模板里使用 <code>&lt;!-- 注释 --&gt;</code>；</p>
</blockquote>
<h4 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h4><ol>
<li><p>​    <strong>scss安装</strong></p>
<blockquote>
<p>可以使用多种预编译处理器进行安装使用，以scss文件为例</p>
<p>下载地址：<strong><a href="https://ext.dcloud.net.cn/plugin?name=compile-node-sass">https://ext.dcloud.net.cn/plugin?name=compile-node-sass</a></strong></p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gsixua1hqdj316w0u0gpv.jpg" alt="image-20210716175247652"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>uniapp</category>
      </categories>
      <tags>
        <tag>uniapp</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序相关</title>
    <url>/135xyq.github.io/2022/04/02/uniapp-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="微信小程序简介"><a href="#微信小程序简介" class="headerlink" title="微信小程序简介"></a>微信小程序简介</h1><h2 id="文档相关"><a href="#文档相关" class="headerlink" title="文档相关"></a>文档相关</h2><ol>
<li>开发文档：<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/">https://developers.weixin.qq.com/miniprogram/dev/framework/</a></li>
<li>微信公众平台：<a href="https://mp.weixin.qq.com/">https://mp.weixin.qq.com/</a></li>
</ol>
<h2 id="开发者工具"><a href="#开发者工具" class="headerlink" title="开发者工具"></a>开发者工具</h2><p>​    下载地址：<a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html">https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html</a></p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><strong>必选项处理</strong></p>
<p><img src="/images/uniapp/008i3skNly1gse9mjp0oxj317k0togot.jpg" alt="image-20210712165252682"></p>
<p><strong>appID获取</strong></p>
<blockquote>
<p>微信公众平台进行appID获取</p>
</blockquote>
<p><img src="/images/uniapp/008i3skNly1gse9lrid90j318m0u0dlg.jpg" alt="image-20210712165206640"></p>
<h3 id="小程序代码构成"><a href="#小程序代码构成" class="headerlink" title="小程序代码构成"></a>小程序代码构成</h3><blockquote>
<p>参考地址：<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/quickstart/code.html#JSON-%E9%85%8D%E7%BD%AE">https://developers.weixin.qq.com/miniprogram/dev/framework/quickstart/code.html#JSON-%E9%85%8D%E7%BD%AE</a></p>
</blockquote>
<ol>
<li><code>.json</code> 后缀的 <code>JSON</code> 配置文件</li>
<li><code>.wxml</code> 后缀的 <code>WXML</code> 模板文件</li>
<li><code>.wxss</code> 后缀的 <code>WXSS</code> 样式文件</li>
<li><code>.js</code> 后缀的 <code>JS</code> 脚本逻辑文件</li>
</ol>
<p><strong>小程序基本结构</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;userinfo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">wx:if</span>=<span class="string">&quot;&#123;&#123;!hasUserInfo &amp;&amp; canIUse&#125;&#125;&quot;</span>&gt;</span> 获取头像昵称 <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:else</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span>=<span class="string">&quot;&#123;&#123;userInfo.avatarUrl&#125;&#125;&quot;</span> <span class="attr">background-size</span>=<span class="string">&quot;cover&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">&quot;userinfo-nickname&quot;</span>&gt;</span>&#123;&#123;userInfo.nickName&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;usermotto&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">&quot;user-motto&quot;</span>&gt;</span>&#123;&#123;motto&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="小程序基本操作"><a href="#小程序基本操作" class="headerlink" title="小程序基本操作"></a>小程序基本操作</h3><ul>
<li><p><strong>配置信息</strong></p>
<ul>
<li><p>全局配置 -&gt; <a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html">https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;pages&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;pages/index/index&quot;</span>,</span><br><span class="line">    <span class="string">&quot;pages/logs/index&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;window&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;navigationBarTitleText&quot;</span>: <span class="string">&quot;Demo&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;tabBar&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;list&quot;</span>: [&#123;</span><br><span class="line">      <span class="attr">&quot;pagePath&quot;</span>: <span class="string">&quot;pages/index/index&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;首页&quot;</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      <span class="attr">&quot;pagePath&quot;</span>: <span class="string">&quot;pages/logs/index&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;日志&quot;</span></span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;networkTimeout&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;request&quot;</span>: <span class="number">10000</span>,</span><br><span class="line">    <span class="attr">&quot;downloadFile&quot;</span>: <span class="number">10000</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;debug&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>页面配置</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;navigationBarBackgroundColor&quot;</span>: <span class="string">&quot;#ffffff&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;navigationBarTextStyle&quot;</span>: <span class="string">&quot;black&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;navigationBarTitleText&quot;</span>: <span class="string">&quot;微信接口功能演示&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;backgroundColor&quot;</span>: <span class="string">&quot;#eeeeee&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;backgroundTextStyle&quot;</span>: <span class="string">&quot;light&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>全局生命周期函数</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当小程序初始化完成时，会触发 onLaunch（全局只触发一次）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="attr">onLaunch</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;,</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当小程序启动，或从后台进入前台显示，会触发 onShow</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="attr">onShow</span>: <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;,</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当小程序从前台进入后台，会触发 onHide</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="attr">onHide</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;,</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当小程序发生脚本错误，或者 api 调用失败时，会触发 onError 并带上错误信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="attr">onError</span>: <span class="function"><span class="keyword">function</span> (<span class="params">msg</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>页面生命周期函数</strong> -&gt; <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page-life-cycle.html">https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page-life-cycle.html</a></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">onLoad: <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 页面创建时执行</span></span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">onShow</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 页面出现在前台时执行</span></span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">onReady</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 页面首次渲染完毕时执行</span></span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">onHide</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 页面从前台变为后台时执行</span></span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">onUnload</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 页面销毁时执行</span></span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">onPullDownRefresh</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 触发下拉刷新时执行</span></span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">onReachBottom</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 页面触底时执行</span></span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">onShareAppMessage</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 页面被用户分享时执行</span></span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">onPageScroll</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 页面滚动时执行</span></span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">onResize</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 页面尺寸变化时执行</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>组件生命周期</strong>-&gt;<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/lifetimes.html">https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/lifetimes.html</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Component(&#123;</span><br><span class="line">  <span class="attr">lifetimes</span>:&#123;</span><br><span class="line">    <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;created,组件实例刚刚被创建好时， created 生命周期被触发&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">attached</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;组件实力进入页面节点树时候进行执行&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">detached</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;在组件实例被从页面节点树移除时执行&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p><strong>界面跳转</strong></p>
<ul>
<li><p>新界面打开=&gt;<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/route.html">https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/route.html</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">调用 API wx.navigateTo</span><br><span class="line">使用组件 &lt;navigator open-type=<span class="string">&quot;navigateTo&quot;</span>/&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>页面重定向</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">调用 API wx.redirectTo</span><br><span class="line">使用组件 &lt;navigator open-type=<span class="string">&quot;redirectTo&quot;</span>/&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>页面返回</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">调用 API wx.navigateBack</span><br><span class="line">使用组件&lt;navigator open-type=&quot;navigateBack&quot;&gt;</span><br><span class="line">用户按左上角返回按钮</span><br></pre></td></tr></table></figure></li>
<li><p>Tab切换</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">调用 API wx.switchTab</span><br><span class="line">使用组件 &lt;navigator open-type=<span class="string">&quot;switchTab&quot;</span>/&gt;</span><br><span class="line">用户切换 Tab</span><br></pre></td></tr></table></figure></li>
<li><p>重启动</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">调用 API wx.reLaunch</span><br><span class="line">使用组件 &lt;navigator open-type=<span class="string">&quot;reLaunch&quot;</span>/&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>数据绑定</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  <span class="attr">data</span>:&#123;</span><br><span class="line">    <span class="attr">message</span>:<span class="string">&quot;hello world&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p><strong>条件渲染</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:if</span>=<span class="string">&quot;&#123;&#123;isShow&#125;&#125;&quot;</span>&gt;</span>条件判断显示<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">	data:&#123;</span><br><span class="line">		isShow:false</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p><strong>列表渲染</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;list&#125;&#125;&quot;</span> <span class="attr">wx:for-index</span>=<span class="string">&quot;idx&quot;</span> <span class="attr">wx:for-item</span>=<span class="string">&quot;itemName&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123;idx&#125;&#125;: &#123;&#123;itemName.name&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">list</span>:[</span><br><span class="line">      &#123;<span class="attr">name</span>:<span class="string">&#x27;a&#x27;</span>&#125;,</span><br><span class="line">      &#123;<span class="attr">name</span>:<span class="string">&#x27;b&#x27;</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>uniapp</category>
      </categories>
      <tags>
        <tag>uniapp</tag>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>uniapp开发规范</title>
    <url>/135xyq.github.io/2022/04/02/uniapp-uniapp%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h1 id="uniapp开发规范"><a href="#uniapp开发规范" class="headerlink" title="uniapp开发规范"></a>uniapp开发规范</h1><ul>
<li><p>页面文件遵循Vue单文件组件（SFC）规范</p>
</li>
<li><p>组件标签靠近小程序规范 =&gt;<a href="https://uniapp.dcloud.io/component/README">https://uniapp.dcloud.io/component/README</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;view&gt;</span><br><span class="line">		页面内容</span><br><span class="line">	&lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">	export default &#123;</span><br><span class="line">		data() &#123;</span><br><span class="line">			return &#123;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		methods: &#123;	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>接口能力（JS API）靠近微信小程序规范 =&gt; <a href="https://uniapp.dcloud.io/api/README">https://uniapp.dcloud.io/api/README</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">uni.getStorageInfoSync()</span><br></pre></td></tr></table></figure></li>
<li><p>数据绑定事件处理同Vue.js规范</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;view @click=&quot;onClickFn&quot;&gt;</span><br><span class="line">      点击事件绑定</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    onClickFn() &#123;</span><br><span class="line">      console.log(&#x27;click事件&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>兼容多端运行，使用flex布局进行开发</p>
</li>
</ul>
<hr>
<h2 id="uniapp开发环境"><a href="#uniapp开发环境" class="headerlink" title="uniapp开发环境"></a>uniapp开发环境</h2><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><p>uni-app 官方推荐使用 <strong>HBuilderX</strong> 来开发 uni-app 类型的项目。主要好处：</p>
<ul>
<li>模板丰富</li>
<li>完善的智能提示</li>
<li>一键运行</li>
</ul>
<h3 id="下载-HBuilderX"><a href="#下载-HBuilderX" class="headerlink" title="下载 HBuilderX"></a>下载 HBuilderX</h3><ol>
<li>访问 HBuilderX 的官网首页 <a href="https://www.dcloud.io/hbuilderx.html">https://www.dcloud.io/hbuilderx.html</a></li>
<li>点击首页的 <code>DOWNLOAD</code> 按钮</li>
<li>选择下载 <code>正式版</code>/alpha -&gt; <code>App 开发版</code></li>
<li>将下载的 <code>zip包</code> 进行解压缩</li>
<li>将解压之后的文件夹，存放到<strong>纯英文</strong>的目录中（且不能包含括号等特殊字符）</li>
<li>双击 <code>HBuilderX.exe</code> 即可启动 HBuilderX</li>
<li>详细安装文档：=&gt; <a href="https://hx.dcloud.net.cn/Tutorial/install/windows">https://hx.dcloud.net.cn/Tutorial/install/windows</a></li>
</ol>
<h2 id="工程搭建"><a href="#工程搭建" class="headerlink" title="工程搭建"></a>工程搭建</h2><ol>
<li><p>文件 -&gt; 新建 -&gt; 项目</p>
<p><img src="/images/uniapp/008i3skNly1gselljycn2j31hc0joq3c-16487011449324.jpg" alt="img"></p>
</li>
<li><p>填写项目基本信息</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gselm265sdj30na0g3di5.jpg" alt="img"></p>
</li>
<li><p>项目创建成功</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gselmb4wf0j61hc0sywev02.jpg" alt="img"></p>
</li>
</ol>
<p>​    <strong>基本目录结构</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">项目名称</span><br><span class="line">----【pages】    内部存放所有页面</span><br><span class="line">----【static】   存放所有静态资源，比如图片，字体图标</span><br><span class="line">----【unpackage】存放所有打包生成后的文件</span><br><span class="line">----app<span class="selector-class">.vue</span>     应用配置，用来配置App全局样式以及监听 应用生命周期</span><br><span class="line">----<span class="selector-tag">main</span><span class="selector-class">.js</span>			Vue初始化入口文件</span><br><span class="line">----mainfast<span class="selector-class">.json</span>  配置应用名称、appid、logo、版本等打包信息</span><br><span class="line">----pages<span class="selector-class">.json</span>    配置页面路由、导航条、选项卡等页面类信息</span><br><span class="line">----uni<span class="selector-class">.scss</span>      用途是为了方便整体控制应用的风格。比如按钮颜色、边框风格，uni<span class="selector-class">.scss</span>文件里预置了一批scss变量预置。</span><br></pre></td></tr></table></figure>



<h2 id="项目运行"><a href="#项目运行" class="headerlink" title="项目运行"></a>项目运行</h2><h3 id="浏览器运行"><a href="#浏览器运行" class="headerlink" title="浏览器运行"></a>浏览器运行</h3><ol>
<li><img src="/images/uniapp/008i3skNly1gsn7079jy3j313q0u0dkk.jpg" alt="image-20210720101209233"></li>
</ol>
<h3 id="小程序运行"><a href="#小程序运行" class="headerlink" title="小程序运行"></a>小程序运行</h3><ol>
<li><p>填写自己的微信小程序的 AppID：</p>
<p><img src="/images/uniapp/008i3skNly1gselrjw91dj31hc0n7q3v.jpg" alt="img"></p>
</li>
<li><p>在 HBuilderX 中，配置“微信开发者工具”的<strong>安装路径</strong>：</p>
<p><img src="/images/uniapp/008i3skNly1gsels176jwj31hc0lpab2.jpg" alt="img"></p>
</li>
<li><p>在微信开发者工具中，通过 <code>设置 -&gt; 安全设置</code> 面板，开启“微信开发者工具”的<strong>服务端口</strong>：</p>
<p><img src="/images/uniapp/008i3skNly1gselum0va7j30tw0nywg0.jpg" alt="image-20210712235549929"></p>
</li>
<li><p>在 HBuilderX 中，点击菜单栏中的 <code>运行 -&gt; 运行到小程序模拟器 -&gt; 微信开发者工具</code>，将当前 uni-app 项目编译之后，自动运行到微信开发者工具中，从而方便查看项目效果与调试：</p>
<p><img src="/images/uniapp/008i3skNly1gselv7wqqrj31hc0s8go0.jpg" alt="img"></p>
</li>
<li><p>初次运行成功之后的项目效果：</p>
<p><img src="/images/uniapp/008i3skNly1gselvryapfj31hc0sygmn.jpg" alt="img"></p>
</li>
</ol>
<h3 id="app真机运行"><a href="#app真机运行" class="headerlink" title="app真机运行"></a>app真机运行</h3><blockquote>
<p>​    确保你的手机与电脑是在同一个局域网下面</p>
</blockquote>
<ol>
<li>手机开启开发者模式</li>
<li>选择数据管理</li>
<li>hbuildeX选择真机运行</li>
<li>等待基座安装</li>
<li>安装完成手机运行项目</li>
</ol>
<h3 id="IOS模拟器运行"><a href="#IOS模拟器运行" class="headerlink" title="IOS模拟器运行"></a>IOS模拟器运行</h3><ol>
<li> Xcode下载</li>
<li>定义版本进行模拟器运行</li>
</ol>
<hr>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>uniapp</category>
      </categories>
      <tags>
        <tag>uniapp</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题HTML中部分讲解</title>
    <url>/135xyq.github.io/2022/04/23/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98-HTML-%E9%83%A8%E5%88%86%E9%9D%A2%E8%AF%95%E9%A2%98%E5%92%8C%E8%AE%B2%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="HTML相关"><a href="#HTML相关" class="headerlink" title="HTML相关"></a>HTML相关</h1><h2 id="文档声明"><a href="#文档声明" class="headerlink" title="文档声明"></a>文档声明</h2><h3 id="经典真题"><a href="#经典真题" class="headerlink" title="经典真题"></a>经典真题</h3><ul>
<li>什么是<code>&lt;!DOCTYPE&gt;</code>？是否需要在 <em>HTML5</em> 中使用？</li>
<li>什么是严格模式与混杂模式？</li>
<li>列举几条怪异模式中的怪癖行为</li>
</ul>
<h3 id="文档声明概念"><a href="#文档声明概念" class="headerlink" title="文档声明概念"></a>文档声明概念</h3><p><em>HTML</em> 文档通常以文档声明开始，该声明的作用是帮助浏览器确定其尝试解析和显示的 <em>HTML</em> 文档类型。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>文档声明必须是 <em>HTML</em> 文档的第一行、且顶格显示，对大小写不敏感。因为任何放在 <em>DOCTYPE</em> 前面的东西，比如批注或 <em>XML</em> 声明，会令 <em>IE9</em> 或更早期的浏览器触发怪异模式（后面的渲染模式会介绍）</p>
<p>文档声明并非一个 <em>HTML</em> 标签。它是一条“信息”，告知浏览器期望的文档类型。</p>
<p>那么说到文档类型，我们首先有必要先了解一下 <em>HTML</em> 的发展历史。如下图所示：</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-07-020539.png" alt="image-20210907100539198" style="zoom:50%;" />



<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-07-020626.png" alt="image-20210907100626110" style="zoom:50%;" />

<p>可以看到，<em>HTML</em> 版本从最开始诞生到最新的 <em>HTML5</em>，中间经历了很多版本。</p>
<p>那不同的版本有啥区别么？当然有区别，比如一个最显著的区别就是支持的 <em>HTML</em> 元素不同。例如：</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-07-021238.png" alt="image-20210907101237957" style="zoom:50%;" />



<blockquote>
<p>更多各版本所支持的不同 <em>HTML</em> 元素可以参阅：<em><a href="https://www.w3school.com.cn/tags/html_ref_dtd.asp">https://www.w3school.com.cn/tags/html_ref_dtd.asp</a></em></p>
</blockquote>
<p>所以，你现在就知道为什么要书写文档声明了。原因是不同版本所支持的 <em>HTML</em> 元素类型是不同的，我需要告诉浏览器以哪一种文档类型方式来解析当前的这个 <em>HTML</em> 文件。</p>
<p>那么，最新的 <em>HTML5</em> 的文档类型倒是很简单，前面我们已经看到了</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>那么稍微老一点的版本，例如 <em>HTML4</em> 或 <em>XHTML</em> 的文档类型声明长啥样呢？</p>
<p>这里我们来看两个。</p>
<p><em><strong>HTML 4.01 Strict</strong></em></p>
<p>该 <em>DTD</em> 包含所有 <em>HTML</em> 元素和属性，但不包括展示性的和弃用的元素（比如 <em>font</em>）。不允许框架集（<em>Framesets</em>）。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//W3C//DTD HTML 4.01//EN&quot;</span> <span class="meta-string">&quot;http://www.w3.org/TR/html4/strict.dtd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><em><strong>HTML 4.01 Transitional</strong></em></p>
<p>该 <em>DTD</em> 包含所有 <em>HTML</em> 元素和属性，包括展示性的和弃用的元素（比如 <em>font</em>）。不允许框架集（<em>Framesets</em>）。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> </span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>更多不同文档类型的声明写法可以参阅：<em><a href="https://www.w3school.com.cn/tags/tag_doctype.asp">https://www.w3school.com.cn/tags/tag_doctype.asp</a></em></p>
</blockquote>
<p>首先，给我们的第一直观感受，就是声明写得很长。</p>
<p>那么为什么会这么长呢？</p>
<p>原因很简单，<em>HTML5</em> 不需要引入 <em>DTD</em> 文件，而其他类型的文档声明是需要引入 <em>DTD</em> 的。</p>
<p>很好，一个新的名词出现了，<em>DTD</em>。</p>
<p>在早期的 <em>HTML</em> 版本，例如 <em>HTML 4.01</em> 中，*&lt;!DOCTYPE&gt;* 声明之所以要引用 <em>DTD</em>，是因为 <em>HTML 4.01</em> 基于 <em>SGML</em>。而 <em>DTD</em> 规定的是标记语言的规则，这样浏览器才能正确地呈现内容。</p>
<p>但是最新的 <em>HTML5</em> 不基于 <em>SGML</em>，所以不需要引用 <em>DTD</em>。</p>
<p>到这里估计有的小伙伴要懵圈了，怎么又冒出来一个 <em>SGML</em> ？？</p>
<p>是的，你没有看错，我们有：<em>SGML、HTML、XML、XHTML、HTML5</em></p>
<p>从这五者的名字中，我们都可以看到 “<em>ML</em>” 这两个字母，所以我们先从 “<em>ML</em>” 说起。</p>
<p>“<em>ML</em>”即 “<em>Markup language</em>(置标语言)”。</p>
<p>根据维基百科对其的解释，“<em>Markup language</em>” 是用标准的标记来解释纯文本文档的内容，从而提供关于文档结构或文档该如何渲染的信息。置标语言的发展可以用下图来表示：</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-07-023423.png" alt="image-20210907103423285" style="zoom:50%;" />



<p><em>GML</em> 是第一代置标语言，使文档能明确将标示和内容分开，所有文件使用同样的标示方法。</p>
<p><em>SGML</em> 在 <em>GML</em> 的基础上进行整理，形成了一套非常严谨的文件描述方法。它的组成包括语法定义，<em>DTD</em>，文件实例三部分。<em>SGML</em> 因太严谨规范达 <em>500</em> 多页，故而不易学、不易用、难以实现，所以在它的基础上又发展出了其他的更易用的置标语言。</p>
<p><em>HTML</em> 抛弃了<em>SGML</em> 复杂庞大的缺点，继承了 <em>SGML</em> 的很多优点。<em>HTML</em> 最大的特点是简单性和跨平台性。它只使用了 <em>SGML</em> 中很少的一部分标记，例如 <em>HTML 4.0</em> 中只定义了 <em>70</em> 余种标记。为了便于在计算机上实现，<em>HTML</em> 规定的标记是固定的，即 <em>HTML</em> 语法是不可扩展的。</p>
<p>随着 <em>Web</em> 应用的不断发展，<em>HTML</em> 的局限性也越来越明显地显现了出来，如 <em>HTML</em> 无法描述数据、可读性差、搜索时间长等。人们又把目光转向 <em>SGML</em>，再次改造 <em>SGML</em> 使之适应现在的网络需求。<em>1998</em> 年 <em>2</em> 月 <em>10</em> 日，<em>W3C</em>(<em>World Wide Web Consortium</em>，万维网联盟)公布 <em>XML 1.0</em> 标准，<em>XML</em> 诞生了。很长一段时间，<em>XML</em> 都作为网络传输的标准数据格式。</p>
<p><em>XHTML</em> 的出现是因为当时的 <em>HTML</em> 语法要求比较松散，这样对网页编写者来说，比较方便，但对于机器来说，语言的语法越松散，处理起来就越困难，对于传统的计算机来说，还有能力兼容松散语法，但对于许多其他设备，比如手机，难度就比较大。因此产生了由 <em>DTD</em> 定义规则，语法要求更加严格的 <em>XHTML</em>。</p>
<blockquote>
<p><em>DTD</em> 教程可以参阅：<em><a href="https://www.w3school.com.cn/dtd/index.asp">https://www.w3school.com.cn/dtd/index.asp</a></em></p>
</blockquote>
<p>最终，<em>HTML5</em> 是 <em>HTML</em> 的第五个修订版，该版本不在基于 <em>SGML</em> 了，所以也就不用再引入 <em>DTD</em> 声明了。</p>
<p><em>HTML5</em> 的出现，其主要的目标是将互联网语义化，以便更好地被人类和机器阅读，并同时提供更好地支持各种媒体的嵌入。</p>
<p>现在国内通常所说的 <em>H5</em> 开发，实际上是 <em>HTML5</em> 与 <em>CSS3</em> 及 <em>ES6</em> 的一个组合，大概可以用以下公式说明：<em>HTML5 ≈ HTML + CSS3 + ES6</em> </p>
<h3 id="渲染模式"><a href="#渲染模式" class="headerlink" title="渲染模式"></a>渲染模式</h3><p>明白了文档类型声明的作用之后，接下来我们还需要看一个东西，那就是渲染模式。</p>
<p>浏览器渲染模式分为 <em>3</em> 种：</p>
<ul>
<li>怪癖模式（混杂模式）[<em>Quirks mode</em>] </li>
<li>严格模式（标准模式） [<em>Standars mode</em>]</li>
<li>几乎标准模式 [<em>Almost standards mode</em>]</li>
</ul>
<blockquote>
<p>之所以出现不同的渲染模式，是由于历史原因造成的。</p>
<p>当年 <em>Netscape4</em>（网景公司早期的浏览器）和 <em>IE4</em>（微软公司早期的浏览器）实现 <em>CSS</em> 机制时，没有遵循 <em>W3C</em> 提出的标准。<em>Netscape4</em> 提供了糟糕的支持，而 <em>IE4</em> 虽然接近标准，但依旧未能完全正确的支持标准。</p>
<p>所以，在 <em>W3C</em> 标准推出以前，浏览器在对页面的渲染上没有统一规范，产生了差异（<em>Quirks mode</em> 或者称为 <em>Compatibility Mode</em>）</p>
<p>为了保障自己的网站在各个浏览器上显示正确，网页开发者们不得不依据各个浏览器自身的规范来使用 <em>CSS</em>，因此大部分网站的 <em>CSS</em> 实现并不符合 <em>W3C</em> 规范的标准。</p>
<p><em>W3C</em> 标准推出后，浏览器渲染页面有了统一的标准（<em>Strict mode</em> 也有叫做 <em>Standars mode</em>）浏览器都开始采纳新标准，但存在一个问题就是如何保证旧的网页还能继续浏览，在标准出来以前，很多页面都是根据旧的渲染方法编写的，如果用的标准来渲染，将导致页面显示异常。</p>
<p>为保持浏览器渲染的兼容性，使以前的页面能够正常浏览，浏览器都保留了旧的渲染方法（如：微软的 <em>IE</em>）。这样浏览器渲染上就产生了 <em>Quircks mode</em> 和 <em>Standars mode</em>，两种渲染方法共存在一个浏览器上。混杂模式服务于旧式规则，而严格模式服务于标准规则。</p>
</blockquote>
<p>对于 <em>HTML</em> 文档来说，浏览器使用文档开头的 <em>DOCTYPE</em> 来决定用怪异模式处理或标准模式处理。</p>
<p>如果文档中没有 <em>DOCTYPE</em> 将触发文档的怪异模式。怪异模式最明显的影响是会触发怪异盒模型。</p>
<p>在  <em>DOCTYPE</em>  声明中，没有使用 <em>DTD</em> 声明或者使用 <em>HTML4</em> 以下的 <em>DTD</em> 声明时，基本所有的浏览器都是使用 <em>Quirks mode</em> 呈现，其他的则使用 <em>Standars mode</em> 解析。</p>
<p><strong>严格模式和怪异模式的部分渲染区别</strong></p>
<ol>
<li>盒模型的高宽包含内边距 <em>padding</em> 和边框 <em>border</em></li>
</ol>
<p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-07-035904.png" alt="img"></p>
<p>在 <em>W3C</em> 标准中，如果设置一个元素的宽度和高度，指的是元素内容的宽度和高度，而在 <em>IE5.5</em> 及以下的浏览器及其他版本的 <em>Quirks</em> 模式下，<em>IE</em> 的宽度和高度还包含了 <em>padding</em> 和 <em>border</em>。</p>
<ol start="2">
<li>可以设置行内元素的高宽</li>
</ol>
<p> 在 <em>standards</em> 模式下，给 <em>span</em> 等行内元素设置 <em>wdith</em> 和 <em>height</em> 都不会生效，而在 <em>Quirks</em> 模式下，则会生效。</p>
<ol start="3">
<li>可设置百分比的高度</li>
</ol>
<p> 在 <em>standards</em> 模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置高度，子元素设置一个百分比的高度是无效的。</p>
<ol start="4">
<li>用 <em>margin:0 auto</em> 设置水平居中在 <em>IE</em> 下会失效</li>
</ol>
<p>使用 <em>margin:0 auto</em> 在 <em>standards</em> 模式下可以使元素水平居中，但在 <em>Quirks</em> 模式下却会失效，<em>Quirks</em> 模式下的解决办法，用 <em>text-align</em> 属性：<em>body{text-align:center};#content{text-align:left}</em></p>
<ol start="5">
<li><p><em>Quirks</em> 模式下设置图片的 <em>padding</em> 会失效</p>
</li>
<li><p><em>Quirks</em> 模式下 <em>Table</em> 中的字体属性不能继承上层的设置</p>
</li>
<li><p><em>Quirks</em> 模式下 <em>white-space:pre</em> 会失效</p>
</li>
</ol>
<blockquote>
<p>更多可以参阅 <em>MDN</em> 上对怪异模式和标准模式的解释：<em><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Quirks_Mode_and_Standards_Mode">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Quirks_Mode_and_Standards_Mode</a></em></p>
</blockquote>
<blockquote>
<p><em>MDN</em> 上还给出了不同模式在不同浏览器下的渲染区别（英文）：<em><a href="https://hsivonen.fi/doctype/">https://hsivonen.fi/doctype/</a></em></p>
</blockquote>
<h3 id="真题解答"><a href="#真题解答" class="headerlink" title="真题解答"></a>真题解答</h3><ul>
<li>什么是<code>&lt;!DOCTYPE&gt;</code>？是否需要在 <em>HTML5</em> 中使用？</li>
</ul>
<blockquote>
<p>它是 <em>HTML</em> 的文档声明，通过它告诉浏览器，使用哪一个 <em>HTML</em> 版本标准解析文档。</p>
<p>在浏览器发展的历史中，<em>HTML</em> 出现过很多个版本，不同版本在元素、属性等书写格式上略有差异，如果不预先告诉浏览器，浏览器就不知道我们的文档标准是什么，在这种情况下，大部分浏览器将开启最大兼容模式来解析网页，我们称之为怪异模式。这不仅会降低解析效率，而且会在解析过程中产生一些难以预知的 <em>bug</em>，所以文档声明是必须的。</p>
<p>而文档声明有多种书写格式，对应不同的 <em>HTML</em> 版本，<code>&lt;!DOCTYPE&gt;</code>这种书写是告诉浏览器，整个文档使用 <em>HTML5</em> 的标准进行解析。</p>
</blockquote>
<ul>
<li>什么是严格模式与混杂模式？</li>
</ul>
<blockquote>
<p><strong>严格模式：</strong>又称标准模式，是指浏览器按照 <em>W3C</em> 标准解析代码。</p>
<p><strong>混杂模式：</strong>又称怪异模式或兼容模式，是指浏览器用自己的方式解析代码。</p>
<p><strong>如何区分：</strong>浏览器解析时到底使用严格模式还是混杂模式，与网页中的 <em>DTD</em> 直接相关。</p>
<ol>
<li>如果文档包含严格的 <em>DOCTYPE</em> ，那么它一般以严格模式呈现。<strong>（严格 <em>DTD</em> ——严格模式）</strong> </li>
<li>包含过渡 <em>DTD</em> 和 <em>URI</em> 的 <em>DOCTYPE</em> ，也以严格模式呈现，但有过渡 <em>DTD</em> 而没有 <em>URI</em> （统一资源标识符，就是声明最后的地址）会导致页面以混杂模式呈现。<strong>（有 <em>URI</em> 的过渡 <em>DTD</em> ——严格模式；没有 <em>URI</em> 的过渡 <em>DTD</em> ——混杂模式）</strong> </li>
<li><em>DOCTYPE</em> 不存在或形式不正确会导致文档以混杂模式呈现。<strong>（<em>DTD</em> 不存在或者格式不正确——混杂模式）</strong></li>
<li><em>HTML5</em> 没有 <em>DTD</em> ，因此也就没有严格模式与混杂模式的区别，<em>HTML5</em> 有相对宽松的语法，实现时，已经尽可能大的实现了向后兼容。<strong>（ <em>HTML5</em> 没有严格和混杂之分）</strong></li>
</ol>
<p><strong>意义：</strong>严格模式与混杂模式存在的意义与其来源密切相关，如果说只存在严格模式，那么许多旧网站必然受到影响，如果只存在混杂模式，那么会回到当时浏览器大战时的混乱，每个浏览器都有自己的解析模式。</p>
</blockquote>
<ul>
<li>列举几条怪异模式中的怪癖行为</li>
</ul>
<blockquote>
<ol>
<li>宽高的算法与 <em>W3C</em> 盒模型不同</li>
<li>在表格中的字体样式不会继承</li>
<li>怪异模式下可以设置行内元素宽高</li>
<li>怪异模式下 <em>white-space:pre</em> 会失效</li>
</ol>
</blockquote>
<h2 id="语义化"><a href="#语义化" class="headerlink" title="语义化"></a>语义化</h2><h3 id="经典真题-1"><a href="#经典真题-1" class="headerlink" title="经典真题"></a>经典真题</h3><ul>
<li>说说对 <em>html</em> 语义化的理解</li>
</ul>
<h3 id="什么是语义元素？"><a href="#什么是语义元素？" class="headerlink" title="什么是语义元素？"></a>什么是语义元素？</h3><p>语义是指对一个词或者句子含义的正确解释。很多 <em>HTML</em> 标签也具有语义的意义，也就是说元素本身传达了关于标签所包含内容类型的一些信息。例如，当浏览器解析到<code>&lt;h1&gt;&lt;/h1&gt;</code>标签时，它将该标签解释为包含这一块内容的最重要的标题。<em>h1</em> 标签的语义就是用它来标识特定网页或部分最重要的标题。</p>
<h3 id="为什么要语义化？"><a href="#为什么要语义化？" class="headerlink" title="为什么要语义化？"></a>为什么要语义化？</h3><ul>
<li>代码结构：使页面没有css的情况下，也能够呈现出很好的内容结构</li>
<li>有利于 <em>SEO</em>： 爬虫依赖标签来确定关键字的权重，因此可以和搜索引擎建立良好的沟通，帮助爬虫抓取更多的有效信息</li>
<li>提升用户体验：例如 <em>title、alt</em> 可以用于解释名称或者解释图片信息，以及 <em>label</em> 标签的灵活运用。</li>
<li>便于团队开发和维护：语义化使得代码更具有可读性，让其他开发人员更加理解你的 <em>html</em> 结构，减少差异化。</li>
<li>方便其他设备解析：如屏幕阅读器、盲人阅读器、移动设备等，以有意义的方式来渲染网页。</li>
</ul>
<h3 id="HTML5-常用的语义元素"><a href="#HTML5-常用的语义元素" class="headerlink" title="HTML5 常用的语义元素"></a><em>HTML5</em> 常用的语义元素</h3><p><em>HTML5</em> 提供了新的语义元素来定义网页的不同部分，它们被称为“切片元素”，如图所示 ：</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-07-062515.png" alt="image-20210907142515375" style="zoom:50%;" />



<ul>
<li><em>header</em>：用于定义页面的头部区域，通常包括网站 <em>logo</em>、主导航、全站链接以及搜索框。</li>
<li><em>nav</em>：定义页面的导航链接部分区域。</li>
<li><em>main</em>：定义文档的主要内容，该内容在文档中应当是独一无二的</li>
<li><em>article</em>：定义页面独立的内容，它可以有自己的 <em>header、footer、sections</em> 等，专注于单个主题的博客文章，报纸文章或网页文章。</li>
<li><em>section</em>：表示文档中的一个区域（或节），比如，内容中的一个专题组。</li>
<li><em>aside</em>：表示一个和其余页面内容几乎无关的部分，被认为是独立于该内容的一部分且可以被单独的拆分出来而不会影响整体。通常表现为侧边栏或嵌入内容。</li>
<li><em>footer</em>：定义最近一个章节内容或者根节点元素的页脚。一个页脚通常包含该章节作者、版权数据或者与文档相关的链接等信息。</li>
</ul>
<p>大约有 <em>100</em> 多个 <em>HTML</em> 语义元素可供选择，以下是常用的语义元素：</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-07-062552.png" alt="image-20210907142551909" style="zoom:50%;" />



<blockquote>
<p>更多的语义化标签可以参阅：<em><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element">https://developer.mozilla.org/en-US/docs/Web/HTML/Element</a></em></p>
</blockquote>
<h3 id="无障碍网页"><a href="#无障碍网页" class="headerlink" title="无障碍网页"></a>无障碍网页</h3><p><em>W3C</em> 在 <em>1997</em> 年发起了一项 <em>WAI</em>（<em>Web Accessibility Initiative</em>）的计划，该计划的目标是提升网站的易用性(<em>accessibility</em>)，而其中有一个很重要的指标，那就是能够被残障人士使用的网站才能称得上一个易用的（易访问的）网站。</p>
<p><em>HTML5</em> 在无障碍方面进行了加强，加入了无障碍属性。</p>
<p>所谓 <em>HTML5</em> 无障碍属性，主要针对的是视觉缺陷，失聪，行动不便的残疾人以及假装残疾的测试人员。尤其像盲人，眼睛看不到，其浏览网页则需要借助辅助设备，如屏幕阅读器，屏幕阅读机可以大声朗读或者输出盲文。</p>
<p>而 <em>HTML5</em> 无障碍属性就是可以让屏幕阅读器准确识别网页中的内容，变化，状态的技术规范，可以让盲人这类用户也能无障碍阅读！</p>
<blockquote>
<p>关于无障碍的更多说明，可以参阅 <em>MDN</em>：<em><a href="https://developer.mozilla.org/zh-CN/docs/Web/Accessibility">https://developer.mozilla.org/zh-CN/docs/Web/Accessibility</a></em></p>
</blockquote>
<p><strong>常见的无障碍属性</strong></p>
<p><em>WAI-ARIA</em> 是 <em>W3C</em> 编写的规范，定义了一组可用于其他元素的 <em>HTML</em> 特性，用于提供额外的语义化以及改善缺乏的可访问性。以下是规范中三个主要的特性：</p>
<ul>
<li>角色：这定义了元素是干什么的。许多「标志性的角色」，其实重复了 <em>HTML5</em> 的结构元素的语义价值。例如 <em>role=”navigation”</em> (<em>nav</em>) 或者 <em>role=”complementary”</em> (<em>aside</em>)。</li>
</ul>
<ul>
<li>属性：我们能通过定义一些属性给元素，让他们具备更多的语义。例如：<em>aria-required=”true”</em> 意味着元素在表单上是必填的。然而 <em>aria-labelledby=”label”</em> 允许在元素上设置一个 <em>ID</em>，用于 <em>labelledby</em> 引用作为屏幕阅读器指定的 <em>label</em> 内容 ，多个也可以。</li>
</ul>
<ul>
<li>状态：用于表达元素当前的条件的特殊属性，例如 *aria-disabled=”true”*，屏幕阅读器就会这个表单禁止输入。状态和属性的差异之处就是：属性在应用的生命周期中不会改变，而状态可以，通常我们用编程的方法改变它，例如 <em>Javascript</em>。</li>
</ul>
<p>关于 <em>WAI-ARIA</em> 属性重要的一点是它不会对 <em>Web</em> 页面有任何影响，除了让更多的信息从浏览器暴露给 <em>accessibility APIs</em> (无障碍 <em>API</em>)，这也是屏幕阅读器这一类软件的信息源。<em>WAI-ARIA</em> 不会影响网页的结构，以及 <em>DOM</em> 等等，尽管这些属性可用于作为 <em>CSS</em> 选择器。</p>
<blockquote>
<p>更多无障碍属性可以参阅：<em><a href="https://developer.mozilla.org/zh-CN/docs/Learn/Accessibility/WAI-ARIA_basics">https://developer.mozilla.org/zh-CN/docs/Learn/Accessibility/WAI-ARIA_basics</a></em></p>
</blockquote>
<h3 id="真题解答-1"><a href="#真题解答-1" class="headerlink" title="真题解答"></a>真题解答</h3><ul>
<li>说说对 <em>html</em> 语义化的理解</li>
</ul>
<blockquote>
<p>语义化的目的主要有以下几点：</p>
<ol>
<li>去掉或者丢失样式的时候能够让页面呈现出清晰的结构</li>
<li>有利于 <em>SEO</em>：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重</li>
<li>方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页</li>
<li>便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循 <em>W3C</em> 标准的团队都遵循这个标准，可以减少差异化。<em>HTML5</em> 中新增加的很多标签，例如：<em>article、nav、header</em> 和 <em>footer</em> 等，就是基于语义化设计原则</li>
</ol>
</blockquote>
<h2 id="W3C-标准组织"><a href="#W3C-标准组织" class="headerlink" title="W3C 标准组织"></a><em>W3C</em> 标准组织</h2><h3 id="经典真题-2"><a href="#经典真题-2" class="headerlink" title="经典真题"></a>经典真题</h3><ul>
<li>对于 <em>WEB</em> 标准以及 <em>W3C</em> 的理解与认识问题</li>
</ul>
<h3 id="什么是-W3C"><a href="#什么是-W3C" class="headerlink" title="什么是 W3C"></a>什么是 <em>W3C</em></h3><ul>
<li>W3C 指万维网联盟（<em>World Wide Web Consortium</em>）</li>
<li>W3C 创建于<em>1994年10月</em></li>
<li>W3C 由 <em>Tim Berners-Lee</em> 创建</li>
<li>W3C 是一个<em>会员组织</em></li>
<li>W3C 的工作是<em>对 web 进行标准化</em></li>
<li>W3C 创建并维护 <em>WWW 标准</em></li>
<li>W3C 标准被称为 <em>W3C 推荐（W3C 规范）</em></li>
</ul>
<h3 id="W3C-是如何创建的？"><a href="#W3C-是如何创建的？" class="headerlink" title="W3C 是如何创建的？"></a><em>W3C</em> 是如何创建的？</h3><p>万维网（<em>World Wide Web</em>）是作为欧洲核子研究组织的一个项目发展起来的，在那里 <em>Tim Berners-Lee</em> 开发出万维网的雏形。<em>Tim Berners-Lee</em> 是万维网的发明人，目前是万维网联盟的主任。</p>
<p><em>W3C</em> 在 <em>1994</em> 年被创建，其创立目的是为了完成麻省理工学院（<em>MIT</em>）与欧洲粒子物理研究所（<em>CERN</em>）之间的协同工作，并得到了美国国防部高级研究计划局（<em>DARPA</em>）和欧洲委员会（<em>European Commission</em>）的支持。</p>
<h3 id="标准化-Web"><a href="#标准化-Web" class="headerlink" title="标准化 Web"></a>标准化 <em>Web</em></h3><p><em>W3C</em> 致力于实现所有的用户都能够对 <em>Web</em> 加以利用（不论其文化教育背景、能力、财力以及其身体残疾）。</p>
<p><em>W3C</em> 同时与其他标准化组织协同工作，比如 <em>Internet</em> 工程工作小组（<em>Internet Engineering Task Force</em>）、无线应用协议（<em>WAP</em>）以及 <em>Unicode</em> 联盟（<em>Unicode Consortium</em>）。</p>
<p><em>W3C</em> 由美国麻省理工学院计算机科学和人工智能实验室 (<em>MIT CSAIL</em>)，总部位于法国的欧洲信息数学研究联盟(<em>ERCIM</em>) 和日本的庆应大学（<em>Keio University</em>）联合运作，并且在世界范围内拥有分支办事处。</p>
<h3 id="W3C-成员"><a href="#W3C-成员" class="headerlink" title="W3C 成员"></a><em>W3C</em> 成员</h3><p>正因为 <em>Web</em> 是如此的重要（不论在其影响范围还是在投资方面），以至于不应由任何一家单独的组织来对它的未来进行控制，因此 <em>W3C</em> 扮演着一个会员组织的角色：</p>
<p>一些知名的会员包括：</p>
<ul>
<li><em>IBM</em></li>
<li><em>Microsoft</em></li>
<li><em>America Online</em></li>
<li><em>Apple</em></li>
<li><em>Adobe</em></li>
<li><em>Macromedia</em></li>
<li><em>Sun Microsystems</em></li>
</ul>
<p><em>W3C</em> 的会员包括了：软件开发商、内容提供商、企业用户、通信公司、研究机构、研究实验室、标准化团体以及政府。</p>
<h3 id="W3C-规范的批准步骤"><a href="#W3C-规范的批准步骤" class="headerlink" title="W3C 规范的批准步骤"></a><em>W3C</em> 规范的批准步骤</h3><p>在 <em>W3C</em> 发布某个新标准的过程中，规范是通过下面的严格程序由一个简单的理念逐步确立为推荐标准的：</p>
<ul>
<li><em>W3C</em> 收到一份提交</li>
<li>由 <em>W3C</em> 发布一份记录</li>
<li>由 <em>W3C</em> 创建一个工作组</li>
<li>由 <em>W3C</em> 发布一份工作草案</li>
<li>由 <em>W3C</em> 发布一份候选的推荐</li>
<li>由 <em>W3C</em> 发布一份被提议的推荐</li>
<li>由 <em>W3C</em> 发布推荐</li>
</ul>
<blockquote>
<p>具体步骤可以参阅：<em><a href="https://www.runoob.com/w3c/w3c-process.html">https://www.runoob.com/w3c/w3c-process.html</a></em></p>
</blockquote>
<h3 id="真题解答-2"><a href="#真题解答-2" class="headerlink" title="真题解答"></a>真题解答</h3><ul>
<li>对于 <em>WEB</em> 标准以及 <em>W3C</em> 的理解与认识问题</li>
</ul>
<blockquote>
<p>任何东西都需要一个标准，有了标准才能够更好的进行交流和推广。不同的标准，得出的便是不同的结果。因此，制定什么样的标准，如何确立标准，至关重要。</p>
<p>正因为有了网页的标准，才能降低开发难度及开发成本，减少各种 <em>BUG</em>、安全问题， 提高网站易用性。</p>
<p>就好比 <em>HTML</em> 在 <em>W3C</em> 组织推出标准之前，不同的浏览器厂商有一套自己的标准，这对于开发人员来讲是痛苦的，所以才会遗留下浏览器的标准模式和怪异模式这个历史问题。</p>
<p><em>W3C</em> 就是一个推出标准的组织，被称之为万维网联盟，<em>W3C</em> 最重要的工作是发展 <em>Web</em> 规范。</p>
</blockquote>
<h2 id="SEO"><a href="#SEO" class="headerlink" title="SEO"></a><em>SEO</em></h2><h3 id="经典真题-3"><a href="#经典真题-3" class="headerlink" title="经典真题"></a>经典真题</h3><ul>
<li>请描述下 <em>SEO</em> 中的 <em>TDK</em>？</li>
</ul>
<h3 id="什么是-SEO？"><a href="#什么是-SEO？" class="headerlink" title="什么是 SEO？"></a>什么是 <em>SEO</em>？</h3><p><em>SEO</em> 由英文 <em>Search Engine Optimization</em> 缩写而来，中文意译为“搜索引擎优化”。</p>
<p>其实叫做针对搜索引擎优化更容易理解。它是指从自然搜索结果获得网站流量的技术和过程，是在了解搜索引擎自然排名机制的基础上，对网站进行内部及外部的调整优化，改进网站在搜索引擎中的关键词自然排名，获得更多流量，从而达成网站销售及品牌建设的目标。</p>
<h3 id="如何进行-SEO-优化工作？"><a href="#如何进行-SEO-优化工作？" class="headerlink" title="如何进行 SEO 优化工作？"></a>如何进行 <em>SEO</em> 优化工作？</h3><p>有的同学第一反应：给钱。</p>
<p>虽然，国内的百度搜索引擎，确实存在给钱就把你排在前面的情况，但是在不给钱的情况下，我们也能够通过一些优化手段来提升页面的权重，从而使我们的页面获取更多流量。</p>
<p>下面就介绍一些常见的 <em>SEO</em> 优化手段。</p>
<p>整个 <em>SEO</em> 工作大致可以分为<strong>内部优化</strong>和<strong>外部优化</strong>。</p>
<h4 id="内部优化"><a href="#内部优化" class="headerlink" title="内部优化"></a>内部优化</h4><h5 id="1-合理的-title、description、keywords"><a href="#1-合理的-title、description、keywords" class="headerlink" title="1. 合理的 title、description、keywords"></a>1. 合理的 <em>title、description、keywords</em></h5><p>这个就是上面经典面试题中出现的 <em>TDK</em>，其实就是这 <em>3</em> 个单词的缩写。</p>
<ul>
<li><p><em>title</em>：浏览器上显示的那些内容，不仅用户能看到，也能被搜索引擎检索到，搜索引擎在抓取网页时，最先读取的就是网页标题，所以 <em>title</em> 是否正确设置极其重要。<em>title</em> 一般不超过 <em>80</em> 个字符，而且词语间要用英文 “-” 隔开，因为计算机只对英语的敏感性较高，对汉语的敏感性不高。</p>
</li>
<li><p><em>description</em>：也就是网页的内容摘要，这是对于一个网页的简要内容概况。<em>description</em> 一般不超过 <em>150</em> 个字符，描述内容要和页面内容相关。</p>
</li>
<li><p><em>keywords</em>：主要作用是告诉搜索引擎本页内容是围绕哪些词展开的。因此 <em>keywords</em> 的每个词都要能在内容中找到相应匹配，才有利于排名。<em>keywords</em> 一般不超过 <em>3</em> 个，每个关键词不宜过长，而且词语间要用英文 “,” 隔开，尽量将重要的关键字靠前放。</p>
</li>
</ul>
<h5 id="2-语义化的-HTML-代码，符合-W3C-规范"><a href="#2-语义化的-HTML-代码，符合-W3C-规范" class="headerlink" title="2. 语义化的 HTML 代码，符合 W3C 规范"></a>2. 语义化的 <em>HTML</em> 代码，符合 <em>W3C</em> 规范</h5><p>语义化代码能够让搜索引擎容易理解网页，即使脱去了 <em>CSS</em> 这一层外衣，整个网页的结构也是清清楚楚的，无论是搜索引擎还是阅读者，都能够很容易的分辨网页的结构。</p>
<p>关于语义化的具体内容，可以参阅《语义化》章节。</p>
<h5 id="3-非装饰性图片必须加-alt"><a href="#3-非装饰性图片必须加-alt" class="headerlink" title="3. 非装饰性图片必须加 alt"></a>3. 非装饰性图片必须加 <em>alt</em></h5><p><em>img</em> 标签的 <em>alt</em> 属性指定了替代文本，用于在图像无法显示或者用户禁用图像显示时，代替图像显示在浏览器中的内容。</p>
<p>例如：<code>&lt;img src=&quot;/xxx.jpg&quot; alt=&quot;海尔官网-双门冰箱&quot; /&gt;</code></p>
<p><em>alt</em> 标签的作用：</p>
<ul>
<li>增强内容相关性：它是可以利用汉字介绍文章内容的，对于一些特定的企业产品，由于视觉的体验，它往往是少文字的。  </li>
<li>提高关键词密度：在操作企业站的时候，我们经常遇到是站点首屏一个大的横幅 <em>banner</em>，几乎占用了首页的大部分页面，为了有效的提高首页核心关键词密度，我们只能利用一切办法增添关键词，比如：在图片的 <em>alt</em> 标签中添加。  </li>
</ul>
<h5 id="4-对于不显示的对象谨慎使用-display-none"><a href="#4-对于不显示的对象谨慎使用-display-none" class="headerlink" title="4. 对于不显示的对象谨慎使用 display:none"></a>4. 对于不显示的对象谨慎使用 <em>display:none</em></h5><p>对于不想显示的文字内容，应当设置 <em>z-index</em> 或设置到浏览器显示器之外。因为搜索引擎会过滤掉 <em>display:none</em> 其中的内容。</p>
<h5 id="5-重要内容-HTML-代码放在最前"><a href="#5-重要内容-HTML-代码放在最前" class="headerlink" title="5. 重要内容 HTML 代码放在最前"></a>5. 重要内容 <em>HTML</em> 代码放在最前</h5><p>索引擎抓取 <em>HTML</em> 顺序是从上到下，所以我们尽量将重要的内容放在前面，保证重要内容一定会被抓取。</p>
<h5 id="6-少用-iframe"><a href="#6-少用-iframe" class="headerlink" title="6. 少用 iframe"></a>6. 少用 <em>iframe</em></h5><p>少用或者尽量不用 <em>iframe</em>，因为搜索引擎不会抓取 <em>iframe</em> 中的内容</p>
<p>优化的细节还有很多，更多细节可以参阅这篇博文：<em><a href="https://blog.csdn.net/yanyihan16/article/details/89209436?utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.control">https://blog.csdn.net/yanyihan16/article/details/89209436?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.control</a></em></p>
<h4 id="外部优化"><a href="#外部优化" class="headerlink" title="外部优化"></a>外部优化</h4><p>外部优化主要是指放友情链接和外链。好的友情链接可以快速的提高网站的权重，高质量的外链，会给你的网站提高源源不断的权重提升。另外，就是要向各大搜索引擎登陆入口提交尚未收录站点。</p>
<h3 id="真题解答-3"><a href="#真题解答-3" class="headerlink" title="真题解答"></a>真题解答</h3><ul>
<li>请描述下 <em>SEO</em> 中的 <em>TDK</em>？</li>
</ul>
<blockquote>
<p>在 <em>SEO</em> 中，所谓的 <em>TDK</em> 其实就是 <em>title、description、keywords</em>。</p>
<ul>
<li><em>title</em>：浏览器上显示的那些内容，不仅用户能看到，也能被搜索引擎检索到，搜索引擎在抓取网页时，最先读取的就是网页标题，所以 <em>title</em> 是否正确设置极其重要。<em>title</em> 一般不超过 <em>80</em> 个字符，而且词语间要用英文 “-” 隔开，因为计算机只对英语的敏感性较高，对汉语的敏感性不高。</li>
<li><em>description</em>：也就是网页的内容摘要，这是对于一个网页的简要内容概况。<em>description</em> 一般不超过 <em>150</em> 个字符，描述内容要和页面内容相关。</li>
<li><em>keywords</em>：主要作用是告诉搜索引擎本页内容是围绕哪些词展开的。因此 <em>keywords</em> 的每个词都要能在内容中找到相应匹配，才有利于排名。<em>keywords</em> 一般不超过 <em>3</em> 个，每个关键词不宜过长，而且词语间要用英文 “,” 隔开，尽量将重要的关键字靠前放。</li>
</ul>
</blockquote>
<h2 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a><em>iframe</em></h2><h3 id="经典真题-4"><a href="#经典真题-4" class="headerlink" title="经典真题"></a>经典真题</h3><ul>
<li><em>iframe</em> 框架有哪些优缺点？</li>
<li><em>iframe</em> 用来干什么的</li>
</ul>
<h3 id="iframe-介绍"><a href="#iframe-介绍" class="headerlink" title="iframe 介绍"></a><em>iframe</em> 介绍</h3><p><em>iframe</em> 称之为嵌入式框架，嵌入式框架可以把一个完整的网页内容嵌入到现有的网页中。</p>
<p>下面是一个 <em>iframe</em> 的简单示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>iframe 示例<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;https://juejin.cn/&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>效果：</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-09-011259.png" alt="image-20210909091258084" style="zoom:50%;" />



<p>可以看到，在当前的网页，又嵌入了一个其他页面。</p>
<p>那么这在实际开发中有啥意义呢？</p>
<p>实际上，在早期的时候， <em>iframe</em> 在开发中用得很多。使用 <em>iframe</em> 可以很方便的制作一个页面的公共部分，例如导航栏。</p>
<p>现在仍然能够找到使用 <em>iframe</em> 的网站（大多是旧的项目）</p>
<p>例如 <em>W3C school</em>：</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-09-015133.png" alt="image-20210909095133166" style="zoom:50%;" />



<p>再比如邮箱：</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-09-014911.png" alt="image-20210909094911187" style="zoom:50%;" />



<p>但是随着 <em>Ajax</em> 的出现，<em>iframe</em> 用得越来越少了。现在在某些特定的场景还能见到，比如模拟窗口，邮箱或者 <em>HTML</em> 在线编辑器等。</p>
<p>究其原因，是因为 <em>iframe</em> 有种种不便，比如一个直观的问题就是 <em>iframe</em> 的自适应高度，这是处理起来比较麻烦的问题，随便百度下都是一大串的代码。</p>
<p>另外还有个重大的缺点，那就是搜索引擎的“爬虫”程序无法解读这种页面，当“爬虫”遇到多个页面嵌套的网页时只看到框架却找不到链接，然后认定此网站是死站点并离开。这对于 <em>SEO</em> 来讲无疑是毁灭性的打击。并且使用大量的 <em>iframe</em> 标签也会稀释你该页面的关键词密度并对其产生影响。</p>
<h3 id="真题解答-4"><a href="#真题解答-4" class="headerlink" title="真题解答"></a>真题解答</h3><ul>
<li><em>iframe</em> 用来干什么的？有哪些优缺点？</li>
</ul>
<blockquote>
<p>参考答案：</p>
<p><em>iframe</em> 也称作嵌入式框架，嵌入式框架和框架网页类似，它可以把一个网页的框架和内容嵌入在现有的网页中。</p>
<p><strong>优点</strong></p>
<ul>
<li>重载页面时不需要重载整个页面，只需要重载页面中的一个框架页(减少了数据的传输，增加了网页下载速度)</li>
<li>方便制作导航栏</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>会产生很多页面，不容易管理</li>
<li>调用外部页面，需要额外调用 <em>CSS</em>，给页面带来额外的请求次数</li>
<li>会阻塞页面的加载，<em>window</em> 的 <em>onload</em> 事件需要在所有 <em>iframe</em> 加载完毕后(包含里面的元素)才会触发</li>
<li>浏览器的后退按钮无效</li>
<li>无法被一些搜索引擎索引到</li>
<li>多数小型的移动设备（<em>PDA</em> 手机）无法完全显示框架</li>
</ul>
<p>由于上面诸多缺点，因此不符合标准网页设计的理念，已经被标准网页设计抛弃，目前框架的所有优点完全可以使用 <em>Ajax</em> 实现，因此已经没有必要使用 <em>iframe</em> 框架了。</p>
</blockquote>
<h2 id="微格式"><a href="#微格式" class="headerlink" title="微格式"></a>微格式</h2><h3 id="经典真题-5"><a href="#经典真题-5" class="headerlink" title="经典真题"></a>经典真题</h3><ul>
<li>知道什么是微格式吗？谈谈理解。在前端构建中应该考虑微格式吗？</li>
</ul>
<h3 id="微格式介绍"><a href="#微格式介绍" class="headerlink" title="微格式介绍"></a>微格式介绍</h3><p>所谓微格式，是建立在已有的、被广泛采用的标准基础之上的一组简单的、开放的数据格式。</p>
<p>具体表现是把语义嵌入到 <em>HTML</em> 中，以便有助于分离式开发，并通过制定一些简单的约定，来兼顾 <em>HTML</em> 文档的人机可读性，相当于对 <em>Web</em> 网页进行了语义注解。</p>
<p><em>talk is cheap，show me code</em></p>
<p>以前我们是这样写一个链接到首页的代码的：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">”http://www.bbon.cn”</span>&gt;</span>Web Design Blog<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>而现在我们要为这个代码元素 <em>a</em> 加上 <em>rel</em> 属性：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">”http://www.bbon.cn“</span> <span class="attr">rel</span>=<span class="string">”homepage”</span>&gt;</span>Web Design Blog<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>通过上面的代码，我们可以发现，多了一个 <em>rel</em> 属性。这个 <em>rel=”home”</em> 属性显示链接的目标页面是该网站的首页。</p>
<p>通过为已有的链接元素添加语义化属性，就为这个链接添加了具体的结构和意义。</p>
<p>就这？</p>
<p><em>No、No、No</em>，我们再去微格式的官网瞅一瞅：<em><a href="https://microformats.org/">https://microformats.org/</a></em></p>
<p>官网对微格式是这么介绍的：</p>
<blockquote>
<p><em>Microformats are based on simple markup conventions that enable you to add meaningful structure to your web content.</em></p>
<p>微格式基于简单的标记约定，使您能够向web内容添加有意义的结构。</p>
<p><em>One of the key principles of microformats, is to privilege human readable content. This means that you should think first and foremost of your content design being readable and accessible to web viewers.</em> </p>
<p>微格式的一个关键原则是赋予人类可读内容特权。这意味着您应该首先考虑内容设计的可读性和可访问性。</p>
<p><em>Using the most appropriate HTML elements and applying structured class names to your markup enables you to produce content that can be clearly understood by a human audience and also used in a structured way by automated programs and other online tools.</em> </p>
<p>通过使用最合适的HTML元素并将结构化类名应用到标记中，您可以生成人类观众可以清楚理解的内容，并通过自动化程序和其他在线工具以结构化方式使用这些内容。</p>
<p><em>But the point is that you shouldn’t have to go out of your way to produce such machine friendly markup - microformats make it easy to integrate this greater degree of structure into your websites, without the overhead of having to learn complicated new languages or formats.</em></p>
<p>但关键是，你不应该不遗余力地制作这样的机器友好型标记——微格式可以轻松地将这种更高程度的结构集成到你的网站中，而无需学习复杂的新语言或格式。</p>
</blockquote>
<p>正如前面所介绍的，微格式就是为了兼顾 <em>HTML</em> 文档的人机可读性，在标签中添加的语义注解。</p>
<p>那好，那么我们以后书写所有的 <em>HTML</em> 代码，都要这样书写注解么？</p>
<p>并不是，否则人都傻了。微格式一般用于标记人员、组织、事件、地点、博客帖子、产品、评论、简历、食谱等的 <em>HTML</em>。</p>
<p>例如：</p>
<blockquote>
<p><em>Mark-up your contact info with h-card, link to other profiles with rel=”me”</em></p>
<p>使用 <em>h-card</em> 标记您的联系信息，使用 <em>rel=“me”</em> 链接到其他个人资料</p>
<p><em>Mark-up your blog with h-entry.</em></p>
<p>用 <em>h-entry</em> 标记你的博客。</p>
</blockquote>
<p>这里我们以  <em>h-card</em> 为例。</p>
<p><em>h-card</em> 是一种微格式，用来发布个人，公司，组织，地点等详细的联系信息。 它可以使分析器（比如其他网站，<em>Firefox</em> 的 <em>Operator</em> 插件）获得详细的信息，并通过别的网站或者地图工具进行显示，或者载入到地址簿等其他程序。</p>
<p>例如，没有加入 <em>h-card</em> 微格式时，我们的 <em>HTML</em> 结构如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>Joe Doe<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>The Example Company<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>604-555-1234<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://example.com/&quot;</span>&gt;</span>http://example.com/<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>加入微格式后，成为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;vcard&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;fn&quot;</span>&gt;</span>Joe Doe<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;org&quot;</span>&gt;</span>The Example Company<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tel&quot;</span>&gt;</span>604-555-1234<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;url&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://example.com/&quot;</span>&gt;</span>http://example.com/<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里，正式名称（<em>class=”fn”</em>），组织（<em>class=”org”</em>），电话号码（<em>class=”tel”</em>）和 <em>url</em>（<em>class=”url”</em>）分别用相应的 <em>class</em> 标示。</p>
<p>同时，所有内容都包含在 <em>class=”vcard”</em> 里。</p>
<p>再例如，我们用一个维基媒体基金会的联系方式，来作为 <em>h-card</em> 微格式实例。</p>
<p>加入  <em>h-card</em> 微格式之前的信息内容如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Wikimedia Foundation Inc.</span><br><span class="line">200 2nd Ave. South #358</span><br><span class="line">St. Petersburg, FL 33701-4313</span><br><span class="line">USA</span><br><span class="line">Phone: +1-727-231-0101</span><br><span class="line">Email: info@wikimedia.org</span><br><span class="line">Fax: +1-727-258-0207</span><br></pre></td></tr></table></figure>

<p>加入微格式后，成为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;vcard&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;fn org&quot;</span>&gt;</span>Wikimedia Foundation Inc.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;adr&quot;</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;street-address&quot;</span>&gt;</span>200 2nd Ave. South #358<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;locality&quot;</span>&gt;</span>St. Petersburg<span class="tag">&lt;/<span class="name">span</span>&gt;</span>,</span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;region&quot;</span>&gt;</span>FL<span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;postal-code&quot;</span>&gt;</span>33701-4313<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;country-name&quot;</span>&gt;</span>USA<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>Phone: <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;tel&quot;</span>&gt;</span>+1-727-231-0101<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>Email: <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;email&quot;</span>&gt;</span>info@wikimedia.org<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;tel&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;type&quot;</span>&gt;</span>Fax<span class="tag">&lt;/<span class="name">span</span>&gt;</span>:</span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;value&quot;</span>&gt;</span>+1-727-258-0207<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，正式名称（<em>class=”fn”</em>）和组织（<em>class=”org”</em>）写在了一个属性中，表示这是一个组织，而不是个人。</p>
<p>这个时候，有的小伙伴就要提问了，这些 <em>h-card</em> 里面的属性名是固定的么？</p>
<p>没错，常用的  <em>h-card</em>  属性还包括：<em>bday</em>（生日）、<em>email</em>（邮箱）、<em>tel</em>（电话）、<em>nickname</em>（昵称）等。</p>
<p>目前已具备完整规范的微格式还包括：<em>hCard、hCalendar、XOXO、XFN、VoteLinks</em> 和 <em>3</em> 个 “rel-” 的微格式：<em>rel- license、rel-nofollow</em> 和 <em>rel-tag</em>。</p>
<p>至于每一种微格式的规范（里面有哪些属性）是什么，我们可以在官网进行查阅。</p>
<p>例如：  <em>h-card</em>  的规范就可以参阅：<em><a href="https://microformats.org/wiki/h-card">https://microformats.org/wiki/h-card</a></em></p>
<h3 id="真题解答-5"><a href="#真题解答-5" class="headerlink" title="真题解答"></a>真题解答</h3><ul>
<li>知道什么是微格式吗？谈谈理解。在前端构建中应该考虑微格式吗？</li>
</ul>
<blockquote>
<p>参考答案：</p>
<p>所谓微格式，是建立在已有的、被广泛采用的标准基础之上的一组简单的、开放的数据格式。</p>
<p>具体表现是把语义嵌入到 <em>HTML</em> 中，以便有助于分离式开发，并通过制定一些简单的约定，来兼顾 <em>HTML</em> 文档的人机可读性，相当于对 <em>Web</em> 网页进行了语义注解。</p>
<p>采用微格式的 <em>Web</em> 页面，在 <em>HTML</em> 文档中给一些标签增加一些属性，这些属性对信息的语义结构进行注解，有助于处理 <em>HTML</em> 文档的软件，更好的理解该 <em>HTML</em> 文档。</p>
<p><strong>在前端构建中微格式的意义</strong></p>
<p>微格式按照某种已有的被广泛应用的标准，通过对内容块的语义标记，可以让外部应用程序、聚合程序和搜索引擎能够做以下事情：</p>
<ol>
<li>在爬取 <em>Web</em> 内容时，能够更为准确地识别内容块的语义；</li>
<li>对内容进行操作，包括提供访问、校对，还可以将其转化成其他的相关格式，提供给外部程序和Web服务使用。</li>
</ol>
<p>总结： 微格式可以对网站进行 <em>SEO</em> 优化，如果需要可以考虑。</p>
</blockquote>
<h2 id="替换元素"><a href="#替换元素" class="headerlink" title="替换元素"></a>替换元素</h2><h3 id="经典真题-6"><a href="#经典真题-6" class="headerlink" title="经典真题"></a>经典真题</h3><ul>
<li>什么是可替换元素，什么是非可替换元素，它们各自有什么特点？</li>
</ul>
<h3 id="什么是替换元素"><a href="#什么是替换元素" class="headerlink" title="什么是替换元素"></a>什么是替换元素</h3><p>所谓可替换元素（<em>replaced element</em>），是指一些展现效果不由 <em>CSS</em> 来控制的元素。这些元素是一种外部对象，它们外观的渲染，是独立于 <em>CSS</em> 的。</p>
<p>简单来说，它们的内容不受当前文档的样式的影响。<em>CSS</em> 可以影响可替换元素的位置，但不会影响到可替换元素自身的内容。某些可替换元素，例如 <code>&lt;iframe&gt;</code> 元素，可能具有自己的样式表，但它们不会继承父文档的样式。</p>
<p>与替换元素相对应的，就是非替换元素，顾名思义就是那些样式完全由 <em>CSS</em> 来控制的元素，例如 <em>p，h1～h6</em> 等。</p>
<blockquote>
<p>更多可替换元素内容可以参阅 <em>MDN</em>：<em><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Replaced_element">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Replaced_element</a></em></p>
</blockquote>
<h3 id="常见的替换元素"><a href="#常见的替换元素" class="headerlink" title="常见的替换元素"></a>常见的替换元素</h3><ul>
<li>图片标签 <em>img</em></li>
<li>内联框架 <em>iframe</em></li>
<li>音频视频标签</li>
</ul>
<h3 id="真题解答-6"><a href="#真题解答-6" class="headerlink" title="真题解答"></a>真题解答</h3><ul>
<li>什么是可替换元素，什么是非可替换元素，它们各自有什么特点？</li>
</ul>
<blockquote>
<p>可替换元素是指这样一种元素，它在页面中的大部分展现效果不由 <em>CSS</em> 决定。</p>
<p>比如 <em>img</em> 元素就是一个可替换元素，它在页面中显示出的效果主要取决于你连接的是什么图片，图片是什么它就展示什么，<em>CSS</em> 虽然可以控制图片的尺寸位置，但永远无法控制图片本身。</p>
<p>再比如，<em>select</em> 元素也是一个典型的可替换元素，它在页面上呈现的是用户操作系统上的下拉列表样式，因此，它的展现效果是由操作系统决定的。所以，同一个 <em>select</em> 元素，放到不同操作系统的电脑上会呈现不同的外观。</p>
<p><em>img、video、audio</em>、大部分表单元素都属于可替换元素。</p>
<p>非可替换元素就是指的普通元素，它具体在页面上呈现什么，完全由 <em>CSS</em> 来决定。</p>
</blockquote>
<h2 id="页面可见性"><a href="#页面可见性" class="headerlink" title="页面可见性"></a>页面可见性</h2><h3 id="经典真题-7"><a href="#经典真题-7" class="headerlink" title="经典真题"></a>经典真题</h3><ul>
<li>页面可见性（<em>Page Visibility</em>）<em>API</em> 可以有哪些用途？</li>
</ul>
<h3 id="页面可见性介绍"><a href="#页面可见性介绍" class="headerlink" title="页面可见性介绍"></a>页面可见性介绍</h3><p>长期以来我们一直缺少一个判断用户是否正在浏览某个指定标签页的方法。</p>
<p>用户是否去看别的网站了？他们切换回来了么？</p>
<p>现在，<em>HTML5</em> 里页面可见性接口就提供给了程序员一个方法，让他们使用 <em>visibilitychange</em> 页面事件来判断当前页面可见性的状态，并针对性的执行某些任务。同时还有新的 <em>document.hidden</em> 属性可以使用。</p>
<p>常用的 <em>API</em> 如下：</p>
<ul>
<li><em><strong>document.hidden</strong></em>：这个新出现的 <em>document.hidden</em> 属性，它显示页面是否为用户当前观看的页面，值为 <em>ture</em> 或 <em>false</em>。</li>
</ul>
<ul>
<li><em><strong>document.visibilityState</strong></em>：<em>visibilityState</em> 的值要么是 <em>visible</em> ，表明页面为浏览器当前激活 <em>tab</em>，而且窗口不是最小化状态；要么是 <em>hidden</em> ，表示页面不是当前激活 <em>tab</em> 页面，或者窗口最小化了；或者 <em>prerender</em> ，表示页面在重新生成，对用户不可见。</li>
</ul>
<ul>
<li><em><strong>visibilitychange</strong></em> 事件：监听页面可见性变化事件</li>
</ul>
<p>下面是一个页面可见性的具体示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>页面可见性示例<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.addEventListener(<span class="string">&quot;visibilitychange&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span>(<span class="built_in">document</span>.visibilityState === <span class="string">&quot;hidden&quot;</span>)&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.title = <span class="string">&quot;小样去哪儿了？快回来&quot;</span></span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span>(<span class="built_in">document</span>.visibilityState === <span class="string">&quot;visible&quot;</span>)&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.title = <span class="string">&quot;页面可见性示例&quot;</span></span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;);</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>更多有关页面可见性的内容可以参阅 <em>MDN</em>：<em><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Page_Visibility_API">https://developer.mozilla.org/zh-CN/docs/Web/API/Page_Visibility_API</a></em></p>
</blockquote>
<h3 id="真题解答-7"><a href="#真题解答-7" class="headerlink" title="真题解答"></a>真题解答</h3><ul>
<li>页面可见性（<em>Page Visibility</em>）<em>API</em> 可以有哪些用途？</li>
</ul>
<blockquote>
<p>所谓页面可见性，就是获取当前页面的可见状态。因为对于用户来讲可以打开好多标签页面来回切换，然而始终只有一个页面处于显示状态。所以我们可以通过页面可见性（<em>Page Visibility</em>）<em>API</em> 来判断当前页面是显示状态还是隐藏状态。</p>
<p>常用的 <em>API</em> 有三个，<em>document.hidden</em> 返回一个布尔值，如果是 <em>true</em>，表示页面可见，<em>false</em> 则表示页面隐藏。不同页面之间来回切换，会触发 <em>visibilitychange</em> 事件，还有一个 <em>document.visibilityState</em>，表示页面所处的状态。</p>
<p>常见的用途：</p>
<ul>
<li>网站有图片轮播效果，只有在用户观看轮播的时候，才会自动展示下一张幻灯片。</li>
<li>显示信息仪表盘的应用程序不希望在页面不可见时轮询服务器进行更新。</li>
<li>页面想要检测是否正在渲染，以便可以准确的计算网页浏览量</li>
<li>当设备进入待机模式时，网站想要关闭设备声音（用户按下电源键关闭屏幕）</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>面试题</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>面试题</tag>
        <tag>HTMl</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题CSS面试题汇总一</title>
    <url>/135xyq.github.io/2022/04/23/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98-CSS-%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B8%80/</url>
    <content><![CDATA[<h1 id="CSS-面试题汇总"><a href="#CSS-面试题汇总" class="headerlink" title="CSS 面试题汇总"></a><em>CSS</em> 面试题汇总</h1><h3 id="1-介绍下-BFC-及其应用"><a href="#1-介绍下-BFC-及其应用" class="headerlink" title="1.  介绍下 BFC 及其应用"></a>1.  介绍下 <em>BFC</em> 及其应用</h3><blockquote>
<p>参考答案：</p>
<p>参考答案：</p>
<p>所谓 <em>BFC</em>，指的是一个独立的布局环境，<em>BFC</em> 内部的元素布局与外部互不影响。</p>
<p>触发 <em>BFC</em> 的方式有很多，常见的有：</p>
<ul>
<li>设置浮动</li>
<li><em>overflow</em> 设置为 <em>auto、scroll、hidden</em></li>
<li><em>positon</em> 设置为 <em>absolute、fixed</em></li>
</ul>
<p>常见的 <em>BFC</em> 应用有：</p>
<ul>
<li>解决浮动元素令父元素高度坍塌的问题</li>
<li>解决非浮动元素被浮动元素覆盖问题</li>
<li>解决外边距垂直方向重合的问题</li>
</ul>
</blockquote>
<h3 id="2-介绍下-BFC、IFC、GFC-和-FFC"><a href="#2-介绍下-BFC、IFC、GFC-和-FFC" class="headerlink" title="2. 介绍下 BFC、IFC、GFC 和 FFC"></a>2. 介绍下 <em>BFC、IFC、GFC</em> 和 <em>FFC</em></h3><blockquote>
<p>参考答案：</p>
<ul>
<li><em>BFC</em>：块级格式上下文，指的是一个独立的布局环境，<em>BFC</em> 内部的元素布局与外部互不影响。</li>
<li><em>IFC</em>：行内格式化上下文，将一块区域以行内元素的形式来格式化。</li>
<li><em>GFC</em>：网格布局格式化上下文，将一块区域以 <em>grid</em> 网格的形式来格式化</li>
<li><em>FFC</em>：弹性格式化上下文，将一块区域以弹性盒的形式来格式化</li>
</ul>
</blockquote>
<h3 id="3-flex-布局如何使用？"><a href="#3-flex-布局如何使用？" class="headerlink" title="3. flex 布局如何使用？"></a>3. <em>flex</em> 布局如何使用？</h3><blockquote>
<p>参考答案：</p>
<p>flex 是 Flexible Box 的缩写，意为”弹性布局”。指定容器display: flex即可。</p>
<p>容器有以下属性：flex-direction，flex-wrap，flex-flow，justify-content，align-items，align-content。</p>
<ul>
<li>flex-direction属性决定主轴的方向；</li>
<li>flex-wrap属性定义，如果一条轴线排不下，如何换行；</li>
<li>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap；</li>
<li>justify-content属性定义了项目在主轴上的对齐方式。</li>
<li>align-items属性定义项目在交叉轴上如何对齐。</li>
<li>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</li>
</ul>
<p>项目（子元素）也有一些属性：order，flex-grow，flex-shrink，flex-basis，flex，align-self。</p>
<ul>
<li>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</li>
<li>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</li>
<li>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</li>
<li>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。</li>
<li>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</li>
<li>align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。默认值为 <em>auto</em>，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</li>
</ul>
</blockquote>
<h3 id="4-怎么让一个-div-水平垂直居中"><a href="#4-怎么让一个-div-水平垂直居中" class="headerlink" title="4. 怎么让一个 div 水平垂直居中"></a>4. 怎么让一个 <em>div</em> 水平垂直居中</h3><blockquote>
<p>参考答案：</p>
<p>水平垂直居中有好多种实现方式，主要就分为两类不定宽高和定宽高 以在 <em>body</em> 下插入一个 <em>div</em> 为例</p>
<p><strong>定宽高</strong> </p>
<p>使用定位 + <em>margin</em></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">element.style &#123;</span><br><span class="line"> <span class="attr">position</span>: absolute;</span><br><span class="line"> left: <span class="number">50</span>%;</span><br><span class="line"> top: <span class="number">50</span>%;</span><br><span class="line"> margin-left: -250px;</span><br><span class="line"> margin-top: -250px;</span><br><span class="line"> width: 500px;</span><br><span class="line"> height: 500px;</span><br><span class="line"> background: yellow;</span><br><span class="line"> z-index: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用定位 + <em>transfrom</em></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">element.style &#123;</span><br><span class="line"> <span class="attr">position</span>: absolute;</span><br><span class="line"> left: <span class="number">50</span>%;</span><br><span class="line"> top: <span class="number">50</span>%;</span><br><span class="line"> width: 500px;</span><br><span class="line"> height: 500px;</span><br><span class="line"> background: yellow;</span><br><span class="line"> z-index: <span class="number">1</span>;</span><br><span class="line"> transform: translate3d(-<span class="number">50</span>%,-<span class="number">50</span>%,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>不定宽高</strong></p>
<p>不定宽高的方法基本都适用于定宽高的情况 这里把 <em>div</em> 的宽高按照内容展开，使用定位 + <em>transform</em> 同样是适用的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">element.style &#123;</span><br><span class="line"> <span class="attr">position</span>: absolute;</span><br><span class="line"> left: <span class="number">50</span>%;</span><br><span class="line"> top: <span class="number">50</span>%;</span><br><span class="line"> background: yellow;</span><br><span class="line"> z-index: <span class="number">1</span>;</span><br><span class="line"> transform: translate3d(-<span class="number">50</span>%,-<span class="number">50</span>%,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="5-分析比较-opacity-0、visibility-hidden、display-none-优劣和适用场景。"><a href="#5-分析比较-opacity-0、visibility-hidden、display-none-优劣和适用场景。" class="headerlink" title="5. 分析比较 opacity: 0、visibility: hidden、display: none 优劣和适用场景。"></a>5. 分析比较 <em>opacity: 0、visibility: hidden、display: none</em> 优劣和适用场景。</h3><blockquote>
<p>参考答案：</p>
<ul>
<li><p>结构： display:none: 会让元素完全从渲染树中消失，渲染的时候不占据任何空间, 不能点击， visibility: hidden:不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，不能点击 opacity: 0: 不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，可以点击</p>
</li>
<li><p>继承： display: none和opacity: 0：是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示。 visibility: hidden：是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显式。</p>
</li>
<li><p>性能： displaynone : 修改元素会造成文档回流,读屏器不会读取display: none元素内容，性能消耗较大 visibility:hidden: 修改元素只会造成本元素的重绘,性能消耗较少读屏器读取visibility: hidden元素内容 opacity: 0 ： 修改元素会造成重绘，性能消耗较少</p>
</li>
</ul>
</blockquote>
<h3 id="6-已知如下代码，如何修改才能让图片宽度为-300px-？注意下面代码不可修改。"><a href="#6-已知如下代码，如何修改才能让图片宽度为-300px-？注意下面代码不可修改。" class="headerlink" title="6. 已知如下代码，如何修改才能让图片宽度为 300px ？注意下面代码不可修改。"></a>6. 已知如下代码，如何修改才能让图片宽度为 <em>300px</em> ？注意下面代码不可修改。</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;img src=<span class="string">&quot;1.jpg&quot;</span> style=<span class="string">&quot;width:480px!important;”&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考答案：</p>
<p><strong>CSS 方法</strong> </p>
<ul>
<li><em>max-width:300px;</em> 覆盖其样式</li>
<li><em>transform: scale(0.625)</em> 按比例缩放图片； </li>
<li>利用 <em>CSS</em> 动画的样式优先级高于 <em>!important</em> 的特性</li>
</ul>
<p><strong>JS 方法</strong> </p>
<ul>
<li><em>document.getElementsByTagName(“img”)[0].setAttribute(“style”,”width:300px!important;”)</em></li>
</ul>
</blockquote>
<h3 id="7-如何用-css-或-js-实现多行文本溢出省略效果，考虑兼容性"><a href="#7-如何用-css-或-js-实现多行文本溢出省略效果，考虑兼容性" class="headerlink" title="7. 如何用 css 或 js 实现多行文本溢出省略效果，考虑兼容性"></a>7. 如何用 <em>css</em> 或 <em>js</em> 实现多行文本溢出省略效果，考虑兼容性</h3><blockquote>
<p>参考答案：</p>
<p>CSS 实现方式</p>
<p>单行：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">overflow</span>: hidden;</span><br><span class="line"><span class="attribute">text-overflow</span>:ellipsis;</span><br><span class="line"><span class="attribute">white-space</span>: nowrap;</span><br></pre></td></tr></table></figure>

<p>多行：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">display</span>: -webkit-box;</span><br><span class="line">-webkit-box-orient: vertical;</span><br><span class="line">-webkit-line-clamp: <span class="number">3</span>; //行数</span><br><span class="line"><span class="attribute">overflow</span>: hidden;</span><br></pre></td></tr></table></figure>

<p>兼容：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">position</span>: relative; <span class="attribute">line-height</span>: <span class="number">20px</span>; <span class="attribute">max-height</span>: <span class="number">40px</span>;<span class="attribute">overflow</span>: hidden;&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::after</span>&#123;<span class="attribute">content</span>: <span class="string">&quot;...&quot;</span>; <span class="attribute">position</span>: absolute; <span class="attribute">bottom</span>: <span class="number">0</span>; <span class="attribute">right</span>: <span class="number">0</span>; <span class="attribute">padding-left</span>: <span class="number">40px</span>;</span><br><span class="line"><span class="attribute">background</span>: <span class="built_in">-webkit-linear-gradient</span>(left, transparent, <span class="number">#fff</span> <span class="number">55%</span>);</span><br><span class="line"><span class="attribute">background</span>: <span class="built_in">-o-linear-gradient</span>(right, transparent, <span class="number">#fff</span> <span class="number">55%</span>);</span><br><span class="line"><span class="attribute">background</span>: <span class="built_in">-moz-linear-gradient</span>(right, transparent, <span class="number">#fff</span> <span class="number">55%</span>);</span><br><span class="line"><span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(to right, transparent, <span class="number">#fff</span> <span class="number">55%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JS 实现方式：</p>
<ul>
<li>使用split + 正则表达式将单词与单个文字切割出来存入words</li>
<li>加上 ‘…’</li>
<li>判断scrollHeight与clientHeight，超出的话就从words中pop一个出来</li>
</ul>
</blockquote>
<h3 id="8-居中为什么要使用-transform（为什么不使用-marginLeft-Top）（阿里）"><a href="#8-居中为什么要使用-transform（为什么不使用-marginLeft-Top）（阿里）" class="headerlink" title="8. 居中为什么要使用 transform（为什么不使用 marginLeft/Top）（阿里）"></a>8. 居中为什么要使用 <em>transform</em>（为什么不使用 <em>marginLeft/Top</em>）（阿里）</h3><blockquote>
<p>参考答案：</p>
<p>transform 属于合成属性（composite property），对合成属性进行 transition/animation 动画将会创建一个合成层（composite layer），这使得被动画元素在一个独立的层中进行动画。通常情况下，浏览器会将一个层的内容先绘制进一个位图中，然后再作为纹理（texture）上传到 GPU，只要该层的内容不发生改变，就没必要进行重绘（repaint），浏览器会通过重新复合（recomposite）来形成一个新的帧。</p>
<p>top/left属于布局属性，该属性的变化会导致重排（reflow/relayout），所谓重排即指对这些节点以及受这些节点影响的其它节点，进行CSS计算-&gt;布局-&gt;重绘过程，浏览器需要为整个层进行重绘并重新上传到 GPU，造成了极大的性能开销。</p>
</blockquote>
<h3 id="9-介绍下粘性布局（sticky）（网易）"><a href="#9-介绍下粘性布局（sticky）（网易）" class="headerlink" title="9. 介绍下粘性布局（sticky）（网易）"></a>9. 介绍下粘性布局（<em>sticky</em>）（网易）</h3><blockquote>
<p>参考答案：</p>
<p>position 中的 sticky 值是 CSS3 新增的，设置了 sticky 值后，在屏幕范围（viewport）时该元素的位置并不受到定位影响（设置是top、left等属性无效），当该元素的位置将要移出偏移范围时，定位又会变成fixed，根据设置的left、top等属性成固定位置的效果。</p>
<p>sticky 属性值有以下几个特点：</p>
<ul>
<li>该元素并不脱离文档流，仍然保留元素原本在文档流中的位置。</li>
<li>当元素在容器中被滚动超过指定的偏移值时，元素在容器内固定在指定位置。亦即如果你设置了top: 50px，那么在sticky元素到达距离相对定位的元素顶部50px的位置时固定，不再向上移动。</li>
<li>元素固定的相对偏移是相对于离它最近的具有滚动框的祖先元素，如果祖先元素都不可以滚动，那么是相对于viewport来计算元素的偏移量</li>
</ul>
</blockquote>
<h3 id="10-说出-space-between-和-space-around-的区别？（携程）"><a href="#10-说出-space-between-和-space-around-的区别？（携程）" class="headerlink" title="10. 说出 space-between 和 space-around 的区别？（携程）"></a>10. 说出 <em>space-between</em> 和 <em>space-around</em> 的区别？（携程）</h3><blockquote>
<p>参考答案：</p>
<p>这个是 <em>flex</em> 布局的内容，其实就是一个边距的区别，按水平布局来说，<code>space-between</code>是两端对齐，在左右两侧没有边距，而<code>space-around</code>是每个 子项目左右方向的 margin 相等，所以两个item中间的间距会比较大。</p>
<p>如图所示：</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-11-03-010805.png" alt="image-20210816161354713" style="zoom:50%;" />
</blockquote>
<h3 id="11-CSS3-中-transition-和-animation-的属性分别有哪些（哔哩哔哩）"><a href="#11-CSS3-中-transition-和-animation-的属性分别有哪些（哔哩哔哩）" class="headerlink" title="11. CSS3 中 transition 和 animation 的属性分别有哪些（哔哩哔哩）"></a>11. <em>CSS3</em> 中 <em>transition</em> 和 <em>animation</em> 的属性分别有哪些（哔哩哔哩）</h3><blockquote>
<p>参考答案：</p>
<p><em>transition</em> 过渡动画：</p>
<ul>
<li><em>transition-property</em>：指定过渡的 <em>CSS</em> 属性</li>
<li><em>transition-duration</em>：指定过渡所需的完成时间</li>
<li><em>transition-timing-function</em>：指定过渡函数</li>
<li><em>transition-delay</em>：指定过渡的延迟时间</li>
</ul>
<p><em>animation</em> 关键帧动画：</p>
<ul>
<li><em>animation-name</em>：指定要绑定到选择器的关键帧的名称</li>
<li><em>animation-duration</em>：动画指定需要多少秒或毫秒完成</li>
<li><em>animation-timing-function</em>：设置动画将如何完成一个周期</li>
<li><em>animation-delay</em>：设置动画在启动前的延迟间隔</li>
<li><em>animation-iteration-count</em>：定义动画的播放次数</li>
<li><em>animation-direction</em>：指定是否应该轮流反向播放动画</li>
<li><em>animation-fill-mode</em>：规定当动画不播放时（当动画完成时，或当动画有一个延迟未开始播放时），要应用到元素的样式</li>
<li><em>animation-play-state</em>：指定动画是否正在运行或已暂停</li>
</ul>
</blockquote>
<h3 id="12-隐藏页面中的某个元素的方法有哪些？"><a href="#12-隐藏页面中的某个元素的方法有哪些？" class="headerlink" title="12. 隐藏页面中的某个元素的方法有哪些？"></a>12. 隐藏页面中的某个元素的方法有哪些？</h3><blockquote>
<p>参考答案：</p>
<ol>
<li>隐藏类型</li>
</ol>
<p>屏幕并不是唯一的输出机制，比如说屏幕上看不见的元素（隐藏的元素），其中一些依然能够被读屏软件阅读出来（因为读屏软件依赖于可访问性树来阐述）。为了消除它们之间的歧义，我们将其归为三大类：</p>
<ul>
<li>完全隐藏：元素从渲染树中消失，不占据空间。</li>
<li>视觉上的隐藏：屏幕中不可见，占据空间。</li>
<li>语义上的隐藏：读屏软件不可读，但正常占据空。</li>
</ul>
<p><strong>完全隐藏</strong></p>
<p>(1) display 属性</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">display</span>: none;</span><br></pre></td></tr></table></figure>

<p>(2) hidden 属性<br>HTML5 新增属性，相当于 display: none</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">hidden</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>视觉上的隐藏</strong></p>
<p>(1) 设置 posoition 为 absolute 或 fixed，通过设置 top、left 等值，将其移出可视区域。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">position</span>:absolute;</span><br><span class="line"><span class="attribute">left</span>: -<span class="number">99999px</span>;</span><br></pre></td></tr></table></figure>

<p>(2) 设置 position 为 relative，通过设置 top、left 等值，将其移出可视区域。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">position</span>: relative;</span><br><span class="line"><span class="attribute">left</span>: -<span class="number">99999px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>(3) 设置 margin 值，将其移出可视区域范围（可视区域占位）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">margin-left: -99999px;</span><br><span class="line">height: <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>语义上隐藏</p>
<p><em>aria-hidden 属性</em></p>
<p>读屏软件不可读，占据空间，可见。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div aria-hidden=<span class="string">&quot;true&quot;</span>&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="13-层叠上下文"><a href="#13-层叠上下文" class="headerlink" title="13. 层叠上下文"></a>13. 层叠上下文</h3><blockquote>
<p>参考答案：</p>
<p><strong>层叠上下文概念</strong></p>
<p>在 <em>CSS2.1</em> 规范中，每个盒模型的位置是三维的，分别是平面画布上的 <em>X</em> 轴，<em>Y</em> 轴以及表示层叠的 <em>Z</em> 轴。</p>
<p>一般情况下，元素在页面上沿 <em>X</em> 轴 <em>Y</em> 轴平铺，我们察觉不到它们在 <em>Z</em> 轴上的层叠关系。而一旦元素发生堆叠，这时就能发现某个元素可能覆盖了另一个元素或者被另一个元素覆盖。</p>
<p><strong>层叠上下文触发条件</strong></p>
<ul>
<li><em>HTML</em> 中的根元素 <em>HTML</em> 本身就具有层叠上下文，称为“根层叠上下文”。</li>
<li>普通元素设置 <em>position</em> 属性为非 <em>static</em> 值并设置 <em>z-index</em> 属性为具体数值，产生层叠上下文</li>
<li><em>CSS3</em> 中的新属性也可以产生层叠上下文</li>
</ul>
<p><strong>层叠顺序</strong></p>
<p>“层叠顺序”（<em>stacking order</em>）表示元素发生层叠时按照特定的顺序规则在 <em>Z</em> 轴上垂直显示。</p>
<p>说简单一点就是当元素处于同一层叠上下文内时如何进行层叠判断。</p>
<p>具体的层叠等级如下图：</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-11-03-010804.png" alt="image-20210816174742449" style="zoom:50%;" />
</blockquote>
<h3 id="14-分析比较-opacity-0、visibility-hidden、display-none-优劣和适用场景"><a href="#14-分析比较-opacity-0、visibility-hidden、display-none-优劣和适用场景" class="headerlink" title="14. 分析比较 opacity: 0、visibility: hidden、display: none 优劣和适用场景"></a>14. 分析比较 <em>opacity: 0、visibility: hidden、display: none</em> 优劣和适用场景</h3><blockquote>
<p>参考答案：</p>
<ol>
<li>display: none (不占空间，不能点击)（场景，显示出原来这里不存在的结构）</li>
<li>visibility: hidden（占据空间，不能点击）（场景：显示不会导致页面结构发生变动，不会撑开）</li>
<li>opacity: 0（占据空间，可以点击）（场景：可以跟transition搭配）</li>
</ol>
</blockquote>
<h3 id="15-讲一下png8、png16、png32的区别，并简单讲讲-png-的压缩原理"><a href="#15-讲一下png8、png16、png32的区别，并简单讲讲-png-的压缩原理" class="headerlink" title="15. 讲一下png8、png16、png32的区别，并简单讲讲 png 的压缩原理"></a>15. 讲一下<em>png8、png16、png32</em>的区别，并简单讲讲 <em>png</em> 的压缩原理</h3><blockquote>
<p>参考答案：</p>
<p>PNG图片主要有三个类型，分别为 PNG 8/ PNG 24 / PNG 32。</p>
<ul>
<li><code>PNG 8</code>：PNG 8中的8，其实指的是8bits，相当于用2^8（2的8次方）大小来存储一张图片的颜色种类，2^8等于256，也就是说PNG 8能存储256种颜色，一张图片如果颜色种类很少，将它设置成PNG 8得图片类型是非常适合的。</li>
<li><code>PNG 24</code>：PNG 24中的24，相当于3乘以8 等于 24，就是用三个8bits分别去表示 R（红）、G（绿）、B（蓝）。R(0-255),G(0-255),B(0-255)，可以表达256乘以256乘以256=16777216种颜色的图片，这样PNG 24就能比PNG 8表示色彩更丰富的图片。但是所占用的空间相对就更大了。</li>
<li><code>PNG 32</code>：PNG 32中的32，相当于PNG 24 加上 8bits的透明颜色通道，就相当于R（红）、G（绿）、B（蓝）、A（透明）。R(0<del>255),G(0</del>255),B(0<del>255),A(0</del>255)。比PNG 24多了一个A（透明），也就是说PNG 32能表示跟PNG 24一样多的色彩，并且还支持256种透明的颜色，能表示更加丰富的图片颜色类型。</li>
</ul>
<p>PNG图片的压缩，分两个阶段：</p>
<ul>
<li><code>预解析（Prediction）</code>：这个阶段就是对png图片进行一个预处理，处理后让它更方便后续的压缩。</li>
<li><code>压缩（Compression）</code>：执行Deflate压缩，该算法结合了 LZ77 算法和 Huffman 算法对图片进行编码。</li>
</ul>
</blockquote>
<h3 id="16-说说渐进增强和优雅降级"><a href="#16-说说渐进增强和优雅降级" class="headerlink" title="16. 说说渐进增强和优雅降级"></a>16. 说说渐进增强和优雅降级</h3><blockquote>
<p>参考答案：</p>
<p>这并不是一个新的概念，其实就是以前提到的”向上兼容”和”向下兼容”。渐进增强相当于向上兼容，优雅降级相当于向下兼容。向下兼容指的是高版本支持低版本，或者说后期开发的版本能兼容早期开发的版本。</p>
<p>在确定用户群体的前提下，渐进增强：针对低版本浏览器进行页面构建，保证基本功能，再针对高级浏览器进行效果、交互等改进和追加功能，达到更好的用户体验。优雅降级：一开始就构建完整的功能，再针对低版本浏览器进行兼容。区别：优雅降级是从复杂的现状开始并试图减少用户体验的供给，而渐进增强则是从一个基础的、能够起到作用的版本开始再不断扩充，以适应未来环境的需要。</p>
<p>绝大多少的大公司都是采用渐进增强的方式，因为业务优先，提升用户体验永远不会排在最前面。</p>
<ul>
<li>例如新浪微博网站这样亿级用户的网站，前端的更新绝不可能追求某个特效而不考虑低版本用户是否可用。一定是确保低版本到高版本的可访问性再渐进增强。</li>
<li>如果开发的是一面面向青少面的软件或网站，你明确这个群体的人总是喜欢尝试新鲜事物，喜欢炫酷的特效，喜欢把软件更新至最新版本，这种情况再考虑优雅降级。</li>
</ul>
</blockquote>
<h3 id="17-介绍下-positon-属性"><a href="#17-介绍下-positon-属性" class="headerlink" title="17. 介绍下 positon 属性"></a>17. 介绍下 <em>positon</em> 属性</h3><blockquote>
<p>参考答案：</p>
<p>position 属性主要用来定位，常见的属性值如下：</p>
<ul>
<li><p><code>absolute</code> 绝对定位，相对于 <code>static</code> 定位以外的第一个父元素进行定位。</p>
</li>
<li><p><code>relative</code> 相对定位，相对于其自身正常位置进行定位。</p>
</li>
<li><p><code>fixed</code> 固定定位，相对于浏览器窗口进行定位。</p>
</li>
<li><p><code>static</code> 默认值。没有定位，元素出现在正常的流中。</p>
</li>
<li><p><code>inherit</code> 规定应该从父元素继承 position 属性的值。</p>
</li>
<li><p><code>sticky</code> 粘性定位，当元素在容器中被滚动超过指定的偏移值时，元素在容器内固定在指定位置。</p>
</li>
</ul>
</blockquote>
<h3 id="18-如何用-CSS-实现一个三角形"><a href="#18-如何用-CSS-实现一个三角形" class="headerlink" title="18. 如何用 CSS 实现一个三角形"></a>18. 如何用 <em>CSS</em> 实现一个三角形</h3><blockquote>
<p>参考答案：</p>
<p>可以利用 border 属性</p>
<p>利用盒模型的 <code>border</code> 属性上下左右边框交界处会呈现出平滑的斜线这个特点，通过设置不同的上下左右边框宽度或者颜色即可得到三角形或者梯形。</p>
<p>如果想实现其中的任一个三角形，把其他方向上的 <code>border-color</code> 都设置成透明即可。</p>
<p>示例代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">10px</span> solid red;</span><br><span class="line"><span class="attribute">border-top-color</span>: transparent;</span><br><span class="line"><span class="attribute">border-left-color</span>: transparent;</span><br><span class="line"><span class="attribute">border-right-color</span>: transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="19-如何实现一个自适应的正方形"><a href="#19-如何实现一个自适应的正方形" class="headerlink" title="19. 如何实现一个自适应的正方形"></a>19. 如何实现一个自适应的正方形</h3><blockquote>
<p>参考答案：</p>
<p><strong>方法1：利用 CSS3 的 vw 单位</strong></p>
<p><code>vw</code> 会把视口的宽度平均分为 100 份</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.square &#123;</span><br><span class="line"> width: 10vw;</span><br><span class="line"> height: 10vw;</span><br><span class="line"> background: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法2：利用 margin 或者 padding 的百分比计算是参照父元素的 width 属性</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.square &#123;</span><br><span class="line"> width: 10%;</span><br><span class="line"> padding-bottom: 10%; </span><br><span class="line"> height: 0; // 防止内容撑开多余的高度</span><br><span class="line"> background: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="20-如何实现三栏布局"><a href="#20-如何实现三栏布局" class="headerlink" title="20. 如何实现三栏布局"></a>20. 如何实现三栏布局</h3><blockquote>
<p>参考答案：</p>
<p>三栏布局是很常见的一种页面布局方式。左右固定，中间自适应。实现方式有很多种方法。</p>
<p><strong>第一种：flex</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line"> &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;</span><br><span class="line"> &lt;div class=&quot;main&quot;&gt;main&lt;/div&gt;</span><br><span class="line"> &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">.container&#123;</span><br><span class="line"> display: flex;</span><br><span class="line">&#125;</span><br><span class="line">.left&#123;</span><br><span class="line"> flex-basis:200px;</span><br><span class="line"> background: green;</span><br><span class="line">&#125;</span><br><span class="line">.main&#123;</span><br><span class="line"> flex: 1;</span><br><span class="line"> background: red;</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line"> flex-basis:200px;</span><br><span class="line"> background: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二种：position + margin</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line"> &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;</span><br><span class="line"> &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;</span><br><span class="line"> &lt;div class=&quot;main&quot;&gt;main&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">body,html&#123;</span><br><span class="line"> padding: 0;</span><br><span class="line"> margin: 0;</span><br><span class="line">&#125;</span><br><span class="line">.left,.right&#123;</span><br><span class="line"> position: absolute;</span><br><span class="line"> top: 0;</span><br><span class="line"> background: red;</span><br><span class="line">&#125;</span><br><span class="line">.left&#123;</span><br><span class="line"> left: 0;</span><br><span class="line"> width: 200px;</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line"> right: 0;</span><br><span class="line"> width: 200px;</span><br><span class="line">&#125;</span><br><span class="line">.main&#123;</span><br><span class="line"> margin: 0 200px ;</span><br><span class="line"> background: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第三种：float + margin</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line"> &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;</span><br><span class="line"> &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;</span><br><span class="line"> &lt;div class=&quot;main&quot;&gt;main&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">body,html&#123;</span><br><span class="line"> padding:0;</span><br><span class="line"> margin: 0;</span><br><span class="line">&#125;</span><br><span class="line">.left&#123;</span><br><span class="line"> float:left;</span><br><span class="line"> width:200px;</span><br><span class="line"> background:red;</span><br><span class="line">&#125;</span><br><span class="line">.main&#123;</span><br><span class="line"> margin:0 200px;</span><br><span class="line"> background: green;</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line"> float:right;</span><br><span class="line"> width:200px;</span><br><span class="line"> background:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="21-import-和-link-区别"><a href="#21-import-和-link-区别" class="headerlink" title="21. import 和 link 区别"></a>21. <em>import</em> 和 <em>link</em> 区别</h3><blockquote>
<p>参考答案：</p>
<ol>
<li>从属关系区别</li>
</ol>
<p><code>@import</code>是 CSS 提供的语法规则，只有导入样式表的作用；<code>link</code>是HTML提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等。</p>
<ol start="2">
<li>加载顺序区别</li>
</ol>
<p>加载页面时，<code>link</code>标签引入的 CSS 被同时加载；<code>@import</code>引入的 CSS 将在页面加载完毕后被加载。</p>
<ol start="3">
<li>兼容性区别</li>
</ol>
<p><code>@import</code>是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；<code>link</code> 标签作为 HTML 元素，不存在兼容性问题。</p>
<ol start="4">
<li>DOM可控性区别</li>
</ol>
<p>可以通过 JS 操作 DOM ，插入<code>link</code>标签来改变样式；由于DOM方法是基于文档的，无法使用<code>@import</code>的方式插入样式。</p>
</blockquote>
<h3 id="22-说说你对-BFC-的理解"><a href="#22-说说你对-BFC-的理解" class="headerlink" title="22. 说说你对 BFC 的理解"></a>22. 说说你对 <em>BFC</em> 的理解</h3><blockquote>
<p>参考答案：</p>
<p>块级格式化上下文 <em>Block Formatting Context</em> 是 CSS 规范中一个概念，决定元素的内容如何渲染以及与其他元素的关系。存在5条规则：</p>
<ol>
<li><em>BFC</em> 有隔离作用，内部元素不受外部元素影响，反之亦然。</li>
<li>一个元素只能存在于一个 <em>BFC</em> 中，如果能同时存在于两个 <em>BFC</em> 中，那么就违反了 <em>BFC</em> 的隔离原则。</li>
<li><em>BFC</em> 内的元素按正常流排列，元素间的间隙由元素外边距控制。</li>
<li><em>BFC</em> 中的内容不会与外面的浮动元素重叠。</li>
<li>计算 <em>BFC</em> 的高度需要包括 <em>BFC</em> 内的浮动子元素的高度。</li>
</ol>
</blockquote>
<h3 id="23-清除浮动的方法"><a href="#23-清除浮动的方法" class="headerlink" title="23. 清除浮动的方法"></a>23. 清除浮动的方法</h3><blockquote>
<p>参考答案：</p>
<ul>
<li><p>clear 清除浮动（添加空div法）在浮动元素下方添加空div，并给该元素写css样式： {clear:both;height:0;overflow:hidden;}</p>
</li>
<li><p>给浮动元素父级设置高度</p>
</li>
<li><p>父级同时浮动（需要给父级同级元素添加浮动）</p>
</li>
<li><p>父级设置成inline-block，其margin: 0 auto居中方式失效</p>
</li>
<li><p>给父级添加overflow:hidden 清除浮动方法</p>
</li>
<li><p>万能清除法 after 伪类清浮动（现在主流方法，推荐使用）</p>
</li>
</ul>
</blockquote>
<h3 id="24-说说选择器的权重计算方式"><a href="#24-说说选择器的权重计算方式" class="headerlink" title="24. 说说选择器的权重计算方式"></a>24. 说说选择器的权重计算方式</h3><blockquote>
<p>参考答案：</p>
<p><em>!important</em> 最高，* 为0，行内样式 A 组加一，id 选择器 B 组加一，类、伪类、属性选择器 C 组加一，元素、伪元素 D 组加一。</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-11-03-10806.png" alt="image-20210816194530798" style="zoom:50%;" />

<p>其中 A 组权重值为 1000，B 组权重值为 100，C 组权重值为 10，D 组权重值为 1。</p>
</blockquote>
<h3 id="25-css-reset-和-normalize-css-有什么区别？"><a href="#25-css-reset-和-normalize-css-有什么区别？" class="headerlink" title="25. css reset 和 normalize.css 有什么区别？"></a>25. <em>css reset</em> 和 <em>normalize.css</em> 有什么区别？</h3><blockquote>
<p>参考答案：</p>
<ul>
<li><p>两者都是通过重置样式，保持浏览器样式的一致性</p>
</li>
<li><p>前者几乎为所有标签添加了样式，后者保持了许多浏览器样式，保持尽可能的一致</p>
</li>
<li><p>后者修复了常见的桌面端和移动端浏览器的 bug：包含了 HTML5 元素的显示设置、预格式化文字的 font-size 问题、在 IE9 中 SVG 的溢出、许多出现在各浏览器和操作系统中的与表单相关的 bug。</p>
</li>
<li><p>前者中含有大段的继承链</p>
</li>
<li><p>后者模块化，文档较前者来说丰富</p>
</li>
</ul>
</blockquote>
<h3 id="26-说说两种盒模型以及区别"><a href="#26-说说两种盒模型以及区别" class="headerlink" title="26. 说说两种盒模型以及区别"></a>26. 说说两种盒模型以及区别</h3><blockquote>
<p>参考答案：</p>
<p>盒模型也称为框模型，就是从盒子顶部俯视所得的一张平面图，用于描述元素所占用的空间。它有两种盒模型，W3C盒模型和IE盒模型（IE6以下，不包括IE6以及怪异模式下的IE5.5+）</p>
<p>理论上两者的主要区别是二者的盒子宽高是否包括元素的边框和内边距。当用CSS给给某个元素定义高或宽时，IE盒模型中内容的宽或高将会包含内边距和边框，而W3C盒模型并不会。</p>
</blockquote>
<h3 id="27-如何避免重绘或者重排？"><a href="#27-如何避免重绘或者重排？" class="headerlink" title="27. 如何避免重绘或者重排？"></a>27. 如何避免重绘或者重排？</h3><blockquote>
<p>参考答案：</p>
<ol>
<li><strong>集中改变样式</strong></li>
</ol>
<p>我们往往通过改变 class 的方式来集中改变样式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 判断是否是黑色系样式</span><br><span class="line">const theme = isDark ? &#x27;dark&#x27; : &#x27;light&#x27;</span><br><span class="line"></span><br><span class="line">// 根据判断来设置不同的class</span><br><span class="line">ele.setAttribute(&#x27;className&#x27;, theme)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>使用 DocumentFragment</strong></li>
</ol>
<p>我们可以通过createDocumentFragment创建一个游离于DOM树之外的节点，然后在此节点上批量操作，最后插入DOM树中，因此只触发一次重排</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var fragment = document.createDocumentFragment();</span><br><span class="line"></span><br><span class="line">for (let i = 0;i&lt;10;i++)&#123;</span><br><span class="line">  let node = document.createElement(&quot;p&quot;);</span><br><span class="line">  node.innerHTML = i;</span><br><span class="line">  fragment.appendChild(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">document.body.appendChild(fragment);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>提升为合成层</strong></li>
</ol>
<p>将元素提升为合成层有以下优点：</p>
<ul>
<li>合成层的位图，会交由 GPU 合成，比 CPU 处理要快</li>
<li>当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层</li>
<li>对于 transform 和 opacity 效果，不会触发 layout 和 paint</li>
</ul>
<p>提升合成层的最好方式是使用 CSS 的 will-change 属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#target &#123;</span><br><span class="line">  will-change: transform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="28-如何触发重排和重绘？"><a href="#28-如何触发重排和重绘？" class="headerlink" title="28. 如何触发重排和重绘？"></a>28. 如何触发重排和重绘？</h3><blockquote>
<p>参考答案：</p>
<p>任何改变用来构建渲染树的信息都会导致一次重排或重绘：</p>
<ul>
<li>添加、删除、更新DOM节点</li>
<li>通过display: none隐藏一个DOM节点-触发重排和重绘</li>
<li>通过visibility: hidden隐藏一个DOM节点-只触发重绘，因为没有几何变化</li>
<li>移动或者给页面中的DOM节点添加动画</li>
<li>添加一个样式表，调整样式属性</li>
<li>用户行为，例如调整窗口大小，改变字号，或者滚动。</li>
</ul>
</blockquote>
<h3 id="29-重绘与重排的区别？"><a href="#29-重绘与重排的区别？" class="headerlink" title="29. 重绘与重排的区别？"></a>29. 重绘与重排的区别？</h3><blockquote>
<p>参考答案：</p>
<ul>
<li>重排: 部分渲染树（或者整个渲染树）需要重新分析并且节点尺寸需要重新计算，表现为重新生成布局，重新排列元素</li>
<li>重绘: 由于节点的几何属性发生改变或者由于样式发生改变，例如改变元素背景色时，屏幕上的部分内容需要更新，表现为某些元素的外观被改变</li>
</ul>
<p>单单改变元素的外观，肯定不会引起网页重新生成布局，但当浏览器完成重排之后，将会重新绘制受到此次重排影响的部分</p>
<p>重排和重绘代价是高昂的，它们会破坏用户体验，并且让UI展示非常迟缓，而相比之下重排的性能影响更大，在两者无法避免的情况下，一般我们宁可选择代价更小的重绘。</p>
<p>『重绘』不一定会出现『重排』，『重排』必然会出现『重绘』。</p>
</blockquote>
<h3 id="30-如何优化图片"><a href="#30-如何优化图片" class="headerlink" title="30. 如何优化图片"></a>30. 如何优化图片</h3><blockquote>
<p>参考答案：</p>
<ol>
<li><p>对于很多装饰类图片，尽量不用图片，因为这类修饰图片完全可以用 CSS 去代替。</p>
</li>
<li><p>对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。</p>
</li>
<li><p>小图使用 <em>base64</em> 格式</p>
</li>
<li><p>将多个图标文件整合到一张图片中（雪碧图）</p>
</li>
<li><p>选择正确的图片格式：</p>
</li>
</ol>
<ul>
<li>对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好</li>
<li>小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替</li>
<li>照片使用 JPEG</li>
</ul>
</blockquote>
<h3 id="31-说说重绘（Repaint）和回流（Reflow）"><a href="#31-说说重绘（Repaint）和回流（Reflow）" class="headerlink" title="31. 说说重绘（Repaint）和回流（Reflow）"></a>31. 说说重绘（Repaint）和回流（Reflow）</h3><blockquote>
<p>参考答案：</p>
<p>请参阅前面 <em>28、29、30</em> 题。</p>
</blockquote>
<h3 id="32-你能描述一下渐进增强和优雅降级之间的不同吗"><a href="#32-你能描述一下渐进增强和优雅降级之间的不同吗" class="headerlink" title="32. 你能描述一下渐进增强和优雅降级之间的不同吗?"></a>32. 你能描述一下渐进增强和优雅降级之间的不同吗?</h3><blockquote>
<p>参考答案：</p>
<p>渐进增强 progressive enhancement：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</p>
<p>优雅降级 graceful degradation：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</p>
<p>区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。</p>
</blockquote>
<h3 id="33-如何在页面上实现一个圆形的可点击区域？"><a href="#33-如何在页面上实现一个圆形的可点击区域？" class="headerlink" title="33. 如何在页面上实现一个圆形的可点击区域？"></a>33. 如何在页面上实现一个圆形的可点击区域？</h3><blockquote>
<p>参考答案：</p>
<p>首先使用 <em>CSS3</em> 新增的 <em>border-radius</em> 属性来将一个区域变成圆形，然后再使用 <em>JS</em> 来绑定事件。</p>
</blockquote>
<h3 id="34-什么是渐进式渲染（progressive-rendering）？"><a href="#34-什么是渐进式渲染（progressive-rendering）？" class="headerlink" title="34. 什么是渐进式渲染（progressive rendering）？"></a>34. 什么是渐进式渲染（<em>progressive rendering</em>）？</h3><blockquote>
<p>参考答案：</p>
<p>渐进式渲染是用于提高网页性能（尤其是提高用户感知的加载速度），以尽快呈现页面的技术。</p>
<p>在以前互联网带宽较小的时期，这种技术更为普遍。如今，移动终端的盛行，而移动网络往往不稳定，渐进式渲染在现代前端开发中仍然有用武之地。</p>
<p>一些举例：</p>
<ul>
<li>图片懒加载——页面上的图片不会一次性全部加载。当用户滚动页面到图片部分时，JavaScript 将加载并显示图像。</li>
<li>确定显示内容的优先级（分层次渲染）——为了尽快将页面呈现给用户，页面只包含基本的最少量的 CSS、脚本和内容，然后可以使用延迟加载脚本或监听<code>DOMContentLoaded</code>/<code>load</code>事件加载其他资源和内容。</li>
<li>异步加载 HTML 片段——当页面通过后台渲染时，把 HTML 拆分，通过异步请求，分块发送给浏览器。</li>
</ul>
</blockquote>
<h3 id="35-CSS3-新增了那些东西？"><a href="#35-CSS3-新增了那些东西？" class="headerlink" title="35. CSS3 新增了那些东西？"></a>35. <em>CSS3</em> 新增了那些东西？</h3><blockquote>
<p>参考答案：</p>
<p><em>CSS3</em> 新增东西众多，这里列举出一些关键的新增内容：</p>
<ul>
<li>选择器</li>
<li>盒子模型属性：<em>border-radius、box-shadow、border-image</em></li>
<li>背景：<em>background-size、background-origin、background-clip</em></li>
<li>文本效果：<em>text-shadow、word-wrap</em></li>
<li>颜色：新增 <em>RGBA，HSLA</em> 模式</li>
<li>渐变：线性渐变、径向渐变</li>
<li>字体：*@font-face*</li>
<li>2D/3D转换：<em>transform、transform-origin</em></li>
<li>过渡与动画：<em>transition、@keyframes、animation</em></li>
<li>多列布局</li>
<li>媒体查询</li>
</ul>
</blockquote>
<h3 id="36-我想实现一根只有-1px-的长线怎么实现"><a href="#36-我想实现一根只有-1px-的长线怎么实现" class="headerlink" title="36. 我想实现一根只有 1px 的长线怎么实现?"></a>36. 我想实现一根只有 <em>1px</em> 的长线怎么实现?</h3><blockquote>
<p>参考答案：</p>
<p>实现的方式很多，下面是一种参考方案：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&gt;<span class="selector-class">.line</span> &#123;</span><br><span class="line">&gt;<span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&gt;<span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">&gt;<span class="attribute">overflow</span>: hidden;</span><br><span class="line">&gt;<span class="attribute">font-size</span>: <span class="number">0px</span>; </span><br><span class="line">&gt;<span class="attribute">border-bottom</span>: dashed <span class="number">1px</span> <span class="number">#ccc</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;line&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="37-三角形怎么实现？要设置宽高吗？"><a href="#37-三角形怎么实现？要设置宽高吗？" class="headerlink" title="37. 三角形怎么实现？要设置宽高吗？"></a>37. 三角形怎么实现？要设置宽高吗？</h3><blockquote>
<p>参考答案：</p>
<p>设置块级元素宽高为 0，边框3条设置为透明色。具体可以参阅第 18 题答案</p>
</blockquote>
<h3 id="38-box-sizing-有什么作用？"><a href="#38-box-sizing-有什么作用？" class="headerlink" title="38. box-sizing 有什么作用？"></a>38. <em>box-sizing</em> 有什么作用？</h3><blockquote>
<p>参考答案：</p>
<p><em>box-sizing</em> 是用于告诉浏览器如何计算一个元素是总宽度和总高度，主要用来切换标准盒模型和 IE 盒子。</p>
<ul>
<li><p>标准盒模型 box-sizing: content-box<br>content-box:<br>width  = content width;<br>height = content height</p>
</li>
<li><p>IE盒模型      box-sizing: border-box<br>border-box:<br>width  = border + padding + content width<br>heigth = border + padding + content heigth</p>
</li>
</ul>
</blockquote>
<h3 id="39-img-标签在页面中有-1px-的边框，怎么处理"><a href="#39-img-标签在页面中有-1px-的边框，怎么处理" class="headerlink" title="39. img 标签在页面中有 1px 的边框，怎么处理"></a>39. <em>img</em> 标签在页面中有 <em>1px</em> 的边框，怎么处理</h3><blockquote>
<p>参考答案：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line">	<span class="attribute">border</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="40-如何绝对居中（不用定位）（看书网）"><a href="#40-如何绝对居中（不用定位）（看书网）" class="headerlink" title="40. 如何绝对居中（不用定位）（看书网）"></a>40. 如何绝对居中（不用定位）（看书网）</h3><blockquote>
<p>参考答案：</p>
<p>方法一：</p>
<p>使用 <em>flex</em> 弹性盒来绝对居中</p>
<p>方法二：</p>
<p>设置 <em>margin-left</em> 为 <em>calc(50% - 50px);</em></p>
</blockquote>
<h3 id="41-CSS-选择器权重值"><a href="#41-CSS-选择器权重值" class="headerlink" title="41. CSS 选择器权重值"></a>41. <em>CSS</em> 选择器权重值</h3><blockquote>
<p>参考答案：</p>
<p>请参阅前面第 <em>24</em> 题答案。</p>
</blockquote>
<h3 id="42-我有5个div在一行，我要让div与div直接间距10px且最左最右两边的div据边框10px，同时在我改变窗口大小时，这个10px不能变，div根据窗口改变大小（长天星斗）"><a href="#42-我有5个div在一行，我要让div与div直接间距10px且最左最右两边的div据边框10px，同时在我改变窗口大小时，这个10px不能变，div根据窗口改变大小（长天星斗）" class="headerlink" title="42. 我有5个div在一行，我要让div与div直接间距10px且最左最右两边的div据边框10px，同时在我改变窗口大小时，这个10px不能变，div根据窗口改变大小（长天星斗）"></a>42. 我有5个div在一行，我要让div与div直接间距10px且最左最右两边的div据边框10px，同时在我改变窗口大小时，这个10px不能变，div根据窗口改变大小（长天星斗）</h3><blockquote>
<p>参考答案：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">*&#123;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span>&gt;<span class="selector-tag">div</span>&#123;</span><br><span class="line"><span class="attribute">outline</span>: <span class="number">1px</span> solid;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">0</span> <span class="number">5px</span>;</span><br><span class="line"><span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span>&gt;<span class="selector-tag">div</span><span class="selector-pseudo">:first</span>-child &#123;</span><br><span class="line"><span class="attribute">margin-left</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span>&gt;<span class="selector-tag">div</span><span class="selector-pseudo">:last-child</span> &#123;</span><br><span class="line"><span class="attribute">margin-right</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="43-bootstrap-响应式的原理是什么"><a href="#43-bootstrap-响应式的原理是什么" class="headerlink" title="43. bootstrap 响应式的原理是什么"></a>43. <em>bootstrap</em> 响应式的原理是什么</h3><blockquote>
<p>参考答案：</p>
<p><em>bootstrap</em> 使用的是栅格布局。栅格布局的实现原理，是通过定义容器大小，平分 <em>12</em> 份，再调整内外边距，最后结合媒体查询，就制作出了强大的响应式网格系统。</p>
</blockquote>
<h3 id="44-如何做响应式？"><a href="#44-如何做响应式？" class="headerlink" title="44. 如何做响应式？"></a>44. 如何做响应式？</h3><blockquote>
<p>参考答案：</p>
<p>可以使用 <em>CSS3</em> 新增的媒体查询。</p>
<p>媒体查询的语法如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> mediatype <span class="keyword">and</span>|<span class="keyword">not</span>|<span class="keyword">only</span> (media feature) &#123; CSS-<span class="selector-tag">Code</span>;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="45-什么是响应式设计"><a href="#45-什么是响应式设计" class="headerlink" title="45. 什么是响应式设计"></a>45. 什么是响应式设计</h3><blockquote>
<p>参考答案：</p>
<p>响应式设计简而言之，就是一个网站能够兼容多个终端——而不是为每个终端做一个特定的版本。</p>
<p>优点：</p>
<ul>
<li>面对不同分辨率设备灵活性强</li>
<li>能够快捷解决多设备显示适应问题</li>
</ul>
<p>缺点：</p>
<p>兼容各种设备工作量大，效率低下</p>
<p>代码累赘，会出现隐藏无用的元素，加载时间加长</p>
<p>其实这是一种折中性质的设计解决方案，多方面因素影响而达不到最佳效果</p>
<p>一定程度上改变了网站原有的布局结构，会出现用户混淆的情况</p>
<p>具体步骤：</p>
<ul>
<li>第一步：meta 标签</li>
</ul>
<p>为了适应屏幕，多数的移动浏览器会把HTML网页缩放到设备屏幕的宽度。你可以使用meta标签的viewport属性来设置。下面的代码告诉浏览器使用设备屏幕宽度作为内容的宽度，并且忽视初始的宽度设置。这段代码写在 <code>&lt;head&gt;</code>里面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>IE8及以下的浏览器不支持media query。你可以使用 media-queries.js 或 respond.js 。这样IE就能支持media query了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--[if lt IE 9]&gt; &lt;script src=&quot;http://css3-mediaqueries-js.googlecode.com/svn/trunk/css3-mediaqueries.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>第二步：HTML 结构</li>
</ul>
<p>这个例子里面，有header、content、sidebar和footer等基本的网页布局。</p>
<p>header 有固定的高180px，content 容器的宽是600px，sidebar的宽是300px。</p>
<ul>
<li>第三步：Media Queries</li>
</ul>
<p>CSS3 media query 响应式网页设计的关键。它像一个 if 语句，告诉浏览器如何根据特定的屏幕宽口来加载网页。</p>
<p>下面是一个媒体查询示例代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@media screen and (max-width: 300px) &#123;</span><br><span class="line">    body &#123;</span><br><span class="line">        background-color:lightblue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果文档宽度小于 300 像素则修改背景演示(background-color)</p>
</blockquote>
<h3 id="46-块级元素转行内元素除了-display-inline-还有什么？"><a href="#46-块级元素转行内元素除了-display-inline-还有什么？" class="headerlink" title="46. 块级元素转行内元素除了 display:inline 还有什么？"></a>46. 块级元素转行内元素除了 <em>display:inline</em> 还有什么？</h3><blockquote>
<p>参考答案：</p>
<p><em>display:inline-block</em></p>
</blockquote>
<h3 id="47-对-CSS-hack-技术的理解"><a href="#47-对-CSS-hack-技术的理解" class="headerlink" title="47. 对 CSS hack 技术的理解"></a>47. 对 <em>CSS hack</em> 技术的理解</h3><blockquote>
<p>参考答案：</p>
<p><strong>什么是CSS hack</strong><br>由于不同厂商的流览器或某浏览器的不同版本（如IE6-IE11,Firefox/Safari/Opera/Chrome等），对CSS的支持、解析不一样，导致在不同浏览器的环境中呈现出不一致的页面展现效果。这时，我们为了获得统一的页面效果，就需要针对不同的浏览器或不同版本写特定的CSS样式，我们把这个针对不同的浏览器/不同版本写相应的CSS code的过程，叫做CSS hack!</p>
<p><strong>CSS hack的原理</strong><br>由于不同的浏览器和浏览器各版本对CSS的支持及解析结果不一样，以及CSS优先级对浏览器展现效果的影响，我们可以据此针对不同的浏览器情景来应用不同的CSS。</p>
<p><strong>CSS hack分类</strong><br>CSS Hack大致有3种表现形式，CSS属性前缀法、选择器前缀法以及IE条件注释法（即HTML头部引用if IE）Hack，实际项目中CSS Hack大部分是针对IE浏览器不同版本之间的表现差异而引入的。</p>
<ul>
<li>属性前缀法(即类内部Hack)：例如 IE6能识别下划线”<em>“和星号” * “，IE7能识别星号” * “，但不能识别下划线”</em>“，IE6~IE10都认识”\9”，但firefox前述三个都不能认识。</li>
<li>选择器前缀法(即选择器Hack)：例如 IE6能识别<em>html .class{}，IE7能识别</em>+html .class{}或者*:first-child+html .class{}。</li>
<li>IE条件注释法(即HTML条件注释Hack)：针对所有IE(注：IE10+已经不再支持条件注释)： <code>&lt;!--[if IE]&gt;</code>IE浏览器显示的内容 <code>&lt;![endif]--&gt;</code>，针对IE6及以下版本： <code>&lt;!--[if lt IE 6]&gt;</code>只在IE6-显示的内容 <code>&lt;![endif]--&gt;</code>。这类Hack不仅对CSS生效，对写在判断语句里面的所有代码都会生效。</li>
</ul>
<p>下面是微软官方推荐使用的 hack 方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">只在IE下生效&lt;!--[<span class="keyword">if</span> IE]&gt;  这段文字只在IE浏览器显示&lt;![endif]--&gt;只在IE6下生效&lt;!--[<span class="keyword">if</span> IE <span class="number">6</span>]&gt;  这段文字只在IE6浏览器显示&lt;![endif]--&gt;只在IE6以上版本生效&lt;!--[<span class="keyword">if</span> gte IE <span class="number">6</span>]&gt;  这段文字只在IE6以上(包括)版本IE浏览器显示&lt;![endif]--&gt;只在IE8上不生效&lt;!--[<span class="keyword">if</span> ! IE <span class="number">8</span>]&gt;  这段文字在非IE8浏览器显示&lt;![endif]--&gt;非IE浏览器生效&lt;!--[<span class="keyword">if</span> !IE]&gt;  这段文字只在非IE浏览器显示&lt;![endif]--&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="48-px-和-em-的区别"><a href="#48-px-和-em-的区别" class="headerlink" title="48. px 和 em 的区别"></a>48. <em>px</em> 和 <em>em</em> 的区别</h3><blockquote>
<p>参考答案：</p>
<ul>
<li><em>px</em> 即 <em>pixel</em> 像素，是相对于屏幕分辨率而言的，是一个相对绝对单位，即在同一设备上每个设备像素所代表的物理长度是固定不变的（绝对性），但在不同设备间每个设备像素所代表的物理长度是可以变化的（相对性）。</li>
<li><em>em</em> 一个相对单位，不是一个固定的值，来源于纸张印刷业，在 <em>web</em> 领域它指代基准字号，浏览器默认渲染文字大小是 16<em>px</em> ，它会继承计算后的父级元素的 font-size。</li>
</ul>
</blockquote>
<h3 id="49-div-之间的间隙是怎么产生的，应该怎么消除？"><a href="#49-div-之间的间隙是怎么产生的，应该怎么消除？" class="headerlink" title="49. div 之间的间隙是怎么产生的，应该怎么消除？"></a>49. <em>div</em> 之间的间隙是怎么产生的，应该怎么消除？</h3><blockquote>
<p>参考答案：</p>
<p>原因：浏览器解析的时候，会把回车换行符解析成一定的间隙，间隙的大小跟默认的字体大小设置有关。</p>
<p>解决：其父元素加上 font-size:0 的属性，但是字体需要额外处理。</p>
</blockquote>
<h3 id="50-position-有哪些值，各自的用法如何？"><a href="#50-position-有哪些值，各自的用法如何？" class="headerlink" title="50. position 有哪些值，各自的用法如何？"></a>50. <em>position</em> 有哪些值，各自的用法如何？</h3><blockquote>
<p>参考答案：</p>
<p><em>position</em> 属性值有 <em>static、relative、absolute、fixed、sticky</em>。</p>
<ol>
<li><p><em>static</em>：该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。</p>
</li>
<li><p><em>relative</em>：相对定位的元素是在文档中的正常位置偏移给定的值，但是不影响其他元素的偏移。</p>
</li>
<li><p><em>absolute</em>：相对定位的元素并未脱离文档流，而绝对定位的元素则脱离了文档流。在布置文档流中其它元素时，绝对定位元素不占据空间。绝对定位元素相对于最近的非 <em>static</em> 祖先元素定位。</p>
</li>
<li><p><em>fixed</em>：固定定位与绝对定位相似，但元素的包含块为 <em>viewport</em> 视口。该定位方式常用于创建在滚动屏幕时仍固定在相同位置的元素。</p>
</li>
<li><p><em>sticky</em>：粘性定位可以被认为是相对定位和固定定位的混合。元素在跨越特定阈值前为相对定位，之后为固定定位。</p>
</li>
</ol>
</blockquote>
<h3 id="51-相对定位、绝对定位、固定定位的区别"><a href="#51-相对定位、绝对定位、固定定位的区别" class="headerlink" title="51. 相对定位、绝对定位、固定定位的区别"></a>51. 相对定位、绝对定位、固定定位的区别</h3><blockquote>
<p>参考答案：</p>
<p>请参阅上一题答案。</p>
</blockquote>
<h3 id="52-display-none-和-visibility-hidden-的区别"><a href="#52-display-none-和-visibility-hidden-的区别" class="headerlink" title="52. display:none 和 visibility:hidden 的区别"></a>52. <em>display:none</em> 和 <em>visibility:hidden</em> 的区别</h3><blockquote>
<p>参考答案：</p>
<p>相同点：都是设置某一个 DOM 元素不可见</p>
<p>区别：</p>
<ul>
<li>display:none 设置不可见后不会再存在于文档流中，也就是说不会再占据空间</li>
<li>visibility:hidden 仍然存在于文档流中，之前所占据的空间还存在</li>
</ul>
</blockquote>
<h3 id="53-触发-BFC-的机制"><a href="#53-触发-BFC-的机制" class="headerlink" title="53. 触发 BFC 的机制"></a>53. 触发 <em>BFC</em> 的机制</h3><blockquote>
<p>参考答案：</p>
<p>请参阅前面第 1 题。</p>
</blockquote>
<h3 id="54-div-怎么垂直居中"><a href="#54-div-怎么垂直居中" class="headerlink" title="54. div 怎么垂直居中"></a>54. div 怎么垂直居中</h3><blockquote>
<p>参考答案：</p>
<p>div 垂直居中的方式比较多，常见的有下面 3 种：</p>
<ul>
<li>利用绝对定位实现的居中</li>
<li>利用flex垂直居中</li>
<li>transform+relative实现的居中</li>
</ul>
</blockquote>
<blockquote>
<p>解析：</p>
<p>下面针对上面所列举的 3 种垂直居中的方式，给出对应的代码片段</p>
<p><strong>利用绝对定位实现的居中</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;<span class="name">title</span>&gt;</span>居中<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span></span><br><span class="line"><span class="css"><span class="xml">         *&#123;</span></span></span><br><span class="line"><span class="css"><span class="xml">             <span class="attribute">padding</span>: <span class="number">0px</span>;</span></span></span><br><span class="line"><span class="css"><span class="xml">             <span class="attribute">margin</span>: <span class="number">0px</span>;</span></span></span><br><span class="line"><span class="css"><span class="xml">         &#125;</span></span></span><br><span class="line"><span class="css"><span class="xml">         <span class="selector-tag">body</span> &#123;</span></span></span><br><span class="line"><span class="css"><span class="xml">             <span class="attribute">height</span>: <span class="number">100%</span>;</span></span></span><br><span class="line"><span class="css"><span class="xml">             <span class="attribute">overflow</span>: hidden;</span></span></span><br><span class="line"><span class="css"><span class="xml">         &#125;</span></span></span><br><span class="line"><span class="css"><span class="xml">         <span class="selector-class">.father</span>&#123;</span></span></span><br><span class="line"><span class="css"><span class="xml">             <span class="attribute">position</span>: absolute;</span></span></span><br><span class="line"><span class="css"><span class="xml">             <span class="attribute">height</span>: <span class="number">500px</span>;</span></span></span><br><span class="line"><span class="css"><span class="xml">             <span class="attribute">width</span>: <span class="number">100%</span>;</span></span></span><br><span class="line"><span class="css"><span class="xml">             <span class="attribute">background-color</span>:<span class="number">#2AABD2</span>;</span></span></span><br><span class="line"><span class="css"><span class="xml">         &#125;</span></span></span><br><span class="line"><span class="css"><span class="xml">         <span class="selector-class">.children</span>&#123;</span></span></span><br><span class="line"><span class="css"><span class="xml">             <span class="attribute">position</span>: absolute;</span></span></span><br><span class="line"><span class="css"><span class="xml">             <span class="attribute">top</span>: <span class="number">50%</span>;</span></span></span><br><span class="line"><span class="css"><span class="xml">             <span class="attribute">left</span>: <span class="number">50%</span>;</span></span></span><br><span class="line"><span class="css"><span class="xml">             <span class="attribute">background-color</span>: red;</span></span></span><br><span class="line"><span class="css"><span class="xml">             <span class="attribute">width</span>: <span class="number">100px</span>; </span></span></span><br><span class="line"><span class="css"><span class="xml">             <span class="attribute">height</span>: <span class="number">100px</span>;</span></span></span><br><span class="line"><span class="css"><span class="xml">             <span class="attribute">margin</span>: -<span class="number">50px</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">50px</span>;</span></span></span><br><span class="line"><span class="css"><span class="xml">         &#125;</span></span></span><br><span class="line"><span class="css"><span class="xml">     </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">         <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;children&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">         <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><strong>利用flex垂直居中</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;<span class="name">title</span>&gt;</span>居中<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span></span><br><span class="line"><span class="css"><span class="xml">         *&#123;</span></span></span><br><span class="line"><span class="css"><span class="xml">             <span class="attribute">padding</span>: <span class="number">0px</span>;</span></span></span><br><span class="line"><span class="css"><span class="xml">             <span class="attribute">margin</span>: <span class="number">0px</span>;</span></span></span><br><span class="line"><span class="css"><span class="xml">         &#125;</span></span></span><br><span class="line"><span class="css"><span class="xml">         <span class="selector-tag">body</span> &#123;</span></span></span><br><span class="line"><span class="css"><span class="xml">             <span class="attribute">height</span>: <span class="number">100%</span>;</span></span></span><br><span class="line"><span class="css"><span class="xml">             <span class="attribute">overflow</span>: hidden;</span></span></span><br><span class="line"><span class="css"><span class="xml">         &#125;</span></span></span><br><span class="line"><span class="css"><span class="xml">         <span class="selector-class">.father</span>&#123;</span></span></span><br><span class="line"><span class="css"><span class="xml">             <span class="attribute">height</span>: <span class="number">500px</span>;</span></span></span><br><span class="line"><span class="css"><span class="xml">             <span class="attribute">width</span>: <span class="number">100%</span>;</span></span></span><br><span class="line"><span class="css"><span class="xml">             <span class="attribute">background-color</span>:<span class="number">#2AABD2</span>;</span></span></span><br><span class="line"><span class="css"><span class="xml">             <span class="attribute">display</span>: flex;</span></span></span><br><span class="line"><span class="css"><span class="xml">             <span class="attribute">justify-content</span>: center;<span class="comment">/*实现水平居中*/</span></span></span></span><br><span class="line"><span class="css"><span class="xml">             <span class="attribute">align-items</span>:center; <span class="comment">/*实现垂直居中*/</span></span></span></span><br><span class="line"><span class="css"><span class="xml">         &#125;</span></span></span><br><span class="line"><span class="css"><span class="xml">         <span class="selector-class">.children</span>&#123;</span></span></span><br><span class="line"><span class="css"><span class="xml">             <span class="attribute">background-color</span>: red;</span></span></span><br><span class="line"><span class="css"><span class="xml">             <span class="attribute">width</span>: <span class="number">100px</span>; </span></span></span><br><span class="line"><span class="css"><span class="xml">             <span class="attribute">height</span>: <span class="number">100px</span>;</span></span></span><br><span class="line"><span class="css"><span class="xml">         &#125;</span></span></span><br><span class="line"><span class="css"><span class="xml">     </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">         <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;children&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">         <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><strong>transform+relative实现的居中</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;<span class="name">title</span>&gt;</span>居中<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span></span><br><span class="line"><span class="css"><span class="xml">         *&#123;</span></span></span><br><span class="line"><span class="css"><span class="xml">             <span class="attribute">padding</span>: <span class="number">0px</span>;</span></span></span><br><span class="line"><span class="css"><span class="xml">             <span class="attribute">margin</span>: <span class="number">0px</span>;</span></span></span><br><span class="line"><span class="css"><span class="xml">         &#125;</span></span></span><br><span class="line"><span class="css"><span class="xml">         <span class="selector-tag">body</span> &#123;</span></span></span><br><span class="line"><span class="css"><span class="xml">             <span class="attribute">height</span>: <span class="number">100%</span>;</span></span></span><br><span class="line"><span class="css"><span class="xml">             <span class="attribute">overflow</span>: hidden;</span></span></span><br><span class="line"><span class="css"><span class="xml">         &#125;</span></span></span><br><span class="line"><span class="css"><span class="xml">         <span class="selector-class">.father</span>&#123;</span></span></span><br><span class="line"><span class="css"><span class="xml">             <span class="attribute">position</span>: absolute;</span></span></span><br><span class="line"><span class="css"><span class="xml">             <span class="attribute">height</span>: <span class="number">500px</span>;</span></span></span><br><span class="line"><span class="css"><span class="xml">             <span class="attribute">width</span>: <span class="number">100%</span>;</span></span></span><br><span class="line"><span class="css"><span class="xml">             <span class="attribute">background-color</span>:<span class="number">#2AABD2</span>;</span></span></span><br><span class="line"><span class="css"><span class="xml">         &#125;</span></span></span><br><span class="line"><span class="css"><span class="xml">         <span class="selector-class">.children</span></span></span></span><br><span class="line"><span class="css"><span class="xml">         &#123;</span></span></span><br><span class="line"><span class="css"><span class="xml">             <span class="attribute">width</span>: <span class="number">300px</span>;</span></span></span><br><span class="line"><span class="css"><span class="xml">             <span class="attribute">height</span>: <span class="number">150px</span>;</span></span></span><br><span class="line"><span class="css"><span class="xml">             <span class="attribute">background-color</span>: <span class="number">#333333</span>;</span></span></span><br><span class="line"><span class="css"><span class="xml"></span></span></span><br><span class="line"><span class="css"><span class="xml">             <span class="attribute">position</span>: relative;</span></span></span><br><span class="line"><span class="css"><span class="xml">             <span class="attribute">top</span>: <span class="number">50%</span>;</span></span></span><br><span class="line"><span class="css"><span class="xml">             <span class="attribute">left</span>: <span class="number">50%</span>;</span></span></span><br><span class="line"><span class="css"><span class="xml">             <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">50%</span>) <span class="built_in">translateY</span>(-<span class="number">50%</span>);</span></span></span><br><span class="line"><span class="css"><span class="xml">         &#125;</span></span></span><br><span class="line"><span class="css"><span class="xml">     </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">         <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;children&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">         <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="55-less、sass-是什么？为什么要用它？"><a href="#55-less、sass-是什么？为什么要用它？" class="headerlink" title="55. less、sass 是什么？为什么要用它？"></a>55. <em>less、sass</em> 是什么？为什么要用它？</h3><blockquote>
<p>参考答案：</p>
<p><em>Less</em> 和 <em>Sass</em> 被称之为 <em>CSS</em> 预处理器。</p>
<p><em>CSS</em> 预处理器可以为 <em>CSS</em> 增加变编程特性，通过编译器将使用新语法的文件输出为一个 <em>CSS</em> 文件，解决 <em>CSS</em> 难以复用、代码冗余、可维护性低的缺点。常见的预处理器有 <em>less、sass、stylus</em>。</p>
<p>使用他们来书写 <em>CSS</em> 代码可以更符合编程思维、简化代码、提高代码重用、便于维护。</p>
</blockquote>
<h3 id="56-如何隐藏一个-DOM-元素"><a href="#56-如何隐藏一个-DOM-元素" class="headerlink" title="56. 如何隐藏一个 DOM 元素"></a>56. 如何隐藏一个 <em>DOM</em> 元素</h3><blockquote>
<p>参考答案：</p>
<ol>
<li><em>display: none;</em></li>
<li><em>visibility: hidden;</em></li>
<li><em>opacity: 0;</em></li>
</ol>
</blockquote>
<h3 id="57-你怎么处理页面兼容性问题？"><a href="#57-你怎么处理页面兼容性问题？" class="headerlink" title="57. 你怎么处理页面兼容性问题？"></a>57. 你怎么处理页面兼容性问题？</h3><blockquote>
<p>参考答案：</p>
<ol>
<li>统一标准模式</li>
<li>利用 <em>CSS</em> 重置技术初始化默认样式</li>
<li>针对不同浏览器采用不同的解决方案</li>
<li>使用 <em>CSS Hack</em> 技术</li>
</ol>
</blockquote>
<h3 id="58-CSS-引用的方式有哪些？link-和-import-的区别？"><a href="#58-CSS-引用的方式有哪些？link-和-import-的区别？" class="headerlink" title="58. CSS 引用的方式有哪些？link 和 @import 的区别？"></a>58. <em>CSS</em> 引用的方式有哪些？<em>link</em> 和 <em>@import</em> 的区别？</h3><blockquote>
<p>参考答案：</p>
<p><em>CSS</em> 引用的方式有：</p>
<ul>
<li>外联，通过 <em>link</em> 标签外部链接样式表</li>
<li>内联，在 <em>head</em> 标记中使用 <em>style</em> 标记定义样式</li>
<li>嵌入，在元素的开始标记里通过 <em>style</em> 属性定义样式</li>
</ul>
<p><em>link</em> 和 <em>@import</em> 的区别：</p>
<ol>
<li><p><strong><em>link</em> 属于 <em>HTML</em> 标签，而 <em>@import</em> 完全是 <em>CSS</em> 提供的一种方式。</strong></p>
<p><em>link</em> 标签除了可以加载 <em>CSS</em> 外，还可以做很多其它的事情，比如定义 <em>RSS</em>，定义 <em>rel</em> 连接属性等，*@import* 就只能加载 <em>CSS</em> 了。</p>
</li>
<li><p><strong>加载顺序的差别。</strong></p>
<p>比如，在 <em>a.css</em> 中使用 <em>import</em> 引用 <em>b.css</em>，只有当使用当使用 <em>import</em> 命令的宿主 <em>css</em> 文件 <em>a.css</em> 被下载、解析之后，浏览器才会知道还有另外一个 <em>b.css</em> 需要下载，这时才去下载，然后下载后开始解析、构建 <em>render tree</em> 等一系列操作.</p>
</li>
<li><p><strong>兼容性的差别。</strong></p>
<p>由于 <em>@import</em> 是 <em>CSS2.1</em> 提出的所以老的浏览器不支持，*@import* 只有在 <em>IE5</em> 以上的才能识别，而 <em>link</em> 标签无此问题。</p>
</li>
<li><p><strong>当使用 <em>JS</em> 控制 <em>DOM</em> 去改变样式的时候，只能使用 <em>link</em> 标签，因为 <em>@import</em> 不是 <em>DOM</em> 可以控制的</strong>。</p>
<p>对于可换皮肤的网站而言，可以通过改变 <em>link</em> 便签这两个的 <em>href</em> 值来改变应用不用的外部样式表，但是对于 <em>import</em> 是无法操作的，毕竟不是标签。</p>
</li>
</ol>
</blockquote>
<h3 id="59-CSS-动画如何实现？"><a href="#59-CSS-动画如何实现？" class="headerlink" title="59. CSS 动画如何实现？"></a>59. <em>CSS</em> 动画如何实现？</h3><blockquote>
<p>参考答案：</p>
<p>即 <em>animation</em> 属性，对元素某个或多个属性的变化进行控制，可以设置多个关键帧。属性包含了动画的名称、完成时间（以毫秒计算）、周期、间隔、播放次数、是否反复播放、不播放时应用的样式、动画暂停或运行。</p>
<p>它不需要触发任何事件就可以随着时间变化来改变元素的样式。</p>
<p><strong>使用 <em>CSS</em> 做动画</strong>：</p>
<ul>
<li><em>@keyframes</em> 规定动画。       </li>
<li><em>animation</em> 所有动画属性的简写属性。     </li>
<li><em>animation-name</em> 规定 <em>@keyframes</em> 动画的名称。</li>
<li><em>animation-duration</em> 规定动画完成一个周期所花费的秒或毫秒。默认是 0。      </li>
<li><em>animation-timing-function</em> 规定动画的速度曲线。默认是 <em>ease</em>。           </li>
<li><em>animation-fill-mode</em> 规定当动画不播放时（当动画完成时，或当动画有一个延迟未开始播放时），要应用到元素的样式。   </li>
<li><em>animation-delay</em> 规定动画何时开始。默认是 <em>0</em>。    </li>
<li><em>animation-iteration-count</em>  规定动画被播放的次数。默认是 <em>1</em>。    </li>
<li><em>animation-direction</em> 规定动画是否在下一周期逆向地播放。默认是 <em>normal</em>。</li>
<li><em>animation-play-state</em> 规定动画是否正在运行或暂停。默认是 <em>running</em>。</li>
</ul>
</blockquote>
<h3 id="60-display：inline-block-在什么情况下会产生间隙？"><a href="#60-display：inline-block-在什么情况下会产生间隙？" class="headerlink" title="60. display：inline-block 在什么情况下会产生间隙？"></a>60. <em>display：inline-block</em> 在什么情况下会产生间隙？</h3><blockquote>
<p>参考答案：</p>
<p><strong>空隙产生的原因</strong></p>
<p>元素被当成行内元素排版的时候，元素之间的空白符（空格、回车换行等）都会被浏览器处理，根据 white-space 的处理方式（默认是 normal，合并多余空白），原来 HTML 代码中的回车换行被转成一个空白符，在字体不为 0 的情况下，空白符占据一定宽度，所以 inline-block 的元素之间就出现了空隙。</p>
<p>这些元素之间的间距会随着字体的大小而变化，例如：当行内元素 font-size:16px 时，间距为8px。</p>
<p><strong>解决空隙的办法</strong></p>
<ol>
<li>办法一：解决元素之间的空白符</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 将前一个标签结束符和后一个标签开始符写在同一行 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>child1</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>child2</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 将所有子元素写在同一行 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>child1<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>child2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>缺点：代码的<strong>可读性变差。</strong></p>
<ol start="2">
<li>方法二：为父元素中设置 font-size: 0，在子元素上重置正确的 font-size</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span> <span class="attr">style</span>=<span class="string">&quot;font-size: 0px&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span> <span class="attr">style</span>=<span class="string">&quot;font-size: 16px&quot;</span>&gt;</span>child1<span class="tag">&lt;/<span class="name">div</span>&gt;</span>  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span> <span class="attr">style</span>=<span class="string">&quot;font-size: 16px&quot;</span>&gt;</span>child2<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>缺点：inline-block 元素必须设定字体，不然行内元素中的字体不会显示。 增加了代码量。</p>
<ol start="3">
<li>方法三：为 inline-block 元素添加样式 float:left</li>
</ol>
<p>缺点：<strong>float布局会有高度塌陷</strong>问题</p>
<ol start="4">
<li>方法四：设置子元素margin值为负数</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> <span class="selector-class">.child</span> + <span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">2px</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：元素之间间距的大小与上下文字体大小相关；并且同一大小的字体，元素之间的间距在不同浏览器下是不一样的。</p>
<p>如：font-size:16px时，Chrome下元素之间的间距为  8px,而 Firefox 下元素之间的间距为 4px。所以不同浏览器下 margin-right 的负值是不一样的，因此这个方法不通用。</p>
<p>注意：当 marigin-right 使用相对单位 em 来表示时，Chrome 下可以正常去除间距,而 Firefox 下元素之间有重叠。</p>
<ol start="5">
<li>方法五：最优解在这，设置父元素，display:table 和 word-spacing</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: table;</span><br><span class="line">  <span class="attribute">word-spacing</span>:-<span class="number">1em</span>; <span class="comment">/*兼容其他浏览器，题主还未验证*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="61-position-和-display、overflow-发生重叠时会发生什么？"><a href="#61-position-和-display、overflow-发生重叠时会发生什么？" class="headerlink" title="61. position 和 display、overflow 发生重叠时会发生什么？"></a>61. <em>position</em> 和 <em>display、overflow</em> 发生重叠时会发生什么？</h3><blockquote>
<p>参考答案：</p>
<p>浮动的行内变成块级元素，绝对定位的行内也会变成块级元素。绝对定位时浮动失效，top,bottom,left,right能改变位置。相邻普通流块级垂直方向margin叠压。浮动，inline-block，绝对定位不会和垂直方向其他元素margin叠压。BFC不会和子元素margin叠压。(absolute,fixed都是绝对定位)</p>
</blockquote>
<h3 id="62-什么是选择器？有哪些选择器？"><a href="#62-什么是选择器？有哪些选择器？" class="headerlink" title="62. 什么是选择器？有哪些选择器？"></a>62. 什么是选择器？有哪些选择器？</h3><blockquote>
<p>参考答案：</p>
<p>选择器决定将样式应用在哪个或哪些元素身上。</p>
<ul>
<li>元素选择器：例如 <em>div{…} p{…}</em></li>
<li>id 选择器： 例如 <em>#box{…}</em></li>
<li>类选择器： 例如 <em>.box{…}</em></li>
<li>属性选择器：*[href=”#”]{…}*</li>
<li>通配：*{…}</li>
<li>组合（并集）选择器：<em>div,p,a,.main{…}</em></li>
<li>交集选择器：<em>input[type=”text”]{…}</em></li>
<li>后代选择器：<em>header nav{…}</em></li>
<li>子级选择器： <em>ul&gt;li{…}</em></li>
<li>伪类选择器：<ul>
<li><em>:nth-child(num){…}</em></li>
<li><em>:nth-child(odd){…}</em></li>
<li><em>:nth-child(even){…}</em></li>
<li><em>:nth-of-type{…}</em></li>
<li><em>:first-child{…}</em></li>
<li><em>:last-child{…}</em></li>
<li><em>only-child{…}</em></li>
<li><em>a:link{…}</em></li>
<li><em>a:visited{…}</em></li>
<li><em>:hover{…}</em></li>
<li><em>a:active{…}</em></li>
</ul>
</li>
<li>伪元素选择器：<ul>
<li><em>::before{…}</em></li>
<li><em>::after{…}</em></li>
<li><em>::first-letter{…}</em></li>
<li><em>::first-line{…}</em></li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="63-什么是继承？CSS-中哪些属性可以继承？哪些不可以继承？"><a href="#63-什么是继承？CSS-中哪些属性可以继承？哪些不可以继承？" class="headerlink" title="63. 什么是继承？CSS 中哪些属性可以继承？哪些不可以继承？"></a>63. 什么是继承？<em>CSS</em> 中哪些属性可以继承？哪些不可以继承？</h3><blockquote>
<p>参考答案：</p>
<ul>
<li>继承，指元素可以自动获得祖先元素的某些 <em>CSS</em> 属性。通常来说文本类的属性具有继承性。</li>
<li>文本类的样式可以继承：例如 <em>color、 font-size、 line-height、 font-family、 font-weight、 font-weight、 text-decoration、 letter-spacing、text-align</em> 等等</li>
<li><em>display、 margin、 padding、 border、 background、 position、 float</em> 等则不会被继承</li>
</ul>
</blockquote>
<h3 id="64-谈谈你对响应式的理解。"><a href="#64-谈谈你对响应式的理解。" class="headerlink" title="64. 谈谈你对响应式的理解。"></a>64. 谈谈你对响应式的理解。</h3><blockquote>
<p>参考答案：</p>
<p>响应式布局是 <em>Ethan Marcotte</em> 在2010年5月提出的一个概念。即页面的设计与开发应当根据用户行为，以及设备环境进行相应的响应与调整。能让一个网站兼容多个终端，展示出不同的结构样式，而不是为每个终端做一个特定的版本。</p>
<p>具体的实践方式可由多方面组成，包括使用 <em>flex</em> 布局、使用 <em>CSS3</em>  媒介查询 <em>media query</em> 实现。其特点在于灵活性较强，但缺点在于兼容性较差、工作量巨大、代码冗余、网页加载时间过长。</p>
</blockquote>
<h3 id="65-CSS-的计算属性知道吗"><a href="#65-CSS-的计算属性知道吗" class="headerlink" title="65. CSS 的计算属性知道吗"></a>65. <em>CSS</em> 的计算属性知道吗</h3><blockquote>
<p>参考答案：</p>
<p>即 <em>calc( )</em> 函数，主要用于指定元素的长度，支持所有 CSS 长度单位，运算符前后都需要保留一个空格。</p>
<p>比如： <em>width: calc(100% - 50px);</em></p>
</blockquote>
<h3 id="66-为何-CSS-放在-HTML-头部？"><a href="#66-为何-CSS-放在-HTML-头部？" class="headerlink" title="66. 为何 CSS 放在 HTML 头部？"></a>66. 为何 <em>CSS</em> 放在 <em>HTML</em> 头部？</h3><blockquote>
<p>参考答案：</p>
<p>为了尽早让浏览器拿到 <em>CSS</em> 并且生成 <em>CSSOM</em>，然后与 <em>HTML</em> 一次性生成最终的 <em>RenderTree</em>，渲染一次即可。如果放在 <em>HTML</em> 底部，会出现渲染卡顿的现象影响性能和用户体验。</p>
</blockquote>
<h3 id="67-background-size-有哪-4-种值类型？"><a href="#67-background-size-有哪-4-种值类型？" class="headerlink" title="67. background-size 有哪 4 种值类型？"></a>67. <em>background-size</em> 有哪 <em>4</em> 种值类型？</h3><blockquote>
<p>参考答案：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background-size</span>: length|percentage|cover|contain;</span><br></pre></td></tr></table></figure>

<ul>
<li><em>length</em>：设置背景图片高度和宽度。第一个值设置宽度，第二个值设置的高度。如果只给出一个值，第二个是设置为 auto(自动)</li>
<li><em>percentage</em>：将计算相对于背景定位区域的百分比。第一个值设置宽度，第二个值设置的高度。如果只给出一个值，第二个是设置为“<em>auto</em>(自动)”</li>
<li><em>cover</em>：此时会保持图像的纵横比并将图像缩放成将完全覆盖背景定位区域的最小大小。</li>
<li><em>contain</em>：此时会保持图像的纵横比并将图像缩放成将适合背景定位区域的最大大小。</li>
</ul>
</blockquote>
<h3 id="68-transition、transform、animate-的区别？"><a href="#68-transition、transform、animate-的区别？" class="headerlink" title="68. transition、transform、animate 的区别？"></a>68. <em>transition、transform、animate</em> 的区别？</h3><blockquote>
<p>参考答案：</p>
<p>transition：过渡效果，它有4个属性：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transition</span>: property duration timing-function delay;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>property ：css属性的名称</p>
</li>
<li><p>duration ：多长时间完成</p>
</li>
<li><p>timing-function：转速曲线</p>
</li>
<li><p>delay：开始的时候。</p>
</li>
</ul>
<p>transform： 应用于元素的 2D 或 3D 转换。这个属性允许你将元素旋转，缩放，移动，倾斜等。</p>
<ul>
<li>旋转：rotate</li>
<li>缩放：scale</li>
<li>移动：translate</li>
<li>倾斜：skew</li>
</ul>
<p>animate：应用动画效果。语法如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">animation</span>: name duration timing-function delay iteration-count direction fill-mode play-state;</span><br></pre></td></tr></table></figure>

<ul>
<li>name ：定义的名称</li>
<li>duration ：多长时间完成</li>
<li>delay ：开始前多长的延迟</li>
<li>iteration-count：播放几次</li>
<li>direction ：指定是否应该轮流反向播放动画。</li>
<li>fill-mode：结束的状态</li>
<li>play-state：指定动画是否正在运行或已暂停。</li>
</ul>
</blockquote>
<h3 id="69-描述-CSS-reset-的作用和用途？"><a href="#69-描述-CSS-reset-的作用和用途？" class="headerlink" title="69. 描述 CSS reset 的作用和用途？"></a>69. 描述 <em>CSS reset</em> 的作用和用途？</h3><blockquote>
<p>参考答案：</p>
<p>因为不同浏览器间的内核存在差异，对于标记都有自己默认的样式用来保证在没有自定样式的情况下也能被排列、渲染。但各个厂家有自己的风格样式，想要样式不被浏览器默认样式影响，就需要清除默认样式，使各浏览器表现得一致。</p>
</blockquote>
<h3 id="70-在-CSS-中，关于盒子的-margin-属性叙述正确的是"><a href="#70-在-CSS-中，关于盒子的-margin-属性叙述正确的是" class="headerlink" title="70. 在 CSS 中，关于盒子的 margin 属性叙述正确的是"></a>70. 在 <em>CSS</em> 中，关于盒子的 <em>margin</em> 属性叙述正确的是</h3><p>A.  边距 margin 只能取一个值  </p>
<p>B.  margin 边距的属性有 margin-left、margin-right、margin-top、margin-bottom</p>
<p>C. margin 属性的值不可为 auto  </p>
<p>D. margin 的参数值不能全部设置为 0px</p>
<blockquote>
<p>参考答案：</p>
<p>B</p>
</blockquote>
<blockquote>
<p>解析：</p>
<p>选项 A，margin 能够设置四个方向的值</p>
<p>选项 C，可以为 auto</p>
<p>选项 D，可以设置为 0px</p>
</blockquote>
<h3 id="71-以下代码中，属于相对定位的是"><a href="#71-以下代码中，属于相对定位的是" class="headerlink" title="71. 以下代码中，属于相对定位的是"></a>71. 以下代码中，属于相对定位的是</h3><p>A. <code>#b&#123;width:100px; position:relative&#125;</code></p>
<p>B. <code>#b&#123;width:100px; position:static&#125;</code></p>
<p>C. <code>#b&#123;width:100px;&#125;</code></p>
<p>D. <code>#b&#123;width:100px; position:absolute&#125;</code></p>
<blockquote>
<p>参考答案：</p>
<p>A</p>
</blockquote>
<blockquote>
<p>解析：</p>
<p>B 和 C 都是静态定位，D 是绝对定位</p>
</blockquote>
<h3 id="72-以下选项中不能实现清除浮动的是（-）"><a href="#72-以下选项中不能实现清除浮动的是（-）" class="headerlink" title="72. 以下选项中不能实现清除浮动的是（ ）"></a>72. 以下选项中不能实现清除浮动的是（ ）</h3><p>A.  空 div</p>
<p>B. hover 伪选择器</p>
<p>C. clear 属性</p>
<p>D. overflow 属性</p>
<blockquote>
<p>参考答案：</p>
<p>B</p>
<p>A、C、D 是常用的清除浮动的方式，B 是为元素添加 hover 效果</p>
</blockquote>
<h3 id="73-关于-z-index-属性叙述正确的是（-）"><a href="#73-关于-z-index-属性叙述正确的是（-）" class="headerlink" title="73. 关于 z-index 属性叙述正确的是（ ）"></a>73. 关于 <em>z-index</em> 属性叙述正确的是（ ）</h3><p>A. 必须与 postion 一起使用才能生效，此时 postion 取任何值都可以</p>
<p>B. 此值越大，层的顺序越往下</p>
<p>C. 一般后添加的元素，其 z-index 值越大</p>
<p>D.  即使上面的层没有任何内容也会挡住下面的层，使下面的层显示不出来</p>
<blockquote>
<p>参考答案：</p>
<p>C</p>
</blockquote>
<blockquote>
<p>解析：</p>
<p>选项 A 确实要和 postion 一起使用，但是不是任何值都可以，z-index 仅能在定位元素上奏效（例如 absolute）</p>
<p>选项 B 值越大，层的顺序越在上面</p>
<p>选项 D，如果当前层没有内容或者内容是透明的，是可以看到下面的层的内容的</p>
</blockquote>
<h3 id="74-有一个高度自适应的-div，里面有-2-个-div，一个高度-100px，希望另一个填满剩下的高度？（CSS-实现）"><a href="#74-有一个高度自适应的-div，里面有-2-个-div，一个高度-100px，希望另一个填满剩下的高度？（CSS-实现）" class="headerlink" title="74. 有一个高度自适应的 div，里面有 2 个 div，一个高度 100px，希望另一个填满剩下的高度？（CSS 实现）"></a>74. 有一个高度自适应的 div，里面有 2 个 div，一个高度 100px，希望另一个填满剩下的高度？（CSS 实现）</h3><blockquote>
<p>参考答案：</p>
<p>方法一：利用定位</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">0px</span>;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">0px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line"><span class="attribute">position</span>: relative;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box1</span> &#123;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box2</span> &#123;</span><br><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line"><span class="attribute">top</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">bottom</span>: <span class="number">0px</span>;</span><br><span class="line"><span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：利用计算属性<em>calc</em></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">0px</span>;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">0px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box1</span> &#123;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box2</span> &#123;</span><br><span class="line"><span class="attribute">height</span>: <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">100px</span>);</span><br><span class="line"><span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="75-display-有哪些值？说明他们的作用。"><a href="#75-display-有哪些值？说明他们的作用。" class="headerlink" title="75. display 有哪些值？说明他们的作用。"></a>75. <em>display</em> 有哪些值？说明他们的作用。</h3><blockquote>
<p>参考答案：</p>
<p>常用的有：</p>
<ul>
<li><em>none</em>：此元素不显示。</li>
<li><em>block</em>：将元素显示为块级元素，前后会带换行符。</li>
<li><em>inline</em>：默认值，元素会被显示为内联元素，前后没有换行符。</li>
<li><em>inline-block</em>：行内块级元素。</li>
</ul>
</blockquote>
<h3 id="76-position-的值-relative-和-absolute-的定位原点是？"><a href="#76-position-的值-relative-和-absolute-的定位原点是？" class="headerlink" title="76. position 的值 relative 和 absolute 的定位原点是？"></a>76. <em>position</em> 的值 <em>relative</em> 和 <em>absolute</em> 的定位原点是？</h3><blockquote>
<p>参考答案：</p>
<ul>
<li><strong>absolute</strong>：生成绝对定位的元素，定位原点是离自己这一级元素最近的一级 <em>position</em> 设置为 <em>absolute</em> 或者 <em>relative</em> 的父元素的左上角为原点的。</li>
<li><strong>relative</strong>：生成相对定位的元素，定位原点是元素本身所在位置。</li>
</ul>
</blockquote>
<h3 id="77-当-margin-top、padding-top-的值是百分比时，分别是如何计算的？"><a href="#77-当-margin-top、padding-top-的值是百分比时，分别是如何计算的？" class="headerlink" title="77. 当 margin-top、padding-top 的值是百分比时，分别是如何计算的？"></a>77. 当 margin-top、padding-top 的值是百分比时，分别是如何计算的？</h3><p>A. 相对父级元素的 height，相对自身的 height</p>
<p>B. 相对最近父级块级元素的 height，相对自身的 height</p>
<p>C. 相对父级元素的 width，相对自身的 width</p>
<p>D. 相对最近父级块级元素的 width，相对最近父级块级元素的 width</p>
<blockquote>
<p>参考答案：</p>
<p>D</p>
<p>可以对元素的margin设置百分数，百分数是相对于父元素的width计算，不管是margin-top/margin-bottom还是margin-left/margin-right。（padding同理）</p>
<p>如果没有为元素声明width，在这种情况下，元素框的总宽度包括外边距取决于父元素的width，这样可能得到“流式”页面，即元素的外边距会扩大或缩小以适应父元素的实际大小。如果对这个文档设置样式，使其元素使用百分数外边距，当用户修改浏览窗口的宽度时，外边距会随之扩大或缩小。</p>
</blockquote>
<h3 id="78-伪元素-before-after-的作用？"><a href="#78-伪元素-before-after-的作用？" class="headerlink" title="78. 伪元素 :before :after 的作用？"></a>78. 伪元素 <em>:before :after</em> 的作用？</h3><blockquote>
<p>参考答案：</p>
<p>特有的 <em>content</em> 可用于在 <em>CSS</em> 中向元素的头部或尾部添加内容，常用于制作小图标。</p>
</blockquote>
<h3 id="79-如何使用选择器来隐藏第一个列表项目？"><a href="#79-如何使用选择器来隐藏第一个列表项目？" class="headerlink" title="79. 如何使用选择器来隐藏第一个列表项目？"></a>79. 如何使用选择器来隐藏第一个列表项目？</h3><blockquote>
<p>参考答案：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">ul</span>&gt;<span class="selector-tag">li</span><span class="selector-pseudo">:first</span>-child&#123; </span><br><span class="line"><span class="attribute">display</span>: none; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="80-transition-和-animation-的区别以及应用场景？"><a href="#80-transition-和-animation-的区别以及应用场景？" class="headerlink" title="80. transition 和 animation 的区别以及应用场景？"></a>80. <em>transition</em> 和 <em>animation</em> 的区别以及应用场景？</h3><blockquote>
<p>参考答案：</p>
<ul>
<li>区别：<ol>
<li>触发条件不同。<em>transition</em> 通常需要交互，由事件触发。<em>animation</em> 则与 <em>gif</em> 动图差不多，立即播放。</li>
<li>循环。<em>animation</em> 可以设定循环次数。</li>
<li>精确性。<em>animation</em> 可以设定每一帧的样式和时间，其中的每一帧都可以有单独的变化。而 <em>transition</em> 中的所有样式都是一起变化的。</li>
<li>与 <em>JS</em> 的交互。使用 <em>JS</em> 去操作时，transition 更多。</li>
</ol>
</li>
<li>应用场景：<ol>
<li>如果需要灵活定制多帧以及循环，使用 <em>animation</em> 。</li>
<li>如果只是简单的从 XX 样式变到 XX 样式，两者皆可。</li>
<li>如果要使用 JS 设定动画，使用 <em>transition</em> 。</li>
</ol>
</li>
</ul>
</blockquote>
<h3 id="81-在-rem-自适应页面中使用-sprite-会出现背景图不随元素放大缩小的情况，如何解决？"><a href="#81-在-rem-自适应页面中使用-sprite-会出现背景图不随元素放大缩小的情况，如何解决？" class="headerlink" title="81. 在 rem 自适应页面中使用 sprite 会出现背景图不随元素放大缩小的情况，如何解决？"></a>81. 在 <em>rem</em> 自适应页面中使用 <em>sprite</em> 会出现背景图不随元素放大缩小的情况，如何解决？</h3><blockquote>
<p>参考答案：</p>
<p>将 <em>backgroud-size</em> 也换算为 <em>rem</em> 作为单位。</p>
</blockquote>
<h3 id="82-Normalize-是什么？"><a href="#82-Normalize-是什么？" class="headerlink" title="82. Normalize 是什么？"></a>82. <em>Normalize</em> 是什么？</h3><blockquote>
<p>参考答案：</p>
<p>一个样式表的重置文件。因为不同浏览器间的内核存在差异，对于标记都有自己默认的样式用来保证在没有自定样式的情况下也能被排列、渲染。但各个厂家有自己的风格样式，想要样式不被浏览器默认样式影响，就需要清除默认样式，使各浏览器表现得一致。</p>
</blockquote>
<h3 id="83-谈一谈-CSS-中的-2D-转换。"><a href="#83-谈一谈-CSS-中的-2D-转换。" class="headerlink" title="83. 谈一谈 CSS 中的 2D 转换。"></a>83. 谈一谈 <em>CSS</em> 中的 <em>2D</em> 转换。</h3><blockquote>
<p>参考答案：</p>
<p>即 <em>transform</em>，能够对元素进行移动、缩放、拉伸。</p>
<ol>
<li><em>translate(x, y)</em>: 元素从当前位置根据给定的 x 坐标 y 坐标移动。</li>
<li><em>rotate(angle)</em>: 元素顺时针旋转指定的角度，若为负值则逆时针旋转。</li>
<li><em>scale(num, num)</em>: 放大或缩小元素。</li>
<li><em>skew(angle, angle)</em>: 围绕 X Y 轴进行转动。</li>
</ol>
</blockquote>
<h3 id="84-谈一谈-CSS3-多列属性是什么？以及其使用场景"><a href="#84-谈一谈-CSS3-多列属性是什么？以及其使用场景" class="headerlink" title="84. 谈一谈  CSS3 多列属性是什么？以及其使用场景"></a>84. 谈一谈  <em>CSS3</em> 多列属性是什么？以及其使用场景</h3><blockquote>
<p>参考答案：</p>
<p>多列布局是 <em>CSS3</em> 新增的一组属性，常用的属性如下：</p>
<ul>
<li><em>column-count: num</em>: 规定元素被分隔的列数。</li>
<li><em>column-gap: num</em>; 规定列之间的间隔。</li>
<li><em>column-rule: width style color</em>: 规定列之间的样式规则。</li>
</ul>
<p>更多多列布局相关属性可以参阅：<em><a href="https://www.runoob.com/css3/css3-multiple-columns.html">https://www.runoob.com/css3/css3-multiple-columns.html</a></em></p>
<p>应用场景：可以将文本内容设计成像报纸一样的多列布局。</p>
</blockquote>
<h3 id="85-vw、vh-是什么？"><a href="#85-vw、vh-是什么？" class="headerlink" title="85. vw、vh 是什么？"></a>85. <em>vw、vh</em> 是什么？</h3><blockquote>
<p>参考答案：</p>
<p><em>vw</em> 和 <em>vh</em> 是 <em>CSS3</em> 新单位，即 <em>view width</em> 可视窗口宽度 和 <em>view height</em> 可视窗口高度。1<em>vw</em> 就等于可视窗口宽度的百分之一，1<em>vh</em> 就等于可视窗口高度的百分之一。</p>
</blockquote>
<h3 id="86-如何通过选择器选择-3-的倍数？"><a href="#86-如何通过选择器选择-3-的倍数？" class="headerlink" title="86. 如何通过选择器选择 3 的倍数？"></a>86. 如何通过选择器选择 <em>3</em> 的倍数？</h3><blockquote>
<p>参考答案：</p>
<p><em>:nth-child(3n){…}</em></p>
</blockquote>
<h3 id="87-页面布局有几种方式？"><a href="#87-页面布局有几种方式？" class="headerlink" title="87. 页面布局有几种方式？"></a>87. 页面布局有几种方式？</h3><blockquote>
<p>参考答案：</p>
<ol>
<li>固定宽度布局：为网页设置一个固定的宽度，通常以 <em>px</em> 做为长度单位，常见于 <em>PC</em> 端网页。</li>
<li>流式布局：为网页设置一个相对的宽度，通常以百分比做为长度单位。</li>
<li>栅格化布局：将网页宽度人为的划分成均等的长度，然后排版布局时则以这些均等的长度做为度量单位，通常利用百分比做为长度单位来划分成均等的长度。</li>
<li>响应式布局：通过检测设备信息，决定网页布局方式，即用户如果采用不同的设备访问同一个网页，有可能会看到不一样的内容，一般情况下是检测设备屏幕的宽度来实现。</li>
</ol>
</blockquote>
<h3 id="88-什么是流式布局？"><a href="#88-什么是流式布局？" class="headerlink" title="88. 什么是流式布局？"></a>88. 什么是流式布局？</h3><blockquote>
<p>参考答案：</p>
<p>即 <em>Fluid Layout</em> 。这种布局方式在前端开发的早期历史上用来应对不同尺寸的 PC 屏幕，那时的屏幕尺寸差异不会太大，在当今的移动设备开发也常用。</p>
<p>流式布局是页面元素宽度依照屏幕分辨率进行适配调整，但整体布局不变，其代表就是栅格系统（网格布局）。划分区域的尺寸使用百分比（通常也会搭配 min-* 或 max-*）。例如设置网页主体宽度为 85%，min-width 为 960px，图片也做类似的处理 width: 100%; max-width 设置为图片本身尺寸以防止被拉伸变形。</p>
<p>布局特点在于：屏幕分辨率发生变化时布局不变元素尺寸变。但缺点也很明显，如果屏幕尺寸跨度太大，那么在相对其原始设计而言过大过小的屏幕上就不能正常显示。</p>
</blockquote>
<h3 id="89-什么是静态布局？"><a href="#89-什么是静态布局？" class="headerlink" title="89. 什么是静态布局？"></a>89. 什么是静态布局？</h3><blockquote>
<p>参考答案：</p>
<p>即 <em>Static Layout</em>。传统的 <em>web</em> 设计，网页中所有元素的尺寸一律使用 <em>px</em> 作为单位。</p>
<p>布局特点在于：无论浏览器尺寸为多少，布局始终按照最初的设计稿布局来显示。常规的 PC 网站都是使用的静态（定宽度）布局，如果浏览器小于这个宽度则出现滚动条，如果浏览器大于这个宽度则内容居中或添加背景。这些设计方式是最常见的。</p>
<p>在 <em>PC</em> 中，居中布局，所有样式使用一个绝对宽度（定宽）适配当今主流屏幕宽度。在移动设备中，另外建立移动网站，单独设计一个布局，使用不同的域名，比如 <em>wap.</em> 或 *m.*。 </p>
<p>这种布局方案对于 UI 设计师和前端开发人员来说都是最简单、没有兼容性问题的。但缺点显而易见，需要做两次开发。当前大部门门户网站、企业宣传站点都采用了这种布局方式。</p>
</blockquote>
<h3 id="90-什么是自适应布局？什么是响应式布局？"><a href="#90-什么是自适应布局？什么是响应式布局？" class="headerlink" title="90. 什么是自适应布局？什么是响应式布局？"></a>90. 什么是自适应布局？什么是响应式布局？</h3><blockquote>
<p>参考答案：</p>
<p><strong>自适应布局</strong></p>
<p>即 <em>Adaptive Layout</em> ，可以把自适应布局看作是静态布局的一个系列。其特点就是分别为不同屏幕分辨率定义布局，即创建多个静态布局，每个静态布局对应一个屏幕分辨率范围，改变分辨率可以切换不同的静态布局，页面元素位置发生改变，元素不随窗口大小的调整而变化。</p>
<p>布局特点在于：屏幕分辨率变化时元素位置发生变化，尺寸不变。</p>
<p><strong>响应式布局</strong></p>
<p>即 <em>Responsive Layout</em>，其目标是确保一个页面在所有终端（各种尺寸的 PC、手机、电视等）都能完美展现，对于开发人员来说通常是结合了流式布局 + 弹性布局 + 媒介查询。分别为不同屏幕分辨率定义布局。</p>
<p>其特点在于：每个屏幕分辨率下都会有一个布局样式，元素位置、尺寸都会随之发生改变。使用多种布局方法配合，如果足够耐心效果完美。但缺点在于：媒介查询有限只能适应主流宽高，需要匹配足够多的屏幕大小工作量巨大，设计和开发都要需要多个版本。</p>
</blockquote>
<h3 id="91-对比各种布局方式的特点。"><a href="#91-对比各种布局方式的特点。" class="headerlink" title="91. 对比各种布局方式的特点。"></a>91. 对比各种布局方式的特点。</h3><blockquote>
<p>参考答案：</p>
<p>原理其实类似，都是检测设备，根据不同的设备采用不同的 <em>CSS</em>，而且 <em>CSS</em> 都是采取百分比的方式。不同点在于：</p>
<ul>
<li>响应式的模板在不同设备上看上去不同，会随着设备的改变而改变表现样式，常用于解决不同设备间分辨率间的兼容。</li>
<li>自适应则是所有设备看起来都是一个模板，不过就是元素长度、图片尺寸变化。</li>
<li>流式则是采用了一些设置，当宽度大于多少时将怎样展示，小于多少时将怎样展示，并且，展示方向像水流一样一部分一部分的加载。常用于解决分辨率差异较小的情况。</li>
<li>静态即采用固定宽度。</li>
</ul>
</blockquote>
<h3 id="92-文字超出了元素的宽度如何使用-CSS-处理？"><a href="#92-文字超出了元素的宽度如何使用-CSS-处理？" class="headerlink" title="92. 文字超出了元素的宽度如何使用 CSS 处理？"></a>92. 文字超出了元素的宽度如何使用 <em>CSS</em> 处理？</h3><blockquote>
<p>参考答案</p>
<p>可以使用 <em>word-wrap</em> 配合 <em>word-break</em> 属性来进行处理。</p>
<p>示例代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&gt;<span class="selector-tag">p</span>&#123;</span><br><span class="line">&gt;<span class="attribute">word-wrap</span>: break-word;</span><br><span class="line"><span class="attribute">word-break</span>: break-all;</span><br><span class="line"><span class="attribute">overflow</span>: hidden;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="93-内外边距取值-1-个、2-个、3-个、4-个参数分别表示什么意思？"><a href="#93-内外边距取值-1-个、2-个、3-个、4-个参数分别表示什么意思？" class="headerlink" title="93. 内外边距取值 1 个、2 个、3 个、4 个参数分别表示什么意思？"></a>93. 内外边距取值 <em>1</em> 个、<em>2</em> 个、<em>3</em> 个、<em>4</em> 个参数分别表示什么意思？</h3><blockquote>
<p>参考答案</p>
<ul>
<li>1个值： <em>margin {10px;}</em> 表示上右下左</li>
<li>2个值： <em>margin {10px 20px ;}</em> 表示上下 左右</li>
<li>3个值： <em>margin {10px 20px 30px;}</em> 表示上  左右 下</li>
<li>3个值： <em>margin {10px 20px 30px 40px ;}</em> 表示上 右 下 左</li>
</ul>
</blockquote>
<h3 id="94-处理长宽不固定的元素居中方案？"><a href="#94-处理长宽不固定的元素居中方案？" class="headerlink" title="94. 处理长宽不固定的元素居中方案？"></a>94. 处理长宽不固定的元素居中方案？</h3><blockquote>
<p>参考答案</p>
<ol>
<li>使用 <em>flex-box</em></li>
<li><em>ele { position: absolute; top: 50%; left: 50%; transform:translate(-50%;-50%);}</em></li>
</ol>
</blockquote>
<h3 id="95-三角形如果不使用图片实现，CSS-如何实现？"><a href="#95-三角形如果不使用图片实现，CSS-如何实现？" class="headerlink" title="95. 三角形如果不使用图片实现，CSS 如何实现？"></a>95. 三角形如果不使用图片实现，<em>CSS</em> 如何实现？</h3><blockquote>
<p>参考答案</p>
<p>设置块级元素宽高为 0，边框3条设置为透明色。具体可以参阅第 18 题答案</p>
</blockquote>
<h3 id="96-你在工作中是如何使用伪类的？列举一些常用的伪类以及用途。"><a href="#96-你在工作中是如何使用伪类的？列举一些常用的伪类以及用途。" class="headerlink" title="96. 你在工作中是如何使用伪类的？列举一些常用的伪类以及用途。"></a>96. 你在工作中是如何使用伪类的？列举一些常用的伪类以及用途。</h3><blockquote>
<p>参考答案</p>
<ol>
<li>快速选择到父元素中某一个子级元素</li>
<li>制作小图标 <em>icon</em></li>
<li>清除浮动</li>
<li>使用 <em>:not()</em> 排除一些不想选择的元素</li>
<li>使用 <em>:nth-child(3n)</em> 可以快速实现 “每N个实现XX效果”</li>
</ol>
</blockquote>
<h3 id="97-列举-flex-布局在你的实际项目里的使用，它能很方便的帮你做一些什么事情？"><a href="#97-列举-flex-布局在你的实际项目里的使用，它能很方便的帮你做一些什么事情？" class="headerlink" title="97. 列举 flex 布局在你的实际项目里的使用，它能很方便的帮你做一些什么事情？"></a>97. 列举 <em>flex</em> 布局在你的实际项目里的使用，它能很方便的帮你做一些什么事情？</h3><blockquote>
<p>参考答案</p>
<p><em>flex</em> 是根据主轴和交叉轴的方向来对元素进行排列，在不固定宽高的情况下可以很方便的帮助我们进行布局、居中、控制对齐方式。</p>
</blockquote>
<h3 id="98-如何将大量可变化的图片显示到页面并不影响浏览器性能？"><a href="#98-如何将大量可变化的图片显示到页面并不影响浏览器性能？" class="headerlink" title="98. 如何将大量可变化的图片显示到页面并不影响浏览器性能？"></a>98. 如何将大量可变化的图片显示到页面并不影响浏览器性能？</h3><blockquote>
<p>参考答案</p>
<p>使用图片懒加载。将页面中未出现在可视区域的图片先不做加载，等滚动到可视区域后，再加载。</p>
</blockquote>
<h3 id="99-图片与图片之间默认存在的间距如何去除？"><a href="#99-图片与图片之间默认存在的间距如何去除？" class="headerlink" title="99. 图片与图片之间默认存在的间距如何去除？"></a>99. 图片与图片之间默认存在的间距如何去除？</h3><blockquote>
<p>参考答案</p>
<ol>
<li>将图片全部脱离文档流</li>
<li>将图片父元素设置文字大小为 0</li>
</ol>
</blockquote>
<h3 id="100-阅读代码，计算元素在-W3C-盒模型中的宽度，和在-IE-盒模型中的宽度。"><a href="#100-阅读代码，计算元素在-W3C-盒模型中的宽度，和在-IE-盒模型中的宽度。" class="headerlink" title="100. 阅读代码，计算元素在 W3C 盒模型中的宽度，和在 IE 盒模型中的宽度。"></a>100. 阅读代码，计算元素在 <em>W3C</em> 盒模型中的宽度，和在 <em>IE</em> 盒模型中的宽度。</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考答案</p>
<ul>
<li>W3C 盒模型中的宽度: <em>width</em> + <em>padding</em> + <em>border</em> = 122<em>px</em></li>
<li><em>IE</em> 盒模型中的宽度： 100<em>px</em></li>
</ul>
</blockquote>
<h3 id="101-两个相邻兄弟元素如代码所示，此时两个元素之间的间隔是多少？"><a href="#101-两个相邻兄弟元素如代码所示，此时两个元素之间的间隔是多少？" class="headerlink" title="101. 两个相邻兄弟元素如代码所示，此时两个元素之间的间隔是多少？"></a>101. 两个相邻兄弟元素如代码所示，此时两个元素之间的间隔是多少？</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div style=&quot;margin-bottom: 20px;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div style=&quot;margin-top: 10px;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考答案</p>
<p>20<em>px</em>，由于两个元素见发生了外边距塌陷，所以中间的间隔就是取其中较大的值。</p>
</blockquote>
<h3 id="102-不使用-border-属性，使用其他属性模拟边框。"><a href="#102-不使用-border-属性，使用其他属性模拟边框。" class="headerlink" title="102. 不使用 border 属性，使用其他属性模拟边框。"></a>102. 不使用 border 属性，使用其他属性模拟边框。</h3><blockquote>
<p>参考答案</p>
<p>使用 <em>outline</em> 或 <em>box-shadow</em> 都可以模拟出边框。</p>
</blockquote>
<h3 id="103-阅读代码，计算-ul-的高度。"><a href="#103-阅读代码，计算-ul-的高度。" class="headerlink" title="103. 阅读代码，计算 ul 的高度。"></a>103. 阅读代码，计算 ul 的高度。</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ul style=&quot;overflow: hidden;&quot;&gt;</span><br><span class="line">  &lt;li style=&quot;height: 100px; float: left;&quot;&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考答案</p>
<p><em>ul</em> 的高度为 100<em>px</em>，虽然子级 <em>li</em> 浮动会造成父元素 <em>ul</em> 的高度塌陷，但父元素触发了 <em>BFC</em>，所以高度可以自动找回。</p>
</blockquote>
<h3 id="104-有哪些方式可以将-p-文字设置为红色？"><a href="#104-有哪些方式可以将-p-文字设置为红色？" class="headerlink" title="104. 有哪些方式可以将 p 文字设置为红色？"></a>104. 有哪些方式可以将 <em>p</em> 文字设置为红色？</h3><blockquote>
<p>参考答案</p>
<ol>
<li><p><em>color: red;</em></p>
</li>
<li><p><em>color: #f00;</em></p>
</li>
<li><p><em>color: #FF0000;</em></p>
</li>
<li><p><em>color: rgb(255, 0, 0);</em></p>
</li>
<li><p><em>color: hsl(120, 100%, 50%);</em></p>
</li>
</ol>
</blockquote>
<h3 id="105-如何使用媒体查询实现视口宽度大于-320px-小于-640px-时-div-元素宽度变成-30-？"><a href="#105-如何使用媒体查询实现视口宽度大于-320px-小于-640px-时-div-元素宽度变成-30-？" class="headerlink" title="105. 如何使用媒体查询实现视口宽度大于 320px 小于 640px 时 div 元素宽度变成 30%？"></a>105. 如何使用媒体查询实现视口宽度大于 320<em>px</em> 小于 640<em>px</em> 时 <em>div</em> 元素宽度变成 30%？</h3><blockquote>
<p>参考答案</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">320px</span>) <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">640px</span>)&#123;</span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">   <span class="attribute">width</span>: <span class="number">30%</span>;</span><br><span class="line">&#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="106-什么是-HTML-实体？"><a href="#106-什么是-HTML-实体？" class="headerlink" title="106. 什么是 HTML 实体？"></a>106. 什么是 <em>HTML</em> 实体？</h3><blockquote>
<p>参考答案</p>
<p>即对当前文档的编码方式不能包含的字符提供一种转义表示。例如对于 “&gt;” 符号，它是 HTML 元素的一部分，如果要在文档中显示就需要进行转义为“&amp;gt;”。</p>
</blockquote>
<h3 id="107-什么是全局属性？列举两个全局属性。"><a href="#107-什么是全局属性？列举两个全局属性。" class="headerlink" title="107. 什么是全局属性？列举两个全局属性。"></a>107. 什么是全局属性？列举两个全局属性。</h3><blockquote>
<p>参考答案</p>
<p>全局属性 <em>Global Attribute</em> 指全部元素都能使用的通用属性，与之对应的是局部属性 <em>Local Attribute</em> 。<em>class、contenteditable、onclick、data-</em> 都是全局属性。</p>
</blockquote>
<h3 id="108-什么是-hasLayout-触发-hasLayout-会有什么后果？"><a href="#108-什么是-hasLayout-触发-hasLayout-会有什么后果？" class="headerlink" title="108. 什么是 hasLayout? 触发 hasLayout 会有什么后果？"></a>108. 什么是 <em>hasLayout</em>? 触发 <em>hasLayout</em> 会有什么后果？</h3><blockquote>
<p>参考答案</p>
<p><em>hasLayout</em> 是微软的一个私有概念，类似于 <em>BFC</em> ，能够运行在早期的 <em>IE</em>6、7 当中，但在 <em>IE</em>8+ 已被抛弃。在早期 <em>IE</em> 浏览器中，元素会被分为：拥有布局（<em>hasLayout</em>）和没有布局，拥有布局的元素就可以控制自己内容的尺寸和位置，没有布局的元素需要由最近的拥有布局的祖先元素代劳。</p>
<p><em>IE6</em> 中很多 <em>bug</em> 都是由于元素没有布局所引起的，例如浮动元素会拥有双倍外边距。可以通过定义特定的属性来触发 <em>lasLayout</em>：</p>
<ol>
<li><em>float</em> 为 <em>left</em> 或 <em>right</em></li>
<li><em>position</em> 为 <em>absolute</em></li>
<li><em>width</em> <em>height</em> 不为 <em>auto</em></li>
<li><em>zoom</em> 不为 <em>normal</em></li>
</ol>
</blockquote>
<h3 id="109-在定位属性-position-中，哪个值会脱离文档流"><a href="#109-在定位属性-position-中，哪个值会脱离文档流" class="headerlink" title="109. 在定位属性 position 中，哪个值会脱离文档流?"></a>109. 在定位属性 <em>position</em> 中，哪个值会脱离文档流?</h3><blockquote>
<p>参考答案</p>
<p><em>absolute、fixed</em>。</p>
</blockquote>
<h3 id="110-假设视口的宽是-70px，高为-50px，执行下面代码后，div-元素的宽度为多少？"><a href="#110-假设视口的宽是-70px，高为-50px，执行下面代码后，div-元素的宽度为多少？" class="headerlink" title="110. 假设视口的宽是 70px，高为 50px，执行下面代码后，div 元素的宽度为多少？"></a>110. 假设视口的宽是 <em>70px</em>，高为 <em>50px</em>，执行下面代码后，<em>div</em> 元素的宽度为多少？</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  section&#123;</span><br><span class="line">    margin: 6px;</span><br><span class="line">  &#125;</span><br><span class="line">  div&#123;</span><br><span class="line">    width: 50vw;</span><br><span class="line">    height: 50vh;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;section&gt;</span><br><span class="line">   &lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;/section&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考答案</p>
<p><em>vw</em> 和 <em>vh</em> 单位，1<em>vw</em> 等于视口宽度的 1/100，1<em>vh</em> 等于视口高度的 1/100，即 1<em>vw</em> = 0.7<em>px</em>，1<em>vh</em> = 0.5<em>px</em>，0.7*50 = 35<em>px</em>，0.5*50 = 25<em>px</em> ，即 <em>div</em> 宽度为35<em>px</em>，高度25<em>px</em>。</p>
</blockquote>
<h3 id="111-伪元素-before-和-before-有什么区别？"><a href="#111-伪元素-before-和-before-有什么区别？" class="headerlink" title="111. 伪元素 ::before 和 :before 有什么区别？"></a>111. 伪元素 <em>::before</em> 和 <em>:before</em> 有什么区别？</h3><blockquote>
<p>参考答案</p>
<p>作用相同，但 <em>CSS3</em> 规范中为了区分伪类和伪元素，将 <em>:before</em> 改为了 <em>::before</em>。</p>
</blockquote>
<h3 id="112-cale-函数是什么？有什么作用？"><a href="#112-cale-函数是什么？有什么作用？" class="headerlink" title="112. cale( ) 函数是什么？有什么作用？"></a>112. <em>cale( )</em> 函数是什么？有什么作用？</h3><blockquote>
<p>参考答案</p>
<p>是 <em>CSS</em> 的一个函数，只有一个数学表达式参数，可处理数学运算，并且在表达式中可混用不同的单位。例如 </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&gt;<span class="selector-tag">div</span>&#123;</span><br><span class="line">&gt;<span class="attribute">width</span>: <span class="built_in">cale</span>(<span class="number">80%</span> - <span class="number">20px</span>);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="113-first-child-和-first-of-type-有什么不同？"><a href="#113-first-child-和-first-of-type-有什么不同？" class="headerlink" title="113. :first-child 和 :first-of-type 有什么不同？"></a>113. <em>:first-child</em> 和 <em>:first-of-type</em> 有什么不同？</h3><blockquote>
<p>参考答案</p>
<ul>
<li>伪类 <em>:first-child</em> 表示父元素第一个子元素，只要这个元素是在第一个位置就会被匹配。</li>
<li>伪类 <em>:first-of-type</em> 表示父元素中第一个相同类型的子元素，这个类型得是相同的元素名。</li>
</ul>
<p>例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>第一个 sapn 元素<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>第一个 p 元素<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>第二个 p 元素<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">/*匹配第一个 span*/</span></span><br><span class="line">&gt;<span class="selector-tag">div</span> <span class="selector-pseudo">:first</span>-child&#123;&#125;</span><br><span class="line">&gt;<span class="comment">/*匹配第一个 p*/</span></span><br><span class="line">&gt;<span class="selector-tag">div</span> <span class="selector-tag">p</span><span class="selector-pseudo">:first</span>-child&#123;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="114-什么叫-web-安全色？"><a href="#114-什么叫-web-安全色？" class="headerlink" title="114. 什么叫 web 安全色？"></a>114. 什么叫 <em>web</em> 安全色？</h3><blockquote>
<p>参考答案</p>
<p>在过去，显示器性能比较落后最多支持 256 种颜色，其中 40 种被操作系统作为了保留色，剩下 216 种就是安全色。安全色就指在各种平台下显示效果与预期一致，如果不是安全色，那么操作系统可能在处理颜色时产生抖动（混合几种颜色，模拟出系统没有的颜色），这样就会造成颜色在不同平台中显示出色差。</p>
</blockquote>
<h3 id="115-在-CSS-中，background-color-transparent-和-opacity-0-有什么区别？"><a href="#115-在-CSS-中，background-color-transparent-和-opacity-0-有什么区别？" class="headerlink" title="115. 在 CSS 中，background-color: transparent 和 opacity: 0 有什么区别？"></a>115. 在 <em>CSS</em> 中，<em>background-color: transparent</em> 和 <em>opacity: 0</em> 有什么区别？</h3><blockquote>
<p>参考答案</p>
<p><em>transparent</em> 关键字相当于 <em>rgba(0,0,0,0,)<em>，作为 <em>background</em> 的属性值仅仅是将元素的背景色设置为透明，而元素中的内容还可以被显示。</em>opacity</em> 则会将元素和内容当作一个整体，全部透明。</p>
</blockquote>
<h3 id="116-阅读代码分析-p-元素的字体大小。"><a href="#116-阅读代码分析-p-元素的字体大小。" class="headerlink" title="116. 阅读代码分析 p 元素的字体大小。"></a>116. 阅读代码分析 <em>p</em> 元素的字体大小。</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  section&#123;font-size: 32px;&#125;</span><br><span class="line">  section&gt;div&#123;font-size: 50%;&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;section&gt;</span><br><span class="line">   &lt;div&gt;</span><br><span class="line">    &lt;p&gt;lorem&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/section&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考答案</p>
<p>16<em>px</em>，因为 <em>font-size</em> 具有继承性。</p>
</blockquote>
<h3 id="117-font-face-有什么作用？"><a href="#117-font-face-有什么作用？" class="headerlink" title="117. @font-face 有什么作用？"></a>117. <em>@font-face</em> 有什么作用？</h3><blockquote>
<p>参考答案</p>
<p>以前，<em>CSS</em> 只能使用操作系统中安装的字体，自从引入了 <em>@font-face</em> 允许使用在线字体，能将放置在服务器上的自定义字体嵌入到页面中，这个字体也可以是矢量图标。</p>
</blockquote>
<h3 id="118-绝对定位和浮动有什么异同？"><a href="#118-绝对定位和浮动有什么异同？" class="headerlink" title="118. 绝对定位和浮动有什么异同？"></a>118. 绝对定位和浮动有什么异同？</h3><blockquote>
<p>参考答案</p>
<ol>
<li>都会脱离文档流，改变元素盒子类型，将元素变为块级</li>
<li>都会创建 <em>BFC</em></li>
<li>不同点在于对包含块的定义、兄弟元素间的影响、可摆放的位置、能否设置 <em>z-index</em></li>
</ol>
</blockquote>
<h3 id="119-字体风格-font-style-的关键字有两个：italic-和-oblique-它们有什么区别？"><a href="#119-字体风格-font-style-的关键字有两个：italic-和-oblique-它们有什么区别？" class="headerlink" title="119. 字体风格 font-style 的关键字有两个：italic 和 oblique 它们有什么区别？"></a>119. 字体风格 <em>font-style</em> 的关键字有两个：<em>italic</em> 和 <em>oblique</em> 它们有什么区别？</h3><blockquote>
<p>参考答案</p>
<ul>
<li><em>italic</em> 会对文字的结构有改动，得到一种倾斜字体</li>
<li><em>oblique</em> 不会修改文字结构，仅仅是倾斜字体</li>
<li>如果不存在 <em>italic</em> 的变形字体 <em>italic</em> 的功能将会与 <em>oblique</em> 相同</li>
</ul>
</blockquote>
<h3 id="120-文本“强制换行”的属性是什么？"><a href="#120-文本“强制换行”的属性是什么？" class="headerlink" title="120. 文本“强制换行”的属性是什么？"></a>120. 文本“强制换行”的属性是什么？</h3><blockquote>
<p>参考答案</p>
<p><em>word-break: break-all</em>;</p>
</blockquote>
<h3 id="121-阅读代码，分析最终执行结果-div-的水平、垂直位置距离。"><a href="#121-阅读代码，分析最终执行结果-div-的水平、垂直位置距离。" class="headerlink" title="121. 阅读代码，分析最终执行结果 div 的水平、垂直位置距离。"></a>121. 阅读代码，分析最终执行结果 <em>div</em> 的水平、垂直位置距离。</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">50%</span>, <span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考答案</p>
<p>水平位移 <em>110px</em> 垂直位移 <em>60px</em>。水平方向参照的是元素的宽度，处置方向参照的是元素的高度。<em>HTM</em>L 元素默认都以标准盒模型，当元素存在内边距，计算时还要包含内边距。即 <em>220</em> 的 <em>50%</em> 和 <em>120</em> 的 *50%*。</p>
</blockquote>
<h3 id="122-设置了元素的过渡后需要有触发条件才能看到效果，列举出可用的触发条件。"><a href="#122-设置了元素的过渡后需要有触发条件才能看到效果，列举出可用的触发条件。" class="headerlink" title="122. 设置了元素的过渡后需要有触发条件才能看到效果，列举出可用的触发条件。"></a>122. 设置了元素的过渡后需要有触发条件才能看到效果，列举出可用的触发条件。</h3><blockquote>
<p>参考答案</p>
<ol>
<li><em>:hover 、:checked</em> 等伪类</li>
<li>媒体查询，当改变窗口尺寸触发</li>
<li><em>js</em> 触发，用脚本更改元素样式</li>
</ol>
</blockquote>
<h3 id="123-怎样把背景图附着在内容上？"><a href="#123-怎样把背景图附着在内容上？" class="headerlink" title="123. 怎样把背景图附着在内容上？"></a>123. 怎样把背景图附着在内容上？</h3><blockquote>
<p>参考答案</p>
<p><em>background-attachment: fixed;</em></p>
</blockquote>
<h3 id="124-CSS-优化、提高性能的方法有哪些？"><a href="#124-CSS-优化、提高性能的方法有哪些？" class="headerlink" title="124. CSS 优化、提高性能的方法有哪些？"></a>124. <em>CSS</em> 优化、提高性能的方法有哪些？</h3><blockquote>
<p>参考答案</p>
<ol>
<li>最好使用表示语义的名字。一个好的类名应该是描述他是什么而不是像什么</li>
<li>避免 <em>!important</em>，可以选择其他选择器</li>
<li>使用紧凑的语法</li>
<li>避免不必要的命名空间</li>
<li>尽可能的精简规则，你可以合并不同类里的重复规则</li>
</ol>
</blockquote>
<h3 id="125-网页中应该使用奇数还是偶数的字体？"><a href="#125-网页中应该使用奇数还是偶数的字体？" class="headerlink" title="125. 网页中应该使用奇数还是偶数的字体？"></a>125. 网页中应该使用奇数还是偶数的字体？</h3><blockquote>
<p>参考答案</p>
<p>偶数。偶数字号相对更容易与 <em>web</em> 设计的其他部分构成比例关系， <em>windows</em> 自带的点阵宋体（中易宋体）从  <em>Vista</em> 开始只提供 12、14、16<em>px</em> 这3个大小的点阵，而奇数时是用的是小一号的点。即每个字占的空间大了 1<em>px</em> 但点阵没有变，于是略显稀疏。</p>
</blockquote>
<h3 id="126-margin-和-padding-分别适合什么场景使用？"><a href="#126-margin-和-padding-分别适合什么场景使用？" class="headerlink" title="126. margin 和 padding 分别适合什么场景使用？"></a>126. <em>margin</em> 和 <em>padding</em> 分别适合什么场景使用？</h3><blockquote>
<p>参考答案</p>
<ul>
<li>使用 <em>margin</em>：需要在 <em>border</em> 外侧添加空白、空白处不需要背景色、上下相连的两个盒子之间的空白，需要相互抵消时。</li>
<li>使用 <em>padding</em>: 需要在 <em>border</em> 内侧添加空白、空白处需要背景色</li>
</ul>
</blockquote>
<h3 id="127-对于-line-height-是如何理解的？"><a href="#127-对于-line-height-是如何理解的？" class="headerlink" title="127. 对于 line-height 是如何理解的？"></a>127. 对于 <em>line-height</em> 是如何理解的？</h3><blockquote>
<p>参考答案</p>
<ul>
<li>行高指一行文字的高度，两行文字间基线与基线之间的距离。在 CSS 中，起高度作用的是 <em>height</em> 和 <em>line-height</em></li>
<li>使用行高等于高的方式可以实现单行文字垂直居中</li>
<li>将 <em>display</em> 设置为 <em>inline-block</em> 可以实现多行文本居中</li>
</ul>
</blockquote>
<h3 id="128-如何让-Chrome-支持小于-12px-的文字？"><a href="#128-如何让-Chrome-支持小于-12px-的文字？" class="headerlink" title="128. 如何让 Chrome 支持小于 12px 的文字？"></a>128. 如何让 <em>Chrome</em> 支持小于 12px 的文字？</h3><blockquote>
<p>参考答案</p>
<p>可以配合 <em>CSS3</em> 中的 <em>transform</em> 属性来实现，例如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&gt;<span class="selector-tag">p</span>&#123;</span><br><span class="line">&gt;<span class="attribute">font-size</span>: <span class="number">10px</span>;</span><br><span class="line">&gt;-webkit-<span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.8</span>);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="129-如果需要手动写动画，你认为最小时间间隔是多久？"><a href="#129-如果需要手动写动画，你认为最小时间间隔是多久？" class="headerlink" title="129. 如果需要手动写动画，你认为最小时间间隔是多久？"></a>129. 如果需要手动写动画，你认为最小时间间隔是多久？</h3><blockquote>
<p>参考答案</p>
<p>多数显示器默认频率是 60<em>Hz</em>，即 1<em>s</em> 刷新 60 次，理论上最小间隔为 1/60*1000<em>ms</em> = 16.7<em>s</em></p>
</blockquote>
<h3 id="130-简述-png、jpg、gif-这些图片格式的适用场景，有没有了解过-webp"><a href="#130-简述-png、jpg、gif-这些图片格式的适用场景，有没有了解过-webp" class="headerlink" title="130. 简述 png、jpg、gif 这些图片格式的适用场景，有没有了解过 webp?"></a>130. 简述 <em>png、jpg、gif</em> 这些图片格式的适用场景，有没有了解过 <em>webp</em>?</h3><blockquote>
<p>参考答案</p>
<ul>
<li><em>png</em> 是便携式网络图片，一种无损数据压缩位图，优点：压缩比高，色彩好。 大多数地方都可以用。</li>
<li><em>jpg</em> 是一种针对相片使用的一种有损的压缩格式，在色调及颜色平滑变化做的不错。常被用来储存和传输照片的格式。</li>
<li><em>gif</em> 是一种位图文件格式，以8位色重现真色彩的图像。可以实现动画效果。</li>
<li><em>webp</em> 格式是谷歌在2010年推出的图片格式，压缩率只有 <em>jpg</em> 的2/3，大小比 <em>png</em> 小了45%。缺点是压缩的时间更久了，兼容性不好，目前只有 <em>Google</em> 和 opera 支持。</li>
</ul>
</blockquote>
<h3 id="131-style-标签写在-body-后面与-body-前面有什么区别？"><a href="#131-style-标签写在-body-后面与-body-前面有什么区别？" class="headerlink" title="131. style 标签写在 body 后面与 body 前面有什么区别？"></a>131. <em>style</em> 标签写在 <em>body</em> 后面与 <em>body</em> 前面有什么区别？</h3><blockquote>
<p>参考答案</p>
<p>页面加载自上而下，当然是先加载样式。写在 <em>body</em> 标签后由于浏览器以逐行方式对 <em>HTML</em> 文档进行解析，当解析到写在尾部的样式表（外联或写在 <em>style</em> 标签）会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后重新渲染，在 <em>windows</em> 的 <em>IE</em> 下可能会出现 <em>fouc</em> 现象（即样式失效导致的页面闪烁问题）。</p>
</blockquote>
<h3 id="132-阐述一下-CSS-Sprites"><a href="#132-阐述一下-CSS-Sprites" class="headerlink" title="132. 阐述一下 CSS Sprites"></a>132. 阐述一下 <em>CSS Sprites</em></h3><blockquote>
<p>参考答案</p>
<p>将一个页面涉及到的所有图片都包含到一张大图中去，然后利用 <em>CSS</em> 的 <em>background-image、background- repeat、background-position</em> 的组合进行背景定位。利用 <em>CSS Sprites</em> 能很好地减少网页的 <em>http</em> 请求，从而大大的提高页面的性能；还能减少图片的字节。</p>
</blockquote>
<h3 id="133-写出背景色渐变的-CSS-代码"><a href="#133-写出背景色渐变的-CSS-代码" class="headerlink" title="133. 写出背景色渐变的 CSS 代码"></a>133. 写出背景色渐变的 <em>CSS</em> 代码</h3><blockquote>
<p>参考答案</p>
<p><strong>线性渐变</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&gt;<span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(direction,color-stop1,color-stop2,...);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>direction：用角度值指定渐变的方向(或角度)；</p>
</li>
<li><p>color-stop1,color-stop2,…：用于指定渐变的起止颜色</p>
</li>
</ul>
<p><strong>径向渐变</strong></p>
<p>CSS 径向颜色渐变(Radial Gradients)跟线性渐变(linear gradients)不一样，它不是沿着一个方向渐变，而是以一个点为中心，向四周辐射渐变。</p>
<p>语法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&gt;<span class="attribute">background-image</span>: <span class="built_in">radial-gradient</span>([&lt;position&gt; || &lt;angle&gt;]，[&lt;shape&gt; || &lt;size&gt;]，&lt;stop&gt;，&lt;stop&gt;，&lt;stop&gt;)</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="134-写出添加下划线的-CSS-代码"><a href="#134-写出添加下划线的-CSS-代码" class="headerlink" title="134. 写出添加下划线的 CSS 代码"></a>134. 写出添加下划线的 <em>CSS</em> 代码</h3><blockquote>
<p>参考答案</p>
<p>一般有两种方法：</p>
<ul>
<li>通过 <em>CSS</em> 下划线代码：text-decoration:underline 来设置文字下划线。</li>
<li>通过设置 <em>div</em> 的 <em>border</em> 实现效果</li>
</ul>
</blockquote>
<h3 id="135-写出让对象顺时针旋转-90-度的-CSS-代码（最好附带动画效果）"><a href="#135-写出让对象顺时针旋转-90-度的-CSS-代码（最好附带动画效果）" class="headerlink" title="135. 写出让对象顺时针旋转 90 度的 CSS 代码（最好附带动画效果）"></a>135. 写出让对象顺时针旋转 90 度的 CSS 代码（最好附带动画效果）</h3><blockquote>
<p>参考答案</p>
<p>顺时针旋转可以使用 <em>CSS3</em> 新增的 <em>transform</em> 属性，属性值对应 *rotate(90deg)*，如果要附带动画效果，那么可以添加 <em>transition</em> 过渡。下面是一段示例代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">background-color</span>: red;</span><br><span class="line"><span class="attribute">transition</span>: all <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">90deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="136-CSS-优先级顺序正确的是（-）"><a href="#136-CSS-优先级顺序正确的是（-）" class="headerlink" title="136. CSS 优先级顺序正确的是（ ）"></a>136. CSS 优先级顺序正确的是（ ）</h3><p>A.  !important &gt; class &gt; id &gt; tag</p>
<p>B.  !important &gt; tag &gt; class &gt; id</p>
<p>C.  !important  &gt; id &gt; class &gt; tag</p>
<p>D.  Class &gt; !important &gt; id &gt; tag</p>
<blockquote>
<p>参考答案</p>
<p>选 C</p>
</blockquote>
<blockquote>
<p>解析：</p>
<p>关于 <em>CSS</em> 选择器的优先级，具体可以参阅下图：</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-11-03-10806.png" alt="image-20210816194530798" style="zoom:50%;" />
</blockquote>
<h3 id="137-如何产生带有正方形项目的列表"><a href="#137-如何产生带有正方形项目的列表" class="headerlink" title="137. 如何产生带有正方形项目的列表"></a>137. 如何产生带有正方形项目的列表</h3><p>A. <em>type:square</em></p>
<p>B. <em>type:2</em></p>
<p>C. <em>list-style-type:square</em></p>
<p>D. <em>list-type:square</em></p>
<blockquote>
<p>参考答案</p>
<p>C</p>
</blockquote>
<blockquote>
<p>解析：</p>
<p><em>CSS list-style-type</em> 属性可以设置不同的列表样式</p>
<p>具体属性值可以参阅：<em><a href="https://www.w3school.com.cn/cssref/pr_list-style-type.asp">https://www.w3school.com.cn/cssref/pr_list-style-type.asp</a></em></p>
</blockquote>
<h3 id="138-手写一个三栏布局，要求：垂直三栏布局，所有两栏宽度固定，中间自适应"><a href="#138-手写一个三栏布局，要求：垂直三栏布局，所有两栏宽度固定，中间自适应" class="headerlink" title="138. 手写一个三栏布局，要求：垂直三栏布局，所有两栏宽度固定，中间自适应"></a>138. 手写一个三栏布局，要求：垂直三栏布局，所有两栏宽度固定，中间自适应</h3><blockquote>
<p>参考答案：</p>
<p>这是一道经典的面试题，实现的方式很多，这里列举两种。</p>
<p>方法一：<em>flexbox</em> 的解决方案</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- flexbox解决方案 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;layout flexbox&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">&quot;left-center-right&quot;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">h1</span>&gt;</span>flexbox的解决方案<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">p</span>&gt;</span>1.这是布局的中间部分<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">p</span>&gt;</span>2.这是布局的中间部分<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line"><span class="selector-class">.layout</span><span class="selector-class">.flexbox</span> &#123;</span><br><span class="line"><span class="attribute">margin-top</span>: <span class="number">140px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.layout</span><span class="selector-class">.flexbox</span> <span class="selector-class">.left-center-right</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.layout</span><span class="selector-class">.flexbox</span> <span class="selector-class">.left</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line"><span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.layout</span><span class="selector-class">.flexbox</span> <span class="selector-class">.center</span> &#123;</span><br><span class="line"><span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line"><span class="attribute">background</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.layout</span><span class="selector-class">.flexbox</span> <span class="selector-class">.right</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line"><span class="attribute">background</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>方法二：网格布局解决方案</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 网格布局的解决方案     --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;layout grid&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">&quot;left-center-right&quot;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">h1</span>&gt;</span>网格布局的解决方案<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">p</span>&gt;</span>1.这是布局的中间部分<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">p</span>&gt;</span>2.这是布局的中间部分<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line"><span class="selector-class">.layout</span><span class="selector-class">.grid</span> <span class="selector-class">.left-center-right</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: grid;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">grid-template-rows: <span class="number">100px</span>;</span><br><span class="line">grid-template-<span class="attribute">columns</span>: <span class="number">300px</span> auto <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.layout</span><span class="selector-class">.grid</span> <span class="selector-class">.left</span> &#123;</span><br><span class="line"><span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.layout</span><span class="selector-class">.grid</span> <span class="selector-class">.center</span> &#123;</span><br><span class="line"><span class="attribute">background</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.layout</span><span class="selector-class">.grid</span> <span class="selector-class">.right</span> &#123;</span><br><span class="line"><span class="attribute">background</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
]]></content>
      <categories>
        <category>面试题</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题HTML面试题汇总</title>
    <url>/135xyq.github.io/2022/04/23/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98-HTML-%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="HTML-面试题汇总"><a href="#HTML-面试题汇总" class="headerlink" title="HTML 面试题汇总"></a><em>HTML</em> 面试题汇总</h1><h4 id="1-什么是-lt-DOCTYPE-gt-？是否需要在-HTML5-中使用？"><a href="#1-什么是-lt-DOCTYPE-gt-？是否需要在-HTML5-中使用？" class="headerlink" title="1. 什么是 &lt;!DOCTYPE&gt;？是否需要在 HTML5 中使用？"></a>1. 什么是 &lt;!DOCTYPE&gt;？是否需要在 <em>HTML5</em> 中使用？</h4><blockquote>
<p>参考答案：</p>
<p>它是 <em>HTML</em> 的文档声明，通过它告诉浏览器，使用哪一个 <em>HTML</em> 版本标准解析文档。</p>
<p>在浏览器发展的历史中，<em>HTML</em> 出现过很多个版本，不同版本在元素、属性等书写格式上略有差异，如果不预先告诉浏览器，浏览器就不知道我们的文档标准是什么，在这种情况下，大部分浏览器将开启最大兼容模式来解析网页，我们称之为怪异模式。这不仅会降低解析效率，而且会在解析过程中产生一些难以预知的 <em>bug</em>，所以文档声明是必须的。</p>
<p>而文档声明有多种书写格式，对应不同的 <em>HTML</em> 版本，&lt;!DOCTYPE&gt; 这种书写是告诉浏览器，整个文档使用 <em>HTML5</em> 的标准进行解析。</p>
</blockquote>
<h4 id="2-什么是可替换元素，什么是非可替换元素，它们各自有什么特点？"><a href="#2-什么是可替换元素，什么是非可替换元素，它们各自有什么特点？" class="headerlink" title="2. 什么是可替换元素，什么是非可替换元素，它们各自有什么特点？"></a>2. 什么是可替换元素，什么是非可替换元素，它们各自有什么特点？</h4><blockquote>
<p>参考答案：</p>
<p>可替换元素是指这样一种元素，它在页面中的大部分展现效果不由 <em>CSS</em> 决定。</p>
<p>比如 <em>img</em> 元素就是一个可替换元素，它在页面中显示出的效果主要取决于你连接的是什么图片，图片是什么它就展示什么，<em>CSS</em> 虽然可以控制图片的尺寸位置，但永远无法控制图片本身。</p>
<p>再比如，<em>select</em> 元素也是一个典型的可替换元素，它在页面上呈现的是用户操作系统上的下拉列表样式，因此，它的展现效果是由操作系统决定的。所以，同一个 <em>select</em> 元素，放到不同操作系统的电脑上会呈现不同的外观。</p>
<p><em>img、video、audio</em>、大部分表单元素都属于可替换元素。</p>
<p>非可替换元素就是指的普通元素，它具体在页面上呈现什么，完全由 <em>CSS</em> 来决定。</p>
</blockquote>
<h4 id="3-src-和-href-的区别（京东）"><a href="#3-src-和-href-的区别（京东）" class="headerlink" title="3. src 和 href 的区别（京东）"></a>3. <em>src</em> 和 <em>href</em> 的区别（京东）</h4><blockquote>
<p>参考答案：</p>
<p>它们都是 <em>HTML</em> 中特定元素的属性。</p>
<p><em>src</em> 是 <em>source</em> 的缩写，它通常用于 <em>img、video、audio、script</em> 元素，通过 <em>src</em> 属性，可以指定外部资源的来源地址。</p>
<p><em>href</em> 是 <em>hyper reference</em> 的缩写，意味「超引用」，它通常用于 <em>a、link</em> 元素，通过 <em>href</em> 属性，可以标识文档中引用的其他超文本。</p>
</blockquote>
<h4 id="4-说说常用的-meta-标签"><a href="#4-说说常用的-meta-标签" class="headerlink" title="4. 说说常用的 meta 标签"></a>4. 说说常用的 <em>meta</em> 标签</h4><blockquote>
<p>参考答案：</p>
<p><em>meta</em> 标签提供关于HTML文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。它可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 <em>web</em> 服务。</p>
<p>常用的 <em>meta</em> 标签的属性有：</p>
<ol>
<li><em>content</em> ，设置或返回 <em>meta</em> 元素的 <em>content</em> 属性的值 。</li>
<li><em>http-equiv</em>，把 <em>content</em> 属性连接到一个 <em>HTTP</em> 头部。</li>
<li><em>name</em>，把 <em>content</em> 属性连接到某个名称。</li>
</ol>
<p>关于 <em>meta</em> 标签，回答出常用的一些属性值即可，不用全部背下来。</p>
<p>具体的关于 <em>meta</em> 标签能够设置的属性，可以参阅：<em><a href="https://www.runoob.com/w3cnote/meta.html">https://www.runoob.com/w3cnote/meta.html</a></em></p>
</blockquote>
<h4 id="5-说说对-html-语义化的理解"><a href="#5-说说对-html-语义化的理解" class="headerlink" title="5. 说说对 html 语义化的理解"></a>5. 说说对 <em>html</em> 语义化的理解</h4><blockquote>
<p>参考答案：</p>
<ol>
<li>去掉或者丢失样式的时候能够让页面呈现出清晰的结构</li>
<li>有利于 <em>SEO</em>：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；</li>
<li>方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；</li>
<li>便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循 <em>W3C</em> 标准的团队都遵循这个标准，可以减少差异化。 <em>HTML5</em> 中新增加的很多标签（如：&lt;article&gt;、&lt;nav&gt;、&lt;header&gt; 和 &lt;footer&gt; 等） 就是基于语义化设计原则）下面就是语义化 <em>html</em> 代码；</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;header&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;<span class="name">h1</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;<span class="name">h2</span>&gt;</span>专注Web前端技术<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">&gt;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>总结一下，总之就是：</p>
<ul>
<li>用正确的标签做正确的事情！</li>
<li><em>html</em> 语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析；</li>
<li>在没有样式 <em>CCS</em> 情况下也以一种文档格式显示，并且是容易阅读的。</li>
<li>搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 <em>SEO</em>。</li>
<li>使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</li>
</ul>
</blockquote>
<h4 id="6-label-的作用是什么？是怎么用的？"><a href="#6-label-的作用是什么？是怎么用的？" class="headerlink" title="6. label 的作用是什么？是怎么用的？"></a>6. <em>label</em> 的作用是什么？是怎么用的？</h4><blockquote>
<p>参考答案：</p>
<p><em>label</em> 元素不会向用户呈现任何特殊效果。</p>
<p>不过，它为鼠标用户改进了可用性。</p>
<p>如果您在 <em>label</em> 元素内点击文本，就会触发此控件。</p>
<p>就是说，当用户选择该标签时，浏览器就会自动将焦点转到和标签相关的表单控件上。</p>
</blockquote>
<blockquote>
<p>解析：</p>
<p>最常用 <em>label</em> 标签的地方，应该就是表单中选择性别的单选框了。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;<span class="xml"><span class="tag">&lt;<span class="name">label</span>&gt;</span> 标签的 for 属性应当与相关元素的 id 属性相同。</span></span><br><span class="line"><span class="xml">&gt;<span class="tag">&lt;<span class="name">form</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;male&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">id</span>=<span class="string">&quot;male&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;female&quot;</span>&gt;</span>女<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">id</span>=<span class="string">&quot;female&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">&gt;<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>上面的代码中，当 <em>label</em> 和表单控件绑定后，用户不用必须点击单选框才能确定自己的选项，点击 <em>label</em> 所包裹的文字也能够自动聚焦绑定的表单控件。</p>
</blockquote>
<h4 id="7-iframe-框架有那些优缺点？"><a href="#7-iframe-框架有那些优缺点？" class="headerlink" title="7. iframe 框架有那些优缺点？"></a>7. <em>iframe</em> 框架有那些优缺点？</h4><blockquote>
<p>参考答案：</p>
<ul>
<li><em>iframe</em> 会阻塞主页面的 <em>Onload</em> 事件；</li>
<li><em>iframe</em> 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。</li>
<li>使用 <em>iframe</em> 之前需要考虑这两个缺点。如果需要使用 <em>iframe</em>，最好是通过 <em>javascript</em> 动态给 <em>iframe</em> 添加 <em>src</em> 属性值，这样可以可以绕开以上两个问题。</li>
</ul>
</blockquote>
<h4 id="8-HTML-与-XHTML-二者有什么区别，你觉得应该使用哪一个并说出理由。"><a href="#8-HTML-与-XHTML-二者有什么区别，你觉得应该使用哪一个并说出理由。" class="headerlink" title="8. HTML 与 XHTML 二者有什么区别，你觉得应该使用哪一个并说出理由。"></a>8. <em>HTML</em> 与 <em>XHTML</em> 二者有什么区别，你觉得应该使用哪一个并说出理由。</h4><blockquote>
<p>参考答案：</p>
<p><em>HTML</em> 与 <em>XHTML</em> 之间的差别，主要分为功能上的差别和书写习惯的差别两方面。</p>
<p>关于功能上的差别，主要是 <em>XHTML</em> 可兼容各大浏览器、手机以及 <em>PDA</em>，并且浏览器也能快速正确地编译网页。 </p>
<p>由于 <em>XHTML</em> 的语法较为严谨，所以如果你是习惯松散结构的 <em>HTML</em> 编写者，那需要注意 <em>XHTML</em> 的规则。</p>
<p>下面列出了几条容易犯的错误，供理解。 </p>
<ol>
<li><strong>所有标签都必须小写</strong></li>
</ol>
<p>  在 <em>XHTML</em> 中，所有的标签都必须小写，不能大小写穿插其中，也不能全部都是大写。</p>
<ol start="2">
<li><strong>标签必须成双成对</strong></li>
</ol>
<p>  像是 &lt;p&gt;…&lt;/p&gt;、&lt;a&gt;…&lt;/a&gt;、&lt;div&gt;…&lt;/div&gt;标签等，当出现一个标签时，必须要有对应的结束标签，缺一不可，就像在任何程序语言中的括号一样</p>
<ol start="3">
<li><strong>标签顺序必须正确</strong></li>
</ol>
<p>  标签由外到内，一层层包覆着，所以假设你先写 <em>div</em> 后写 <em>h1</em>，结尾就要先写 <em>h1</em> 后写 <em>div</em>。只要记住一个原则“先进后出”，先弹出的标签要后结尾。</p>
<ol start="4">
<li><strong>所有属性都必须使用双引号</strong></li>
</ol>
<p>  在 <em>XHTML 1.0</em> 中规定连单引号也不能使用，所以全程都得用双引号。</p>
<ol start="5">
<li>不允许使用 <em>target=”_blank”</em></li>
</ol>
<p>  从 <em>XHTML 1.1</em> 开始全面禁止 <em>target</em> 属性，如果想要有开新窗口的功能，就必须改写为 *rel=”external”*，并搭配 <em>JavaScript</em> 实现此效果。</p>
</blockquote>
<h4 id="9-HTML5-的-form-如何关闭自动完成功能？"><a href="#9-HTML5-的-form-如何关闭自动完成功能？" class="headerlink" title="9. HTML5 的 form 如何关闭自动完成功能？"></a>9. <em>HTML5</em> 的 <em>form</em> 如何关闭自动完成功能？</h4><blockquote>
<p>参考答案：</p>
<p><em>HTML</em> 的输入框可以拥有自动完成的功能，当你往输入框输入内容的时候，浏览器会从你以前的同名输入框的历史记录中查找出类似的内容并列在输入框下面，这样就不用全部输入进去了，直接选择列表中的项目就可以了。</p>
<p>使用 *autocomplete=”off”*（给不想要提示的 <em>form</em> 或某个 <em>input</em> 设置为 <em>autocomplete=off</em>。）</p>
<p>很多时候，需要对客户的资料进行保密，防止浏览器软件或者恶意插件获取到；</p>
<p>可以在 <em>input</em> 中加入 <em>autocomplete=“off”</em> 来关闭记录系统需要保密的情况下可以使用此参数</p>
<p>提示：<em>autocomplete</em> 属性有可能在 <em>form</em> 元素中是开启的，而在 <em>input</em> 元素中是关闭的。</p>
<p>注意：<em>autocomplete</em> 适用于 &lt;form&gt; 标签，以及以下类型的 &lt;input&gt; 标签：<em>text, search, url, telephone, email, password, datepickers, range</em> 以及 <em>color</em>。</p>
</blockquote>
<h4 id="10-title-与-h1-的区别、b-与-strong-的区别、i-与-em-的区别？"><a href="#10-title-与-h1-的区别、b-与-strong-的区别、i-与-em-的区别？" class="headerlink" title="10. title 与 h1 的区别、b 与 strong 的区别、i 与 em 的区别？"></a>10. <em>title</em> 与 <em>h1</em> 的区别、<em>b</em> 与 <em>strong</em> 的区别、<em>i</em> 与 <em>em</em> 的区别？</h4><blockquote>
<p>参考答案：</p>
<p><em>title</em> 与 <em>h1</em>：<em>h1</em> 标签写在网页的 <em>body</em> 中，<em>title</em> 标签写在网页的 <em>head</em> 中，<em>h1</em> 标签控制一段文字的大小（从 <em>h1~h6</em>），<em>title</em> 是网页标题的意思，如 &lt;title&gt;这是网页标题&lt;/title&gt;。</p>
<p><em>b</em> 与 <em>strong</em> 的区别：<em>b</em> 是以前的加粗元素，而新出来的 <em>strong</em> 元素虽然在表现上看上去也是加粗，但是却拥有语义，表示强调某段文字的信息。</p>
<p><em>i</em> 与 <em>em</em> 的区别：</p>
<p>同样，<em>i</em> 是 <em>italic</em>（斜体）的简写，是早期的斜体元素，而 <em>em</em> 是 <em>emphasize</em>（强调）的简写，是一个表示强调的元素。后者相比前者拥有语义。</p>
<p>经典的总结：</p>
<ul>
<li><em>title</em> 属性表示网页的标题，<em>h1</em> 元素则表示层次明确的页面内容标题，对页面信息的抓取也有很大的影响</li>
<li><em>strong</em> 是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：&lt;strong&gt;会重读，而 &lt;b&gt;是展示强调内容</li>
<li><em>i</em> 内容展示为斜体，<em>em</em> 表示强调的文本</li>
</ul>
<p>除了上面所列举的那几组外，相似的还有如下的元素：</p>
<p>自然样式标签：<em>b、i、u、s、pre</em></p>
<p>语义样式标签：<em>strong、em、ins、del、code</em></p>
<p>应该准确使用语义样式标签，但不能滥用，如果不能确定时首选使用自然样式标签。</p>
</blockquote>
<h4 id="11-请描述下-SEO-中的-TDK？"><a href="#11-请描述下-SEO-中的-TDK？" class="headerlink" title="11. 请描述下 SEO 中的 TDK？"></a>11. 请描述下 <em>SEO</em> 中的 <em>TDK</em>？</h4><blockquote>
<p>参考答案：</p>
<p>在 <em>SEO</em> 中，所谓的 <em>TDK</em> 其实就是 <em>title、description、keywords</em> 这三个标签，<em>title</em> 标题标签，<em>description</em> 描述标签，<em>keywords</em> 关键词标签。</p>
</blockquote>
<h4 id="12-每个-HTML-文件头里都有个很重要的东西，Doctype，知道这是干什么的么？"><a href="#12-每个-HTML-文件头里都有个很重要的东西，Doctype，知道这是干什么的么？" class="headerlink" title="12. 每个 HTML 文件头里都有个很重要的东西，Doctype，知道这是干什么的么？"></a>12. 每个 <em>HTML</em> 文件头里都有个很重要的东西，<em>Doctype</em>，知道这是干什么的么？</h4><blockquote>
<p>参考答案：</p>
<p>&lt;!DOCTYPE&gt; 声明位于文档中的最前面的位置，处于 &lt;html&gt; 标签之前，主要作用是告诉浏览器按照何种规范解析网页。</p>
</blockquote>
<blockquote>
<p>解析：</p>
<p><em>doctype</em> 声明是一种标准通用标记语言的文档类型声明，目的是告诉标准通用标记语言解析器要使用什么样的文档类型定义（<em>DTD</em>）来解析文档。</p>
<p>声明是用来指示 <em>web</em> 浏览器关于页面使用哪个 <em>HTML</em> 版本进行编写的指令。 声明必须是 <em>HTML</em> 文档的第一行，位于 &lt;html&gt; 标签之前。</p>
<p>浏览器本身分为两种模式，一种是标准模式，一种是怪异模式，浏览器通过 <em>doctype</em> 来区分这两种模式，<em>doctype</em> 在 <em>html</em> 中的作用就是触发浏览器的标准模式，如果 <em>html</em> 中省略了 <em>doctype</em>，浏览器就会进入到 <em>Quirks</em> 模式（怪异模式）。</p>
<p>在这种模式下，有些样式会和标准模式存在差异，而 <em>html</em> 标准和 <em>dom</em> 标准值规定了标准模式下的行为，没有对怪异模式做出规定，因此不同浏览器在怪异模式下的处理也是不同的，所以一定要在 <em>html</em> 开头使用 <em>doctype</em>。</p>
</blockquote>
<h4 id="13-什么是严格模式与混杂模式？"><a href="#13-什么是严格模式与混杂模式？" class="headerlink" title="13. 什么是严格模式与混杂模式？"></a>13. 什么是严格模式与混杂模式？</h4><blockquote>
<p>参考答案：</p>
<ul>
<li><p>严格模式：以浏览器支持的最高标准运行</p>
</li>
<li><p>混杂模式：页面以宽松向下兼容的方式显示，模拟老式浏览器的行为</p>
</li>
</ul>
</blockquote>
<h4 id="14-对于-WEB-标准以及-W3C-的理解与认识问题"><a href="#14-对于-WEB-标准以及-W3C-的理解与认识问题" class="headerlink" title="14. 对于 WEB 标准以及 W3C 的理解与认识问题"></a>14. 对于 <em>WEB</em> 标准以及 <em>W3C</em> 的理解与认识问题</h4><blockquote>
<p>参考答案：</p>
<p><strong><em>Web</em> 标准</strong>简单来说可以分为<strong>结构、表现和行为</strong>。其中结构主要是有 <em>HTML</em> 标签组成。或许通俗点说，在页面 <em>body</em> 里面我们写入的标签都是为了页面的结构。表现即指 <em>css</em> 样式表，通过 <em>css</em> 可以是页面的结构标签更具美感。行为是指页面和用户具有一定的交互，同时页面结构或者表现发生变化，主要是有 <em>js</em> 组成。</p>
<p><em>W3C</em> 是一个定制各种标准的非盈利性组织，标准包括了 <em>HTML、CSS、XHTML</em> 等，<em>web</em> 标准制定后，有以下几个优点：</p>
<ol>
<li>学习成本降低，只学习标准即可，否则将学习各个浏览器厂商的标准。</li>
<li>统一开发流程，用标准化工具开发（例如 <em>VSCode、WebStorm、Sublime</em> 等）再用标准化的浏览器测试，便于多人协作。</li>
<li>简化网站代码的维护。</li>
<li>跨平台，可方便迁移到不同设备中</li>
</ol>
</blockquote>
<h4 id="15-列举-IE-与其他浏览器不一样的特性？"><a href="#15-列举-IE-与其他浏览器不一样的特性？" class="headerlink" title="15. 列举 IE 与其他浏览器不一样的特性？"></a>15. 列举 <em>IE</em> 与其他浏览器不一样的特性？</h4><blockquote>
<p>参考答案：</p>
<ul>
<li><p><em>IE</em> 的排版引擎是 <em>Trident</em> （又称为 <em>MSHTML</em>）</p>
</li>
<li><p><em>Trident</em> 内核曾经几乎与 <em>W3C</em> 标准脱节</p>
</li>
<li><p><em>Trident</em> 内核的大量 <em>Bug</em> 等安全性问题没有得到及时解决</p>
</li>
<li><p><em>JS</em> 方面，有很多独立的方法，例如绑定事件的 <em>attachEvent</em>、创建事件的 <em>createEventObject</em> 等</p>
</li>
<li><p><em>CSS</em> 方面，也有自己独有的处理方式，例如设置透明，低版本 <em>IE</em> 中使用滤镜的方式，盒模型也和 <em>W3C</em> 规定的盒模型不同</p>
</li>
</ul>
</blockquote>
<h4 id="16-前端页面有哪三层构成，分别是什么？作用是什么？"><a href="#16-前端页面有哪三层构成，分别是什么？作用是什么？" class="headerlink" title="16. 前端页面有哪三层构成，分别是什么？作用是什么？"></a>16. 前端页面有哪三层构成，分别是什么？作用是什么？</h4><blockquote>
<p>参考答案：</p>
<p>分成：结构层、表示层、行为层。</p>
<ol>
<li>结构层（<em>structural layer</em>）</li>
</ol>
<p>由 <em>HTML</em> 或 <em>XHTML</em> 之类的标记语言负责创建。标签，也就是那些出现在尖括号里的单词，对网页内容的语义含义做出了描述，但这些标签不包含任何关于如何显示有关内容的信息。例如，<em>p</em> 标签表达了这样一种语义：“这是一个文本段。”</p>
<ol start="2">
<li>表示层（<em>presentation layer</em>）</li>
</ol>
<p>由 <em>CSS</em> 负责创建。 <em>CSS</em> 对“如何显示有关内容”的问题做出了回答。</p>
<ol start="3">
<li>行为层（<em>behaviorlayer</em>）</li>
</ol>
<p>负责回答“内容应该如何对事件做出反应”这一问题。这是 <em>Javascript</em> 语言和 <em>DOM</em> 主宰的领域。</p>
</blockquote>
<h4 id="17-页面可见性（Page-Visibility）API-可以有哪些用途？"><a href="#17-页面可见性（Page-Visibility）API-可以有哪些用途？" class="headerlink" title="17. 页面可见性（Page Visibility）API 可以有哪些用途？"></a>17. 页面可见性（<em>Page Visibility</em>）<em>API</em> 可以有哪些用途？</h4><blockquote>
<p>参考答案：</p>
<p>所谓页面可见性，就是获取当前页面的可见状态。因为对于用户来讲可以打开好多标签页面来回切换，然而始终只有一个页面处于显示状态。所以我们可以通过页面可见性（<em>Page Visibility</em>）<em>API</em> 来判断当前页面是显示状态还是隐藏状态。</p>
<p>常用的 <em>API</em> 有三个，<em>document.hidden</em> 返回一个布尔值，如果是 <em>true</em>，表示页面可见，<em>false</em> 则表示页面隐藏。不同页面之间来回切换，会触发 <em>visibilitychange</em> 事件，还有一个 <em>document.visibilityState</em>，表示页面所处的状态。</p>
</blockquote>
<h4 id="18-Quirks（怪癖）模式是什么？它和-Standards（标准）模式有什么区别"><a href="#18-Quirks（怪癖）模式是什么？它和-Standards（标准）模式有什么区别" class="headerlink" title="18. Quirks（怪癖）模式是什么？它和 Standards（标准）模式有什么区别"></a>18. <em>Quirks</em>（怪癖）模式是什么？它和 <em>Standards</em>（标准）模式有什么区别</h4><blockquote>
<p>参考答案：</p>
<p>以 <em>IE6</em> 为例，如果写了 <em>DTD</em>，就意味着这个页面将采用对 <em>CSS</em> 支持更好的布局，而如果没有，则采用兼容之前的布局方式。这就是 <em>Quirks</em> 模式（怪癖模式，诡异模式，怪异模式）。</p>
<p>区别：总体会有布局、样式解析和脚本执行三个方面的区别，这里列举一些比较常见的区别：</p>
<ul>
<li><p>盒模型：在 <em>W3C</em> 标准中，如果设置一个元素的宽度和高度，指的是元素内容的宽度和高度，而在 <em>Quirks</em> 模式下，<em>IE</em> 的宽度和高度还包含了 <em>padding</em> 和 <em>border</em>。</p>
</li>
<li><p>设置行内元素的高宽：在 <em>Standards</em> 模式下，给 &lt;span&gt; 等行内元素设置 <em>wdith</em> 和 <em>height</em> 都不会生效，而在 <em>Quirks</em> 模式下，则会生效。</p>
</li>
<li><p>设置百分比的高度：在 <em>Standards</em> 模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置百分比的高度，子元素设置一个百分比的高度是无效的</p>
</li>
<li><p>用 <em>margin:0 auto</em> 设置水平居中：使用 <em>margin:0 auto</em> 在 <em>Standards</em> 模式下可以使元素水平居中，但在 <em>Quirks</em> 模式下却会失效。</p>
</li>
</ul>
</blockquote>
<h4 id="19-div-css-的布局较-table-布局有什么优点？"><a href="#19-div-css-的布局较-table-布局有什么优点？" class="headerlink" title="19. div+css 的布局较 table 布局有什么优点？"></a>19. <em>div+css</em> 的布局较 <em>table</em> 布局有什么优点？</h4><blockquote>
<p>参考答案：</p>
<ul>
<li><p>样式的调整更加方便，内容和样式的分离，使页面和样式的调整变得更加方便。</p>
</li>
<li><p>页面加载速度更快、结构化清晰、页面显示简洁。</p>
</li>
<li><p>表现与结构相分离。</p>
</li>
<li><p>易于优化（<em>SEO</em>）搜索引擎更友好，排名更容易靠前。</p>
</li>
<li><p>符合 <em>W3C</em> 标准。</p>
</li>
</ul>
</blockquote>
<h4 id="20-请谈一下你对网页标准和标准制定机构重要性的理解。"><a href="#20-请谈一下你对网页标准和标准制定机构重要性的理解。" class="headerlink" title="20. 请谈一下你对网页标准和标准制定机构重要性的理解。"></a>20. 请谈一下你对网页标准和标准制定机构重要性的理解。</h4><blockquote>
<p>参考答案：</p>
<p>任何东西都需要一个标准，有了标准才能够更好的进行交流和推广。不同的标准，得出的便是不同的结果。因此，制定什么样的标准，如何确立标准，至关重要。</p>
<p>正因为有了网页的标准，才能降低开发难度及开发成本，减少各种 <em>BUG</em>、安全问题， 提高网站易用性。</p>
</blockquote>
<h4 id="21-知道什么是微格式吗？谈谈理解。在前端构建中应该考虑微格式吗？"><a href="#21-知道什么是微格式吗？谈谈理解。在前端构建中应该考虑微格式吗？" class="headerlink" title="21. 知道什么是微格式吗？谈谈理解。在前端构建中应该考虑微格式吗？"></a>21. 知道什么是微格式吗？谈谈理解。在前端构建中应该考虑微格式吗？</h4><blockquote>
<p>参考答案：</p>
<p>参考答案：</p>
<p>所谓微格式，是建立在已有的、被广泛采用的标准基础之上的一组简单的、开放的数据格式。</p>
<p>具体表现是把语义嵌入到 <em>HTML</em> 中，以便有助于分离式开发，并通过制定一些简单的约定，来兼顾 <em>HTML</em> 文档的人机可读性，相当于对 <em>Web</em> 网页进行了语义注解。</p>
<p>采用微格式的 <em>Web</em> 页面，在 <em>HTML</em> 文档中给一些标签增加一些属性，这些属性对信息的语义结构进行注解，有助于处理 <em>HTML</em> 文档的软件，更好的理解该 <em>HTML</em> 文档。</p>
<p><strong>在前端构建中微格式的意义</strong></p>
<p>微格式按照某种已有的被广泛应用的标准，通过对内容块的语义标记，可以让外部应用程序、聚合程序和搜索引擎能够做以下事情：</p>
<ol>
<li>在爬取 <em>Web</em> 内容时，能够更为准确地识别内容块的语义；</li>
<li>对内容进行操作，包括提供访问、校对，还可以将其转化成其他的相关格式，提供给外部程序和Web服务使用。</li>
</ol>
<p>总结： 微格式可以对网站进行 <em>SEO</em> 优化，如果需要可以考虑。</p>
</blockquote>
<h4 id="22-html-常见兼容性问题？"><a href="#22-html-常见兼容性问题？" class="headerlink" title="22. html 常见兼容性问题？"></a>22. <em>html</em> 常见兼容性问题？</h4><blockquote>
<p>参考答案：</p>
<ol>
<li><em>PNG24</em> 位的图片在 <em>IE6</em> 浏览器上出现背景</li>
</ol>
<p>解决方案：做成 <em>PNG8</em>，也可以引用一段脚本处理。</p>
<ol start="2">
<li>浏览器默认的 <em>margin</em> 和 <em>padding</em> 不同</li>
</ol>
<p>解决方案：使用 <em>CSS</em> 重置文件。</p>
<ol start="3">
<li><em>IE6</em> 双边距 <em>bug</em></li>
</ol>
<p>在 <em>IE6</em> 下，如果对元素设置了浮动，同时又设置了 <em>margin-left</em> 或 <em>margin-right</em>，<em>margin</em> 值会加倍。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&gt;<span class="selector-id">#box</span>&#123; </span><br><span class="line"> <span class="attribute">float</span><span class="selector-pseudo">:left</span>; </span><br><span class="line"> <span class="attribute">width</span>:<span class="number">10px</span>; </span><br><span class="line"> <span class="attribute">margin</span>:<span class="number">10px</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>这种情况之下 <em>IE</em> 会产生 <em>20px</em> 的距离</p>
<p>解决方案：在 <em>float</em> 的标签样式控制中加入 </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&gt;_display:inline;</span><br></pre></td></tr></table></figure>

<p>将其转化为行内属性。( _ 这个符号只有 <em>IE6</em> 会识别）</p>
<ol start="4">
<li>渐进识别的方式，从总体中逐渐排除局部。</li>
</ol>
<p>首先，巧妙的使用 “\9” 这一标记，将 <em>IE</em> 游览器从所有情况中分离出来。</p>
<p>接着，再次使用 “+” 将 <em>IE8</em> 和 <em>IE7、IE6</em> 分离开来，这样 <em>IE8</em> 已经独立识别。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&gt;<span class="selector-class">.bb</span>&#123;    </span><br><span class="line"> <span class="attribute">background-color</span>:<span class="number">#f1ee18</span>; <span class="comment">/*所有识别*/</span>    </span><br><span class="line"><span class="selector-class">.background-color</span>:<span class="number">#00deff</span>\<span class="number">9</span>; <span class="comment">/*IE6、7、8 识别*/</span>    </span><br><span class="line">+<span class="attribute">background-color</span>:<span class="number">#a200ff</span>; <span class="comment">/*IE6、7 识别*/</span>    </span><br><span class="line">_background-<span class="attribute">color</span>:<span class="number">#1e0bd1</span>; <span class="comment">/*IE6 识别*/</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><em>IE</em> 下，获取自定义属性用获取常规</li>
</ol>
<p><em>IE</em> 下，可以使属性的方法来获取自定义属性用获取常规，也可以使用 <em>getAttribute( )</em> 方法获取自定义属性，<em>Firefox</em> 下，只能使用 <em>getAttribute( )</em> 方法获取自定义属性</p>
<p>解决方法：统一通过 <em>getAttribute( )</em> 方法获取自定义属性</p>
<ol start="6">
<li><em>event</em> 对象的区别</li>
</ol>
<p><em>IE</em> 下，<em>event</em> 对象有 <em>x、y</em> 属性，但是没有 <em>pageX、pageY</em> 属性，<em>Firefox</em> 下，<em>event</em> 对象有 <em>pageX、pageY</em> 属性，但是没有 <em>x、y</em> 属性。</p>
<p>解决方法：（条件注释）缺点是在 <em>IE</em> 浏览器下可能会增加额外的 <em>HTTP</em> 请求数。</p>
<ol start="7">
<li><em>Chrome 12px</em> 像素</li>
</ol>
<p><em>Chrome</em> 中文界面下默认会将小于 <em>12px</em> 的文本强制按照 <em>12px</em> 显示</p>
<p>解决方法：可通过加入 <em>CSS</em> 属性 <em>-webkit-text-size-adjust: none;</em> 解决。</p>
<ol start="8">
<li><em>hover</em> 和 <em>active</em> 失效</li>
</ol>
<p>超链接访问过后 <em>hover</em> 样式就不出现了，被点击访问过的超链接样式不在具有 <em>hover</em> 和 <em>active</em> 了</p>
<p>解决方法：改变 <em>CSS</em> 属性的排列顺序 <em>L-V-H-A</em></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&gt;<span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123;&#125;</span><br><span class="line">&gt;<span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;&#125;</span><br><span class="line">&gt;<span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;&#125;</span><br><span class="line">&gt;<span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>怪异模式问题</li>
</ol>
<p>漏写 <em>DTD</em> 声明，<em>Firefox</em> 仍然会按照标准模式来解析网页，但在 <em>IE</em> 中会触发怪异模式。</p>
<p>为避免怪异模式给我们带来不必要的麻烦，最好养成书写 <em>DTD</em> 声明的好习惯。</p>
<p>现在可以使用 <em>HTML5</em>, 推荐的写法：&lt;!DOCTYPE html&gt;</p>
<ol start="10">
<li>上下 <em>margin</em> 重合问题</li>
</ol>
<p><em>IE</em> 和 <em>FireFox</em> 都存在，相邻的两个 <em>div</em> 的 <em>margin-left</em> 和 <em>margin-right</em> 不会重合，</p>
<p>但是 <em>margin-top</em> 和 <em>margin-bottom</em> 却会发生重合。</p>
<p>解决方法：养成良好的代码编写习惯，同时采用 <em>margin-top</em> 或者同时采用 <em>margin-bottom</em>。</p>
<ol start="11">
<li><em>IE6</em> 对 <em>png</em> 图片格式支持不好</li>
</ol>
<p>解决方案：引用一段脚本处理</p>
</blockquote>
<h4 id="23-HTML5-有哪些新特性、移除了那些元素？"><a href="#23-HTML5-有哪些新特性、移除了那些元素？" class="headerlink" title="23. HTML5 有哪些新特性、移除了那些元素？"></a>23. <em>HTML5</em> 有哪些新特性、移除了那些元素？</h4><blockquote>
<p>参考答案：</p>
<ul>
<li><em>HTML5</em> 现在已经不是 <em>SGML</em> 的⼦集，主要是关于图像，位置，存储，多任务等功能的增加</li>
<li>绘画 <em>canvas</em></li>
<li>⽤于媒介回放的 <em>video</em> 和 <em>audio</em> 元素</li>
<li>本地离线存储 <em>localStorage</em> ⻓期存储数据，浏览器关闭后数据不丢失</li>
<li><em>sessionStorage</em> 的数据在浏览器关闭后⾃动删除</li>
<li>语意化更好的内容元素，⽐如 <em>article 、 footer 、 header 、 nav 、 section</em></li>
<li>表单控件， <em>calendar 、 date 、 time 、 email 、 url 、 search</em></li>
<li>新的技术 <em>webworker 、 websocket 、 Geolocation</em></li>
</ul>
<p>移除的元素：</p>
<ul>
<li>纯表现的元素： <em>basefont 、 big 、 center 、 font 、 s 、 strike 、 tt 、 u</em></li>
<li>对可⽤性产⽣负⾯影响的元素： <em>frame 、 frameset 、 noframes</em></li>
</ul>
<p>⽀持 <em>HTML5</em> 新标签：</p>
<ul>
<li><em>IE8/IE7/IE6</em> ⽀持通过 <em>document.createElement</em> ⽅法产⽣的标签</li>
<li>可以利⽤这⼀特性让这些浏览器⽀持 <em>HTML5</em> 新标签</li>
<li>浏览器⽀持新标签后，还需要添加标签默认的样式</li>
<li>当然也可以直接使⽤成熟的框架、⽐如 <em>html5shim</em></li>
</ul>
</blockquote>
<h4 id="24-HTML-全局属性-global-attribute-有哪些"><a href="#24-HTML-全局属性-global-attribute-有哪些" class="headerlink" title="24. HTML 全局属性(global attribute)有哪些"></a>24. <em>HTML</em> 全局属性(<em>global attribute</em>)有哪些</h4><blockquote>
<p>参考答案：</p>
<p>所谓全局属性，就是指每个 <em>HTML</em> 元素都拥有的属性，大致有如下的属性：</p>
<ul>
<li><em>class</em> :为元素设置类标识</li>
<li>data-* : 为元素增加⾃定义属性</li>
<li><em>draggable</em> : 设置元素是否可拖拽</li>
<li><em>id</em> : 元素 <em>id</em> ，⽂档内唯⼀</li>
<li><em>lang</em> : 元素内容的的语⾔</li>
<li><em>style</em> : ⾏内 <em>css</em> 样式</li>
<li><em>title</em> : 元素相关的建议信息</li>
</ul>
</blockquote>
<h4 id="25-HTML5-为什么只需要写-lt-DOCTYPE-HTML-gt-？"><a href="#25-HTML5-为什么只需要写-lt-DOCTYPE-HTML-gt-？" class="headerlink" title="25. HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？"></a>25. <em>HTML5</em> 为什么只需要写 &lt;!DOCTYPE HTML&gt;？</h4><blockquote>
<p>参考答案：</p>
<p>为什么 <em>HTML5</em> 的顶部只需要一段</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&gt;<span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><em>HTML4</em> 却需要很长的一段</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&gt;<span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> <span class="meta-string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其主要原因，是因为 <em>HTML5</em> 不基于 <em>SGML</em>，所以不需要引用 <em>DTD</em>。</p>
<p>在 <em>HTML 4.01</em> 中，&lt;!DOCTYPE&gt; 声明引用 <em>DTD</em>，因为 <em>HTML 4.01</em> 基于 <em>SGML</em>。</p>
<p><em>DTD</em> 规定了标记语言的规则，这样浏览器才能正确地呈现内容。</p>
</blockquote>
<h4 id="26-对-web-标准、可用性、可访问性的理解"><a href="#26-对-web-标准、可用性、可访问性的理解" class="headerlink" title="26. 对 web 标准、可用性、可访问性的理解"></a>26. 对 <em>web</em> 标准、可用性、可访问性的理解</h4><blockquote>
<p>参考答案：</p>
<ul>
<li><p>可用性（<em>Usability</em>）：产品是否容易上手，用户能否完成任务，效率如何，以及这过程中用户的主观感受可好，是从用户的角度来看产品的质量。可用性好意味着产品质量高，是企业的核心竞争力。</p>
</li>
<li><p>可访问性（<em>Accessibility</em>）：Web 内容对于残障用户的可阅读和可理解性</p>
</li>
<li><p>可维护性（<em>Maintainability</em>）：一般包含两个层次，一是当系统出现问题时，快速定位并解决问题的成本，成本低则可维护性好。二是代码是否容易被人理解，是否容易修改和增强功能。</p>
</li>
</ul>
</blockquote>
<h4 id="27-HTML5-引入什么新的表单属性？"><a href="#27-HTML5-引入什么新的表单属性？" class="headerlink" title="27. HTML5 引入什么新的表单属性？"></a>27. <em>HTML5</em> 引入什么新的表单属性？</h4><blockquote>
<p>参考答案：</p>
<p><strong><em>form</em> 新属性</strong>：</p>
<ul>
<li><em>autocomplete</em>：属性规定表单是否应该启用自动完成功能。<em>autocomplete</em> 属性适用于 &lt;form&gt;，以及下面的 &lt;input&gt;类型：</li>
</ul>
<p><em>text, search, url, telephone, email, password, date，pickers, range</em> 以及 <em>color</em>。语法是 &lt;form autocomplete=”on|off”&gt;</p>
<ul>
<li><em>novalidate</em>：如果使用该属性，则提交表单时不进行内容的验证。<em>novalidate</em> 属性适用于：&lt;form&gt;，以及以下类型的 &lt;input&gt; 标签：<em>text, search, url, telephone, email, password, date pickers, range</em> 以及 <em>color</em>。语法：<em>novalidate=”novalidate”</em></li>
</ul>
<p><strong><em>input</em> 新属性</strong>：</p>
<ul>
<li><p><em>autocomplete</em>：同上</p>
</li>
<li><p><em>autofocus</em>：规定输入字段在页面加载时是否获得焦点，加载完成后，光标马上定位在该 <em>input</em></p>
</li>
<li><p><em>form</em>：<em>form</em> 属性的值必须是其所属表单的 <em>id</em>。如需引用一个以上的表单，请使用空格分隔的列表。</p>
</li>
<li><p><em>formaction</em>：属性覆盖 <em>form</em> 元素的 <em>action</em> 属性，比如两个提交按钮的时候，一个是正常提交，一个是管理员提交。该属性适用于 <em>type=”submit”</em> 以及 *type=”image”*。语法是 <em>formaction=”#”</em></p>
</li>
<li><p><em>formenctype：formenctype</em> 属性覆盖 <em>form</em> 元素的 <em>enctype</em> 属性。该属性与 <em>type=”submit”</em> 和 <em>type=”image”</em> 配合使用。属性规定在发送到服务器之前应该如何对表单数据进行编码。</p>
</li>
<li><p><em>formmethod</em>：覆盖表单的 method 属性。适用于 type=“submit” 和 type=“image”</p>
</li>
<li><p><em>formnovalidate：formnovalidate</em> 属性覆盖 <em>form</em> 元素的 <em>novalidate</em> 属性。如果使用该属性，则提交表单时按钮不会执行验证过程。</p>
</li>
<li><p><em>formtarget</em>：覆盖表单的 <em>target</em> 属性。适用于 <em>type=”submit”</em> 和 *type=”image”*， 该属性规定在何处打开 <em>action URL</em>。</p>
</li>
<li><p><em>height</em> 和 <em>width</em>：<em>height</em> 和 <em>width</em> 属性规定用于 <em>image</em> 类型的 &lt;input&gt; 标签的图像高度和宽度。</p>
</li>
<li><p><em>list</em>：引用包含输入字段的预定义选项的 <em>datalist</em> 。</p>
</li>
<li><p><em>min</em> 和 <em>max</em>：<em>min</em> 属性与 <em>max</em> 属性配合使用，可创建合法值范围，两个要一对用。语法是选择 <em>0-10</em> 数字，例如：&lt;input type=”number” name=”points” min=”0” max=”10” /&gt;</p>
</li>
<li><p>multiple：如果使用该属性，则允许一个以上的值，比如上传文件的时候，设置这个属性后可以一次选择几个图片；multiple 属性适用于以下类型的 <code>&lt;input&gt;</code>标签：email 和 file。</p>
</li>
<li><p><em>pattern (regexp)<em>：描述了一个正则表达式用于验证 &lt;input&gt; 元素的值，</em>pattern</em> 属性适用于以下 &lt;input&gt; 类型：<em>text, search, url, telephone, email</em> 以及 <em>password</em>。</p>
</li>
<li><p><em>placeholder</em>：提供可描述输入字段预期值的提示信息 (<em>hint</em>)。该提示会在输入字段为空时显示，并会在字段获得焦点时消失。</p>
</li>
<li><p><em>required</em>：规定必需在提交之前填写输入字段。 如果使用该属性，则字段是必填（或必选）的。</p>
</li>
<li><p><em>step</em>：为输入域规定合法的数字间隔。 如果 <em>step=”3”<em>，则合法的数是 <em>-3、0、3、6</em> 等。</em>step</em> 属性可以与 <em>max</em> 和 <em>min</em> 属性创建一个区域值。</p>
</li>
</ul>
</blockquote>
<h4 id="28-iframe-的作用"><a href="#28-iframe-的作用" class="headerlink" title="28.  iframe 的作用"></a>28.  <em>iframe</em> 的作用</h4><blockquote>
<p>参考答案：</p>
<p>参考答案：</p>
<p><em>iframe</em> 也称作嵌入式框架，嵌入式框架和框架网页类似，它可以把一个网页的框架和内容嵌入在现有的网页中。</p>
<p><strong>优点</strong></p>
<ul>
<li>重载页面时不需要重载整个页面，只需要重载页面中的一个框架页(减少了数据的传输，增加了网页下载速度)</li>
<li>方便制作导航栏</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>会产生很多页面，不容易管理</li>
<li>浏览器的后退按钮无效</li>
<li>无法被一些搜索引擎索引到</li>
<li>多数小型的移动设备（<em>PDA</em> 手机）无法完全显示框架</li>
<li>由于上面诸多缺点，因此不符合标准网页设计的理念，已经被标准网页设计抛弃</li>
</ul>
<p>目前框架的所有优点完全可以使用 <em>Ajax</em> 实现，因此已经没有必要使用 <em>iframe</em> 框架了。</p>
</blockquote>
<h4 id="29-img-上-title-与-alt"><a href="#29-img-上-title-与-alt" class="headerlink" title="29. img 上 title 与 alt"></a>29. <em>img</em> 上 <em>title</em> 与 <em>alt</em></h4><blockquote>
<p>参考答案：</p>
<ul>
<li><p><em>alt</em>：如果无法显示图像，浏览器将显示 <em>alt</em> 指定的内容</p>
</li>
<li><p><em>title</em>：在鼠标移到元素上时显示 <em>title</em> 的内容</p>
</li>
</ul>
<p>两者之间的区别：</p>
<p>通常当⿏标滑动到元素上的时候显示 <em>title</em>。</p>
<p><em>alt</em> 是 &lt;img&gt; 的特有属性，是图⽚内容的等价描述，⽤于图⽚⽆法加载时显示、读屏器 阅读图⽚。可提图⽚⾼可访问性，除了纯装饰图⽚外都必须设置有意义的值，搜索引擎会重点分析。</p>
</blockquote>
<h4 id="30-HTML5-新增哪些新特性-？"><a href="#30-HTML5-新增哪些新特性-？" class="headerlink" title="30. HTML5 新增哪些新特性 ？"></a>30. <em>HTML5</em> 新增哪些新特性 ？</h4><blockquote>
<p>参考答案：</p>
<p><em>HTML5</em> 新增特性有：</p>
<ol>
<li>拖拽释放</li>
<li>语义化更好的内容标签</li>
<li>视频、音频</li>
<li>画布</li>
<li>地理</li>
<li>本地离线存储</li>
<li>表单控件</li>
</ol>
</blockquote>
<h4 id="31-行内元素和块级元素区别，有哪些，怎样转换？（顶呱呱）"><a href="#31-行内元素和块级元素区别，有哪些，怎样转换？（顶呱呱）" class="headerlink" title="31. 行内元素和块级元素区别，有哪些，怎样转换？（顶呱呱）"></a>31. 行内元素和块级元素区别，有哪些，怎样转换？（顶呱呱）</h4><blockquote>
<p>参考答案：</p>
<p>块级元素：</p>
<ul>
<li>总是在新行上开始；</li>
<li>高度，行高以及外边距和内边距都可控制；</li>
<li>宽度缺省是它的容器的 *100%*，除非设定一个宽度。</li>
<li>它可以容纳内联元素和其他块元素</li>
</ul>
<p>行内元素：</p>
<ul>
<li>和其他元素都在一行上；</li>
<li>高，行高及外边距和内边距不可改变；</li>
<li>宽度就是它的文字或图片的宽度，不可改变</li>
<li>内联元素只能容纳文本或者其他内联元素</li>
</ul>
<p>对行内元素，需要注意如下：</p>
<ul>
<li>设置宽度 <em>width</em> 无效。</li>
<li>设置高度 <em>height</em> 无效，可以通过 <em>line-height</em> 来设置。</li>
<li>设置 <em>margin</em> 只有左右 <em>margin</em> 有效，上下无效。</li>
<li>设置 <em>padding</em> 只有左右 <em>padding</em> 有效，上下则无效。注意元素范围是增大了，但是对元素周围的内容是没影响的。</li>
</ul>
<p>通过 <em>display</em> 属性对行内元素和块级元素进行切换(主要看第 <em>2、3、4</em> 个值)：</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-08-16-062732.png" alt="image-20210816142732193" style="zoom:50%;" />

<p><em>html</em> 中常见的块级元素：<em>p、div、form、ul、ol、table</em></p>
<p><em>html</em> 中常见的行内元素：<em>a、img、span、button</em></p>
</blockquote>
<h4 id="32-HTML5-与-HTML4-的区别（华安永康）"><a href="#32-HTML5-与-HTML4-的区别（华安永康）" class="headerlink" title="32. HTML5 与 HTML4 的区别（华安永康）"></a>32. <em>HTML5</em> 与 <em>HTML4</em> 的区别（华安永康）</h4><blockquote>
<p>参考答案：</p>
<p>1、语法简化</p>
<p><em>HTML、XHTML</em> 的 <em>DOCTYPE、html、meta、script</em> 等标签，在 <em>HTML5</em> 中有大幅度的简化。</p>
<p>2、统一网页内嵌多媒体语法</p>
<p>以前，在网页中播放多媒体时，需要使用插件的方式来完成。有了 <em>HTML5</em> 之后，使用<code>&lt;video&gt;</code>或<code>&lt;audio&gt;</code>标签播放视频和音频，不需要在安装其他的什么来播放了。</p>
<p>3、新增了语义标签</p>
<p>为了增加网页的可读性，<em>HTML5</em> 增加了 &lt;header&gt;、&lt;footer&gt;、&lt;section&gt;、&lt;article&gt;、&lt;nav&gt;、&lt;hgroup&gt;、&lt;aside&gt;、&lt;figure&gt; 语义标签。</p>
<p>4、<em>HTML5</em> 废除了一些旧标签</p>
<p>废除的大部分是网页美化方面的标签，例如：&lt;big&gt;、&lt;u&gt;、&lt;font&gt;、&lt;basefont&gt;、&lt;center&gt;、&lt;s&gt;、&lt;tt&gt;。对 &lt;frame&gt;框架，不能使用。</p>
<p>5、全新的表单设计</p>
<p>表单是网页设计者最常用的功能，<em>HTML5</em> 对表单做了很大的更改，不但新增了几项新的标签，对原来的 &lt;form&gt; 标签也增加了许多属性。</p>
<p>6、新增了 &lt;canvas&gt; 标签，可以绘制图形</p>
<p><em>HTML5</em> 新增了具有绘图功能的 &lt;canvas&gt;</p>
<p>7、新增许多新的 <em>API</em></p>
<p>例如：<em>querySelector、querySelectorAll</em>、拖拽相关 <em>Api</em></p>
</blockquote>
<h4 id="33-如何处理-HTML5-新标签兼容问题"><a href="#33-如何处理-HTML5-新标签兼容问题" class="headerlink" title="33. 如何处理 HTML5 新标签兼容问题"></a>33. 如何处理 <em>HTML5</em> 新标签兼容问题</h4><blockquote>
<p>参考答案：</p>
<p>主要有两种方式：</p>
<p>方法 1：实现标签被识别</p>
<p>通过 <em>document.createElement(tagName)</em> 方法即可让浏览器识别新标签，浏览器支持新标签后，还可以为新标签添加 <em>CSS</em> 样式。</p>
<p>方法 2：<em>JavaScript</em> 解决方案</p>
<p>使用 <em>html5shim</em> 框架，在<code>&lt;head&gt;</code>中调用以下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;&lt;!--[<span class="keyword">if</span> lt IE <span class="number">9</span>]&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"> src=<span class="string">&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&gt;&lt;![endif]--&gt;</span><br></pre></td></tr></table></figure>


<p>当然也可以直接把这个文件下载到自己的网站上，但这个文件必须在 <em>head</em> 标签中调用。</p>
</blockquote>
<h4 id="34-h5-和-html5-区别"><a href="#34-h5-和-html5-区别" class="headerlink" title="34.  h5 和 html5 区别"></a>34.  <em>h5</em> 和 <em>html5</em> 区别</h4><blockquote>
<p>参考答案：</p>
<p><em>H5</em> 是一个产品名词，包含了最新的 <em>HTML5、CSS3、ES6</em> 等新的技术来制作的应用。</p>
<p><em>HTML5</em> 是一个技术名词，指代的就仅仅是第五代 <em>HTML</em>。</p>
</blockquote>
<h4 id="35-form-表单上传文件时需要进行什么样的声明"><a href="#35-form-表单上传文件时需要进行什么样的声明" class="headerlink" title="35. form 表单上传文件时需要进行什么样的声明"></a>35. <em>form</em> 表单上传文件时需要进行什么样的声明</h4><blockquote>
<p>参考答案：</p>
<p>需要添加如下的声明：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">enctype=&quot;multipart/form-data&quot;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="36-哪个属性可以做到当鼠标悬停在图片上时显示出文字"><a href="#36-哪个属性可以做到当鼠标悬停在图片上时显示出文字" class="headerlink" title="36. 哪个属性可以做到当鼠标悬停在图片上时显示出文字"></a>36. 哪个属性可以做到当鼠标悬停在图片上时显示出文字</h4><blockquote>
<p>参考答案：</p>
<p><em>title</em> 属性。当我们为图片设置了 <em>title</em> 属性后，鼠标悬停在图片上面，就会显示出 <em>title</em> 属性所设置的值。</p>
</blockquote>
<h4 id="37-如何在一张图片上的某一个区域做到点击事件"><a href="#37-如何在一张图片上的某一个区域做到点击事件" class="headerlink" title="37. 如何在一张图片上的某一个区域做到点击事件"></a>37. 如何在一张图片上的某一个区域做到点击事件</h4><blockquote>
<p>参考答案：</p>
<p>可以使用图片热区技术。步骤如下：</p>
<p>1、插入图片，并设置好图像的有关参数，且在 &lt;img&gt; 标记中设置参数 <em>usemap=”#Map”<em>，以表示对图像地图（</em>Map</em>）的引用；<br>2、用 &lt;map&gt; 标记设定图像地图的作用区域，并取名为：<em>Map</em>；<br>3、分别用 &lt;area&gt; 标记针对相应位置划分出多个矩形作用区域，并设定好其链接参数 <em>href</em>。</p>
<p>示例代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;url/to/your/image.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">usemap</span>=<span class="string">&quot;#Map&quot;</span> /&gt;</span></span><br><span class="line"> 　　<span class="tag">&lt;<span class="name">map</span> <span class="attr">name</span>=<span class="string">&quot;Map&quot;</span> <span class="attr">id</span>=<span class="string">&quot;Map&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">area</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">title</span>=<span class="string">&quot;&quot;</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">shape</span>=<span class="string">&quot;poly&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">coords</span>=<span class="string">&quot;65,71,98,58,114,90,108,112,79,130,56,116,38,100,41,76,52,53,83,34,110,33,139,46,141,75,145,101,127,115,113,133,85,132,82,131,159,117&quot;</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">area</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">title</span>=<span class="string">&quot;&quot;</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">shape</span>=<span class="string">&quot;poly&quot;</span> <span class="attr">coords</span>=<span class="string">&quot;28,22,57,20,36,39,27,61&quot;</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="38-行内元素有哪些？块级元素有哪些？空（void）元素有哪些？"><a href="#38-行内元素有哪些？块级元素有哪些？空（void）元素有哪些？" class="headerlink" title="38. 行内元素有哪些？块级元素有哪些？空（void）元素有哪些？"></a>38. 行内元素有哪些？块级元素有哪些？空（void）元素有哪些？</h4><blockquote>
<p>参考答案：</p>
<ul>
<li>行内元素：最大的特点就是共享一行，常见的有 <em>span a em i b strong abbr input select</em> 等</li>
<li>块级元素：最大的特点就是独占一行，常见的有 <em>header footer nav section article aside div p ul li ol dl table</em> 等</li>
<li>空元素：就是没有内容的 <em>HTML</em> 元素，比较常见的空元素有 <em>img、link、meta、br、hr</em></li>
</ul>
</blockquote>
<h4 id="39-什么是锚点？"><a href="#39-什么是锚点？" class="headerlink" title="39. 什么是锚点？"></a>39. 什么是锚点？</h4><blockquote>
<p>参考答案：</p>
<p>锚点（<em>anchor</em>）是一种特殊连接，能定位到 <em>HTML</em> 文档中某个特定位置，通过 HTML 元素的 <em>id</em> 来设置锚点。</p>
</blockquote>
<h4 id="40-图片与-span-元素混排图像下方会出现几像素的空隙的原因是什么？"><a href="#40-图片与-span-元素混排图像下方会出现几像素的空隙的原因是什么？" class="headerlink" title="40. 图片与 span 元素混排图像下方会出现几像素的空隙的原因是什么？"></a>40. 图片与 <em>span</em> 元素混排图像下方会出现几像素的空隙的原因是什么？</h4><blockquote>
<p>参考答案：</p>
<p><em>img</em> 作为可替换元素，它没有自己的基线，如果与不可替换元素混合排列，其行盒底端与基线对齐。由于与基线对齐，图像下方就会出现几像素的空隙。</p>
</blockquote>
<h4 id="41-a-元素除了用于导航外，还可以有什么作用？"><a href="#41-a-元素除了用于导航外，还可以有什么作用？" class="headerlink" title="41. a 元素除了用于导航外，还可以有什么作用？"></a>41. <em>a</em> 元素除了用于导航外，还可以有什么作用？</h4><blockquote>
<p>参考答案：</p>
<p><em>href</em> 属性中的 <em>url</em> 可以是浏览器支持的任何协议，所以 <em>a</em> 可以用于手机拨号 &lt;a href=’tel:10086’&gt;10086</a>、发送短信 &lt;a href=”sms:10086?body=test”&gt; 等。</p>
<p>当然，<em>a</em> 元素最常见的两个应用就是做锚点和下载文件。</p>
<p>锚点可以在点击时快速定位到一个页面的某一个位置，而下载的原理在于 <em>a</em> 标签所对应的资源浏览器无法解析，于是浏览器会选择将其下载下来。</p>
</blockquote>
]]></content>
      <categories>
        <category>面试题</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>面试题</tag>
        <tag>HTMl</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题promise面试题汇总一</title>
    <url>/135xyq.github.io/2022/05/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98-promise-%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B8%80/</url>
    <content><![CDATA[<h2 id="1-下面代码的输出结果是什么"><a href="#1-下面代码的输出结果是什么" class="headerlink" title="1. 下面代码的输出结果是什么"></a>1. 下面代码的输出结果是什么</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>); </span><br><span class="line">  resolve(); </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>答案：<br>1<br>2<br>4<br>3</p>
</blockquote>
<h2 id="2-下面代码的输出结果是什么"><a href="#2-下面代码的输出结果是什么" class="headerlink" title="2. 下面代码的输出结果是什么"></a>2. 下面代码的输出结果是什么</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>); </span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">      resolve(); </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>答案：<br>1<br>5<br>2<br>3<br>4</p>
</blockquote>
<h2 id="3-下面代码的输出结果是什么"><a href="#3-下面代码的输出结果是什么" class="headerlink" title="3. 下面代码的输出结果是什么"></a>3. 下面代码的输出结果是什么</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> promise2 = promise1.catch(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>, promise1) </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>, promise2) </span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>, promise1) </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>, promise2) </span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>答案：<br>promise1    Promise {pending}<br>promise2    Promise {pending}<br>promise1    Promise {fulfilled undefined}<br>promise2    Promise {fulfilled undefined}</p>
</blockquote>
<h2 id="4-下面代码的输出结果是什么"><a href="#4-下面代码的输出结果是什么" class="headerlink" title="4. 下面代码的输出结果是什么"></a>4. 下面代码的输出结果是什么</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">m</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> n = <span class="keyword">await</span> <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>答案：<br>2<br>1</p>
</blockquote>
<h2 id="5-下面代码的输出结果是什么"><a href="#5-下面代码的输出结果是什么" class="headerlink" title="5. 下面代码的输出结果是什么"></a>5. 下面代码的输出结果是什么</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">m</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> n = <span class="keyword">await</span> <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">  <span class="keyword">await</span> m();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>答案：<br>3<br>1<br>2</p>
</blockquote>
<h2 id="6-下面代码的输出结果是什么"><a href="#6-下面代码的输出结果是什么" class="headerlink" title="6. 下面代码的输出结果是什么"></a>6. 下面代码的输出结果是什么</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">m1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">m2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> n = <span class="keyword">await</span> m1();</span><br><span class="line">  <span class="built_in">console</span>.log(n)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">m3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> n = m2();</span><br><span class="line">  <span class="built_in">console</span>.log(n);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m3().then(<span class="function"><span class="params">n</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(n);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">m3();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>答案：<br>Promise { <pending> }<br>Promise { <pending> }<br>4<br>1<br>3<br>1</p>
</blockquote>
<h2 id="7-下面代码的输出结果是什么"><a href="#7-下面代码的输出结果是什么" class="headerlink" title="7. 下面代码的输出结果是什么"></a>7. 下面代码的输出结果是什么</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">  .then(<span class="number">2</span>)</span><br><span class="line">  .then(<span class="built_in">Promise</span>.resolve(<span class="number">3</span>))</span><br><span class="line">  .then(<span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>答案：<br>1</p>
</blockquote>
<h2 id="8-下面代码的输出结果是什么"><a href="#8-下面代码的输出结果是什么" class="headerlink" title="8. 下面代码的输出结果是什么"></a>8. 下面代码的输出结果是什么</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise3&#x27;</span>);</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise4&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">a = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="keyword">async</span> (resolve, reject) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="keyword">await</span> b;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;after1&#x27;</span>);</span><br><span class="line">  <span class="keyword">await</span> a</span><br><span class="line">  resolve(<span class="literal">true</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;after2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;end&#x27;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>答案：<br>promise1<br>undefined<br>end<br>promise2<br>promise3<br>promise4<br>Promise { <pending> }<br>after1</p>
</blockquote>
<h2 id="9-下面代码的输出结果是什么"><a href="#9-下面代码的输出结果是什么" class="headerlink" title="9. 下面代码的输出结果是什么"></a>9. 下面代码的输出结果是什么</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async1 start&#x27;</span>);</span><br><span class="line">    <span class="keyword">await</span> async2();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;async2&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">async1();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>答案：<br>script start<br>async1 start<br>async2<br>promise1<br>script end<br>async1 end<br>promise2<br>setTimeout</p>
</blockquote>
<h2 id="promise-手写"><a href="#promise-手写" class="headerlink" title="promise 手写"></a>promise 手写</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记录Promise的三种状态</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 运行一个微队列任务</span></span><br><span class="line"><span class="comment"> * 把传递的函数放到微队列中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> <span class="variable">callback</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runMicroTask</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 判断node环境</span></span><br><span class="line"><span class="comment">// 为了避免「变量未定义」的错误，这里最好加上前缀globalThis</span></span><br><span class="line"><span class="comment">// globalThis是一个关键字，指代全局对象，浏览器环境为window，node环境为global</span></span><br><span class="line"><span class="keyword">if</span> (globalThis.process &amp;&amp; globalThis.process.nextTick) &#123;</span><br><span class="line">  process.nextTick(callback);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (globalThis.MutationObserver) &#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> observer = <span class="keyword">new</span> MutationObserver(callback);</span><br><span class="line">  observer.observe(p, &#123;</span><br><span class="line">    <span class="attr">childList</span>: <span class="literal">true</span>, <span class="comment">// 观察该元素内部的变化</span></span><br><span class="line">  &#125;);</span><br><span class="line">  p.innerHTML = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(callback, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断一个数据是否是Promise对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;any&#125;</span> <span class="variable">obj</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPromise</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> !!(obj &amp;&amp; <span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> obj.then === <span class="string">&#x27;function&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个Promise</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> </span>executor 任务执行器，立即执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>._state = PENDING; <span class="comment">// 状态</span></span><br><span class="line">  <span class="built_in">this</span>._value = <span class="literal">undefined</span>; <span class="comment">// 数据</span></span><br><span class="line">  <span class="built_in">this</span>._handlers = []; <span class="comment">// 处理函数形成的队列</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    executor(<span class="built_in">this</span>._resolve.bind(<span class="built_in">this</span>), <span class="built_in">this</span>._reject.bind(<span class="built_in">this</span>));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">this</span>._reject(error);</span><br><span class="line">    <span class="built_in">console</span>.error(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向处理队列中添加一个函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> </span>executor 添加的函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>state 该函数什么状态下执行</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> </span>resolve 让then函数返回的Promise成功</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> </span>reject 让then函数返回的Promise失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="title">_pushHandler</span>(<span class="params">executor, state, resolve, reject</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>._handlers.push(&#123;</span><br><span class="line">    executor,</span><br><span class="line">    state,</span><br><span class="line">    resolve,</span><br><span class="line">    reject,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据实际情况，执行队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="title">_runHandlers</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>._state === PENDING) &#123;</span><br><span class="line">    <span class="comment">// 目前任务仍在挂起</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">this</span>._handlers[<span class="number">0</span>]) &#123;</span><br><span class="line">    <span class="keyword">const</span> handler = <span class="built_in">this</span>._handlers[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">this</span>._runOneHandler(handler);</span><br><span class="line">    <span class="built_in">this</span>._handlers.shift();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理一个handler</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> <span class="variable">handler</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="title">_runOneHandler</span>(<span class="params">&#123; executor, state, resolve, reject &#125;</span>)</span> &#123;</span><br><span class="line">  runMicroTask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>._state !== state) &#123;</span><br><span class="line">      <span class="comment">// 状态不一致，不处理</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> executor !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 传递后续处理并非一个函数</span></span><br><span class="line">      <span class="built_in">this</span>._state === FULFILLED ? resolve(<span class="built_in">this</span>._value) : reject(<span class="built_in">this</span>._value);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> result = executor(<span class="built_in">this</span>._value);</span><br><span class="line">      <span class="keyword">if</span> (isPromise(result)) &#123;</span><br><span class="line">        result.then(resolve, reject);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      reject(error);</span><br><span class="line">      <span class="built_in">console</span>.error(error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Promise A+规范的then</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> <span class="variable">onFulfilled</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> <span class="variable">onRejected</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._pushHandler(onFulfilled, FULFILLED, resolve, reject);</span><br><span class="line">    <span class="built_in">this</span>._pushHandler(onRejected, REJECTED, resolve, reject);</span><br><span class="line">    <span class="built_in">this</span>._runHandlers(); <span class="comment">// 执行队列</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 仅处理失败的场景</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> <span class="variable">onRejected</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">catch</span>(onRejected) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">null</span>, onRejected);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无论成功还是失败都会执行回调</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> <span class="variable">onSettled</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="title">finally</span>(<span class="params">onSettled</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.then(</span><br><span class="line">    <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      onSettled();</span><br><span class="line">      <span class="keyword">return</span> data;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">      onSettled();</span><br><span class="line">      <span class="keyword">throw</span> reason;</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更改任务状态</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>newState 新状态</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;any&#125;</span> </span>value 相关数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="title">_changeState</span>(<span class="params">newState, value</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>._state !== PENDING) &#123;</span><br><span class="line">    <span class="comment">// 目前状态已经更改</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>._state = newState;</span><br><span class="line">  <span class="built_in">this</span>._value = value;</span><br><span class="line">  <span class="built_in">this</span>._runHandlers(); <span class="comment">// 状态变化，执行队列</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 标记当前任务完成</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;any&#125;</span> </span>data 任务完成的相关数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="title">_resolve</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>._changeState(FULFILLED, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 标记当前任务失败</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;any&#125;</span> </span>reason 任务失败的相关数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="title">_reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>._changeState(REJECTED, reason);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个已完成的Promise</span></span><br><span class="line"><span class="comment"> * 特殊情况：</span></span><br><span class="line"><span class="comment"> * 1. 传递的data本身就是ES6的Promise对象</span></span><br><span class="line"><span class="comment"> * 2. 传递的data是PromiseLike（Promise A+），返回新的Promise，状态和其保持一致即可</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;any&#125;</span> <span class="variable">data</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">resolve</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (data <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isPromise(data)) &#123;</span><br><span class="line">      data.then(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 得到一个被拒绝的Promise</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;any&#125;</span></span>&#125; reason</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(reason);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 得到一个新的Promise</span></span><br><span class="line"><span class="comment"> * 该Promise的状态取决于proms的执行</span></span><br><span class="line"><span class="comment"> * proms是一个迭代器，包含多个Promise</span></span><br><span class="line"><span class="comment"> * 全部Promise成功，则返回的Promise成功，数据为所有Promise成功的数据，并且顺序是按照传入的顺序排列</span></span><br><span class="line"><span class="comment"> * 只要有一个Promise失败，则返回的Promise失败，原因是第一个失败的Promise的原因</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;iterator&#125;</span> <span class="variable">proms</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">all</span>(<span class="params">proms</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> results = [];</span><br><span class="line">      <span class="keyword">let</span> count = <span class="number">0</span>; <span class="comment">// Promise的总数</span></span><br><span class="line">      <span class="keyword">let</span> fulfilledCount = <span class="number">0</span>; <span class="comment">// 已完成的数量</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> p <span class="keyword">of</span> proms) &#123;</span><br><span class="line">        <span class="keyword">let</span> i = count;</span><br><span class="line">        count++;</span><br><span class="line">        MyPromise.resolve(p).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">          fulfilledCount++;</span><br><span class="line">          results[i] = data;</span><br><span class="line">          <span class="keyword">if</span> (fulfilledCount === count) &#123;</span><br><span class="line">            <span class="comment">// 当前是最后一个Promise完成了</span></span><br><span class="line">            resolve(results);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, reject);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (count === <span class="number">0</span>) &#123;</span><br><span class="line">        resolve(results);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      reject(error);</span><br><span class="line">      <span class="built_in">console</span>.error(error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 等待所有的Promise有结果之后</span></span><br><span class="line"><span class="comment"> * 该方法返回的Promise完成</span></span><br><span class="line"><span class="comment"> * 并且按照顺序将所有结果汇总</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;iterator&#125;</span> <span class="variable">proms</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">allSettled</span>(<span class="params">proms</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> ps = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> p <span class="keyword">of</span> proms) &#123;</span><br><span class="line">    ps.push(</span><br><span class="line">      MyPromise.resolve(p).then(</span><br><span class="line">        <span class="function">(<span class="params">value</span>) =&gt;</span> (&#123;</span><br><span class="line">          <span class="attr">status</span>: FULFILLED,</span><br><span class="line">          value,</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="function">(<span class="params">reason</span>) =&gt;</span> (&#123;</span><br><span class="line">          <span class="attr">status</span>: REJECTED,</span><br><span class="line">          reason,</span><br><span class="line">        &#125;)</span><br><span class="line">      )</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> MyPromise.all(ps);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回的Promise与第一个有结果的一致</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;iterator&#125;</span> <span class="variable">proms</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">race</span>(<span class="params">proms</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> p <span class="keyword">of</span> proms) &#123;</span><br><span class="line">      MyPromise.resolve(p).then(resolve, reject);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>面试题</category>
        <category>promise</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>面试题</tag>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题场景题面试题汇总一</title>
    <url>/135xyq.github.io/2022/05/10/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%9C%BA%E6%99%AF%E9%A2%98-%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B8%80/</url>
    <content><![CDATA[<h1 id="场景题汇总一"><a href="#场景题汇总一" class="headerlink" title="场景题汇总一"></a>场景题汇总一</h1><h2 id="类数组转化为数组"><a href="#类数组转化为数组" class="headerlink" title="类数组转化为数组"></a>类数组转化为数组</h2><h3 id="通过-call-调用数组的-slice-方法来实现转换"><a href="#通过-call-调用数组的-slice-方法来实现转换" class="headerlink" title="通过 call 调用数组的 slice 方法来实现转换"></a>通过 call 调用数组的 slice 方法来实现转换</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.slice.call(arrayLike);</span><br></pre></td></tr></table></figure>
<h3 id="通过-call-调用数组的-splice-方法来实现转换"><a href="#通过-call-调用数组的-splice-方法来实现转换" class="headerlink" title="通过 call 调用数组的 splice 方法来实现转换"></a>通过 call 调用数组的 splice 方法来实现转换</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.splice.call(arrayLike, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h3 id="通过-apply-调用数组的-concat-方法来实现转换"><a href="#通过-apply-调用数组的-concat-方法来实现转换" class="headerlink" title="通过 apply 调用数组的 concat 方法来实现转换"></a>通过 apply 调用数组的 concat 方法来实现转换</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.concat.apply([], arrayLike);</span><br></pre></td></tr></table></figure>
<h3 id="通过-Array-from-方法来实现转换"><a href="#通过-Array-from-方法来实现转换" class="headerlink" title="通过 Array.from 方法来实现转换"></a>通过 Array.from 方法来实现转换</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(arrayLike);</span><br></pre></td></tr></table></figure>

<h2 id="将js对象转化为树形结构"><a href="#将js对象转化为树形结构" class="headerlink" title="将js对象转化为树形结构"></a>将js对象转化为树形结构</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 转换前：</span></span><br><span class="line">source = [&#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">pid</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;body&#x27;</span></span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">pid</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;title&#x27;</span></span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="number">3</span>,</span><br><span class="line">            <span class="attr">pid</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;div&#x27;</span></span><br><span class="line">          &#125;]</span><br><span class="line"><span class="comment">// 转换为: </span></span><br><span class="line">tree = [&#123;</span><br><span class="line">          <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">          <span class="attr">pid</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&#x27;body&#x27;</span>,</span><br><span class="line">          <span class="attr">children</span>: [&#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">pid</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;title&#x27;</span>,</span><br><span class="line">            <span class="attr">children</span>: [&#123;</span><br><span class="line">              <span class="attr">id</span>: <span class="number">3</span>,</span><br><span class="line">              <span class="attr">pid</span>: <span class="number">1</span>,</span><br><span class="line">              <span class="attr">name</span>: <span class="string">&#x27;div&#x27;</span></span><br><span class="line">            &#125;]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonToTree</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化结果数组，并判断输入数据的格式</span></span><br><span class="line">  <span class="keyword">let</span> result = []</span><br><span class="line">  <span class="keyword">if</span>(!<span class="built_in">Array</span>.isArray(data)) &#123;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 使用map，将当前对象的id与当前对象对应存储起来</span></span><br><span class="line">  <span class="keyword">let</span> map = &#123;&#125;;</span><br><span class="line">  data.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    map[item.id] = item;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  data.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> parent = map[item.pid];</span><br><span class="line">    <span class="keyword">if</span>(parent) &#123;</span><br><span class="line">      (parent.children || (parent.children = [])).push(item);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.push(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小孩报数问题"><a href="#小孩报数问题" class="headerlink" title="小孩报数问题"></a>小孩报数问题</h2><p>有30个小孩儿，编号从1-30，围成一圈依此报数，1、2、3 数到 3 的小孩儿退出这个圈， 然后下一个小孩 重新报数 1、2、3，问最后剩下的那个小孩儿的编号是多少?</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">childNum</span>(<span class="params">num, count</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> allplayer = [];    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">        allplayer[i] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> exitCount = <span class="number">0</span>;    <span class="comment">// 离开人数</span></span><br><span class="line">    <span class="keyword">let</span> counter = <span class="number">0</span>;      <span class="comment">// 记录报数</span></span><br><span class="line">    <span class="keyword">let</span> curIndex = <span class="number">0</span>;     <span class="comment">// 当前下标</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(exitCount &lt; num - <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(allplayer[curIndex] !== <span class="number">0</span>) counter++;    </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(counter == count)&#123;</span><br><span class="line">            allplayer[curIndex] = <span class="number">0</span>;                 </span><br><span class="line">            counter = <span class="number">0</span>;</span><br><span class="line">            exitCount++;  </span><br><span class="line">        &#125;</span><br><span class="line">        curIndex++;</span><br><span class="line">        <span class="keyword">if</span>(curIndex == num)&#123;</span><br><span class="line">            curIndex = <span class="number">0</span>               </span><br><span class="line">        &#125;;           </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(allplayer[i] !== <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> allplayer[i]</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">childNum(<span class="number">30</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h2 id="用Promise实现图片的异步加载"><a href="#用Promise实现图片的异步加载" class="headerlink" title="用Promise实现图片的异步加载"></a>用Promise实现图片的异步加载</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> imageAsync=<span class="function">(<span class="params">url</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">let</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">                img.src = url;</span><br><span class="line">                img.οnlοad=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">`图片请求成功，此处进行通用操作`</span>);</span><br><span class="line">                    resolve(image);</span><br><span class="line">                &#125;</span><br><span class="line">                img.οnerrοr=<span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">`失败，此处进行失败的通用操作`</span>);</span><br><span class="line">                    reject(err);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">imageAsync(<span class="string">&quot;url&quot;</span>).then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;加载成功&quot;</span>);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">error</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;加载失败&quot;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="实现发布-订阅模式"><a href="#实现发布-订阅模式" class="headerlink" title="实现发布-订阅模式"></a>实现发布-订阅模式</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventCenter</span></span>&#123;</span><br><span class="line">  <span class="comment">// 1. 定义事件容器，用来装事件数组</span></span><br><span class="line">	<span class="keyword">let</span> handlers = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 添加事件方法，参数：事件名 事件方法</span></span><br><span class="line">  <span class="function"><span class="title">addEventListener</span>(<span class="params">type, handler</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建新数组容器</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.handlers[type]) &#123;</span><br><span class="line">      <span class="built_in">this</span>.handlers[type] = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存入事件</span></span><br><span class="line">    <span class="built_in">this</span>.handlers[type].push(handler)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 触发事件，参数：事件名 事件参数</span></span><br><span class="line">  <span class="function"><span class="title">dispatchEvent</span>(<span class="params">type, params</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 若没有注册该事件则抛出错误</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.handlers[type]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;该事件未注册&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 触发事件</span></span><br><span class="line">    <span class="built_in">this</span>.handlers[type].forEach(<span class="function"><span class="params">handler</span> =&gt;</span> &#123;</span><br><span class="line">      handler(...params)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 事件移除，参数：事件名 要删除事件，若无第二个参数则删除该事件的订阅和发布</span></span><br><span class="line">  <span class="function"><span class="title">removeEventListener</span>(<span class="params">type, handler</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.handlers[type]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;事件无效&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!handler) &#123;</span><br><span class="line">      <span class="comment">// 移除事件</span></span><br><span class="line">      <span class="keyword">delete</span> <span class="built_in">this</span>.handlers[type]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> index = <span class="built_in">this</span>.handlers[type].findIndex(<span class="function"><span class="params">el</span> =&gt;</span> el === handler)</span><br><span class="line">      <span class="keyword">if</span> (index === -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;无该绑定事件&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 移除事件</span></span><br><span class="line">      <span class="built_in">this</span>.handlers[type].splice(index, <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.handlers[type].length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="built_in">this</span>.handlers[type]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="查找文章中出现频率最高的单词"><a href="#查找文章中出现频率最高的单词" class="headerlink" title="查找文章中出现频率最高的单词"></a>查找文章中出现频率最高的单词</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findMostWord</span>(<span class="params">article</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 合法性判断</span></span><br><span class="line">  <span class="keyword">if</span> (!article) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 参数处理</span></span><br><span class="line">  article = article.trim().toLowerCase();</span><br><span class="line">  <span class="keyword">let</span> wordList = article.match(<span class="regexp">/[a-z]+/g</span>),</span><br><span class="line">    visited = [],</span><br><span class="line">    maxNum = <span class="number">0</span>,</span><br><span class="line">    maxWord = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  article = <span class="string">&quot; &quot;</span> + wordList.join(<span class="string">&quot;  &quot;</span>) + <span class="string">&quot; &quot;</span>;</span><br><span class="line">  <span class="comment">// 遍历判断单词出现次数</span></span><br><span class="line">  wordList.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (visited.indexOf(item) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 加入 visited </span></span><br><span class="line">      visited.push(item);</span><br><span class="line">      <span class="keyword">let</span> word = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot; &quot;</span> + item + <span class="string">&quot; &quot;</span>, <span class="string">&quot;g&quot;</span>),</span><br><span class="line">        num = article.match(word).length;</span><br><span class="line">      <span class="keyword">if</span> (num &gt; maxNum) &#123;</span><br><span class="line">        maxNum = num;</span><br><span class="line">        maxWord = item;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> maxWord + <span class="string">&quot;  &quot;</span> + maxNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="封装异步的fetch，使用async-await方式来使用"><a href="#封装异步的fetch，使用async-await方式来使用" class="headerlink" title="封装异步的fetch，使用async await方式来使用"></a>封装异步的fetch，使用async await方式来使用</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">HttpRequestUtil</span> </span>&#123;</span><br><span class="line">        <span class="keyword">async</span> <span class="function"><span class="title">get</span>(<span class="params">url</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="keyword">await</span> fetch(url);</span><br><span class="line">            <span class="keyword">const</span> data = <span class="keyword">await</span> res.json();</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">async</span> <span class="function"><span class="title">post</span>(<span class="params">url, data</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="keyword">await</span> fetch(url, &#123;</span><br><span class="line">                <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">                <span class="attr">headers</span>: &#123;</span><br><span class="line">                    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">body</span>: <span class="built_in">JSON</span>.stringify(data)</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">const</span> result = <span class="keyword">await</span> res.json();</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">async</span> <span class="function"><span class="title">put</span>(<span class="params">url, data</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="keyword">await</span> fetch(url, &#123;</span><br><span class="line">                <span class="attr">method</span>: <span class="string">&#x27;PUT&#x27;</span>,</span><br><span class="line">                <span class="attr">headers</span>: &#123;</span><br><span class="line">                    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">data</span>: <span class="built_in">JSON</span>.stringify(data)</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">const</span> result = <span class="keyword">await</span> res.json();</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">async</span> <span class="function"><span class="title">delete</span>(<span class="params">url, data</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="keyword">await</span> fetch(url, &#123;</span><br><span class="line">                <span class="attr">method</span>: <span class="string">&#x27;DELETE&#x27;</span>,</span><br><span class="line">                <span class="attr">headers</span>: &#123;</span><br><span class="line">                    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">data</span>: <span class="built_in">JSON</span>.stringify(data)</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">const</span> result = <span class="keyword">await</span> res.json();</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> httpRequestUtil = <span class="keyword">new</span> HttpRequestUtil();</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> httpRequestUtil.get(<span class="string">&#x27;http://golderbrother.cn/&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="实现prototype继承"><a href="#实现prototype继承" class="headerlink" title="实现prototype继承"></a>实现prototype继承</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SupperFunction</span>(<span class="params">flag1</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.flag1 = flag1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubFunction</span>(<span class="params">flag2</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.flag2 = flag2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//父实例</span></span><br><span class="line"><span class="keyword">var</span> superInstance = <span class="keyword">new</span> SupperFunction(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//子继承父</span></span><br><span class="line">SubFunction.prototype = superInstance;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子实例</span></span><br><span class="line"><span class="keyword">var</span> subInstance = <span class="keyword">new</span> SubFunction(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">//子调用自己和父的属性</span></span><br><span class="line">subInstance.flag1;   <span class="comment">// true</span></span><br><span class="line">subInstance.flag2;   <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h2 id="实现双向数据绑定"><a href="#实现双向数据绑定" class="headerlink" title="实现双向数据绑定"></a>实现双向数据绑定</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> input = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;input&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> span = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;span&#x27;</span>)</span><br><span class="line"><span class="comment">// 数据劫持</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;text&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;获取数据了&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">newVal</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;数据更新了&#x27;</span>)</span><br><span class="line">    input.value = newVal</span><br><span class="line">    span.innerHTML = newVal</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 输入监听</span></span><br><span class="line">input.addEventListener(<span class="string">&#x27;keyup&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  obj.text = e.target.value</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="实现简单路由"><a href="#实现简单路由" class="headerlink" title="实现简单路由"></a>实现简单路由</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hash路由</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Route</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 路由存储对象</span></span><br><span class="line">    <span class="built_in">this</span>.routes = &#123;&#125;</span><br><span class="line">    <span class="comment">// 当前hash</span></span><br><span class="line">    <span class="built_in">this</span>.currentHash = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="comment">// 绑定this，避免监听时this指向改变</span></span><br><span class="line">    <span class="built_in">this</span>.freshRoute = <span class="built_in">this</span>.freshRoute.bind(<span class="built_in">this</span>)</span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;load&#x27;</span>, <span class="built_in">this</span>.freshRoute, <span class="literal">false</span>)</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;hashchange&#x27;</span>, <span class="built_in">this</span>.freshRoute, <span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 存储</span></span><br><span class="line">  storeRoute (path, cb) &#123;</span><br><span class="line">    <span class="built_in">this</span>.routes[path] = cb || <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更新</span></span><br><span class="line">  freshRoute () &#123;</span><br><span class="line">    <span class="built_in">this</span>.currentHash = location.hash.slice(<span class="number">1</span>) || <span class="string">&#x27;/&#x27;</span></span><br><span class="line">    <span class="built_in">this</span>.routes[<span class="built_in">this</span>.currentHash]()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="实现斐波那契数列"><a href="#实现斐波那契数列" class="headerlink" title="实现斐波那契数列"></a>实现斐波那契数列</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> fn(n-<span class="number">2</span>)+fn(n-<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 优化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacci2</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">const</span> arrLen = arr.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= arrLen) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = arrLen; i &lt; n; i++) &#123;</span><br><span class="line">        arr.push(arr[i - <span class="number">1</span>] + arr[ i - <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr[arr.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非递归</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pre1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> pre2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        pre1 = pre2;</span><br><span class="line">        pre2 = current;</span><br><span class="line">        current = pre1 + pre2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串出现的不重复最长长度"><a href="#字符串出现的不重复最长长度" class="headerlink" title="字符串出现的不重复最长长度"></a>字符串出现的不重复最长长度</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">let</span> i = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> n = s.length</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.has(s[j])) &#123;</span><br><span class="line">            i = <span class="built_in">Math</span>.max(i, map.get(s[j]))</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">Math</span>.max(res, j - i)</span><br><span class="line">        map.set(s[j], j)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="使用-setTimeout-实现-setInterval"><a href="#使用-setTimeout-实现-setInterval" class="headerlink" title="使用 setTimeout 实现 setInterval"></a>使用 setTimeout 实现 setInterval</h2><blockquote>
<p>setInterval 的作用是每隔一段指定时间执行一个函数，但是这个执行不是真的到了时间立即执行，它真正的作用是每隔一段时间将事件加入事件队列中去，只有当当前的执行栈为空的时候，才能去从事件队列中取出事件执行。所以可能会出现这样的情况，就是当前执行栈执行的时间很长，导致事件队列里边积累多个定时器加入的事件，当执行栈结束的时候，这些事件会依次执行，因此就不能到间隔一段时间执行的效果。<br>针对 setInterval 的这个缺点，我们可以使用 setTimeout 递归调用来模拟 setInterval，这样我们就确保了只有一个事件结束了，我们才会触发下一个定时器事件，这样解决了 setInterval 的问题。<br>实现思路是使用递归函数，不断地去执行 setTimeout 从而达到 setInterval 的效果</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mySetInterval</span>(<span class="params">fn, timeout</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 控制器，控制定时器是否继续执行</span></span><br><span class="line">  <span class="keyword">var</span> timer = &#123;</span><br><span class="line">    <span class="attr">flag</span>: <span class="literal">true</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 设置递归函数，模拟定时器执行。</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">interval</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timer.flag) &#123;</span><br><span class="line">      fn();</span><br><span class="line">      <span class="built_in">setTimeout</span>(interval, timeout);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 启动定时器</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(interval, timeout);</span><br><span class="line">  <span class="comment">// 返回控制器</span></span><br><span class="line">  <span class="keyword">return</span> timer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现-jsonp"><a href="#实现-jsonp" class="headerlink" title="实现 jsonp"></a>实现 jsonp</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态的加载js文件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addScript</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">  script.src = src;</span><br><span class="line">  script.type = <span class="string">&quot;text/javascript&quot;</span>;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line">addScript(<span class="string">&quot;http://xxx.xxx.com/xxx.js?callback=handleRes&quot;</span>);</span><br><span class="line"><span class="comment">// 设置一个全局的callback函数来接收回调结果</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleRes</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口返回的数据格式</span></span><br><span class="line">handleRes(&#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="判断对象是否存在循环引用"><a href="#判断对象是否存在循环引用" class="headerlink" title="判断对象是否存在循环引用"></a>判断对象是否存在循环引用</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isCycleObject = <span class="function">(<span class="params">obj,parent</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> parentArr = parent || [obj];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> obj[i] === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> flag = <span class="literal">false</span>;</span><br><span class="line">            parentArr.forEach(<span class="function">(<span class="params">pObj</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(pObj === obj[i])&#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">if</span>(flag) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            flag = isCycleObject(obj[i],[...parentArr,obj[i]]);</span><br><span class="line">            <span class="keyword">if</span>(flag) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> b = &#123;a&#125;;</span><br><span class="line"><span class="keyword">const</span> c = &#123;b&#125;;</span><br><span class="line"><span class="keyword">const</span> o = &#123;<span class="attr">d</span>:&#123;<span class="attr">a</span>:<span class="number">3</span>&#125;,c&#125;</span><br><span class="line">o.c.b.aa = a;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(isCycleObject(o)</span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>面试题</category>
        <category>场景题</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题手写题面试题汇总一</title>
    <url>/135xyq.github.io/2022/05/10/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%89%8B%E5%86%99%E9%A2%98-%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B8%80/</url>
    <content><![CDATA[<h1 id="手写代码"><a href="#手写代码" class="headerlink" title="手写代码"></a>手写代码</h1><h2 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create"></a>Object.create</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = obj</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="instanceof-方法"><a href="#instanceof-方法" class="headerlink" title="instanceof 方法"></a>instanceof 方法</h2><ol>
<li>首先获取类型的原型</li>
<li>然后获得对象的原型</li>
<li>然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 null，因为原型链最终为 null</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceof</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> proto = <span class="built_in">Object</span>.getPrototypeOf(left), <span class="comment">// 获取对象的原型</span></span><br><span class="line">      prototype = right.prototype; <span class="comment">// 获取构造函数的 prototype 对象</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断构造函数的 prototype 对象是否在对象的原型链上</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!proto) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (proto === prototype) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    proto = <span class="built_in">Object</span>.getPrototypeOf(proto);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="new-操作符"><a href="#new-操作符" class="headerlink" title="new 操作符"></a>new 操作符</h2><ol>
<li>首先创建了一个新的空对象</li>
<li>设置原型，将对象的原型设置为函数的 prototype 对象。</li>
<li>让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）</li>
<li>判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objectFactory</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> newObject = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="title">constructor</span> = <span class="title">Array</span>.<span class="title">prototype</span>.<span class="title">shift</span>.<span class="title">call</span>(<span class="params"><span class="built_in">arguments</span></span>);</span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 判断参数是否是一个函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title">constructor</span> !== &quot;<span class="title">function</span>&quot;) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">&quot;type error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 新建一个空对象，对象的原型为构造函数的 prototype 对象</span></span><br><span class="line">  newObject = <span class="built_in">Object</span>.create(<span class="title">constructor</span>.<span class="title">prototype</span>);</span><br><span class="line">  <span class="comment">// 将 this 指向新建对象，并执行函数</span></span><br><span class="line">  result = <span class="title">constructor</span>.<span class="title">apply</span>(<span class="params">newObject, <span class="built_in">arguments</span></span>);</span><br><span class="line">  <span class="comment">// 判断返回对象</span></span><br><span class="line">  <span class="keyword">let</span> flag = result &amp;&amp; (<span class="keyword">typeof</span> result === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> result === <span class="string">&quot;function&quot;</span>);</span><br><span class="line">  <span class="comment">// 判断返回结果</span></span><br><span class="line">  <span class="keyword">return</span> flag ? result : newObject;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line">objectFactory(构造函数, 初始化参数);</span><br></pre></td></tr></table></figure>

<h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记录Promise的三种状态</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 运行一个微队列任务</span></span><br><span class="line"><span class="comment"> * 把传递的函数放到微队列中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> <span class="variable">callback</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runMicroTask</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断node环境</span></span><br><span class="line">  <span class="comment">// 为了避免「变量未定义」的错误，这里最好加上前缀globalThis</span></span><br><span class="line">  <span class="comment">// globalThis是一个关键字，指代全局对象，浏览器环境为window，node环境为global</span></span><br><span class="line">  <span class="keyword">if</span> (globalThis.process &amp;&amp; globalThis.process.nextTick) &#123;</span><br><span class="line">    process.nextTick(callback);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (globalThis.MutationObserver) &#123;</span><br><span class="line">    <span class="keyword">const</span> p = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> observer = <span class="keyword">new</span> MutationObserver(callback);</span><br><span class="line">    observer.observe(p, &#123;</span><br><span class="line">      <span class="attr">childList</span>: <span class="literal">true</span>, <span class="comment">// 观察该元素内部的变化</span></span><br><span class="line">    &#125;);</span><br><span class="line">    p.innerHTML = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(callback, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断一个数据是否是Promise对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;any&#125;</span> <span class="variable">obj</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPromise</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !!(obj &amp;&amp; <span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> obj.then === <span class="string">&#x27;function&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 创建一个Promise</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> </span>executor 任务执行器，立即执行</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._state = PENDING; <span class="comment">// 状态</span></span><br><span class="line">    <span class="built_in">this</span>._value = <span class="literal">undefined</span>; <span class="comment">// 数据</span></span><br><span class="line">    <span class="built_in">this</span>._handlers = []; <span class="comment">// 处理函数形成的队列</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      executor(<span class="built_in">this</span>._resolve.bind(<span class="built_in">this</span>), <span class="built_in">this</span>._reject.bind(<span class="built_in">this</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="built_in">this</span>._reject(error);</span><br><span class="line">      <span class="built_in">console</span>.error(error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 向处理队列中添加一个函数</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> </span>executor 添加的函数</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>state 该函数什么状态下执行</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> </span>resolve 让then函数返回的Promise成功</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> </span>reject 让then函数返回的Promise失败</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="title">_pushHandler</span>(<span class="params">executor, state, resolve, reject</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._handlers.push(&#123;</span><br><span class="line">      executor,</span><br><span class="line">      state,</span><br><span class="line">      resolve,</span><br><span class="line">      reject,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 根据实际情况，执行队列</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="title">_runHandlers</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>._state === PENDING) &#123;</span><br><span class="line">      <span class="comment">// 目前任务仍在挂起</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">this</span>._handlers[<span class="number">0</span>]) &#123;</span><br><span class="line">      <span class="keyword">const</span> handler = <span class="built_in">this</span>._handlers[<span class="number">0</span>];</span><br><span class="line">      <span class="built_in">this</span>._runOneHandler(handler);</span><br><span class="line">      <span class="built_in">this</span>._handlers.shift();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 处理一个handler</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> <span class="variable">handler</span></span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="title">_runOneHandler</span>(<span class="params">&#123; executor, state, resolve, reject &#125;</span>)</span> &#123;</span><br><span class="line">    runMicroTask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>._state !== state) &#123;</span><br><span class="line">        <span class="comment">// 状态不一致，不处理</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> executor !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 传递后续处理并非一个函数</span></span><br><span class="line">        <span class="built_in">this</span>._state === FULFILLED ? resolve(<span class="built_in">this</span>._value) : reject(<span class="built_in">this</span>._value);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> result = executor(<span class="built_in">this</span>._value);</span><br><span class="line">        <span class="keyword">if</span> (isPromise(result)) &#123;</span><br><span class="line">          result.then(resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resolve(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        reject(error);</span><br><span class="line">        <span class="built_in">console</span>.error(error);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Promise A+规范的then</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> <span class="variable">onFulfilled</span></span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> <span class="variable">onRejected</span></span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>._pushHandler(onFulfilled, FULFILLED, resolve, reject);</span><br><span class="line">      <span class="built_in">this</span>._pushHandler(onRejected, REJECTED, resolve, reject);</span><br><span class="line">      <span class="built_in">this</span>._runHandlers(); <span class="comment">// 执行队列</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 仅处理失败的场景</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> <span class="variable">onRejected</span></span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">catch</span>(onRejected) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">null</span>, onRejected);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 无论成功还是失败都会执行回调</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> <span class="variable">onSettled</span></span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="title">finally</span>(<span class="params">onSettled</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.then(</span><br><span class="line">      <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        onSettled();</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">        onSettled();</span><br><span class="line">        <span class="keyword">throw</span> reason;</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 更改任务状态</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>newState 新状态</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;any&#125;</span> </span>value 相关数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="title">_changeState</span>(<span class="params">newState, value</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>._state !== PENDING) &#123;</span><br><span class="line">      <span class="comment">// 目前状态已经更改</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>._state = newState;</span><br><span class="line">    <span class="built_in">this</span>._value = value;</span><br><span class="line">    <span class="built_in">this</span>._runHandlers(); <span class="comment">// 状态变化，执行队列</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 标记当前任务完成</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;any&#125;</span> </span>data 任务完成的相关数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="title">_resolve</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._changeState(FULFILLED, data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 标记当前任务失败</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;any&#125;</span> </span>reason 任务失败的相关数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="title">_reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._changeState(REJECTED, reason);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 返回一个已完成的Promise</span></span><br><span class="line"><span class="comment">   * 特殊情况：</span></span><br><span class="line"><span class="comment">   * 1. 传递的data本身就是ES6的Promise对象</span></span><br><span class="line"><span class="comment">   * 2. 传递的data是PromiseLike（Promise A+），返回新的Promise，状态和其保持一致即可</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;any&#125;</span> <span class="variable">data</span></span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">resolve</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (data <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">      <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (isPromise(data)) &#123;</span><br><span class="line">        data.then(resolve, reject);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(data);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 得到一个被拒绝的Promise</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;any&#125;</span></span>&#125; reason</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      reject(reason);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 得到一个新的Promise</span></span><br><span class="line"><span class="comment">   * 该Promise的状态取决于proms的执行</span></span><br><span class="line"><span class="comment">   * proms是一个迭代器，包含多个Promise</span></span><br><span class="line"><span class="comment">   * 全部Promise成功，则返回的Promise成功，数据为所有Promise成功的数据，并且顺序是按照传入的顺序排列</span></span><br><span class="line"><span class="comment">   * 只要有一个Promise失败，则返回的Promise失败，原因是第一个失败的Promise的原因</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;iterator&#125;</span> <span class="variable">proms</span></span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">all</span>(<span class="params">proms</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> results = [];</span><br><span class="line">        <span class="keyword">let</span> count = <span class="number">0</span>; <span class="comment">// Promise的总数</span></span><br><span class="line">        <span class="keyword">let</span> fulfilledCount = <span class="number">0</span>; <span class="comment">// 已完成的数量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> p <span class="keyword">of</span> proms) &#123;</span><br><span class="line">          <span class="keyword">let</span> i = count;</span><br><span class="line">          count++;</span><br><span class="line">          MyPromise.resolve(p).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">            fulfilledCount++;</span><br><span class="line">            results[i] = data;</span><br><span class="line">            <span class="keyword">if</span> (fulfilledCount === count) &#123;</span><br><span class="line">              <span class="comment">// 当前是最后一个Promise完成了</span></span><br><span class="line">              resolve(results);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, reject);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count === <span class="number">0</span>) &#123;</span><br><span class="line">          resolve(results);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        reject(error);</span><br><span class="line">        <span class="built_in">console</span>.error(error);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 等待所有的Promise有结果之后</span></span><br><span class="line"><span class="comment">   * 该方法返回的Promise完成</span></span><br><span class="line"><span class="comment">   * 并且按照顺序将所有结果汇总</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;iterator&#125;</span> <span class="variable">proms</span></span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">allSettled</span>(<span class="params">proms</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> ps = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> p <span class="keyword">of</span> proms) &#123;</span><br><span class="line">      ps.push(</span><br><span class="line">        MyPromise.resolve(p).then(</span><br><span class="line">          <span class="function">(<span class="params">value</span>) =&gt;</span> (&#123;</span><br><span class="line">            <span class="attr">status</span>: FULFILLED,</span><br><span class="line">            value,</span><br><span class="line">          &#125;),</span><br><span class="line">          <span class="function">(<span class="params">reason</span>) =&gt;</span> (&#123;</span><br><span class="line">            <span class="attr">status</span>: REJECTED,</span><br><span class="line">            reason,</span><br><span class="line">          &#125;)</span><br><span class="line">        )</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MyPromise.all(ps);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 返回的Promise与第一个有结果的一致</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;iterator&#125;</span> <span class="variable">proms</span></span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">race</span>(<span class="params">proms</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> p <span class="keyword">of</span> proms) &#123;</span><br><span class="line">        MyPromise.resolve(p).then(resolve, reject);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="类型判断函数"><a href="#类型判断函数" class="headerlink" title="类型判断函数"></a>类型判断函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断数据是 null 的情况</span></span><br><span class="line">  <span class="keyword">if</span> (value === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value + <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断数据是引用类型的情况</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> valueClass = <span class="built_in">Object</span>.prototype.toString.call(value),</span><br><span class="line">      type = valueClass.split(<span class="string">&quot; &quot;</span>)[<span class="number">1</span>].split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    type.pop();</span><br><span class="line">    <span class="keyword">return</span> type.join(<span class="string">&quot;&quot;</span>).toLowerCase();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 判断数据是基本数据类型的情况和函数的情况</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="call-函数"><a href="#call-函数" class="headerlink" title="call 函数"></a>call 函数</h2><ol>
<li>判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>
<li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li>
<li>处理传入的参数，截取第一个参数后的所有参数。</li>
<li>将函数作为上下文对象的一个属性。</li>
<li>使用上下文对象来调用这个方法，并保存返回结果。</li>
<li>删除刚才新增的属性。</li>
<li>返回结果。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// call函数实现</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断调用对象</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">&quot;type error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取参数</span></span><br><span class="line">  <span class="keyword">let</span> args = [...arguments].slice(<span class="number">1</span>),</span><br><span class="line">      result = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 判断 context 是否传入，如果未传入则设置为 window</span></span><br><span class="line">  context = context || <span class="built_in">window</span>;</span><br><span class="line">  <span class="comment">// 将调用函数设为对象的方法</span></span><br><span class="line">  context.fn = <span class="built_in">this</span>;</span><br><span class="line">  <span class="comment">// 调用函数</span></span><br><span class="line">  result = context.fn(...args);</span><br><span class="line">  <span class="comment">// 将属性删除</span></span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="apply-函数"><a href="#apply-函数" class="headerlink" title="apply 函数"></a>apply 函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// apply 函数实现</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断调用对象是否为函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 判断 context 是否存在，如果未传入则为 window</span></span><br><span class="line">  context = context || <span class="built_in">window</span>;</span><br><span class="line">  <span class="comment">// 将函数设为对象的方法</span></span><br><span class="line">  context.fn = <span class="built_in">this</span>;</span><br><span class="line">  <span class="comment">// 调用方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>[<span class="number">1</span>]) &#123;</span><br><span class="line">    result = context.fn(...arguments[<span class="number">1</span>]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = context.fn();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将属性删除</span></span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="bind-函数"><a href="#bind-函数" class="headerlink" title="bind 函数"></a>bind 函数</h2><ol>
<li>判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>
<li>保存当前函数的引用，获取其余传入参数值。</li>
<li>创建一个函数返回</li>
<li>函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bind 函数实现</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断调用对象是否为函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取参数</span></span><br><span class="line">  <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>),</span><br><span class="line">      fn = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 根据调用方式，传入不同绑定值</span></span><br><span class="line">    <span class="keyword">return</span> fn.apply(</span><br><span class="line">      <span class="built_in">this</span> <span class="keyword">instanceof</span> Fn ? <span class="built_in">this</span> : context,</span><br><span class="line">      args.concat(...arguments)</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="函数柯里化的实现"><a href="#函数柯里化的实现" class="headerlink" title="函数柯里化的实现"></a>函数柯里化的实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn, args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取函数需要的参数长度</span></span><br><span class="line">  <span class="keyword">let</span> length = fn.length;</span><br><span class="line"></span><br><span class="line">  args = args || [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> subArgs = args.slice(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接得到现有的所有参数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">      subArgs.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断参数的长度是否已经满足函数所需参数的长度</span></span><br><span class="line">    <span class="keyword">if</span> (subArgs.length &gt;= length) &#123;</span><br><span class="line">      <span class="comment">// 如果满足，执行函数</span></span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="built_in">this</span>, subArgs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果不满足，递归返回科里化的函数，等待参数的传入</span></span><br><span class="line">      <span class="keyword">return</span> curry.call(<span class="built_in">this</span>, fn, subArgs);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es6 实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fn.length &lt;= args.length ? fn(...args) : curry.bind(<span class="literal">null</span>, fn, ...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现AJAX请求"><a href="#实现AJAX请求" class="headerlink" title="实现AJAX请求"></a>实现AJAX请求</h2><ol>
<li>创建一个 XMLHttpRequest 对象。</li>
<li>在这个对象上使用 open 方法创建一个 HTTP 请求，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。</li>
<li>在发起请求前，可以为这个对象添加一些信息和监听函数。比如说可以通过 setRequestHeader 方法来为请求添加头信息。还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候就可以通过 response 中的数据来对页面进行更新了。</li>
<li>当对象的属性和监听函数设置完成后，最后调用 sent 方法来向服务器发起请求，可以传入参数作为发送的数据体。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SERVER_URL = <span class="string">&quot;/server&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">// 创建 Http 请求</span></span><br><span class="line">xhr.open(<span class="string">&quot;GET&quot;</span>, SERVER_URL, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 设置状态监听函数</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.readyState !== <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 当请求成功时</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">    handle(<span class="built_in">this</span>.response);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="built_in">this</span>.statusText);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 设置请求失败时的监听函数</span></span><br><span class="line">xhr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="built_in">this</span>.statusText);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 设置请求头信息</span></span><br><span class="line">xhr.responseType = <span class="string">&quot;json&quot;</span>;</span><br><span class="line">xhr.setRequestHeader(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line"><span class="comment">// 发送 Http 请求</span></span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="Promise封装AJAX请求"><a href="#Promise封装AJAX请求" class="headerlink" title="Promise封装AJAX请求"></a>Promise封装AJAX请求</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// promise 封装实现：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getJSON</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个 promise 对象</span></span><br><span class="line">  <span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    <span class="comment">// 新建一个 http 请求</span></span><br><span class="line">    xhr.open(<span class="string">&quot;GET&quot;</span>, url, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 设置状态的监听函数</span></span><br><span class="line">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.readyState !== <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">      <span class="comment">// 当请求成功或失败时，改变 promise 的状态</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">        resolve(<span class="built_in">this</span>.response);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="built_in">this</span>.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 设置错误监听函数</span></span><br><span class="line">    xhr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="built_in">this</span>.statusText));</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 设置响应的数据类型</span></span><br><span class="line">    xhr.responseType = <span class="string">&quot;json&quot;</span>;</span><br><span class="line">    <span class="comment">// 设置请求头信息</span></span><br><span class="line">    xhr.setRequestHeader(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">    <span class="comment">// 发送 http 请求</span></span><br><span class="line">    xhr.send(<span class="literal">null</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 浅拷贝的实现;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowCopy</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 只拷贝对象</span></span><br><span class="line">  <span class="keyword">if</span> (!object || <span class="keyword">typeof</span> object !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据 object 的类型判断是新建一个数组还是对象</span></span><br><span class="line">  <span class="keyword">let</span> newObject = <span class="built_in">Array</span>.isArray(object) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历 object，并且判断是 object 的属性才拷贝</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">    <span class="keyword">if</span> (object.hasOwnProperty(key)) &#123;</span><br><span class="line">      newObject[key] = object[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newObject;</span><br><span class="line">&#125;<span class="comment">// 浅拷贝的实现;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowCopy</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 只拷贝对象</span></span><br><span class="line">  <span class="keyword">if</span> (!object || <span class="keyword">typeof</span> object !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据 object 的类型判断是新建一个数组还是对象</span></span><br><span class="line">  <span class="keyword">let</span> newObject = <span class="built_in">Array</span>.isArray(object) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历 object，并且判断是 object 的属性才拷贝</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">    <span class="keyword">if</span> (object.hasOwnProperty(key)) &#123;</span><br><span class="line">      newObject[key] = object[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newObject;</span><br><span class="line">&#125;<span class="comment">// 浅拷贝的实现;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowCopy</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 只拷贝对象</span></span><br><span class="line">  <span class="keyword">if</span> (!object || <span class="keyword">typeof</span> object !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 根据 object 的类型判断是新建一个数组还是对象</span></span><br><span class="line">  <span class="keyword">let</span> newObject = <span class="built_in">Array</span>.isArray(object) ? [] : &#123;&#125;;</span><br><span class="line">  <span class="comment">// 遍历 object，并且判断是 object 的属性才拷贝</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">    <span class="keyword">if</span> (object.hasOwnProperty(key)) &#123;</span><br><span class="line">      newObject[key] = object[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 深拷贝的实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!object || <span class="keyword">typeof</span> object !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> newObject = <span class="built_in">Array</span>.isArray(object) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">    <span class="keyword">if</span> (object.hasOwnProperty(key)) &#123;</span><br><span class="line">      newObject[key] =</span><br><span class="line">        <span class="keyword">typeof</span> object[key] === <span class="string">&quot;object&quot;</span> ? deepCopy(object[key]) : object[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组的扁平化"><a href="#数组的扁平化" class="headerlink" title="数组的扁平化"></a>数组的扁平化</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]]];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(arr[i])) &#123;</span><br><span class="line">      result = result.concat(flatten(arr[i]));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">flatten(arr);  <span class="comment">//  [1, 2, 3, 4，5]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="reduce-函数"><a href="#reduce-函数" class="headerlink" title="reduce 函数"></a>reduce 函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, next</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> prev.concat(<span class="built_in">Array</span>.isArray(next) ? flatten(next) : next)</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr));<span class="comment">//  [1, 2, 3, 4，5]</span></span><br></pre></td></tr></table></figure>
<h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (arr.some(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">Array</span>.isArray(item))) &#123;</span><br><span class="line">        arr = [].concat(...arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr)); <span class="comment">//  [1, 2, 3, 4，5]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="split-和-toString"><a href="#split-和-toString" class="headerlink" title="split 和 toString"></a>split 和 toString</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.toString().split(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr)); <span class="comment">//  [1, 2, 3, 4，5]</span></span><br></pre></td></tr></table></figure>

<h3 id="ES6-中的-flat"><a href="#ES6-中的-flat" class="headerlink" title="ES6 中的 flat"></a>ES6 中的 flat</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.flat(<span class="literal">Infinity</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr)); <span class="comment">//  [1, 2, 3, 4，5]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="数组的flat方法"><a href="#数组的flat方法" class="headerlink" title="数组的flat方法"></a>数组的flat方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">_flat</span>(<span class="params">arr, depth</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!<span class="built_in">Array</span>.isArray(arr) || depth &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">prev, cur</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(cur)) &#123;</span><br><span class="line">      <span class="keyword">return</span> prev.concat(_flat(cur, depth - <span class="number">1</span>))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> prev.concat(cur);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="数组的push方法"><a href="#数组的push方法" class="headerlink" title="数组的push方法"></a>数组的push方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"><span class="built_in">Array</span>.prototype.push = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>( <span class="keyword">let</span> i = <span class="number">0</span> ; i &lt; <span class="built_in">arguments</span>.length ; i++)&#123;</span><br><span class="line">		<span class="built_in">this</span>[<span class="built_in">this</span>.length] = <span class="built_in">arguments</span>[i] ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">this</span>.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组的filter方法"><a href="#数组的filter方法" class="headerlink" title="数组的filter方法"></a>数组的filter方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype._filter = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">&#x27;参数必须是一个函数&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = <span class="built_in">this</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">        fn(<span class="built_in">this</span>[i]) &amp;&amp; res.push(<span class="built_in">this</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组的map方法"><a href="#数组的map方法" class="headerlink" title="数组的map方法"></a>数组的map方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype._map = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">&#x27;参数必须是一个函数&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = <span class="built_in">this</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">        res.push(fn(<span class="built_in">this</span>[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="字符串的repeat方法"><a href="#字符串的repeat方法" class="headerlink" title="字符串的repeat方法"></a>字符串的repeat方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">repeat</span>(<span class="params">s, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>)).join(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串翻转"><a href="#字符串翻转" class="headerlink" title="字符串翻转"></a>字符串翻转</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype._reverse = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.split(<span class="string">&quot;&quot;</span>).reverse().join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">String</span>();</span><br><span class="line"><span class="keyword">var</span> res = obj._reverse (<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res);    <span class="comment">// olleh</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="解析URL-Params-为对象"><a href="#解析URL-Params-为对象" class="headerlink" title="解析URL Params 为对象"></a>解析URL Params 为对象</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseParam</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> paramsStr = <span class="regexp">/.+\?(.+)$/</span>.exec(url)[<span class="number">1</span>]; <span class="comment">// 将 ? 后面的字符串取出来</span></span><br><span class="line">  <span class="keyword">const</span> paramsArr = paramsStr.split(<span class="string">&#x27;&amp;&#x27;</span>); <span class="comment">// 将字符串以 &amp; 分割后存到数组中</span></span><br><span class="line">  <span class="keyword">let</span> paramsObj = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 将 params 存到对象中</span></span><br><span class="line">  paramsArr.forEach(<span class="function"><span class="params">param</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/=/</span>.test(param)) &#123; <span class="comment">// 处理有 value 的参数</span></span><br><span class="line">      <span class="keyword">let</span> [key, val] = param.split(<span class="string">&#x27;=&#x27;</span>); <span class="comment">// 分割 key 和 value</span></span><br><span class="line">      val = <span class="built_in">decodeURIComponent</span>(val); <span class="comment">// 解码</span></span><br><span class="line">      val = <span class="regexp">/^\d+$/</span>.test(val) ? <span class="built_in">parseFloat</span>(val) : val; <span class="comment">// 判断是否转为数字</span></span><br><span class="line">      <span class="keyword">if</span> (paramsObj.hasOwnProperty(key)) &#123; <span class="comment">// 如果对象有 key，则添加一个值</span></span><br><span class="line">        paramsObj[key] = [].concat(paramsObj[key], val);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果对象没有这个 key，创建 key 并设置值</span></span><br><span class="line">        paramsObj[key] = val;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 处理没有 value 的参数</span></span><br><span class="line">      paramsObj[param] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> paramsObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>面试题</category>
        <category>手写题</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题vue面试题汇总一</title>
    <url>/135xyq.github.io/2022/05/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98-vue-%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B8%80/</url>
    <content><![CDATA[<h1 id="Vue-面试题相关"><a href="#Vue-面试题相关" class="headerlink" title="Vue 面试题相关"></a><em>Vue</em> 面试题相关</h1><h2 id="1-谈一谈对-MVVM-的理解？"><a href="#1-谈一谈对-MVVM-的理解？" class="headerlink" title="1. 谈一谈对 MVVM 的理解？"></a>1. <strong>谈一谈对 <em>MVVM</em> 的理解？</strong></h2><blockquote>
<p>参考答案：</p>
<ul>
<li> <em>MVVM</em> 是 <em>Model-View-ViewModel</em> 的缩写。<em>MVVM</em> 是一种设计思想。</li>
<li><em>Model</em> 层代表数据模型，也可以在 <em>Model</em> 中定义数据修改和操作的业务逻辑; </li>
<li><em>View</em> 代表 <em>UI</em> 组件，它负责将数据模型转化成 <em>UI</em> 展现出来，<em>View</em> 是一个同步 <em>View</em> 和 <em>Model</em> 的对象</li>
<li>在 <em>MVVM</em> 架构下，<em>View</em> 和 <em>Model</em> 之间并没有直接的联系，而是通过 <em>ViewModel</em> 进行交互， <em>Model</em> 和 <em>ViewModel</em> 之间的交互是双向的， 因此 <em>View</em> 数据的变化会同步到 <em>Model</em> 中，而 <em>Model</em> 数据的变化也会立即反应到 <em>View</em> 上。</li>
<li>对 <em>ViewModel</em> 通过双向数据绑定把 <em>View</em> 层和 <em>Model</em> 层连接了起来，而 <em>View</em> 和 <em>Model</em> 之间的 同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 <em>DOM</em>，不需要关注数据状态的同步问题，复杂的数据状态维护完全由 <em>MVVM</em> 来统一管理。</li>
</ul>
</blockquote>
<h2 id="2-说一下-Vue-的优点"><a href="#2-说一下-Vue-的优点" class="headerlink" title="2. 说一下 Vue 的优点"></a>2. <strong>说一下 <em>Vue</em> 的优点</strong></h2><blockquote>
<p>参考答案：</p>
<p><em>Vue</em> 是一个构建数据驱动的 <em>Web</em> 界面的渐进式框架。</p>
<p><em>Vue</em> 的目标是通过尽可能简单的 <em>API</em> 实现响应的数据绑定和组合的视图组件。核心是一个响应的数据绑定系统。</p>
<p>关于 <em>Vue</em> 的优点，主要有<strong>响应式编程、组件化开发、虚拟 <em>DOM</em></strong></p>
<p><strong>响应式编程</strong></p>
<p>这里的响应式不是 <em>@media</em> 媒体查询中的响应式布局，而是指 <em>Vue</em> 会自动对页面中某些数据的变化做出响应。这也就是 <em>Vue</em> 最大的优点，通过 <em>MVVM</em> 思想实现数据的双向绑定，让开发者不用再操作 <em>DOM</em> 对象，有更多的时间去思考业务逻辑。</p>
<p><strong>组件化开发</strong></p>
<p><em>Vue</em> 通过组件，把一个单页应用中的各种模块拆分到一个一个单独的组件（<em>component</em>）中，我们只要先在父级应用中写好各种组件标签（占坑），并且在组件标签中写好要传入组件的参数（就像给函数传入参数一样，这个参数叫做组件的属性），然后再分别写好各种组件的实现（填坑），然后整个应用就算做完了。</p>
<p>组件化开发的优点：提高开发效率、方便重复使用、简化调试步骤、提升整个项目的可维护性、便于协同开发。</p>
<p><strong>虚拟 <em>DOM</em></strong></p>
<p>在传统开发中，用 <em>JQuery</em> 或者原生的 <em>JavaScript DOM</em> 操作函数对 <em>DOM</em> 进行频繁操作的时候，浏览器要不停的渲染新的 <em>DOM</em> 树，导致在性能上面的开销特别的高。</p>
<p>而 <em>Virtual DOM</em> 则是虚拟 <em>DOM</em> 的英文，简单来说，他就是一种可以预先通过 <em>JavaScript</em> 进行各种计算，把最终的 <em>DOM</em> 操作计算出来并优化，由于这个 <em>DOM</em> 操作属于预处理操作，并没有真实的操作 <em>DOM</em>，所以叫做虚拟 <em>DOM</em>。最后在计算完毕才真正将 <em>DOM</em> 操作提交，将 <em>DOM</em> 操作变化反映到 <em>DOM</em> 树上。</p>
</blockquote>
<h2 id="3-解释一下对-Vue-生命周期的理解"><a href="#3-解释一下对-Vue-生命周期的理解" class="headerlink" title="3. 解释一下对 Vue 生命周期的理解"></a>3. <strong>解释一下对 <em>Vue</em> 生命周期的理解</strong></h2><ul>
<li>什么是 <em>vue</em> 生命周期</li>
<li><em>vue</em> 生命周期的作用是什么</li>
<li><em>vue</em> 生命周期有几个阶段</li>
<li>第一次页面加载会触发哪几个钩子</li>
<li><em>DOM</em> 渲染在哪个周期就已经完成</li>
<li>多组件（父子组件）中生命周期的调用顺序说一下</li>
</ul>
<blockquote>
<p>参考答案：</p>
<p><strong>什么是 <em>vue</em> 生命周期</strong></p>
<p>对于 <em>vue</em> 来讲，生命周期就是一个 <em>vue</em> 实例从创建到销毁的过程。</p>
<p><strong><em>vue</em> 生命周期的作用是什么</strong></p>
<p>在生命周期的过程中会运行着一些叫做生命周期的函数，给予了开发者在不同的生命周期阶段添加业务代码的能力。</p>
<p>其实和回调是一个概念，当系统执行到某处时，检查是否有 <em>hook</em>(钩子)，有的话就会执行回调。</p>
<p>通俗的说，<em>hook</em> 就是在程序运行中，在某个特定的位置，框架的开发者设计好了一个钩子来告诉我们当前程序已经运行到特定的位置了，会触发一个回调函数，并提供给我们，让我们可以在生命周期的特定阶段进行相关业务代码的编写。</p>
<p><strong><em>vue</em> 生命周期有几个阶段</strong></p>
<p>它可以总共分为 <em>8</em> 个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后。</p>
<ul>
<li><p><em>beforeCreate</em>：是 <em>new Vue( )</em> 之后触发的第一个钩子，在当前阶段 <em>data、methods、computed</em> 以及 <em>watch</em> 上的数据和方法都不能被访问。</p>
</li>
<li><p><em>created</em>：在实例创建完成后发生，当前阶段已经完成了数据观测，也就是可以使用数据，更改数据，在这里更改数据不会触发 <em>updated</em> 函数。可以做一些初始数据的获取，在当前阶段无法与 <em>DOM</em> 进行交互，如果非要想，可以通过 <em>vm.$nextTick</em> 来访问 <em>DOM</em> 。</p>
</li>
<li><p><em>beforeMount</em>：发生在挂载之前，在这之前 <em>template</em> 模板已导入渲染函数编译。而当前阶段虚拟 <em>DOM</em> 已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发 <em>updated</em>。</p>
</li>
<li><p><em>mounted</em>：在挂载完成后发生，在当前阶段，真实的 <em>DOM</em> 挂载完毕，数据完成双向绑定，可以访问到 <em>DOM</em> 节点，使用 <em>$refs</em> 属性对 <em>DOM</em> 进行操作。</p>
</li>
<li><p><em>beforeUpdate</em>：发生在更新之前，也就是响应式数据发生更新，虚拟 <em>DOM</em> 重新渲染之前被触发，你可以在当前阶段进行更改数据，不会造成重渲染。</p>
</li>
<li><p><em>updated</em>：发生在更新完成之后，当前阶段组件 <em>DOM</em> 已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。</p>
</li>
<li><p><em>beforeDestroy</em>：发生在实例销毁之前，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器。</p>
</li>
<li><p><em>destroyed</em>：发生在实例销毁之后，这个时候只剩下了 <em>DOM</em> 空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。</p>
</li>
</ul>
<p><strong>第一次页面加载会触发哪几个钩子</strong></p>
<p>会触发 <em>4</em> 个钩子，分别是：<em>beforeCreate、created、beforeMount、mounted</em></p>
<p><strong><em>DOM</em> 渲染在哪个周期就已经完成</strong></p>
<p><em>DOM</em> 渲染是在 <em>mounted</em> 阶段完成，此阶段真实的 <em>DOM</em> 挂载完毕，数据完成双向绑定，可以访问到 <em>DOM</em> 节点。</p>
<p><strong>多组件（父子组件）中生命周期的调用顺序说一下</strong></p>
<p>组件的调用顺序都是先父后子，渲染完成的顺序是先子后父。组件的销毁操作是先父后子，销毁完成的顺序是先子后父。</p>
<ul>
<li><p>加载渲染过程：父<em>beforeCreate</em>-&gt;父<em>created</em>-&gt;父<em>beforeMount</em>-&gt;子<em>beforeCreate</em>-&gt;子<em>created</em>-&gt;子<em>beforeMount</em>- &gt;子<em>mounted</em>-&gt;父<em>mounted</em></p>
</li>
<li><p>子组件更新过程：父<em>beforeUpdate</em>-&gt;子<em>beforeUpdate</em>-&gt;子<em>updated</em>-&gt;父<em>updated</em></p>
</li>
<li><p>父组件更新过程：父 <em>beforeUpdate</em> -&gt; 父 <em>updated</em></p>
</li>
<li><p>销毁过程：父<em>beforeDestroy</em>-&gt;子<em>beforeDestroy</em>-&gt;子<em>destroyed</em>-&gt;父<em>destroyed</em></p>
</li>
</ul>
</blockquote>
<h2 id="4-Vue-实现双向数据绑定原理是什么？"><a href="#4-Vue-实现双向数据绑定原理是什么？" class="headerlink" title="4. Vue 实现双向数据绑定原理是什么？"></a>4. <strong><em>Vue</em> 实现双向数据绑定原理是什么？</strong></h2><blockquote>
<p>参考答案：</p>
<p><em>Vue2.x</em> 采用数据劫持结合发布订阅模式（<em>PubSub</em> 模式）的方式，通过 <em>Object.defineProperty</em> 来劫持各个属性的 <em>setter、getter</em>，在数据变动时发布消息给订阅者，触发相应的监听回调。</p>
<p>当把一个普通 <em>Javascript</em> 对象传给 <em>Vue</em> 实例来作为它的 <em>data</em> 选项时，<em>Vue</em> 将遍历它的属性，用 <em>Object.defineProperty</em> 将它们转为 <em>getter/setter</em>。用户看不到 <em>getter/setter</em>，但是在内部它们让 <em>Vue</em> 追踪依赖，在属性被访问和修改时通知变化。</p>
<p><em>Vue</em> 的数据双向绑定整合了 <em>Observer</em>，<em>Compile</em> 和 <em>Watcher</em> 三者，通过 <em>Observer</em> 来监听自己的 <em>model</em> 的数据变化，通过 <em>Compile</em> 来解析编译模板指令，最终利用 <em>Watcher</em> 搭起 <em>Observer</em> 和 <em>Compile</em> 之间的通信桥梁，达到数据变化-&gt;视图更新，视图交互变化（例如 input 操作）-&gt;数据 <em>model</em> 变更的双向绑定效果。</p>
<p><em>Vue3.x</em> 放弃了 <em>Object.defineProperty</em> ，使用 <em>ES6</em> 原生的 <em>Proxy</em>，来解决以前使用  <em>Object.defineProperty</em> 所存在的一些问题。</p>
</blockquote>
<h2 id="5-说一下对-Vue2-x-响应式原理的理解"><a href="#5-说一下对-Vue2-x-响应式原理的理解" class="headerlink" title="5. 说一下对 Vue2.x 响应式原理的理解"></a>5. <strong>说一下对 <em>Vue2.x</em> 响应式原理的理解</strong></h2><blockquote>
<p>参考答案：</p>
<p><em>Vue</em> 在初始化数据时，会使用 <em>Object.defineProperty</em> 重新定义 <em>data</em> 中的所有属性，当页面使用对应属性时，首先会进行依赖收集(收集当前组件的 <em>watcher</em>)，如果属性发生变化会通知相关依赖进行更新操作(发布订阅)。</p>
<p>（可以参阅前面第 <em>4</em> 题答案）</p>
</blockquote>
<h2 id="6-说一下在-Vue2-x-中如何检测数组的变化？"><a href="#6-说一下在-Vue2-x-中如何检测数组的变化？" class="headerlink" title="6. 说一下在 Vue2.x 中如何检测数组的变化？"></a>6. <strong>说一下在 <em>Vue2.x</em> 中如何检测数组的变化？</strong></h2><blockquote>
<p>参考答案：</p>
<p><em>Vue2.x</em> 中实现检测数组变化的方法，是<strong>将数组的常用方法进行了重写</strong>。<em>Vue</em> 将 <em>data</em> 中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组 <em>api</em> 时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。</p>
<p>流程:</p>
<ol>
<li>初始化传入 data 数据执行 initData</li>
<li>将数据进行观测 new Observer</li>
<li>将数组原型方法指向重写的原型</li>
<li>深度观察数组中的引用类型</li>
</ol>
<p>有两种情况无法检测到数组的变化。</p>
<ul>
<li>当利用索引直接设置一个数组项时，例如 <em>vm.items[indexOfItem] = newValue</em></li>
<li>当修改数组的长度时，例如 <em>vm.items.length = newLength</em></li>
</ul>
<p>不过这两种场景都有对应的解决方案。</p>
<p><strong>利用索引设置数组项的替代方案</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用该方法进行更新视图</span></span><br><span class="line"><span class="comment">// vm.$set，Vue.set的一个别名</span></span><br><span class="line">vm.$set(vm.items, indexOfItem, newValue)</span><br></pre></td></tr></table></figure>

<p><strong>修改数组的长度的替代方案</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用该方法进行更新视图</span></span><br><span class="line"><span class="comment">// Array.prototype.splice</span></span><br><span class="line">vm.items.splice(indexOfItem, <span class="number">1</span>, newValue)</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="7-Vue3-x-响应式数据"><a href="#7-Vue3-x-响应式数据" class="headerlink" title="7. Vue3.x 响应式数据"></a>7. <strong><em>Vue3.x</em> 响应式数据</strong></h2><ul>
<li><em>Vue3.x</em> 响应式数据原理是什么？</li>
<li><em>Proxy</em> 只会代理对象的第一层，那么 <em>Vue3</em> 又是怎样处理这个问题的呢？</li>
<li>监测数组的时候可能触发多次 <em>get/set</em>，那么如何防止触发多次呢？</li>
</ul>
<blockquote>
<p>参考答案：</p>
<p><strong><em>Vue3.x</em> 响应式数据原理是什么？</strong></p>
<p>在 <em>Vue 2</em> 中，响应式原理就是使用的 <em>Object.defineProperty</em> 来实现的。但是在 <em>Vue 3.0</em> 中采用了 <em>Proxy</em>，抛弃了 <em>Object.defineProperty</em> 方法。</p>
<p>究其原因，主要是以下几点：</p>
<ul>
<li><em>Object.defineProperty</em> 无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应</li>
<li><em>Object.defineProperty</em> 只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。<em>Proxy</em> 可以劫持整个对象，并返回一个新的对象。</li>
<li><em>Proxy</em> 不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性。</li>
<li><em>Proxy</em> 有多达 <em>13</em> 种拦截方法</li>
<li><em>Proxy</em>作为新标准将受到浏览器厂商重点持续的性能优化</li>
</ul>
<p><strong><em>Proxy</em> 只会代理对象的第一层，那么 <em>Vue3</em> 又是怎样处理这个问题的呢？</strong></p>
<p>判断当前 <em>Reflect.get</em> 的返回值是否为 <em>Object</em>，如果是则再通过 <em>reactive</em> 方法做代理， 这样就实现了深度观测。</p>
<p>*<em>监测数组的时候可能触发多次 <em>get/set</em>，那么如何防止触发多次呢？</em>*</p>
<p>我们可以判断 <em>key</em> 是否为当前被代理对象 <em>target</em> 自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行 <em>trigger</em>。</p>
</blockquote>
<h2 id="8-v-model-双向绑定的原理是什么？"><a href="#8-v-model-双向绑定的原理是什么？" class="headerlink" title="8. v-model 双向绑定的原理是什么？"></a>8. <strong><em>v-model</em> 双向绑定的原理是什么？</strong></h2><blockquote>
<p>参考答案：</p>
<p><em>v-model</em> 本质就是 <em>:value + input</em> 方法的语法糖。可以通过 <em>model</em> 属性的 <em>prop</em> 和 <em>event</em> 属性来进行自定义。原生的 <em>v-model</em>，会根据标签的不同生成不同的事件和属性。</p>
<p>例如：</p>
<ul>
<li><em>text</em> 和 <em>textarea</em> 元素使用 <em>value</em> 属性和 <em>input</em> 事件</li>
<li><em>checkbox</em> 和 <em>radio</em> 使用 <em>checked</em> 属性和 <em>change</em> 事件</li>
<li><em>select</em> 字段将 <em>value</em> 作为 <em>prop</em> 并将 <em>change</em> 作为事件</li>
</ul>
<p>以输入框为例，当用户在输入框输入内容时，会触发 <em>input</em> 事件，从而更新 <em>value</em>。而 <em>value</em> 的改变同样会更新视图，这就是 <em>vue</em> 中的双向绑定。双向绑定的原理，其实现思路如下：</p>
<p>首先要对数据进行劫持监听，所以我们需要设置一个监听器 <em>Observer</em>，用来监听所有属性。如果属性发上变化了，就需要告诉订阅者 <em>Watcher</em> 看是否需要更新。</p>
<p>因为订阅者是有很多个，所以我们需要有一个消息订阅器 <em>Dep</em> 来专门收集这些订阅者，然后在监听器 <em>Observer</em> 和订阅者 <em>Watcher</em> 之间进行统一管理的。</p>
<p>接着，我们还需要有一个指令解析器 <em>Compile</em>，对每个节点元素进行扫描和解析，将相关指令对应初始化成一个订阅者 <em>Watcher</em>，并替换模板数据或者绑定相应的函数，此时当订阅者 <em>Watcher</em> 接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。</p>
<p>因此接下去我们执行以下 <em>3</em> 个步骤，实现数据的双向绑定：</p>
<ol>
<li><p>实现一个监听器 <em>Observer</em>，用来劫持并监听所有属性，如果有变动的，就通知订阅者。</p>
</li>
<li><p>实现一个订阅者 <em>Watcher</em>，可以收到属性的变化通知并执行相应的函数，从而更新视图。</p>
</li>
<li><p>实现一个解析器 <em>Compile</em>，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器。</p>
</li>
</ol>
<p>流程图如下：</p>
<img src="https://img-blog.csdnimg.cn/img_convert/717034f25ee385b09e9dee53b2988cae.png" alt="img"  />
</blockquote>
<h2 id="9-vue2-x-和-vuex3-x-渲染器的-diff-算法分别说一下？"><a href="#9-vue2-x-和-vuex3-x-渲染器的-diff-算法分别说一下？" class="headerlink" title="9. vue2.x 和 vuex3.x 渲染器的 diff 算法分别说一下？"></a>9. <strong><em>vue2.x</em> 和 <em>vuex3.x</em> 渲染器的 <em>diff</em> 算法分别说一下？</strong></h2><blockquote>
<p>直播讲解</p>
</blockquote>
<blockquote>
<p>参考答案：</p>
<p>简单来说，<em>diff</em> 算法有以下过程</p>
<ul>
<li>同级比较，再比较子节点</li>
<li>先判断一方有子节点一方没有子节点的情况(如果新的 <em>children</em> 没有子节点，将旧的子节点移除)</li>
<li>比较都有子节点的情况(核心 <em>diff</em>)</li>
<li>递归比较子节点</li>
</ul>
<p>正常 <em>Diff</em> 两个树的时间复杂度是 *O(n^3)<em>，但实际情况下我们很少会进行跨层级的移动 <em>DOM</em>，所以 <em>Vue</em> 将 <em>Diff</em> 进行了优化，从</em>O(n^3) -&gt; O(n)*，只有当新旧 <em>children</em> 都为多个子节点时才需要用核心的 <em>Diff</em> 算法进行同层级比较。</p>
<p><em>Vue2</em> 的核心 <em>Diff</em> 算法采用了双端比较的算法，同时从新旧 <em>children</em> 的两端开始进行比较，借助 <em>key</em> 值找到可复用的节点，再进行相关操作。相比 <em>React</em> 的 <em>Diff</em> 算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅。</p>
<p><em>Vue3.x</em> 借鉴了 <em>ivi</em> 算法和 <em>inferno</em> 算法</p>
<p>在创建 <em>VNode</em> 时就确定其类型，以及在 <em>mount/patch</em> 的过程中采用位运算来判断一个 <em>VNode</em> 的类型，在这个基础之上再配合核心的 <em>Diff</em> 算法，使得性能上较 <em>Vue2.x</em> 有了提升。该算法中还运用了动态规划的思想求解最长递归子序列。</p>
</blockquote>
<h2 id="10-vue-组件的参数传递"><a href="#10-vue-组件的参数传递" class="headerlink" title="10. vue 组件的参数传递"></a>10. <strong><em>vue</em> 组件的参数传递</strong></h2><ul>
<li>解释一下父组件与子组件传值实现过程</li>
<li>非父子组件的数据传递，兄弟组件传值是如何实现的</li>
</ul>
<blockquote>
<p>参考答案：</p>
<p><strong>解释一下父组件与子组件传值实现过程</strong></p>
<ul>
<li><p>父组件传给子组件：子组件通过 <em>props</em> 方法接受数据</p>
</li>
<li><p>子组件传给父组件：使用自定义事件，自组件通过 <em>$emit</em> 方法触发父组件的方法来传递参数</p>
</li>
</ul>
<p><strong>非父子组件的数据传递，兄弟组件传值是如何实现的</strong></p>
<p><em>eventBus</em>，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。项目比较小时，用这个比较合适。</p>
<p>此外，总结 <em>vue</em> 中的组件通信方式，常见使用场景可以分为三类：</p>
<ul>
<li>父子通信：<ul>
<li>父向子传递数据是通过 <em>props</em> ，子向父是通过 <em>$emit / $on</em></li>
<li><em>$emit / $bus</em></li>
<li><em>vuex</em></li>
<li>通过父链 / 子链也可以通信（ <em>$parent / $children</em> ）</li>
<li><em>ref</em> 也可以访问组件实例</li>
<li><em>v-model</em></li>
<li>.<em>sync</em> 修饰符</li>
</ul>
</li>
<li>兄弟通信：<ul>
<li><em>$emit / $bus</em></li>
<li><em>vuex</em></li>
</ul>
</li>
<li>跨级通信：<ul>
<li><em>$emit / $bus</em> </li>
<li><em>vuex</em> </li>
<li><em>provide / inject API</em></li>
<li><em>$attrs/$listeners</em></li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="11-Vue-的路由实现"><a href="#11-Vue-的路由实现" class="headerlink" title="11. Vue 的路由实现"></a>11. <strong><em>Vue</em> 的路由实现</strong></h2><ul>
<li>解释 <em>hash</em> 模式和 <em>history</em> 模式的实现原理</li>
<li>说一下 <em>$router</em> 与 <em>$route</em> 的区别</li>
<li><em>vueRouter</em> 有哪几种导航守卫？</li>
<li>解释一下 <em>vueRouter</em> 的完整的导航解析流程是什么</li>
</ul>
<blockquote>
<p>参考答案：</p>
<p><strong>解释 <em>hash</em> 模式和 <em>history</em> 模式的实现原理</strong></p>
<p><code>#</code> 后面 <em>hash</em> 值的变化，不会导致浏览器向服务器发出请求，浏览器不发出请求，就不会刷新页面；通过监听 <em>hashchange</em> 事件可以知道 <em>hash</em> 发生了哪些变化，然后根据 <em>hash</em> 变化来实现更新页面部分内容的操作。</p>
<p><em>history</em> 模式的实现，主要是 <em>HTML5</em> 标准发布的两个 <em>API</em>，<em>pushState</em> 和 <em>replaceState</em>，这两个 <em>API</em> 可以在改变 <em>URL</em>，但是不会发送请求。这样就可以监听 <em>url</em> 变化来实现更新页面部分内容的操作。 </p>
<p>两种模式的区别：</p>
<ul>
<li><p>首先是在 <em>URL</em> 的展示上，<em>hash</em> 模式有“#”，<em>history</em> 模式没有</p>
</li>
<li><p>刷新页面时，<em>hash</em> 模式可以正常加载到 <em>hash</em> 值对应的页面，而 <em>history</em> 没有处理的话，会返回 <em>404</em>，一般需要后端将所有页面都配置重定向到首页路由</p>
</li>
<li><p>在兼容性上，<em>hash</em> 可以支持低版本浏览器和 <em>IE</em></p>
</li>
</ul>
<p><strong>说一下 <em>$router</em> 与 <em>$route</em> 的区别</strong></p>
<p><em>$route</em> 对象表示当前的路由信息，包含了当前 <em>URL</em> 解析得到的信息。包含当前的路径，参数，<em>query</em> 对象等。</p>
<ul>
<li><em>$route.path</em>：字符串，对应当前路由的路径，总是解析为绝对路径，如 “/foo/bar”。 </li>
<li><em>$route.params</em>： 一个 key/value 对象，包含了 动态片段 和 全匹配片段，如果没有路由参数，就是一个空对象。 </li>
<li><em>$route.query</em>：一个 key/value 对象，表示 URL 查询参数。例如对于路径 <em>/foo?user=1</em>，则有 <em>$route.query.user == 1</em>，如果没有查询参数，则是个空对象。 </li>
<li><em>$route.hash</em>：当前路由的 hash 值 (不带 #) ，如果没有 <em>hash</em> 值，则为空字符串。</li>
<li><em>$route.fullPath</em>：完成解析后的 <em>URL</em>，包含查询参数和 <em>hash</em> 的完整路径。 </li>
<li><em>$route.matched</em>：数组，包含当前匹配的路径中所包含的所有片段所对应的配置参数对象。 </li>
<li><em>$route.name</em>：当前路径名字 </li>
<li><em>$route.meta</em>：路由元信息  </li>
</ul>
<p><em>$route</em> 对象出现在多个地方:</p>
<ul>
<li>组件内的 <em>this.$route</em> 和 <em>route watcher</em> 回调（监测变化处理）</li>
<li><em>router.match(location)</em> 的返回值</li>
<li><em>scrollBehavior</em> 方法的参数</li>
<li>导航钩子的参数，例如 <em>router.beforeEach</em> 导航守卫的钩子函数中，<em>to</em> 和 <em>from</em> 都是这个路由信息对象。</li>
</ul>
<p><em>$router</em> 对象是全局路由的实例，是 <em>router</em> 构造方法的实例。</p>
<p><em>$router</em> 对象常用的方法有：</p>
<ul>
<li><em>push</em>：向 <em>history</em> 栈添加一个新的记录</li>
<li><em>go</em>：页面路由跳转前进或者后退</li>
<li><em>replace</em>：替换当前的页面，不会向 <em>history</em> 栈添加一个新的记录</li>
</ul>
<p><strong><em>vueRouter</em> 有哪几种导航守卫？</strong></p>
<ul>
<li><p>全局前置/钩子：<em>beforeEach、beforeR-esolve、afterEach</em></p>
</li>
<li><p>路由独享的守卫：<em>beforeEnter</em></p>
</li>
<li><p>组件内的守卫：<em>beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave</em> </p>
</li>
</ul>
<p><strong>解释一下 <em>vueRouter</em> 的完整的导航解析流程是什么</strong></p>
<p>一次完整的导航解析流程如下：</p>
<ol>
<li>导航被触发。</li>
<li>在失活的组件里调用离开守卫。</li>
<li>调用全局的 <em>beforeEach</em> 守卫。</li>
<li>在重用的组件里调用 <em>beforeRouteUpdate</em> 守卫（*2.2+*）。</li>
<li>在路由配置里调用 <em>beforeEnter</em>。</li>
<li>解析异步路由组件。</li>
<li>在被激活的组件里调用 <em>beforeRouteEnter</em>。</li>
<li>调用全局的 <em>beforeResolve</em> 守卫（*2.5+*）。</li>
<li>导航被确认。</li>
<li>调用全局的 <em>afterEach</em> 钩子。</li>
<li>触发 <em>DOM</em> 更新。</li>
<li>用创建好的实例调用 <em>beforeRouteEnter</em> 守卫中传给 <em>next</em> 的回调函数。</li>
</ol>
</blockquote>
<h2 id="12-vuex-是什么？怎么使用它？什么场景下我们会使用到-vuex"><a href="#12-vuex-是什么？怎么使用它？什么场景下我们会使用到-vuex" class="headerlink" title="12. vuex* 是什么？怎么使用它？什么场景下我们会使用到 *vuex"></a>12. <em><strong>vuex* 是什么？怎么使用它？什么场景下我们会使用到 *vuex</strong></em></h2><blockquote>
<p>参考答案：</p>
<p><strong><em>vuex</em> 是什么</strong></p>
<p><em>vuex</em> 是一个专为 <em>Vue</em> 应用程序开发的状态管理器，采用集中式存储管理应用的所有组件的状态。每一个 <em>vuex</em> 应用的核心就是 <em>store</em>（仓库）。“<em>store</em>” 基本上就是一个容器，它包含着应用中大部分的状态 (<em>state</em>)。</p>
<p><strong>为什么需要 <em>vuex</em></strong></p>
<p>由于组件只维护自身的状态(<em>data</em>)，组件创建时或者路由切换时，组件会被初始化，从而导致 <em>data</em> 也随之销毁。</p>
<p><strong>使用方法</strong></p>
<p>在 <em>main.js</em> 引入 <em>store</em>，注入。只用来读取的状态集中放在 <em>store</em> 中， 改变状态的方式是提交 <em>mutations</em>，这是个同步的事物，异步逻辑应该封装在 <em>action</em> 中。</p>
<p><strong>什么场景下会使用到 <em>vuex</em></strong></p>
<p>如果是 <em>vue</em> 的小型应用，那么没有必要使用 <em>vuex</em>，这个时候使用 <em>vuex</em> 反而会带来负担。组件之间的状态传递使用 <em>props</em>、自定义事件来传递即可。</p>
<p>但是如果涉及到 <em>vue</em> 的大型应用，那么就需要类似于 <em>vuex</em> 这样的集中管理状态的状态机来管理所有组件的状态。例如登录状态、加入购物车、音乐播放等，总之只要是开发 <em>vue</em> 的大型应用，都推荐使用 <em>vuex</em> 来管理所有组件状态。</p>
</blockquote>
<h2 id="13-说一下-v-for-与-v-show-的区别"><a href="#13-说一下-v-for-与-v-show-的区别" class="headerlink" title="13. 说一下 v-for 与 v-show 的区别"></a>13. <strong>说一下 <em>v-for</em> 与 <em>v-show</em> 的区别</strong></h2><blockquote>
<p>参考答案：</p>
<ul>
<li><p>共同点：都是动态显示 <em>DOM</em> 元素 </p>
</li>
<li><p>区别点:</p>
<ul>
<li><p>手段</p>
<p><em>v-if</em> 是动态的向 <em>DOM</em> 树内添加或者删除 <em>DOM</em> 元素</p>
<p><em>v-show</em> 是通过设置 <em>DOM</em> 元素的 <em>display</em> 样式属性控制显隐</p>
</li>
<li><p>编译过程</p>
<p><em>v-if</em>  切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件</p>
<p><em>v-show</em> 只是简单的基于 <em>css</em> 切换</p>
</li>
<li><p>编译条件</p>
<p><em>v-if</em>  是惰性的，如果初始条件为假，则什么也不做。只有在条件第一次变为真时才开始局部编译</p>
<p><em>v-show</em> 是在任何条件下(首次条件是否为真)都被编译，然后被缓存，而且 <em>DOM</em> 元素保留</p>
</li>
<li><p>性能消耗</p>
<p><em>v-if</em>  有更高的切换消耗</p>
<p><em>v-show</em> 有更高的初始渲染消耗</p>
</li>
<li><p>使用场景</p>
<p><em>v-if</em>  适合运营条件不大可能改变 </p>
<p><em>v-show</em> 适合频繁切换</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="14-如何让-CSS-值在当前的组件中起作用"><a href="#14-如何让-CSS-值在当前的组件中起作用" class="headerlink" title="14. 如何让 CSS 值在当前的组件中起作用"></a>14. <strong>如何让 <em>CSS</em> 值在当前的组件中起作用</strong></h2><blockquote>
<p>参考答案：</p>
<p>在 <em>vue</em> 文件中的 <em>style</em> 标签上，有一个特殊的属性：<em>scoped</em>。当一个 style 标签拥有 <em>scoped</em> 属性时，它的 <em>CSS</em> 样式就只能作用于当前的组件，也就是说，该样式只能适用于当前组件元素。通过该属性，可以使得组件之间的样式不互相污染。如果一个项目中的所有 <em>style</em> 标签全部加上了 <em>scoped</em>，相当于实现了样式的模块化。</p>
<p><strong><em>scoped</em> 的实现原理</strong></p>
<p><em>vue</em> 中的 <em>scoped</em> 属性的效果主要通过 <em>PostCSS</em> 转译实现的。<em>PostCSS</em> 给一个组件中的所有 <em>DOM</em> 添加了一个独一无二的动态属性，然后，给 <em>CSS</em> 选择器额外添加一个对应的属性选择器来选择该组件中 <em>DOM</em>，这种做法使得样式只作用于含有该属性的 <em>DOM</em>，即组件内部 <em>DOM</em>。</p>
<p>例如：</p>
<p>转译前</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;example&quot;</span>&gt;</span>hi<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="css"></span></span></span><br><span class="line"><span class="css"><span class="xml"><span class="selector-class">.example</span> &#123;</span></span></span><br><span class="line"><span class="css"><span class="xml">  <span class="attribute">color</span>: red;</span></span></span><br><span class="line"><span class="css"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="css"><span class="xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>转译后：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;example&quot;</span> <span class="attr">data-v-5558831a</span>&gt;</span>hi<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span></span><br><span class="line"><span class="css"><span class="xml"><span class="selector-class">.example</span><span class="selector-attr">[data-v-5558831a]</span> &#123;</span></span></span><br><span class="line"><span class="css"><span class="xml">  <span class="attribute">color</span>: red;</span></span></span><br><span class="line"><span class="css"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="css"><span class="xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="15-keep-alive-相关"><a href="#15-keep-alive-相关" class="headerlink" title="15. keep-alive 相关"></a>15. <strong><em>keep-alive</em> 相关</strong></h2><ul>
<li>keep-alive的实现原理是什么</li>
<li>与keep-alive相关的生命周期函数是什么，什么场景下会进行使用</li>
<li>keep-alive的常用属性有哪些</li>
</ul>
<blockquote>
<p>参考答案：</p>
<p>keep-alive 组件是 vue 的内置组件，用于缓存内部组件实例。这样做的目的在于，keep-alive 内部的组件切回时，不用重新创建组件实例，而直接使用缓存中的实例，一方面能够避免创建组件带来的开销，另一方面可以保留组件的状态。</p>
<p>keep-alive 具有 include 和 exclude 属性，通过它们可以控制哪些组件进入缓存。另外它还提供了 max 属性，通过它可以设置最大缓存数，当缓存的实例超过该数时，vue 会移除最久没有使用的组件缓存。</p>
<p>受keep-alive的影响，其内部所有嵌套的组件都具有两个生命周期钩子函数，分别是 activated 和 deactivated，它们分别在组件激活和失活时触发。第一次 activated 触发是在 mounted 之后</p>
<p>在具体的实现上，keep-alive 在内部维护了一个 key 数组和一个缓存对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// keep-alive 内部的声明周期函数</span></span><br><span class="line">created () &#123;</span><br><span class="line">    <span class="built_in">this</span>.cache = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">    <span class="built_in">this</span>.keys = []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>key 数组记录目前缓存的组件 key 值，如果组件没有指定 key 值，则会为其自动生成一个唯一的 key 值</p>
<p>cache 对象以 key 值为键，vnode 为值，用于缓存组件对应的虚拟 DOM</p>
<p>在 keep-alive 的渲染函数中，其基本逻辑是判断当前渲染的 vnode 是否有对应的缓存，如果有，从缓存中读取到对应的组件实例；如果没有则将其缓存。</p>
<p>当缓存数量超过 max 数值时，keep-alive 会移除掉 key 数组的第一个元素。</p>
</blockquote>
<h2 id="16-Vue-中如何进行组件的使用？-Vue-如何实现全局组件的注册？"><a href="#16-Vue-中如何进行组件的使用？-Vue-如何实现全局组件的注册？" class="headerlink" title="16. *Vue 中如何进行组件的使用？*Vue 如何实现全局组件的注册？**"></a>16. <em>*<em>Vue</em> 中如何进行组件的使用？*Vue</em> 如何实现全局组件的注册？**</h2><blockquote>
<p>参考答案：</p>
<p>要使用组件，首先需要使用 <em>import</em> 来引入组件，然后在 <em>components</em> 属性中注册组件，之后就可以在模板中使用组件了。</p>
<p>可以使用 <em>Vue.component</em> 方法来实现全局组件的注册。</p>
</blockquote>
<h2 id="17-vue-cli-工程相关"><a href="#17-vue-cli-工程相关" class="headerlink" title="17. vue-cli 工程相关"></a>17. <strong><em>vue-cli</em> 工程相关</strong></h2><ul>
<li>构建 <em>vue-cli</em> 工程都用到了哪些技术？他们的作用分别是什么？</li>
<li><em>vue-cli</em> 工程常用的 <em>npm</em> 命令有哪些？</li>
</ul>
<blockquote>
<p>参考答案：</p>
<p><strong>构建 <em>vue-cli</em> 工程都用到了哪些技术？他们的作用分别是什么？</strong></p>
<ol>
<li>vue.js：vue-cli 工程的核心，主要特点是双向数据绑定和组件系统。</li>
<li>vue-router：vue 官方推荐使用的路由框架。</li>
<li>vuex：专为 Vue.js 应用项目开发的状态管理器，主要用于维护 vue 组件间共用的一些 变量 和 方法。</li>
<li>axios（或者 fetch、ajax）：用于发起 GET 、或 POST 等 http请求，基于 Promise 设计。</li>
<li>vux等：一个专为vue设计的移动端UI组件库。</li>
<li>webpack：模块加载和vue-cli工程打包器。</li>
<li>eslint：代码规范工具</li>
</ol>
<p><strong><em>vue-cli</em> 工程常用的 <em>npm</em> 命令有哪些？</strong></p>
<p>下载 node_modules 资源包的命令：npm install</p>
<p>启动 vue-cli 开发环境的 npm命令：npm run dev</p>
<p>vue-cli 生成 生产环境部署资源 的 npm命令：npm run build</p>
<p>用于查看 vue-cli 生产环境部署资源文件大小的 npm命令：npm run build –report</p>
</blockquote>
<h2 id="18-nextTick-的作用是什么？他的实现原理是什么？"><a href="#18-nextTick-的作用是什么？他的实现原理是什么？" class="headerlink" title="18. nextTick 的作用是什么？他的实现原理是什么？"></a>18. <strong><em>nextTick</em> 的作用是什么？他的实现原理是什么？</strong></h2><blockquote>
<p>参考答案：</p>
<p>作用：<em>vue</em> 更新 <em>DOM</em> 是异步更新的，数据变化，<em>DOM</em> 的更新不会马上完成，<em>nextTick</em> 的回调是在下次 <em>DOM</em> 更新循环结束之后执行的延迟回调。</p>
<p>实现原理：<em>nextTick</em> 主要使用了宏任务和微任务。根据执行环境分别尝试采用</p>
<ul>
<li><em>Promise</em>：可以将函数延迟到当前函数调用栈最末端</li>
<li><em>MutationObserver</em> ：是 <em>H5</em> 新加的一个功能，其功能是监听 <em>DOM</em> 节点的变动，在所有 <em>DOM</em> 变动完成后，执行回调函数</li>
<li><em>setImmediate</em>：用于中断长时间运行的操作，并在浏览器完成其他操作（如事件和显示更新）后立即运行回调函数</li>
<li>如果以上都不行则采用 <em>setTimeout</em> 把函数延迟到 DOM 更新之后再使用</li>
</ul>
<p>原因是宏任务消耗大于微任务，优先使用微任务，最后使用消耗最大的宏任务。</p>
</blockquote>
<h2 id="19-说一下-Vue-SSR-的实现原理"><a href="#19-说一下-Vue-SSR-的实现原理" class="headerlink" title="19. 说一下 Vue SSR 的实现原理"></a>19. <strong>说一下 <em>Vue SSR</em> 的实现原理</strong></h2><blockquote>
<p>参考答案：</p>
<ul>
<li><em>app.js</em> 作为客户端与服务端的公用入口，导出 <em>Vue</em> 根实例，供客户端 <em>entry</em> 与服务端 <em>entry</em> 使用。客户端 <em>entry</em> 主要作用挂载到 <em>DOM</em> 上，服务端 <em>entry</em> 除了创建和返回实例，还需要进行路由匹配与数据预获取。</li>
<li><em>webpack</em> 为客服端打包一个 <em>ClientBundle</em>，为服务端打包一个 <em>ServerBundle</em>。</li>
<li>服务器接收请求时，会根据 <em>url</em>，加载相应组件，获取和解析异步数据，创建一个读取 <em>Server Bundle</em> 的 <em>BundleRenderer</em>，然后生成 <em>html</em> 发送给客户端。</li>
<li>客户端混合，客户端收到从服务端传来的 <em>DOM</em> 与自己的生成的 <em>DOM</em> 进行对比，把不相同的 <em>DOM</em> 激活，使其可以能够响应后续变化，这个过程称为客户端激活（也就是转换为单页应用）。为确保混合成功，客户 端与服务器端需要共享同一套数据。在服务端，可以在渲染之前获取数据，填充到 <em>store</em> 里，这样，在客户端挂载到 <em>DOM</em> 之前，可以直接从 <em>store</em> 里取数据。首屏的动态数据通过 <em>window._<em>INITIAL_STATE</em>_</em> 发送到客户端</li>
<li><em>VueSSR</em> 的原理，主要就是通过 <em>vue-server-renderer</em> 把 <em>Vue</em> 的组件输出成一个完整 <em>HTML</em>，输出到客户端，到达客户端后重新展开为一个单页应用。</li>
</ul>
</blockquote>
<h2 id="20-Vue-组件的-data-为什么必须是函数"><a href="#20-Vue-组件的-data-为什么必须是函数" class="headerlink" title="20. Vue 组件的 data 为什么必须是函数"></a>20. <strong><em>Vue</em> 组件的 <em>data</em> 为什么必须是函数</strong></h2><blockquote>
<p>参考答案：</p>
<p>组件中的 <em>data</em> 写成一个函数，数据以函数返回值形式定义。这样每复用一次组件，就会返回一份新的 <em>data</em>，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份 <em>data</em>，就会造成一个变了全都会变的结果。</p>
</blockquote>
<h2 id="21-说一下-Vue-的-computed-的实现原理"><a href="#21-说一下-Vue-的-computed-的实现原理" class="headerlink" title="21. 说一下 Vue 的 computed 的实现原理"></a>21. <strong>说一下 <em>Vue</em> 的 <em>computed</em> 的实现原理</strong></h2><blockquote>
<p>参考答案：</p>
<p>当组件实例触发生命周期函数 <em>beforeCreate</em> 后，它会做一系列事情，其中就包括对 <em>computed</em> 的处理。</p>
<p>它会遍历 <em>computed</em> 配置中的所有属性，为每一个属性创建一个 <em>Watcher</em> 对象，并传入一个函数，该函数的本质其实就是 <em>computed</em> 配置中的 <em>getter</em>，这样一来，<em>getter</em> 运行过程中就会收集依赖</p>
<p>但是和渲染函数不同，为计算属性创建的 <em>Watcher</em> 不会立即执行，因为要考虑到该计算属性是否会被渲染函数使用，如果没有使用，就不会得到执行。因此，在创建 <em>Watcher</em> 的时候，它使用了 <em>lazy</em> 配置，<em>lazy</em> 配置可以让 <em>Watcher</em> 不会立即执行。</p>
<p>收到 <em>lazy</em> 的影响，<em>Watcher</em> 内部会保存两个关键属性来实现缓存，一个是 <em>value</em>，一个是 <em>dirty</em></p>
<p><em>value</em> 属性用于保存 <em>Watcher</em> 运行的结果，受 <em>lazy</em> 的影响，该值在最开始是 <em>undefined</em></p>
<p><em>dirty</em> 属性用于指示当前的 <em>value</em> 是否已经过时了，即是否为脏值，受 <em>lazy</em> 的影响，该值在最开始是 <em>true</em></p>
<p>Watcher 创建好后，vue 会使用代理模式，将计算属性挂载到组件实例中</p>
<p>当读取计算属性时，<em>vue</em> 检查其对应的 <em>Watcher</em> 是否是脏值，如果是，则运行函数，计算依赖，并得到对应的值，保存在 <em>Watcher</em> 的 <em>value</em> 中，然后设置 <em>dirty</em> 为 <em>false</em>，然后返回。</p>
<p>如果 <em>dirty</em> 为 <em>false</em>，则直接返回 <em>watcher</em> 的 <em>value</em></p>
<p>巧妙的是，在依赖收集时，被依赖的数据不仅会收集到计算属性的 <em>Watcher</em>，还会收集到组件的 <em>Watcher</em></p>
<p>当计算属性的依赖变化时，会先触发计算属性的 <em>Watcher</em> 执行，此时，它只需设置 <em>dirty</em> 为 <em>true</em> 即可，不做任何处理。</p>
<p>由于依赖同时会收集到组件的 <em>Watcher</em>，因此组件会重新渲染，而重新渲染时又读取到了计算属性，由于计算属性目前已为 dirty，因此会重新运行 <em>getter</em> 进行运算</p>
<p>而对于计算属性的 <em>setter</em>，则极其简单，当设置计算属性时，直接运行 <em>setter</em> 即可。</p>
</blockquote>
<h2 id="22-说一下-Vue-complier-的实现原理是什么样的？"><a href="#22-说一下-Vue-complier-的实现原理是什么样的？" class="headerlink" title="22. 说一下 Vue complier 的实现原理是什么样的？"></a>22. <strong>说一下 <em>Vue complier</em> 的实现原理是什么样的？</strong></h2><blockquote>
<p>参考答案：</p>
<p>在使用 vue 的时候，我们有两种方式来创建我们的 HTML 页面，第一种情况，也是大多情况下，我们会使用模板 template 的方式，因为这更易读易懂也是官方推荐的方法；第二种情况是使用 render 函数来生成 HTML，它比 template 更接近最终结果。</p>
<p>complier 的主要作用是解析模板，生成渲染模板的 <em>render</em>， 而 <em>render</em> 的作用主要是为了生成 <em>VNode</em></p>
<p>complier 主要分为 3 大块：</p>
<ul>
<li>parse：接受 template 原始模板，按着模板的节点和数据生成对应的 ast</li>
<li>optimize：遍历 ast 的每一个节点，标记静态节点，这样就知道哪部分不会变化，于是在页面需要更新时，通过 diff 减少去对比这部分DOM，提升性能</li>
<li>generate 把前两步生成完善的 ast，组成 render 字符串，然后将 render 字符串通过 new Function 的方式转换成渲染函数</li>
</ul>
</blockquote>
<h2 id="23-vue-如何快速定位那个组件出现性能问题的"><a href="#23-vue-如何快速定位那个组件出现性能问题的" class="headerlink" title="23. vue 如何快速定位那个组件出现性能问题的"></a>23. <strong><em>vue</em> 如何快速定位那个组件出现性能问题的</strong></h2><blockquote>
<p>参考答案：</p>
<p>⽤ <em>timeline</em> ⼯具。 通过 <em>timeline</em> 来查看每个函数的调⽤时常，定位出哪个函数的问题，从⽽能判断哪个组件出了问题。</p>
</blockquote>
<h2 id="24-Proxy-相比-defineProperty-的优势在哪里"><a href="#24-Proxy-相比-defineProperty-的优势在哪里" class="headerlink" title="24. Proxy 相比 defineProperty 的优势在哪里"></a>24. <strong><em>Proxy</em> 相比 <em>defineProperty</em> 的优势在哪里</strong></h2><blockquote>
<p>参考答案：</p>
<p><em>Vue3.x</em> 改用 <em>Proxy</em> 替代 <em>Object.defineProperty</em></p>
<p>原因在于 <em>Object.defineProperty</em> 本身存在的一些问题：</p>
<ul>
<li><em>Object.defineProperty</em> 只能劫持对象属性的 <em>getter</em> 和 <em>setter</em> 方法。</li>
<li><em>Object.definedProperty</em> 不支持数组(可以监听数组,不过数组方法无法监听自己重写)，更准确的说是不支持数组的各种 <em>API</em>(所以 <em>Vue</em> 重写了数组方法。</li>
</ul>
<p>而相比  <em>Object.defineProperty</em>，<em>Proxy</em> 的优点在于：</p>
<ul>
<li><em>Proxy</em> 是直接代理劫持整个对象。</li>
<li><em>Proxy</em> 可以直接监听对象和数组的变化，并且有多达 <em>13</em> 种拦截方法。</li>
</ul>
<p>目前，<em>Object.definedProperty</em> 唯一比 <em>Proxy</em> 好的一点就是兼容性，不过 <em>Proxy</em> 新标准也受到浏览器厂商重点持续的性能优化当中。</p>
</blockquote>
<h2 id="25-Vue-与-Angular-以及-React-的区别是什么？"><a href="#25-Vue-与-Angular-以及-React-的区别是什么？" class="headerlink" title="25. Vue 与 Angular 以及 React 的区别是什么？"></a>25. <strong><em>Vue</em> 与 <em>Angular</em> 以及 <em>React</em> 的区别是什么？</strong></h2><blockquote>
<p>参考答案：</p>
<p>这种题目是开放性题目，一般是面试过程中面试官口头来提问，不太可能出现在笔试试卷里面。</p>
<p>关于 <em>Vue</em> 和其他框架的不同，官方专门写了一篇文档，从性能、体积、灵活性等多个方面来进行了说明。</p>
<p>详细可以参阅：<em><a href="https://cn.vuejs.org/v2/guide/comparison.html">https://cn.vuejs.org/v2/guide/comparison.html</a></em></p>
<p>建议面试前通读一遍该篇文档，然后进行适当的总结。</p>
</blockquote>
<h2 id="26-说一下-watch-与-computed-的区别是什么？以及他们的使用场景分别是什么？"><a href="#26-说一下-watch-与-computed-的区别是什么？以及他们的使用场景分别是什么？" class="headerlink" title="26. 说一下 watch 与 computed 的区别是什么？以及他们的使用场景分别是什么？"></a>26. <strong>说一下 <em>watch</em> 与 <em>computed</em> 的区别是什么？以及他们的使用场景分别是什么？</strong></h2><blockquote>
<p>参考答案：</p>
<p>区别：</p>
<ol>
<li>都是观察数据变化的（相同）</li>
<li>计算属性将会混入到 vue 的实例中，所以需要监听自定义变量；watch 监听 data 、props 里面数据的变化；</li>
<li>computed 有缓存，它依赖的值变了才会重新计算，watch 没有；</li>
<li>watch 支持异步，computed 不支持；</li>
<li>watch 是一对多（监听某一个值变化，执行对应操作）；computed 是多对一（监听属性依赖于其他属性）</li>
<li>watch 监听函数接收两个参数，第一个是最新值，第二个是输入之前的值；</li>
<li>computed 属性是函数时，都有 get 和 set 方法，默认走 get 方法，get 必须有返回值（return）</li>
</ol>
<p>watch 的 参数：</p>
<ul>
<li>deep：深度监听</li>
<li>immediate ：组件加载立即触发回调函数执行</li>
</ul>
<p>computed 缓存原理：</p>
<p>conputed本质是一个惰性的观察者；当计算数据存在于 data 或者 props里时会被警告；</p>
<p>vue 初次运行会对 computed 属性做初始化处理（initComputed），初始化的时候会对每一个 computed 属性用 watcher 包装起来 ，这里面会生成一个 dirty 属性值为 true；然后执行 defineComputed 函数来计算，计算之后会将 dirty 值变为 false，这里会根据 dirty 值来判断是否需要重新计算；如果属性依赖的数据发生变化，computed 的 watcher 会把 dirty 变为 true，这样就会重新计算 computed 属性的值。</p>
</blockquote>
<h2 id="27-scoped-是如何实现样式穿透的？"><a href="#27-scoped-是如何实现样式穿透的？" class="headerlink" title="27. scoped 是如何实现样式穿透的？"></a>27. <strong><em>scoped</em> 是如何实现样式穿透的？</strong></h2><blockquote>
<p>参考答案：</p>
<p>首先说一下什么场景下需要 <em>scoped</em> 样式穿透。</p>
<p>在很多项目中，会出现这么一种情况，即：引用了第三方组件，需要在组件中局部修改第三方组件的样式，而又不想去除 <em>scoped</em> 属性造成组件之间的样式污染。此时只能通过特殊的方式，穿透 <em>scoped</em>。</p>
<p>有三种常用的方法来实现样式穿透。</p>
<p><strong>方法一</strong></p>
<p>使用 <em>::v-deep</em> 操作符( &gt;&gt;&gt; 的别名)</p>
<p>如果希望 <em>scoped</em> 样式中的一个选择器能够作用得“更深”，例如影响子组件，可以使用 &gt;&gt;&gt; 操作符：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;style scoped&gt;</span><br><span class="line">    .a &gt;&gt;&gt; .b &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>上述代码将会编译成：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.a[data-v-f3f3eg9] .b &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>

<p>后面的类名没有 <em>data</em> 属性，所以能选到子组件里面的类名。</p>
<p>有些像 <em>Sass</em> 之类的预处理器无法正确解析 &gt;&gt;&gt;，所以需要使用 <em>::v-deep</em> 操作符来代替。</p>
<p><strong>方法二</strong></p>
<p>定义一个含有 <em>scoped</em> 属性的 <em>style</em> 标签之外，再定义一个不含有 <em>scoped</em> 属性的 <em>style</em> 标签，即在一个 <em>vue</em> 组件中定义一个全局的 <em>style</em> 标签，一个含有作用域的 <em>style</em> 标签：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line"><span class="comment">/* global styles */</span></span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="css"></span></span></span><br><span class="line"><span class="css"><span class="xml"><span class="comment">/* local styles */</span></span></span></span><br><span class="line"><span class="css"><span class="xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>此时，我们只需要将修改第三方样式的 <em>css</em> 写在第一个 <em>style</em> 中即可。</p>
<p><strong>方法三</strong></p>
<p>上面的方法一需要单独书写一个不含有 <em>scoped</em> 属性的 <em>style</em> 标签，可能会造成全局样式的污染。</p>
<p>更推荐的方式是在组件的外层 <em>DOM</em> 上添加唯一的 <em>class</em> 来区分不同组件，在书写样式时就可以正常针对针对这部分 <em>DOM</em> 书写样式。</p>
</blockquote>
<h2 id="28-说一下-ref-的作用是什么？"><a href="#28-说一下-ref-的作用是什么？" class="headerlink" title="28. 说一下 ref 的作用是什么？"></a>28. <strong>说一下 <em>ref</em> 的作用是什么？</strong></h2><blockquote>
<p>参考答案：</p>
<p><em>ref</em> 的作用是被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 <em>$refs</em> 对象上。其特点是：</p>
<ul>
<li>如果在普通的 <em>DOM</em> 元素上使用，引用指向的就是 <em>DOM</em> 元素</li>
<li>如果用在子组件上，引用就指向组件实例</li>
</ul>
<p>所以常见的使用场景有：</p>
<ol>
<li>基本用法，本页面获取 <em>DOM</em> 元素</li>
<li>获取子组件中的 <em>data</em></li>
<li>调用子组件中的方法</li>
</ol>
</blockquote>
<h2 id="29-说一下你知道的-vue-修饰符都有哪些？"><a href="#29-说一下你知道的-vue-修饰符都有哪些？" class="headerlink" title="29. 说一下你知道的 vue 修饰符都有哪些？"></a>29. <strong>说一下你知道的 <em>vue</em> 修饰符都有哪些？</strong></h2><blockquote>
<p>参考答案：</p>
<p>在 <em>vue</em> 中修饰符可以分为 <em>3</em> 类：</p>
<ul>
<li>事件修饰符</li>
<li>按键修饰符</li>
<li>表单修饰符</li>
</ul>
<p><strong>事件修饰符</strong></p>
<p>在事件处理程序中调用 <em>event.preventDefault</em> 或 <em>event.stopPropagation</em> 方法是非常常见的需求。尽管可以在 <em>methods</em> 中轻松实现这点，但更好的方式是：<em>methods</em> 只有纯粹的数据逻辑，而不是去处理 <em>DOM</em> 事件细节。</p>
<p>为了解决这个问题，<em>vue</em> 为 <em>v-on</em> 提供了事件修饰符。通过由点 <em>.</em> 表示的指令后缀来调用修饰符。</p>
<p>常见的事件修饰符如下：</p>
<ul>
<li><em>.stop</em>：阻止冒泡。</li>
<li><em>.prevent</em>：阻止默认事件。</li>
<li><em>.capture</em>：使用事件捕获模式。</li>
<li><em>.self</em>：只在当前元素本身触发。</li>
<li><em>.once</em>：只触发一次。</li>
<li><em>.passive</em>：默认行为将会立即触发。</li>
</ul>
<p><strong>按键修饰符</strong></p>
<p>除了事件修饰符以外，在 <em>vue</em> 中还提供了有鼠标修饰符，键值修饰符，系统修饰符等功能。</p>
<ul>
<li>.<em>left</em>：左键</li>
<li>.<em>right</em>：右键</li>
<li>.<em>middle</em>：滚轮</li>
<li>.<em>enter</em>：回车</li>
<li>.<em>tab</em>：制表键</li>
<li>.<em>delete</em>：捕获 “删除” 和 “退格” 键</li>
<li>.<em>esc</em>：返回</li>
<li>.<em>space</em>：空格</li>
<li>.<em>up</em>：上</li>
<li>.<em>down</em>：下</li>
<li>.<em>left</em>：左</li>
<li>.<em>right</em>：右</li>
<li>.<em>ctrl</em>：<em>ctrl</em> 键</li>
<li>.<em>alt</em>：<em>alt</em> 键</li>
<li>.<em>shift</em>：<em>shift</em> 键</li>
<li>.<em>meta</em>：<em>meta</em> 键</li>
</ul>
<p><strong>表单修饰符</strong></p>
<p><em>vue</em> 同样也为表单控件也提供了修饰符，常见的有 <em>.lazy</em>、*.number* 和 <em>.trim</em>。</p>
<ul>
<li>.<em>lazy</em>：在文本框失去焦点时才会渲染</li>
<li>.<em>number</em>：将文本框中所输入的内容转换为number类型</li>
<li>.<em>trim</em>：可以自动过滤输入首尾的空格</li>
</ul>
</blockquote>
<h2 id="30-如何实现-vue-项目中的性能优化？"><a href="#30-如何实现-vue-项目中的性能优化？" class="headerlink" title="30. 如何实现 vue 项目中的性能优化？"></a>30. <strong>如何实现 <em>vue</em> 项目中的性能优化？</strong></h2><blockquote>
<p>直播课讲解</p>
</blockquote>
<blockquote>
<p>参考答案：</p>
<p><strong>编码阶段</strong></p>
<ul>
<li>尽量减少 <em>data</em> 中的数据，<em>data</em> 中的数据都会增加 <em>getter</em> 和 <em>setter</em>，会收集对应的 <em>watcher</em></li>
<li><em>v-if</em> 和 <em>v-for</em> 不能连用</li>
<li>如果需要使用 <em>v-for</em> 给每项元素绑定事件时使用事件代理</li>
<li><em>SPA</em> 页面采用 <em>keep-alive</em> 缓存组件</li>
<li>在更多的情况下，使用 <em>v-if</em> 替代 <em>v-show</em></li>
<li><em>key</em> 保证唯一</li>
<li>使用路由懒加载、异步组件</li>
<li>防抖、节流</li>
<li>第三方模块按需导入</li>
<li>长列表滚动到可视区域动态加载</li>
<li>图片懒加载</li>
</ul>
<p><strong><em>SEO</em> 优化</strong></p>
<ul>
<li>预渲染</li>
<li>服务端渲染 <em>SSR</em></li>
</ul>
<p><strong>打包优化</strong></p>
<ul>
<li>压缩代码</li>
<li><em>Tree Shaking/Scope Hoisting</em></li>
<li>使用 <em>cdn</em> 加载第三方模块</li>
<li>多线程打包 <em>happypack</em></li>
<li><em>splitChunks</em> 抽离公共文件</li>
<li><em>sourceMap</em> 优化</li>
</ul>
<p><strong>用户体验</strong></p>
<ul>
<li>骨架屏</li>
<li><em>PWA</em></li>
</ul>
<p>还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启 <em>gzip</em> 压缩等。</p>
</blockquote>
<h2 id="31-Vue-extend-和-Vue-component-的区别是什么？"><a href="#31-Vue-extend-和-Vue-component-的区别是什么？" class="headerlink" title="31. Vue.extend 和 Vue.component 的区别是什么？"></a>31. <strong><em>Vue.extend</em> 和 <em>Vue.component</em> 的区别是什么？</strong></h2><blockquote>
<p>参考答案：</p>
<p><em>Vue.extend</em> 用于创建一个基于 <em>Vue</em> 构造函数的“子类”，其参数应为一个包含组件选项的对象。</p>
<p><em>Vue.component</em> 用来注册全局组件。</p>
</blockquote>
<h2 id="32-vue-中的-spa-应用如何优化首屏加载速度"><a href="#32-vue-中的-spa-应用如何优化首屏加载速度" class="headerlink" title="32. vue 中的 spa 应用如何优化首屏加载速度?"></a>32. <strong><em>vue</em> 中的 <em>spa</em> 应用如何优化首屏加载速度?</strong></h2><blockquote>
<p>参考答案：</p>
<p>优化首屏加载可以从这几个方面开始：</p>
<ul>
<li>请求优化：CDN 将第三方的类库放到 CDN 上，能够大幅度减少生产环境中的项目体积，另外 CDN 能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。</li>
<li>缓存：将长时间不会改变的第三方类库或者静态资源设置为强缓存，将 max-age 设置为一个非常长的时间，再将访问路径加上哈希达到哈希值变了以后保证获取到最新资源，好的缓存策略有助于减轻服务器的压力，并且显著的提升用户的体验</li>
<li>gzip：开启 gzip 压缩，通常开启 gzip 压缩能够有效的缩小传输资源的大小。</li>
<li>http2：如果系统首屏同一时间需要加载的静态资源非常多，但是浏览器对同域名的 tcp 连接数量是有限制的(chrome 为 6 个)超过规定数量的 tcp 连接，则必须要等到之前的请求收到响应后才能继续发送，而 http2 则可以在多个 tcp 连接中并发多个请求没有限制，在一些网络较差的环境开启 http2 性能提升尤为明显。</li>
<li>懒加载：当 url 匹配到相应的路径时，通过 import 动态加载页面组件，这样首屏的代码量会大幅减少，webpack 会把动态加载的页面组件分离成单独的一个 chunk.js 文件</li>
<li>预渲染：由于浏览器在渲染出页面之前，需要先加载和解析相应的 html、css 和 js 文件，为此会有一段白屏的时间，可以添加loading，或者骨架屏幕尽可能的减少白屏对用户的影响体积优化</li>
<li>合理使用第三方库：对于一些第三方 ui 框架、类库，尽量使用按需加载，减少打包体积</li>
<li>使用可视化工具分析打包后的模块体积：webpack-bundle- analyzer 这个插件在每次打包后能够更加直观的分析打包后模块的体积，再对其中比较大的模块进行优化</li>
<li>提高代码使用率：利用代码分割，将脚本中无需立即调用的代码在代码构建时转变为异步加载的过程</li>
<li>封装：构建良好的项目架构，按照项目需求就行全局组件，插件，过滤器，指令，utils 等做一 些公共封装，可以有效减少我们的代码量，而且更容易维护资源优化</li>
<li>图片懒加载：使用图片懒加载可以优化同一时间减少 http 请求开销，避免显示图片导致的画面抖动，提高用户体验</li>
<li>使用 svg 图标：相对于用一张图片来表示图标，svg 拥有更好的图片质量，体积更小，并且不需要开启额外的 http 请求</li>
<li>压缩图片：可以使用 image-webpack-loader，在用户肉眼分辨不清的情况下一定程度上压缩图片</li>
</ul>
</blockquote>
<h2 id="33-移动端如何实现一个比较友好的-header-组件"><a href="#33-移动端如何实现一个比较友好的-header-组件" class="headerlink" title="33. 移动端如何实现一个比较友好的 header 组件"></a>33. <strong>移动端如何实现一个比较友好的 <em>header</em> 组件</strong></h2><blockquote>
<p>参考答案：</p>
<p><em>Header</em> 一般分为左、中、右三个部分，分为三个区域来设计，中间为主标题，每个页面的标题肯定不同，所以可以通过 <em>vue props</em>的方式做成可配置对外进行暴露，左侧大部分页面可能都是回退按钮，但是样式和内容不尽相同，右侧一般都是具有功能性的操作按钮，所以左右两侧可以通过 <em>vue slot</em> 插槽的方式对外暴露以实现多样化，同时也可以提供 <em>default slot</em> 默认插槽来统一页面风格。</p>
</blockquote>
<h2 id="34-既然-Vue-通过数据劫持可以精准探测数据变化，为什么还需要虚拟-DOM-进行-diff-监测差异-？"><a href="#34-既然-Vue-通过数据劫持可以精准探测数据变化，为什么还需要虚拟-DOM-进行-diff-监测差异-？" class="headerlink" title="34. 既然 Vue 通过数据劫持可以精准探测数据变化，为什么还需要虚拟 DOM 进行 diff 监测差异 ？"></a>34. <strong>既然 <em>Vue</em> 通过数据劫持可以精准探测数据变化，为什么还需要虚拟 <em>DOM</em> 进行 <em>diff</em> 监测差异 ？</strong></h2><blockquote>
<p>参考答案：</p>
<p>现代前端框架有两种方式侦测变化，一种是 <em>pull</em>，一种是 <em>push</em>。</p>
<p><em><strong>pull</strong></em></p>
<p>其代表为 <em>React</em>，我们可以回忆一下 <em>React</em> 是如何侦测到变化的。</p>
<p>我们通常会用 <em>setState API</em> 显式更新,然后 <em>React</em> 会进行一层层的 <em>Virtual Dom Diff</em> 操作找出差异，然后 <em>Patch</em> 到 <em>DOM</em> 上，<em>React</em> 从一开始就不知道到底是哪发生了变化,只是知道「有变化了」,然后再进行比较暴力的 <em>Diff</em> 操作查找「哪发生变化了」，另外一个代表就是 <em>Angular</em> 的脏检查操作。</p>
<p><em><strong>push</strong></em></p>
<p><em>Vue</em> 的响应式系统则是 <em>push</em> 的代表，当 <em>Vue</em> 程序初始化的时候就会对数据 <em>data</em> 进行依赖的收集，一但数据发生变化，响应式系统就会立刻得知，因此 <em>Vue</em> 是一开始就知道是「在哪发生变化了」</p>
<p>但是这又会产生一个问题，通常绑定一个数据就需要一个 <em>Watcher</em>，一但我们的绑定细粒度过高就会产生大量的 <em>Watcher</em>，这会带来内存以及依赖追踪的开销，而细粒度过低会无法精准侦测变化，因此 <em>Vue</em> 的设计是选择中等细粒度的方案，在组件级别进行 <em>push</em> 侦测的方式，也就是那套响应式系统。</p>
<p>通常我们会第一时间侦测到发生变化的组件,然后在组件内部进行 <em>Virtual Dom Diff</em> 获取更加具体的差异，而 <em>Virtual Dom Diff</em> 则是 <em>pull</em> 操作，<em>Vue</em> 是 <em>push + pull</em> 结合的方式进行变化侦测的。</p>
</blockquote>
<h2 id="35-Vue-为什么没有类似于-React-中-shouldComponentUpdate-的生命周期？"><a href="#35-Vue-为什么没有类似于-React-中-shouldComponentUpdate-的生命周期？" class="headerlink" title="35. Vue 为什么没有类似于 React 中 shouldComponentUpdate 的生命周期？"></a>35. <strong><em>Vue</em> 为什么没有类似于 <em>React</em> 中 <em>shouldComponentUpdate</em> 的生命周期？</strong></h2><blockquote>
<p>参考答案：</p>
<p>根本原因是 <em>Vue</em> 与 <em>React</em> 的变化侦测方式有所不同</p>
<p><em>React</em> 是 <em>pull</em> 的方式侦测变化，当 <em>React</em> 知道发生变化后，会使用 <em>Virtual Dom Diff</em> 进行差异检测,但是很多组件实际上是肯定不会发生变化的，这个时候需要用 <em>shouldComponentUpdate</em> 进行手动操作来减少 <em>diff</em>，从而提高程序整体的性能。</p>
<p><em>Vue</em> 是 <em>pull+push</em> 的方式侦测变化的，在一开始就知道那个组件发生了变化，因此在 <em>push</em> 的阶段并不需要手动控制 <em>diff</em>，而组件内部采用的 <em>diff</em> 方式实际上是可以引入类似于 <em>shouldComponentUpdate</em> 相关生命周期的，但是通常合理大小的组件不会有过量的 <em>diff</em>，手动优化的价值有限，因此目前 <em>Vue</em> 并没有考虑引入 <em>shouldComponentUpdate</em> 这种手动优化的生命周期。</p>
</blockquote>
<h2 id="36-Vue-中的-Key-的作用是什么？"><a href="#36-Vue-中的-Key-的作用是什么？" class="headerlink" title="36. Vue 中的 Key 的作用是什么？"></a>36. <strong><em>Vue</em> 中的 <em>Key</em> 的作用是什么？</strong></h2><blockquote>
<p>参考答案：</p>
<p><em><strong>key* 的作用主要是为了高效的更新虚拟 *DOM</strong></em>。另外 <em>vue</em> 中在使用相同标签名元素的过渡切换时，也会使用到 <em>key</em> 属性，其目的也是为了让 <em>vue</em> 可以区分它们，否则 <em>vue</em> 只会替换其内部属性而不会触发过渡效果。</p>
</blockquote>
<blockquote>
<p>解析：</p>
<p>其实不只是 <em>vue</em>，<em>react</em> 中在执行列表渲染时也会要求给每个组件添加上 <em>key</em> 这个属性。</p>
<p>要解释 <em>key</em> 的作用，不得不先介绍一下虚拟 <em>DOM</em> 的 <em>Diff</em> 算法了。</p>
<p>我们知道，<em>vue</em> 和 <em>react</em> 都实现了一套虚拟 <em>DOM</em>，使我们可以不直接操作 <em>DOM</em> 元素，只操作数据便可以重新渲染页面。而隐藏在背后的原理便是其高效的 <em>Diff</em> 算法。</p>
<p><em>vue</em> 和 <em>react</em> 的虚拟 <em>DOM</em> 的 <em>Diff</em> 算法大致相同，其核心有以下两点：</p>
<ul>
<li><p>两个相同的组件产生类似的 <em>DOM</em> 结构，不同的组件产生不同的 <em>DOM</em> 结构。</p>
</li>
<li><p>同一层级的一组节点，他们可以通过唯一的 <em>id</em> 进行区分。</p>
</li>
</ul>
<p>基于以上这两点，使得虚拟 <em>DOM</em> 的 <em>Diff</em> 算法的复杂度从 <em>O(n^3)</em> 降到了 *O(n)*。</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-08-21-062058.png" alt="image-20210821142057777" style="zoom:50%;" />

<p>当页面的数据发生变化时，<em>Diff</em> 算法只会比较同一层级的节点：</p>
<ul>
<li>如果节点类型不同，直接干掉前面的节点，再创建并插入新的节点，不会再比较这个节点以后的子节点了。</li>
<li>如果节点类型相同，则会重新设置该节点的属性，从而实现节点的更新。</li>
</ul>
<p>当某一层有很多相同的节点时，也就是列表节点时，<em>Diff</em> 算法的更新过程默认情况下也是遵循以上原则。</p>
<p>比如一下这个情况：</p>
<p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-08-21-062225.jpg" alt="img"></p>
<p>我们希望可以在 <em>B</em> 和 <em>C</em> 之间加一个 <em>F</em>，<em>Diff</em> 算法默认执行起来是这样的：</p>
<p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-08-21-062244.jpg" alt="img"></p>
<p>即把 <em>C</em> 更新成 <em>F</em>，<em>D</em> 更新成 <em>C</em>，<em>E</em> 更新成 <em>D</em>，最后再插入 <em>E</em></p>
<p>是不是很没有效率？</p>
<p>所以我们需要使用 <em>key</em> 来给每个节点做一个唯一标识，<em>Diff</em> 算法就可以正确的识别此节点，找到正确的位置区插入新的节点。</p>
<p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-08-21-062321.jpg" alt="img"></p>
</blockquote>
<h2 id="37-你的接口请求一般放在哪个生命周期中？为什么要这样做？"><a href="#37-你的接口请求一般放在哪个生命周期中？为什么要这样做？" class="headerlink" title="37. 你的接口请求一般放在哪个生命周期中？为什么要这样做？"></a>37. <strong>你的接口请求一般放在哪个生命周期中？为什么要这样做？</strong></h2><blockquote>
<p>参考答案：</p>
<p>接口请求可以放在钩子函数 <em>created、beforeMount、mounted</em> 中进行调用，因为在这三个钩子函数中，<em>data</em> 已经创建，可以将服务端端返回的数据进行赋值。</p>
<p>但是推荐在 <em>created</em> 钩子函数中调用异步请求，因为在 <em>created</em> 钩子函数中调用异步请求有以下优点：</p>
<ul>
<li>能更快获取到服务端数据，减少页面 <em>loading</em> 时间</li>
<li><em>SSR</em> 不支持 <em>beforeMount 、mounted</em> 钩子函数，所以放在 <em>created</em> 中有助于代码的一致性</li>
<li><em>created</em> 是在模板渲染成 <em>html</em> 前调用，即通常初始化某些属性值，然后再渲染成视图。如果在 <em>mounted</em> 钩子函数中请求数据可能导致页面闪屏问题 </li>
</ul>
</blockquote>
<h2 id="38-说一下你对-vue-事件绑定原理的理解？"><a href="#38-说一下你对-vue-事件绑定原理的理解？" class="headerlink" title="38. 说一下你对 vue 事件绑定原理的理解？"></a>38. <strong>说一下你对 <em>vue</em> 事件绑定原理的理解？</strong></h2><blockquote>
<p>参考答案：</p>
<p><em>vue</em> 中的事件绑定是有两种，一种是原生的事件绑定，另一种是组件的事件绑定。</p>
<p>原生的事件绑定在普通元素上是通过 <em>@click</em> 进行绑定，在组件上是通过 <em>@click.native</em> 进行绑定，组件中的 <em>nativeOn</em> 是等价于 on 的。组件的事件绑定的 @click 是 vue 中自定义的 $on 方法来实现的，必须有 $emit 才可以触发。</p>
<p><strong>原生事件绑定原理</strong></p>
<p>在 runtime下的patch.js中createPatchFunction执行了之后再赋值给patch。</p>
<p>createPatchFunction方法有两个参数，分别是nodeOps存放操作dom节点的方法和modules，modules是有两个数组拼接起来的，modules拼接完的数组中有一个元素就是events，事件添加就发生在这里。</p>
<p>events元素关联的就是events.js文件，在events中有一个updateDOMListeners方法，在events文件的结尾导出了一个对象，然后对象有一个属性叫做create，这个属性关联的就是updateDOMListeners方法。</p>
<p>在执行createPatchFunction方法时，就会将这两个参数传入，在createPatchFunction方法中接收了一个参数backend，在该方法中一开始进行backend的解构，就是上面的nodeOps和modules参数，解构完之后进入for循环。</p>
<p>在createPatchFunction开头定义了一个cbs对象。for循环遍历一个叫hooks的数组。hooks是文件一开头定义的一个数组，其中包括有create，for循环就是在cbs上定义一系列和hooks元素相同的属性，然后键值是一个数组，然后数组内容是modules里面的一些内容。这时就把events文件中导出来的create属性放在了cbs上。</p>
<p>当我们进入首次渲染的时候，会执行到patch函数里面的createElm方法，这个方法中就会调用invokeCreateHooks函数，用来处理事件系统，这里就是真正准备进行原生事件绑定的入口。invokeCreateHooks方法中，遍历了cbs.create数组里面的内容。然后把cbs.create里面的函数全部都执行一次，在cbs.create其中一个函数就是updateDOMListeners。</p>
<p>updateDOMListeners就是用来添加事件的方法，在这方法中会根据vnode判断是否有定义一个点击事件。如果没有点击事件就return。有的话就继续执行，给on进行赋值，然后进行一些赋值操作，将vnode.elm赋值给target，elm这个属性就是指向vnode所对应的真实dom节点，这里就是把我们要绑定事件的dom结点进行缓存，接下来执行updateListeners方法。在接下来执行updateListeners方法中调用了一个add的方法，然后在app方法中通过原生addEventListener把事件绑定到dom上。</p>
<p><strong>组件事件绑定原理</strong></p>
<p>在组件实例初始化会调用initMixin方法中的Vue.prototype._init，在init函数中，会通过initInternalComponent方法初始化组件信息，将自定义的组件事件放到_parentListeners上，下来就会调用initEvents来初始化组件事件，在initEvents中会实例上添加一个 _event对象，用于保存自定义事件，然后获取到 父组件给 子组件绑定的自定义事件，也就是刚才在初始化组件信息的时候将自定义的组件事件放在了_parentListeners上，这时候vm.$options._parentListeners就是自定义的事件。</p>
<p>最后进行判断，如果有自定义的组件事件就执行updateComponentListeners方法进行事件绑定，在updateComponentListeners方法中会调用updateListeners方法，并传传一个add方法进行执行，这个add方法里就是$on方法。</p>
</blockquote>
<h2 id="39-说一下-vue-模版编译的原理是什么"><a href="#39-说一下-vue-模版编译的原理是什么" class="headerlink" title="39. 说一下 vue 模版编译的原理是什么"></a>39. <strong>说一下 <em>vue</em> 模版编译的原理是什么</strong></h2><blockquote>
<p>参考答案：</p>
<p>简单说，<em>Vue</em> 的编译过程就是将 <em>template</em> 转化为 <em>render</em> 函数的过程。会经历以下阶段：</p>
<ul>
<li>生成 <em>AST</em> 树</li>
<li>优化</li>
<li><em>codegen</em></li>
</ul>
<p>首先解析模版，生成 <em>AST</em> 语法树(一种用 <em>JavaScript</em> 对象的形式来描述整个模板)。 使用大量的正则表达式对模板进行解析，遇到标签、文本的时候都会执行对应的钩子进行相关处理。</p>
<p><em>Vue</em> 的数据是响应式的，但其实模板中并不是所有的数据都是响应式的。有一些数据首次渲染后就不会再变化，对应的 <em>DOM</em> 也不会变化。那么优化过程就是深度遍历 <em>AST</em> 树，按照相关条件对树节点进行标记。这些被标记的节点(静态节点)我们就可以跳过对它们的比对，对运行时的模板起到很大的优化作用。</p>
<p>编译的最后一步是将优化后的 <em>AST</em> 树转换为可执行的代码。</p>
</blockquote>
<blockquote>
<p>可以参阅前面第 <em>22</em> 题。</p>
</blockquote>
<h2 id="40-delete-和-Vue-delete-删除数组的区别是什么？"><a href="#40-delete-和-Vue-delete-删除数组的区别是什么？" class="headerlink" title="40. delete 和 Vue.delete 删除数组的区别是什么？"></a>40. <strong><em>delete</em> 和 <em>Vue.delete</em> 删除数组的区别是什么？</strong></h2><blockquote>
<p>参考答案：</p>
<p><em>delete</em> 只是被删除的元素变成了 <em>empty/undefined</em> 其他的元素的键值还是不变。<br><em>Vue.delete</em> 是直接将元素从数组中完全删除，改变了数组其他元素的键值。</p>
</blockquote>
<h2 id="41-v-on-可以实现监听多个方法么？"><a href="#41-v-on-可以实现监听多个方法么？" class="headerlink" title="41. v-on 可以实现监听多个方法么？"></a>41. <strong><em>v-on</em> 可以实现监听多个方法么？</strong></h2><blockquote>
<p>参考答案：</p>
<p>可以监听多个方法。关于监听多个方法提供了几种不同的写法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">写法一：<span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on</span>=<span class="string">&quot;&#123; 事件类型: 事件处理函数, 事件类型: 事件处理函数 &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">写法二：<span class="tag">&lt;<span class="name">div</span> @事件类型=<span class="string">“事件处理函数”</span> @事件类型=<span class="string">“事件处理函数”</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">写法三：在一个事件里面书写多个事件处理函数</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> @事件类型=<span class="string">“事件处理函数1，事件处理函数2”</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">写法四：在事件处理函数内部调用其他的函数</span><br></pre></td></tr></table></figure>

<p>示例代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- v-on在vue2.x中测试,以下两种均可--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on</span>=<span class="string">&quot;&#123; mouseenter: onEnter, mouseleave: onLeave &#125;&quot;</span>&gt;</span></span><br><span class="line">      鼠标进来1</span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">mouseenter</span>=<span class="string">&quot;onEnter&quot;</span> @<span class="attr">mouseleave</span>=<span class="string">&quot;onLeave&quot;</span>&gt;</span>鼠标进来2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 一个事件绑定多个函数，按顺序执行，这里分隔函数可以用逗号也可以用分号--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;a(), b()&quot;</span>&gt;</span>点我ab<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;one()&quot;</span>&gt;</span>点我onetwothree<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//这里是es6对象里函数写法</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">a</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">b</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;b&quot;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">one</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;one&quot;</span>);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.two();</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.three();</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">two</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;two&quot;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">three</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;three&quot;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">onEnter</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;mouse enter&quot;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">onLeave</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;mouse leave&quot;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">&#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="42-vue-的数据为什么频繁变化但只会更新一次？"><a href="#42-vue-的数据为什么频繁变化但只会更新一次？" class="headerlink" title="42. vue 的数据为什么频繁变化但只会更新一次？"></a>42. <strong><em>vue</em> 的数据为什么频繁变化但只会更新一次？</strong></h2><blockquote>
<p>参考答案：</p>
<p>这是因为 <em>vue</em> 的 <em>DOM</em> 更新是一个异步操作，在数据更新后会首先被 <em>set</em> 钩子监听到，但是不会马上执行 <em>DOM</em> 更新，而是在下一轮循环中执行更新。</p>
<p>具体实现是 <em>vue</em> 中实现了一个 <em>queue</em> 队列用于存放本次事件循环中的所有 <em>watcher</em> 更新，并且同一个 <em>watcher</em> 的更新只会被推入队列一次，并在本轮事件循环的微任务执行结束后执行此更新(<em>UI Render</em> 阶段)，这就是 <em>DOM</em> 只会更新一次的原因。</p>
<p>这种在缓冲时去除重复数据对于避免不必要的计算和 <em>DOM</em> 操作是非常重要的。然后，在下一个的事件循环“<em>tick</em>”中，<em>vue</em> 刷新队列并执行实际 (已去重的) 工作。<em>vue</em> 在内部对异步队列尝试使用原生的 <em>Promise.then、MutationObserver</em>  和 <em>setImmediate</em>，如果执行环境不支持，则会采用 <em>setTimeout(fn, 0)</em> 代替。</p>
</blockquote>
<h2 id="43-说一下-vue-中-computed-和-methods-的区别是什么？"><a href="#43-说一下-vue-中-computed-和-methods-的区别是什么？" class="headerlink" title="43. 说一下 vue 中 computed 和 methods 的区别是什么？"></a>43. <strong>说一下 <em>vue</em> 中 <em>computed</em> 和 <em>methods</em> 的区别是什么？</strong></h2><blockquote>
<p>参考答案：</p>
<p>首先从表现形式上面来看， <em>computed</em> 和 <em>methods</em> 的区别大致有下面 <em>4</em> 点：</p>
<ol>
<li>在使用时，<em>computed</em> 当做属性使用，而 <em>methods</em> 则当做方法调用</li>
<li><em>computed</em> 可以具有 <em>getter</em> 和 <em>setter</em>，因此可以赋值，而 <em>methods</em> 不行</li>
<li><em>computed</em> 无法接收多个参数，而 <em>methods</em> 可以</li>
<li><em>computed</em> 具有缓存，而 <em>methods</em> 没有</li>
</ol>
<p>而如果从底层来看的话， <em>computed</em> 和 <em>methods</em> 在底层实现上面还有很大的区别。</p>
<p><em>vue</em> 对 <em>methods</em> 的处理比较简单，只需要遍历 <em>methods</em> 配置中的每个属性，将其对应的函数使用 <em>bind</em> 绑定当前组件实例后复制其引用到组件实例中即可</p>
<p>而 <em>vue</em> 对 <em>computed</em> 的处理会稍微复杂一些。</p>
<p>具体可以参阅前面第 <em>21</em> 题。</p>
</blockquote>
<h2 id="44-在-Vue-中要获取当前时间你会放到-computed-还是-methods-里？-抖音直播"><a href="#44-在-Vue-中要获取当前时间你会放到-computed-还是-methods-里？-抖音直播" class="headerlink" title="44. 在 Vue 中要获取当前时间你会放到 computed 还是 methods 里？(抖音直播)"></a>44. <strong>在 <em>Vue</em> 中要获取当前时间你会放到 <em>computed</em> 还是 <em>methods</em> 里？(抖音直播)</strong></h2><blockquote>
<p>参考答案：</p>
<p>放在 <em>computed</em> 里面。因为 <em>computed</em> 只有在它的相关依赖发生改变时才会重新求值。相比而言，方法只要发生重新渲染，<em>methods</em> 调用总会执行所有函数。 </p>
</blockquote>
<h2 id="45-在给-vue-中的元素设置-key-值时可以使用-Math-的-random-方法么？"><a href="#45-在给-vue-中的元素设置-key-值时可以使用-Math-的-random-方法么？" class="headerlink" title="45. 在给 vue 中的元素设置 key 值时可以使用 Math 的 random 方法么？"></a>45. <strong>在给 <em>vue</em> 中的元素设置 <em>key</em> 值时可以使用 <em>Math</em> 的 <em>random</em> 方法么？</strong></h2><blockquote>
<p>参考答案：</p>
<p><em>random</em> 是生成随机数，有一定概率多个 <em>item</em> 会生成相同的值，不能保证唯一。</p>
<p>如果是根据数据来生成 <em>item</em>，数据具有 <em>id</em> 属性，那么就可以使用 <em>id</em> 来作为 <em>key</em>。</p>
<p>如果不是根据数据生成 <em>item</em>，那么最好的方式就是使用时间戳来作为 <em>key</em>。或者使用诸如 <em>uuid</em> 之类的库来生成唯一的 <em>id</em>。</p>
</blockquote>
<h2 id="46-插槽与作用域插槽的区别是什么？"><a href="#46-插槽与作用域插槽的区别是什么？" class="headerlink" title="46. 插槽与作用域插槽的区别是什么？"></a>46. <strong>插槽与作用域插槽的区别是什么？</strong></h2><blockquote>
<p>参考答案：</p>
<p>插槽的作用是子组件提供了可替换模板，父组件可以更换模板的内容。</p>
<p>作用域插槽给了子组件将数据返给父组件的能力，子组件一样可以复用，同时父组件也可以重新组织内容和样式。</p>
</blockquote>
<h2 id="47-vue-中相同逻辑如何进行抽离？"><a href="#47-vue-中相同逻辑如何进行抽离？" class="headerlink" title="47. vue 中相同逻辑如何进行抽离？"></a>47. <strong><em>vue</em> 中相同逻辑如何进行抽离？</strong></h2><blockquote>
<p>参考答案：</p>
<p>可以使用 <em>vue</em> 里面的混入（<em>mixin</em>）技术。混入（<em>mixin</em>）提供了一种非常灵活的方式，来将 <em>vue</em> 中相同的业务逻辑进行抽离。</p>
<p>例如：</p>
<ul>
<li>在 <em>data</em> 中有很多是公用数据</li>
<li>引用封装好的组件也都是一样的</li>
<li><em>methods、watch、computed</em> 中也都有大量的重复代码</li>
</ul>
<p>当然这个时候可以将所有的代码重复去写来实现功能，但是我们并不不推荐使用这种方式，无论是工作量、工作效率和后期维护来说都是不建议的，这个时候 <em>mixin</em> 就可以大展身手了。</p>
<p>一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。说白了就是给每个生命周期，函数等等中间加入一些公共逻辑。</p>
<p><strong>混入技术特点</strong></p>
<ul>
<li>当组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”。比如，数据对象在内部会进行递归合并，并在发生冲突时以组件数据优先。</li>
<li>同名钩子函数将合并为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用。</li>
<li>值为对象的选项，例如 <em>methods、components</em> 和 <em>directives</em>，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。</li>
</ul>
</blockquote>
<h2 id="48-如何监听-pushstate-和-replacestate-的变化呢？"><a href="#48-如何监听-pushstate-和-replacestate-的变化呢？" class="headerlink" title="48. 如何监听 pushstate 和 replacestate 的变化呢？"></a>48. <strong>如何监听 <em>pushstate</em> 和 <em>replacestate</em> 的变化呢？</strong></h2><blockquote>
<p>参考答案：</p>
<p><em>History.replaceState</em> 和 <em>pushState</em> 不会触发 <em>popstate</em> 事件，所以我们可以通过在方法中创建一个新的全局事件来实现  <em>pushstate</em> 和 <em>replacestate</em> 变化的监听。</p>
<p>具体做法为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> _wr = <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> orig = history[type];</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> rv = orig.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">     <span class="keyword">var</span> e = <span class="keyword">new</span> Event(type);</span><br><span class="line">      e.arguments = <span class="built_in">arguments</span>;</span><br><span class="line">      <span class="built_in">window</span>.dispatchEvent(e);</span><br><span class="line">      <span class="keyword">return</span> rv;</span><br><span class="line">  &#125;;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;history.pushState = _wr(<span class="string">&#x27;pushState&#x27;</span>);</span><br><span class="line">&gt;history.replaceState = _wr(<span class="string">&#x27;replaceState&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>这样就创建了 <em>2</em> 个全新的事件，事件名为 <em>pushState</em> 和 <em>replaceState</em>，我们就可以在全局监听：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;<span class="built_in">window</span>.addEventListener(<span class="string">&#x27;replaceState&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;THEY DID IT AGAIN! replaceState 111111&#x27;</span>);</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="built_in">window</span>.addEventListener(<span class="string">&#x27;pushState&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;THEY DID IT AGAIN! pushState 2222222&#x27;</span>);</span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure>

<p>这样就可以监听到 <em>pushState</em> 和 <em>replaceState</em> 行为。</p>
</blockquote>
<h2 id="49-说一下-vue3-0-是如何变得更快的？"><a href="#49-说一下-vue3-0-是如何变得更快的？" class="headerlink" title="49. 说一下 vue3.0 是如何变得更快的？"></a>49. <strong>说一下 <em>vue3.0</em> 是如何变得更快的？</strong></h2><blockquote>
<p>参考答案：</p>
<p><strong>优化 <em>Diff</em> 算法</strong></p>
<p>相比 <em>Vue 2</em>，<em>Vue 3</em> 采用了更加优化的渲染策略。去掉不必要的虚拟 <em>DOM</em> 树遍历和属性比较，因为这在更新期间往往会产生最大的性能开销。</p>
<p>这里有三个主要的优化：</p>
<ul>
<li>首先，在 <em>DOM</em> 树级别。</li>
</ul>
<p> 在没有动态改变节点结构的模板指令（例如 <em>v-if</em> 和 <em>v-for</em>）的情况下，节点结构保持完全静态。</p>
<p> 当更新节点时，不再需要递归遍历 <em>DOM</em> 树。所有的动态绑定部分将在一个平面数组中跟踪。这种优化通过将需要执行的树遍历量减少一个数量级来规避虚拟 <em>DOM</em> 的大部分开销。</p>
<ul>
<li><p>其次，编译器积极地检测模板中的静态节点、子树甚至数据对象，并在生成的代码中将它们提升到渲染函数之外。这样可以避免在每次渲染时重新创建这些对象，从而大大提高内存使用率并减少垃圾回收的频率。</p>
</li>
<li><p>第三，在元素级别。</p>
</li>
</ul>
<p> 编译器还根据需要执行的更新类型，为每个具有动态绑定的元素生成一个优化标志。</p>
<p> 例如，具有动态类绑定和许多静态属性的元素将收到一个标志，提示只需要进行类检查。运行时将获取这些提示并采用专用的快速路径。</p>
<p>综合起来，这些技术大大改进了渲染更新基准，<em>Vue 3.0</em> 有时占用的 <em>CPU</em> 时间不到 <em>Vue 2</em> 的十分之一。</p>
<p><strong>体积变小</strong></p>
<p>重写后的 <em>Vue</em> 支持了 <em>tree-shaking</em>，像修剪树叶一样把不需要的东西给修剪掉，使 <em>Vue 3.0</em> 的体积更小。</p>
<p>需要的模块才会打入到包里，优化后的 <em>Vue 3.0</em> 的打包体积只有原来的一半（<em>13kb</em>）。哪怕把所有的功能都引入进来也只有 <em>23kb</em>，依然比 <em>Vue 2.x</em> 更小。像 <em>keep-alive、transition</em> 甚至 <em>v-for</em> 等功能都可以按需引入。</p>
<p>并且 <em>Vue 3.0</em> 优化了打包方法，使得打包后的 <em>bundle</em> 的体积也更小。</p>
<p>官方所给出的一份惊艳的数据：打包大小减少 *41%*，初次渲染快 *55%*，更新快 *133%*，内存使用减少 *54%*。</p>
</blockquote>
<h2 id="50-说一说自定义指令有哪些生命周期？"><a href="#50-说一说自定义指令有哪些生命周期？" class="headerlink" title="50. 说一说自定义指令有哪些生命周期？"></a>50. 说一说自定义指令有哪些生命周期？</h2><blockquote>
<p>参考答案：</p>
<p>自定义指令的生命周期，有 5 个事件钩子，可以设置指令在某一个事件发生时的具体行为：</p>
<ul>
<li>bind: 只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个在绑定时执行一次的初始化动作。</li>
<li>inserted: 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）。</li>
<li>update: 被绑定元素所在的模板更新时调用，而不论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新（详细的钩子函数参数见下）。</li>
<li>componentUpdated: 被绑定元素所在模板完成一次更新周期时调用。</li>
<li>unbind: 只调用一次， 指令与元素解绑时调用。</li>
</ul>
<p>钩子函数的参数 (包括 el，binding，vnode，oldVnode)</p>
<ul>
<li>el: 指令所绑定的元素，可以用来直接操作 DOM 。</li>
<li>binding: 一个对象，包含以下属性：name: 指令名、value: 指令的绑定值、oldValue: 指令绑定的前一个值、expression: 绑定值的字符串形式、arg: 传给指令的参数、modifiers: 一个包含修饰符的对象。</li>
<li>vnode: Vue 编译生成的虚拟节点。</li>
<li>oldVnode: 上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。</li>
</ul>
</blockquote>
<h2 id="51-说一说相比-vue3-x-对比-vue2-x-变化"><a href="#51-说一说相比-vue3-x-对比-vue2-x-变化" class="headerlink" title="51. 说一说相比 vue3.x 对比 vue2.x 变化"></a>51. 说一说相比 <em>vue3.x</em> 对比 <em>vue2.x</em> 变化</h2><blockquote>
<p>参考答案：</p>
<ol>
<li>源码组织方式变化：使用 TS 重写</li>
<li>支持 Composition API：基于函数的API，更加灵活组织组件逻辑（vue2用的是options api）</li>
<li>响应式系统提升：Vue3中响应式数据原理改成proxy，可监听动态新增删除属性，以及数组变化</li>
<li>编译优化：vue2通过标记静态根节点优化diff，Vue3 标记和提升所有静态根节点，diff的时候只需要对比动态节点内容</li>
<li>打包体积优化：移除了一些不常用的api（inline-template、filter）</li>
<li>生命周期的变化：使用setup代替了之前的beforeCreate和created</li>
<li>Vue3 的 template 模板支持多个根标签</li>
<li>Vuex状态管理：创建实例的方式改变,Vue2为new Store , Vue3为createStore</li>
<li>Route 获取页面实例与路由信息：vue2通过this获取router实例，vue3通过使用 getCurrentInstance/ userRoute和userRouter方法获取当前组件实例</li>
<li>Props 的使用变化：vue2 通过 this 获取 props 里面的内容，vue3 直接通过 props</li>
<li>父子组件传值：vue3 在向父组件传回数据时，如使用的自定义名称，如 backData，则需要在 emits 中定义一下</li>
</ol>
</blockquote>
<h2 id="52-vue-为什么采用异步渲染"><a href="#52-vue-为什么采用异步渲染" class="headerlink" title="52. vue 为什么采用异步渲染"></a>52. <em>vue</em> 为什么采用异步渲染</h2><blockquote>
<p>参考答案：</p>
<p>因为如果不采用异步更新，那么每次更新数据都会对当前组件进行重新渲染；所以为了性能考虑，<em>Vue</em> 会在本轮数据更新后，再去异步更新视图。</p>
<p>异步渲染的原理：</p>
<ol>
<li>调用 <em>notify( )</em> 方法，通知 <em>watcher</em> 进行更新操作</li>
<li>依次调用 watcher 的 update 方法</li>
<li>对 watcher 进行去重操作（通过id）放到队列里</li>
<li>执行完后异步清空这个队列，nextTick（flushSchedulerQueue）进行批量更新操作</li>
</ol>
</blockquote>
<h2 id="53-组件中写-name-选项有哪些好处"><a href="#53-组件中写-name-选项有哪些好处" class="headerlink" title="53. 组件中写 name 选项有哪些好处"></a>53. 组件中写 <em>name</em> 选项有哪些好处</h2><blockquote>
<p>参考答案：</p>
<ol>
<li>可以通过名字找到对应的组件（ 递归组件：组件自身调用自身 ）</li>
<li>可以通过 <em>name</em> 属性实现缓存功能（<em>keep-alive</em>）</li>
<li>可以通过 <em>name</em> 来识别组件（跨级组件通信时非常重要）</li>
<li>使用 <em>vue-devtools</em> 调试工具里显示的组见名称是由 <em>vue</em> 中组件 <em>name</em> 决定的</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>面试题</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>面试题</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题浏览器面试题汇总一</title>
    <url>/135xyq.github.io/2022/05/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%B5%8F%E8%A7%88%E5%99%A8-%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B8%80/</url>
    <content><![CDATA[<ol>
<li><p>介绍下重绘和重排（repaint &amp; reflow），以及如何进行优化</p>
<blockquote>
<p>参考答案：</p>
<p>整个页面可以看做是一幅画，这幅画是由浏览器绘制出来的，浏览器绘制这幅画的过程称之为渲染。</p>
<p>渲染是一件复杂的工作，它大致分为以下几个过程：</p>
<ol>
<li>解析 HTML，生成 DOM 树，解析 CSS，生成样式规则树</li>
<li>将 DOM 树和样式规则树结合，生成渲染树(Render Tree)</li>
<li>根据生成的渲染树，确定元素的布局信息（元素的尺寸、位置），<strong>这一步称之为 reflow，译作重排或回流</strong></li>
<li>根据渲染树和布局信息，生成元素的像素信息（元素横纵的像素点，左上角的偏移量、每个像素的颜色等）。<strong>这一步称之为 repaint，译作重绘</strong></li>
<li>将像素信息提交到 GPU 完成屏幕绘制</li>
</ol>
<p>当元素的布局信息发生变化时，会导致重排。</p>
<p>当元素的像素信息发生变化时，会导致重绘。</p>
<p>重排一定会导致重绘，因此布局信息的变化一定会导致像素信息的变化。</p>
<p>在实际开发中，获取和设置元素尺寸、位置均会导致重排和重绘，而仅设置元素的外观（比如背景颜色）则只会导致重绘，不会导致重排。</p>
<p>重排是一项繁琐的工作，会降低效率，因此在开发中，应该尽量避免直接获取和设置元素的尺寸、位置，尽量使用变量来保存元素的布局信息。</p>
</blockquote>
</li>
<li><p>说说浏览器和 Node 事件循环的区别</p>
<blockquote>
<p>参考答案：</p>
<p>浏览器的事件循环比较简单，它把任务分为宏任务和微任务，当执行栈清空后，会优先调取微任务运行，当微任务队列清空后，才会调取宏任务运行。</p>
<p>而 node 的事件循环机制比较复杂，它将整个任务调度分为 6 个阶段，当执行栈清空后，将依次循环 6 个阶段：</p>
<ol>
<li>timers</li>
<li>pending callbacks</li>
<li>idle, prepare</li>
<li>poll</li>
<li>check</li>
<li>close callback</li>
</ol>
<p>在进入任何一个阶段时，都将检查微队列中是否有任务需要执行，只有微队列清空后才能顺利进入下一个阶段。</p>
</blockquote>
</li>
<li><p>浏览器缓存读取规则</p>
<blockquote>
<p>参考答案：</p>
<p>当需要获取一个资源时，浏览器会先检查缓存中是否存在，若命中缓存，则不会发送请求。浏览器按照一定的顺序检查缓存，具体顺序是：</p>
<ol>
<li><p>service worker</p>
<p>在 service worker 中，开发者可以根据需要将远程获取的资源缓存到 cache storage 中，之后对该资源的请求会直接从缓存中获取。</p>
<p>这部分缓存需要前端开发者手动完成的</p>
</li>
<li><p>memory cache</p>
<p>浏览器会自动将请求过的资源自动加入到 memory cache，这主要是为了解决一个页面中有多次相同的请求，比如页面中链接了多张相同的图片。</p>
<p>memory cache 是浏览器自动完成的，它保存在内存中。</p>
</li>
<li><p>disk cache</p>
<p>当浏览器得到的响应头中包含<code>cache-control</code>等缓存指令时，会按照指令的要求设置 disk cache。请求的资源会被保存在磁盘中，在指定的期限内有效。</p>
<p>disk cache 是长期的，即使关闭浏览器也不会消失。</p>
</li>
</ol>
</blockquote>
</li>
<li><p>为什么通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片？</p>
<blockquote>
<p>参考答案：</p>
<p>首先，在很多场景中，处理埋点的服务器很有可能是第三方服务器，比如百度的站点统计埋点，百度就是一个第三方服务器，这就不可避免的带来跨域问题。</p>
<p>其次，埋点服务方需要提供一种特别利于安装的埋点置入代码，使用传统的 ajax 会使代码变得臃肿。</p>
<p>同时，埋点请求绝大部分都是 get 请求，又无须得到服务器的响应结果。</p>
<p>基于以上的特点，使用 img 元素请求服务器就变得理所当然了，img 元素发出的请求天生支持跨域，书写的代码简单，只需要创建一个 img 元素，然后设置 src 为埋点请求地址即可。</p>
<p>其实请求一旦发出，埋点就成功了，无须得到服务器的响应结果。但如果服务器不给予任何响应的话，可能会导致浏览器端控制台报错，尽管这个报错并不影响实质的功能。为了避免这种情况，服务器于是响应一个最小体积的图片即可，而 1x1 像素的透明 gif 图片是体积最小的图片，自然就选用了它作为响应结果。</p>
</blockquote>
</li>
<li><p>请求时浏览器缓存 from memory cache 和 from disk cache 的依据是什么，哪些数据什么时候存放在 Memory Cache 和 Disk Cache 中？</p>
<blockquote>
<p>参考答案：</p>
<p>memory cache 是浏览器自动完成的，它不关心 http 语义，但会遵守<code>cache-control: no-store</code>指令。浏览器在请求资源后，会自动将资源加入 memory cache，在后续的请求中，若请求的 url 地址和之前缓存的对应地址相同，则直接使用 memory cache。memory cache 只缓存 get 请求，并且缓存的内容在内存中，因此会很快的清理。</p>
<p>disk cache 遵守 http 缓存语义，它会按照服务器响应头中指定的缓存要求进行缓存，由于它存在于磁盘中，因此，即便浏览器关闭后缓存内容也不会消失。它的保存时间由服务器的<code>cache-control</code>字段指定，当缓存失效后，会重新发送请求到服务器，进入协商缓存的流程。</p>
</blockquote>
</li>
<li><p>什么是浏览器同源策略？</p>
<blockquote>
<p>参考答案：</p>
<p>所谓同源，是指协议、主机、端口均相同的地址。</p>
<p>同源策略是指，当前页面和页面运行过程中发出的请求必须是同源的，即必须协议、主机、端口均相同，否则即被视为跨域请求。</p>
<p>浏览器中的大部分内容都是受同源策略限制的，但是以下三个标签可以不受限制：</p>
<ul>
<li>img</li>
<li>script</li>
<li>link</li>
</ul>
</blockquote>
</li>
<li><p>DOM Tree 是如何构建的？</p>
<blockquote>
<p>参考答案：</p>
<ol>
<li>转码: 浏览器将接收到的二进制数据按照指定编码格式转化为 HTML 字符串</li>
<li>生成 Tokens: 之后开始 parser，浏览器会将 HTML 字符串解析成 Tokens</li>
<li>构建 Nodes: 对 Node 添加特定的属性，通过指针确定 Node 的父、子、兄弟关系和所属 treeScope</li>
<li>生成 DOM Tree: 通过 node 包含的指针确定的关系构建出 DOM Tree</li>
</ol>
</blockquote>
</li>
<li><p>浏览器如何解析 css 选择器？</p>
<blockquote>
<p>参考答案：</p>
<p>浏览器读取到选择器时，会从 DOM 树中找到匹配的对应节点，然后将样式附着到对应的 DOM 元素上。当选择器出现多个层级时，浏览器会使用「从右到左」的顺序进行匹配，对应到 DOM 树的遍历上，是从叶子到根的方向进行筛选，这样可以提升匹配效率。</p>
</blockquote>
</li>
<li><p>浏览器是如何渲染 UI 的？</p>
<blockquote>
<p>参考答案：</p>
<ol>
<li>浏览器解析 HTML，形成 DOM Tree</li>
<li>解析 HTML 过程中遇到 CSS，则进行 CSS 解析，生成 Style Rules</li>
<li>将 DOM Tree 与 Style Rules 合成为 Render Tree</li>
<li>进入布局（Layout）阶段，为每个节点分配一个应出现在屏幕上的确切坐标</li>
<li>随后调用 GPU 进行绘制（Paint），遍历 Render Tree 的节点，并将元素呈现出来</li>
</ol>
</blockquote>
</li>
<li><p>浏览器的主要组成部分是什么？</p>
<blockquote>
<p>参考答案：</p>
<ol>
<li><p>用户界面（user interface）</p>
<p>用于呈现浏览器窗口部件，比如地址栏、前进后退按钮、书签、顶部菜单等</p>
</li>
<li><p>浏览器引擎（browser engine）</p>
<p>用户在用户界面和渲染引擎中传递指令</p>
</li>
<li><p>渲染引擎（rendering engine）</p>
<p>负责解析 HTML、CSS，并将解析的内容显示到屏幕上。我们平时说的浏览器内核就是指这部分。</p>
</li>
<li><p>网络（networking）</p>
<p>用户网络调用，比如发送 http 请求</p>
</li>
<li><p>用户界面后端（UI backend）</p>
<p>用于绘制基本的窗口小部件，比如下拉列表、文本框、按钮等，向上提供公开的接口，向下调用操作系统的用户界面。</p>
</li>
<li><p>JS 解释器（JavaScript interpreter）</p>
<p>解释执行 JS 代码。我们平时说的 JS 引擎就是指这部分。</p>
</li>
<li><p>数据存储（data storage）</p>
<p>用户保存数据到磁盘中。比如 cookie、localstorage 等都是使用的这部分功能。</p>
</li>
</ol>
</blockquote>
</li>
<li><p>常见的浏览器内核有哪些?</p>
<blockquote>
<p>参考答案：</p>
<table>
<thead>
<tr>
<th>浏览器</th>
<th>内核（渲染引擎）</th>
<th>JavaScript 引擎</th>
</tr>
</thead>
<tbody><tr>
<td>Chrome</td>
<td>Blink（新） Webkit（旧）</td>
<td>V8</td>
</tr>
<tr>
<td>FireFox</td>
<td>Gecko</td>
<td>SpiderMonkey</td>
</tr>
<tr>
<td>Safari</td>
<td>Webkit</td>
<td>JavaScriptCore</td>
</tr>
<tr>
<td>Edge</td>
<td>EdgeHTML</td>
<td>Chakra</td>
</tr>
<tr>
<td>IE</td>
<td>Trident</td>
<td>Chakra</td>
</tr>
<tr>
<td>PhantomJS</td>
<td>Webkit</td>
<td>JavaScriptCore</td>
</tr>
<tr>
<td>Node.js</td>
<td>无</td>
<td>V8</td>
</tr>
</tbody></table>
</blockquote>
</li>
<li><p>怎样选择合适的缓存策略</p>
<blockquote>
<p>参考答案：</p>
<ol>
<li><p>对于一次性的资源，比如验证码图片，不进行缓存。</p>
<p>设置响应头<code>cache-control: no-store</code></p>
</li>
<li><p>对于频繁变动的资源，比如某些数据接口，使用协商缓存。</p>
<p>设置响应头<code>cache-control: no-cache</code>，同时配合<code>ETag</code>标记，让浏览器缓存资源，但每次都会发送请求询问资源是否更新。</p>
</li>
<li><p>对于静态资源，比如 JS、CSS、图片等文件，使用强制缓存。</p>
<p>设置响应头<code>cache-control: max-age=有效时长</code>，设置一个很长的过期时间，比如十年，然后通过文件 hash 的处理更新</p>
</li>
</ol>
</blockquote>
</li>
<li><p>为什么用多个域名存储网站资源更有效？</p>
<blockquote>
<p>参考答案：</p>
<p>主要原因是浏览器对同一个域下的 TCP 连接数是有限制的，这样就导致某个网页如果外部资源多了，比如图片很多的网页，在解析页面时，由于 TCP 连接数受限，就无法同时发起多个下载连接，无法充分利用带宽资源。因此，可以把静态资源放到多个域名下，这样就绕开了连接数的限制，做到了并发下载。</p>
</blockquote>
</li>
<li><p>前端需要注意哪些 SEO</p>
<blockquote>
<p>参考答案：</p>
<ol>
<li><p>语义化</p>
<p>多使用语义化标签，让正确的标签对应正确的内容。</p>
</li>
<li><p>重要内容前置</p>
<p>可以利用弹性盒布局中的 order 属性，将核心、重要的内容尽量放到文档的前面。</p>
</li>
<li><p>服务端渲染</p>
<p>由于目前的搜索引擎对客户端渲染并不友好，因此使用服务端渲染仍然是 SEO 的重要手段。</p>
</li>
<li><p>TDK</p>
<p>利用 title、meta 元素，设置网页的标题、描述、关键字</p>
</li>
</ol>
</blockquote>
</li>
<li><p>浏览器是怎么对 HTML5 的离线储存资源进行管理和加载的呢</p>
<blockquote>
<p>参考答案：</p>
<p>在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问 app，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过 app 并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。<br>离线的情况下，浏览器就直接使用离线存储的资源。</p>
</blockquote>
</li>
</ol>
<ol start="16">
<li>如何兼容低版本浏览器</li>
</ol>
<blockquote>
<p>参考答案：</p>
<p>分为三个部分来说</p>
<p>HTML</p>
<p>低版本浏览器无法识别新增的HTML5元素，如果要兼容这部分浏览器，需要做以下处理：</p>
<ol>
<li>对于非可替换元素，比如article、section、header、footer等，这种元素虽然低版本浏览器不识别，但它仍然会把它们渲染出来，只是没有浏览器的默认样式。因此，我们只需要在css中稍作处理即可，比如给它们都加上<code>display:block</code>。</li>
<li>对于可替换元素，比如video、audio等，这种元素会涉及低版本浏览器没有功能，因此需要使用条件注释，在低版本浏览器中使用兼容的做法</li>
</ol>
<p>CSS</p>
<p>对于CSS代码，低版本浏览器可能无法识别某些CSS属性，比如圆角边框、背景渐变、过渡动画等。但由于浏览器对于不能识别样式的处理方式是「直接丢弃、不影响后续渲染」，所以，我们可以保持这样的原则：尽量让其兼容，实在不行，至少不影响浏览。按照这样的原则，我们可以对CSS进行以下处理：</p>
<ol>
<li>使用厂商前缀，尽量让其兼容。</li>
<li>对于某些样式使用JS替代，比如渐变、动画等</li>
</ol>
<p>JavaScript</p>
<p>对于JS代码，低版本浏览器无法识别H5的API，因此缺少了一些新功能，比如localstorage、web worker等。不仅如此，低版本浏览器还无法识别ES6的新语法，比如let、const、async、await等。因此，要处理JS的兼容性问题，只能具体情况具体分析，通常，我们会使用下面两种手段来完成兼容：</p>
<ol>
<li>模拟API。就是自己写一个功能完全和官方相同的API，来弥补低版本浏览器API没有的情况。比较典型的就是ES5中有大量的数组API，这些API都是可以轻松模拟的。</li>
<li>编译。某些新语法是无法模拟的，只能通过制作工具对源代码进行编译，将其新语法全部去掉，如果新语法涉及特殊功能，则转换为使用API完成，比较典型的例子就是async和await会被转换为generator的函数调用。</li>
</ol>
<p>在前端工程化的今天，上面的几乎所有兼容性问题都可以依靠工程化完成，比如，css可以依托postcss平台完成兼容性处理，JS可以依托babel平台完成兼容性处理。</p>
</blockquote>
<ol start="17">
<li>浏览器怪异模式和普通模式的区别</li>
</ol>
<blockquote>
<p>参考答案：</p>
<p>标准模式：浏览器按W3C标准解析执行代码</p>
<p>怪异模式：使用浏览器自己的方式解析执行代码，因为不同浏览器解析执行的方式不一样，所以称之为怪异模式。比如IE中盒模型的宽高使用的是边框盒。</p>
</blockquote>
<ol start="18">
<li>各个浏览器兼容前缀？</li>
</ol>
<blockquote>
<p>参考答案：</p>
<table>
<thead>
<tr>
<th>前缀</th>
<th>浏览器</th>
</tr>
</thead>
<tbody><tr>
<td>-moz-</td>
<td>firefox</td>
</tr>
<tr>
<td>-webkit-</td>
<td>chrome、safari</td>
</tr>
<tr>
<td>-o-</td>
<td>opera</td>
</tr>
<tr>
<td>-ms-</td>
<td>IE</td>
</tr>
</tbody></table>
</blockquote>
<ol start="19">
<li>跨标签页的通讯方式有哪些（哔哩哔哩）</li>
</ol>
<blockquote>
<p>参考答案：</p>
<ul>
<li>BroadCast Channel</li>
<li>Service Worker</li>
<li>LocalStorage window.onstorage 监听</li>
<li>Shared Worker 定时器轮询(setInterval)</li>
<li>IndexedDB 定时器轮询(setInterval)</li>
<li>cookie 定时器轮询(setInterval)</li>
<li>window.open window.postMessage</li>
<li>Websocket</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>面试题</category>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>浏览器</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题工程化面试题汇总一</title>
    <url>/135xyq.github.io/2022/05/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%B7%A5%E7%A8%8B%E5%8C%96-%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B8%80/</url>
    <content><![CDATA[<ol>
<li><p>下面的模块导出了什么结果？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exports</span>.a = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="built_in">module</span>.exports.b = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"><span class="built_in">this</span>.c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">d</span>: <span class="string">&#x27;d&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考答案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">d</span>: <span class="string">&#x27;d&#x27;</span> &#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>说一下你对前端工程化，模块化，组件化的理解？</p>
<blockquote>
<p>参考答案：</p>
<p>这三者中，模块化是基础，没有模块化，就没有组件化和工程化</p>
<p>模块化的出现，解决了困扰前端的两大难题：全局污染问题和依赖混乱问题，从而让精细的拆分前端工程成为了可能。</p>
<p>工程化的出现，解决了前端开发环境和生产环境要求不一致的矛盾。在开发环境中，我们希望代码使用尽可能的细分，代码格式尽可能的统一和规范，而在生产环境中，我们希望代码尽可能的被压缩、混淆，尽可能的优化体积。工程化的出现，就是为了解决这一矛盾，它可以让我们舒服的在开发环境中书写代码，然后经过打包，生成最合适的生产环境代码，这样就解放了开发者的精力，让开发者把更多的注意力集中在开发环境上即可。</p>
<p>组件化开发是一些前端框架带来的概念，它把一个网页，或者一个站点，甚至一个完整的产品线，划分为多个小的组件，组件是一个可以复用的单元，它包含了一个某个区域的完整功能。这样一来，前端便具备了开发复杂应用的能力。</p>
</blockquote>
</li>
<li><p>webpack 和 gulp 的区别是什么？</p>
<blockquote>
<p>直播讲解</p>
</blockquote>
<blockquote>
<p>参考答案：</p>
<p>webpack 是基于模块化的构建工具，gulp 是基于工作流的构建工具。</p>
<p>webpack 是一个打包器，它以一个入口为起点，构建出整个项目的依赖关系图，然后进行打包合并，生成打包结果。</p>
<p>gulp 是一个过程管理器，每一步做什么完全看开发人员如何配置，把每一个步骤连接起来形成一个完整的构建流水线。</p>
<p>这两者并不矛盾，完全可以在一个工程中同时使用 webpack 和 gulp，将 webpack 作为 gulp 流水线中的一环。</p>
</blockquote>
</li>
<li><p>webpack 中的 loader 属性和 plugins 属性的区别是什么？</p>
<blockquote>
<p>参考答案：</p>
<p>它们都是 webpack 功能的扩展点。</p>
<p>loader 是加载器，主要用于代码转换，比如 JS 代码降级，CSS 预编译、模块化等</p>
<p>plugins 是插件，webpack 打包流程中每个环节都提供了钩子函数，可以利用这些钩子函数参与到打包生命周期中，更改或增加 webpack 的某些功能，比如生成页面和 css 文件、压缩打包结果等</p>
</blockquote>
</li>
<li><p>webpack 的核心概念都有哪些？</p>
<blockquote>
<p>参考答案：</p>
<ul>
<li><p>loader</p>
<p>加载器，主要用于代码转换，比如 JS 代码降级，CSS 预编译、模块化等</p>
</li>
<li><p>plugin</p>
<p>插件，webpack 打包流程中每个环节都提供了钩子函数，可以利用这些钩子函数参与到打包生命周期中，更改或增加 webpack 的某些功能，比如生成页面和 css 文件、压缩打包结果等</p>
</li>
<li><p>module</p>
<p>模块。webpack 将所有依赖均视为模块，无论是 js、css、html、图片，统统都是模块</p>
</li>
<li><p>entry</p>
<p>入口。打包过程中的概念，webpack 以一个或多个文件作为入口点，分析整个依赖关系。</p>
</li>
<li><p>chunk</p>
<p>打包过程中的概念，一个 chunk 是一个相对独立的打包过程，以一个或多个文件为入口，分析整个依赖关系，最终完成打包合并</p>
</li>
<li><p>bundle</p>
<p>webpack 打包结果</p>
</li>
<li><p>tree shaking</p>
<p>树摇优化。在打包结果中，去掉没有用到的代码。</p>
</li>
<li><p>HMR</p>
<p>热更新。是指在运行期间，遇到代码更改后，无须重启整个项目，只更新变动的那一部分代码。</p>
</li>
<li><p>dev server</p>
<p>开发服务器。在开发环境中搭建的临时服务器，用于承载对打包结果的访问</p>
</li>
</ul>
</blockquote>
</li>
<li><p>commonjs 和 es6 模块的区别是什么？</p>
<blockquote>
<p>参考答案：</p>
<ol>
<li>CMJ 是社区标准，ESM 是官方标准</li>
<li>CMJ 是使用 API 实现的模块化，ESM 是使用新语法实现的模块化</li>
<li>CMJ 仅在 node 环境中支持，ESM 各种环境均支持</li>
<li>CMJ 是动态的依赖，ESM 既支持动态，也支持静态</li>
<li>ESM 导入时有符号绑定，CMJ 只是普通函数调用和赋值</li>
</ol>
</blockquote>
</li>
<li><p>ES6 中如何实现模块化的异步加载？</p>
<blockquote>
<p>参考答案：</p>
<p>使用动态导入即可，导入后，得到的是一个 Promise，完成后，得到一个模块对象，其中包含了所有的导出结果。</p>
</blockquote>
</li>
<li><p>说一下 webpack 中的几种 hash 的实现原理是什么？</p>
<blockquote>
<p>参考答案：</p>
<ul>
<li><p>hash</p>
<p>hash 是跟整个项目的构建相关，只要项目里有文件更改，整个项目构建的 hash 值都会更改，并且全部文件都共用相同的 hash 值</p>
</li>
<li><p>chunkhash</p>
<p>每个打包过程单独的 hash 值，如果一个项目有多个 entry，则每个 entry 维护自己的 chunkhash。</p>
</li>
<li><p>contenthash</p>
<p>每个文件内容单独的 hash 值，它和打包结果文件内容有关，只要文件内容不变，contenthash 不变。</p>
</li>
</ul>
</blockquote>
</li>
<li><p>webpack 如果使用了 hash 命名，那是每次都会重新生成 hash 吗？</p>
<blockquote>
<p>参考答案：</p>
<p>不会。它跟关联的内容是否有变化有关系，如果没有变化，hash 就不会变。具体来说，contenthash 和具体的打包文件内容有关，chunkhash 和某一 entry 为起点的打包过程中涉及的内容有关，hash 和整个工程所有模块内容有关。</p>
</blockquote>
</li>
<li><p>webpack 中是如何处理图片的？ （抖音直播）</p>
<blockquote>
<p>参考答案：</p>
<p>webpack 本身不处理图片，它会把图片内容仍然当做 JS 代码来解析，结果就是报错，打包失败。如果要处理图片，需要通过 loader 来处理。其中，url-loader 会把图片转换为 base64 编码，然后得到一个 dataurl，file-loader 则会将图片生成到打包目录中，然后得到一个资源路径。但无论是哪一种 loader，它们的核心功能，都是把图片内容转换成 JS 代码，因为只有转换成 JS 代码，webpack 才能识别。</p>
</blockquote>
</li>
<li><p>webpack 打包出来的 html 为什么 style 放在头部 script 放在底部？</p>
<blockquote>
<p>说明：这道题的表述是有问题的，webpack 本身并不打包 html，相反，它如果遇到 html 代码会直接打包失败，因为 webpack 本身只能识别 JS。之所以能够打包出 html 文件，是因为插件或 loader 的作用，其中，比较常见的插件是 html-webpack-plugin。所以这道题的正确表述应该是：「html-webpack-plugin 打包出来的 html 为什么 style 放在头部 script 放在底部？」</p>
</blockquote>
<blockquote>
<p>参考答案：</p>
<p>浏览器在解析 HTML 时是从上到下进行解析的，当遇到样式和 JS 时，都会停止 HTML 解析，转而解析样式和执行 JS。而我们往往希望，页面的样式解析完成后再解析 HTML，这样可以避免页面闪烁，基于此，样式应该放到顶部；而相反的，我们希望在解析完 HTML 后再执行 JS，这样可以让用户尽快的看到页面，同时也让 JS 执行时能够拿到完整的 DOM 树，基于此，JS 代码应该放到底部。</p>
<p>不过，在 HTML5 中出现了 async 和 defer 属性，使用该属性可以更好的解决 JS 的问题，我们可以把 script 放到顶部，让浏览器尽快下载，但延迟执行。实际上，在新版本的 html-webpack-plugin 中，它已经这样做了。</p>
</blockquote>
</li>
<li><p>webpack 配置如何实现开发环境不使用 cdn、生产环境使用 cdn？</p>
<blockquote>
<p>要配置 CDN，有两个步骤：</p>
<ol>
<li>在 html 模板中直接加入 cdn 引用</li>
<li>在 webpack 配置中，加入<code>externals</code>配置，告诉 webpack 不要打包其中的模块，转而使用全局变量</li>
</ol>
<p>若要在开发环境中不使用 CDN，只需根据环境变量判断不同的环境，进行不同的打包处理即可。</p>
<ol>
<li>在 html 模板中使用 ejs 模板语法进行判断，只有在生产环境中引入 CDN</li>
<li>在 webpack 配置中，可以根据<code>process.env</code>中的环境变量进行判断是否使用<code>externals</code>配置</li>
<li>在<code>package.json</code>脚本中设置不同的环境变量完成打包或开发启动。</li>
</ol>
</blockquote>
</li>
<li><p>介绍一下 webpack4 中的 tree-shaking 的工作流程？</p>
<blockquote>
<p>推荐阅读：<a href="https://tsejx.github.io/webpack-guidebook/principle-analysis/operational-principle/tree-shaking">https://tsejx.github.io/webpack-guidebook/principle-analysis/operational-principle/tree-shaking</a></p>
</blockquote>
<blockquote>
<p>参考答案：</p>
<p>tree-shaking 仅支持 ESM 的静态导入语法，对于 CMJ 或者 ESM 中的动态导入不支持 tree shaking。</p>
<p>具体流程主要分为两步：标记和删除</p>
<ol>
<li><p>标记</p>
<p>webpack 在分析依赖时，会使用注释的方式对导入和导出进行标记，对于模块中没有被其他模块用到的导出标记为 unused harmony export</p>
</li>
<li><p>删除</p>
<p>之后在 Uglifyjs (或者其他类似的工具) 步骤进行代码精简，把标记为无用的代码删除。</p>
</li>
</ol>
</blockquote>
</li>
<li><p>说一下 webpack loader 的作用是什么？</p>
<blockquote>
<p>参考答案：</p>
<p>用于转换代码。有时是因为 webpack 无法识别某些内容，比如图片、css 等，需要由 loader 将其转换为 JS 代码。有时是因为某些代码需要被特殊处理，比如 JS 兼容性的处理，需要由 loader 将其进一步转换。不管是什么情况，loader 的作用只有一个，就是转换代码。</p>
</blockquote>
</li>
<li><p>在开发过程中如果需要对已有模块进行扩展，如何进行开发保证调用方不受影响？</p>
<blockquote>
<p>参考答案：</p>
<p>实际上就是一个版本管理的问题。</p>
<p>如果此次模块升级只是修复了某一些 bug，作为补丁版本升级即可，不影响主版本和次版本号</p>
<p>如果此次模块升级会新增一些内容，完全兼容之前的 API，作为次版本升级即可</p>
<p>如果此次模块升级会修改之前的 API，则作为主版本升级</p>
<p>在开发项目时，让项目依赖模块的主版本，因此，当模块更新时，只要不是主版本更新，项目都可以非常方便的升级模块版本，无须改动任何代码。但若涉及主版本更新，项目可以完全无视此次版本更新，仍然使用之前的旧版本，无须改动任何代码；当然也可以升级主版本，但就会涉及代码的改动，这就好比跟将 vue2 升级到 vue3 会涉及大量改动一样。</p>
<p>而在开发模块时，在一开始就要精心设计 API，尽量保证 API 的接口稳定，不要经常变动主版本号。如果实在要更新主版本，就需要在一段时间内同时维护两个版本（新的主版本，旧的主版本），给予其他项目一定的升级时间。</p>
</blockquote>
</li>
<li><p>export 和 export default 的区别是什么？</p>
<blockquote>
<p>参考答案：</p>
<p>export 为普通导出，又叫做具名导出，顾名思义，它导出的数据必须带有命名，比如变量定义、函数定义这种带有命名的语句。在导出的模块对象中，命名即为模块对象的属性名。在一个模块中可以有多个具名导出</p>
<p>export default 为默认导出，在模块对象中名称固定为 default，因此无须命名，通常导出一个表达式或字面量。在一个模块中只能有一个默认导出。</p>
</blockquote>
</li>
<li><p>webpack 打包原理是什么？</p>
<blockquote>
<p>参考答案：</p>
<ol>
<li><strong>初始化参数</strong>：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数</li>
<li><strong>开始编译</strong>：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 <code>run</code> 方法开始执行编译</li>
<li><strong>确定入口</strong>：根据配置中的 <code>entry</code> 找出所有的入口文件</li>
<li><strong>编译模块</strong>：从入口文件出发，调用所有配置的 <code>loader</code> 对模块进行翻译，再把翻译后的内容转换成 AST，通过对 AST 的分析找出该模块依赖的模块，再 <code>递归</code> 本步骤直到所有入口依赖的文件都经过了本步骤的处理</li>
<li><strong>完成模块编译</strong>：在经过第 4 步使用 <code>loader</code> 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的 <code>依赖关系图</code></li>
<li><strong>输出资源</strong>：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 <code>Chunk</code>，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会</li>
<li><strong>输出完成</strong>：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统</li>
</ol>
</blockquote>
</li>
<li><p>webpack 热更新原理是什么？</p>
<blockquote>
<p>参考答案：</p>
<p>当开启热更新后，页面中会植入一段 websocket 脚本，同时，开发服务器也会和客户端建立 websocket 通信，当源码发生变动时，webpack 会进行以下处理：</p>
<ol>
<li>webpack 重新打包</li>
<li>webpack-dev-server 检测到模块的变化，于是通过 webscoket 告知客户端变化已经发生</li>
<li>客户端收到消息后，通过 ajax 发送请求到开发服务器，以过去打包的 hash 值请求服务器的一个 json 文件</li>
<li>服务器告诉客户端哪些模块发生了变动，同时告诉客户端这次打包产生的新 hash 值</li>
<li>客户端再次用过去的 hash 值，以 JSONP 的方式请求变动的模块</li>
<li>服务器响应一个函数调用，用于更新模块的代码</li>
<li>此时，模块代码已经完成更新。客户端按照之前的监听配置，执行相应模块变动后的回调函数。</li>
</ol>
</blockquote>
</li>
<li><p>如何优化 webpack 的打包速度？</p>
<blockquote>
<p>参考答案：</p>
<ol>
<li><p>noParse</p>
<p>很多第三方库本身就是已经打包好的代码，对于这种代码无须再进行解析，可以使用 noParse 配置排除掉这些第三方库</p>
</li>
<li><p>externals</p>
<p>对于一些知名的第三方库可以使用 CDN，这部分库可以通过 externals 配置不进行打包</p>
</li>
<li><p>限制 loader 的范围</p>
<p>在使用 loader 的时候，可以通过 exclude 排除掉一些不必要的编译，比如 babel-loader 对于那些已经完成打包的第三方库没有必要再降级一次，可以排除掉</p>
</li>
<li><p>开启 loader 缓存</p>
<p>可以利用<code>cache-loader</code>缓存 loader 的编译结果，避免在源码没有变动时反复编译</p>
</li>
<li><p>开启多线程编译</p>
<p>可以利用<code>thread-loader</code>开启多线程编译，提升编译效率</p>
</li>
<li><p>动态链接库</p>
<p>对于某些需要打包的第三方库，可以使用 dll 的方式单独对其打包，然后 DLLPlugin 将其整合到当前项目中，这样就避免了在开发中频繁去打包这些库</p>
</li>
</ol>
</blockquote>
</li>
<li><p>webpack 如何实现动态导入？</p>
<blockquote>
<p>参考答案：</p>
<p>当遇到代码中包含动态导入语句时，webpack 会将导入的模块及其依赖分配到单独的一个 chunk 中进行打包，形成单独的打包结果。而动态导入的语句会被编译成一个普通的函数调用，该函数在执行时，会使用 JSONP 的方式动态的把分离出去的包加载到模块集合中。</p>
</blockquote>
</li>
<li><p>说一下 webpack 有哪几种文件指纹</p>
<blockquote>
<p>参考答案：</p>
<ul>
<li><p>hash</p>
<p>hash 是跟整个项目的构建相关，只要项目里有文件更改，整个项目构建的 hash 值都会更改，并且全部文件都共用相同的 hash 值</p>
</li>
<li><p>chunkhash</p>
<p>每个打包过程单独的 hash 值，如果一个项目有多个 entry，则每个 entry 维护自己的 chunkhash。</p>
</li>
<li><p>contenthash</p>
<p>每个文件内容单独的 hash 值，它和打包结果文件内容有关，只要文件内容不变，contenthash 不变。</p>
</li>
</ul>
</blockquote>
</li>
<li><p>常用的 webpack Loader 都有哪些？</p>
<blockquote>
<p>参考答案：</p>
<ul>
<li>cache-loader：启用编译缓存</li>
<li>thread-loader：启用多线程编译</li>
<li>css-loader：编译 css 代码为 js</li>
<li>file-loader：保存文件到输出目录，将文件内容转换成文件路径</li>
<li>postcss-loader：将 css 代码使用 postcss 进行编译</li>
<li>url-loader：将文件内容转换成 dataurl</li>
<li>less-loader：将 less 代码转换成 css 代码</li>
<li>sass-loader：将 sass 代码转换成 css 代码</li>
<li>vue-loader：编译单文件组件</li>
<li>babel-loader：对 JS 代码进行降级处理</li>
</ul>
</blockquote>
</li>
<li><p>说一下 webpack 常用插件都有哪些？</p>
<blockquote>
<p>参考答案：</p>
<ul>
<li>clean-webpack-plugin：清除输出目录</li>
<li>copy-webpack-plugin：复制文件到输出目录</li>
<li>html-webpack-plugin：生成 HTML 文件</li>
<li>mini-css-extract-plugin：将 css 打包成单独文件的插件</li>
<li>HotModuleReplacementPlugin：热更新的插件</li>
<li>purifycss-webpack：去除无用的 css 代码</li>
<li>optimize-css-assets-webpack-plugin：优化 css 打包体积</li>
<li>uglify-js-plugin：对 JS 代码进行压缩、混淆</li>
<li>compression-webpack-plugin：gzip 压缩</li>
<li>webpack-bundle-analyzer：分析打包结果</li>
</ul>
</blockquote>
</li>
<li><p>使用 babel-loader 会有哪些问题，可以怎样优化？</p>
<blockquote>
<p>参考答案：</p>
<ol>
<li>如果不做特殊处理，babel-loader 会对所有匹配的模块进行降级，这对于那些已经处理好兼容性问题的第三方库显得多此一举，因此可以使用 exclude 配置排除掉这些第三方库</li>
<li>在旧版本的 babel-loader 中，默认开启了对 ESM 的转换，这样会导致 webpack 的 tree shaking 失效，因为 tree shaking 是需要保留 ESM 语法的，所以需要关闭 babel-loader 的 ESM 转换，在其新版本中已经默认关闭了。</li>
</ol>
</blockquote>
</li>
<li><p>babel 是如何对 class 进行编译的？</p>
<blockquote>
<p>参考答案：</p>
<p>本质上就是把 class 语法转换成普通构造函数定义，并做了以下处理：</p>
<ol>
<li>增加了对 this 指向的检测</li>
<li>将原型方法和静态方法变为不可枚举</li>
<li>将整个代码放到了立即执行函数中，运行后返回构造函数本身</li>
</ol>
</blockquote>
</li>
<li><p>解释一下 babel-polyfill 的作用是什么？</p>
<blockquote>
<p>说明：</p>
<p>babel-polyfill 已经是一个非常古老的项目了，babel 从 7.4 版本开始已不再支持它，转而使用更加强大的 core-js，此题也适用于问「core-js 的作用是什么」</p>
</blockquote>
<blockquote>
<p>参考答案：</p>
<p>默认情况下，babel 本身只转换新的语法，而不对新的 API 进行处理。由于旧的环境中无法支持新的 API，比如 IE6 无法支持 fetch api，这就需要一个补丁，用旧语言的特性实现一遍新的 API，babel-polyfill 就是用来做这件事的。</p>
</blockquote>
</li>
<li><p>解释一下 less 的&amp;的操作符是做什么用的？</p>
<blockquote>
<p>参考答案：</p>
<p>&amp;符号后面的内容会和父级选择器合并书写，即中间不加入空格字符</p>
</blockquote>
</li>
<li><p>在前端工程化中，可以进行哪些方面的优化？</p>
<blockquote>
<p>参考答案：</p>
<ol>
<li><p>对传输性能的优化</p>
<ul>
<li><p>压缩和混淆</p>
<p>使用 Uglifyjs 或其他类似工具对打包结果进行压缩、混淆，可以有效的减少包体积</p>
</li>
<li><p>tree shaking</p>
<p>项目中尽量使用 ESM，可以有效利用 tree shaking 优化，降低包体积</p>
</li>
<li><p>抽离公共模块</p>
<p>将一些公共代码单独打包，这样可以充分利用浏览器缓存，其他代码变动后，不影响公共代码，浏览器可以直接从缓存中找到公共代码。</p>
<p>具体方式有多种，比如 dll、splitChunks</p>
</li>
<li><p>异步加载</p>
<p>对一些可以延迟执行的模块可以使用动态导入的方式异步加载它们，这样在打包结果中，它们会形成单独的包，同时，在页面一开始解析时并不需要加载它们，而是页面解析完成后，执行 JS 的过程中去加载它们。</p>
<p>这样可以显著提高页面的响应速度，在单页应用中尤其有用。</p>
</li>
<li><p>CDN</p>
<p>对一些知名的库使用 CDN，不仅可以节省打包时间，还可以显著提升库的加载速度</p>
</li>
<li><p>gzip</p>
<p>目前浏览器普遍支持 gzip 格式，因此可以将静态文件均使用 gzip 进行压缩</p>
</li>
<li><p>环境适配</p>
<p>有些打包结果中包含了大量兼容性处理的代码，但在新版本浏览器中这些代码毫无意义。因此，可以把浏览器分为多个层次，为不同层次的浏览器给予不同的打包结果。</p>
</li>
</ul>
</li>
<li><p>对打包过程的优化</p>
<ul>
<li><p>noParse</p>
<p>很多第三方库本身就是已经打包好的代码，对于这种代码无须再进行解析，可以使用 noParse 配置排除掉这些第三方库</p>
</li>
<li><p>externals</p>
<p>对于一些知名的第三方库可以使用 CDN，这部分库可以通过 externals 配置不进行打包</p>
</li>
<li><p>限制 loader 的范围</p>
<p>在使用 loader 的时候，可以通过 exclude 排除掉一些不必要的编译，比如 babel-loader 对于那些已经完成打包的第三方库没有必要再降级一次，可以排除掉</p>
</li>
<li><p>开启 loader 缓存</p>
<p>可以利用<code>cache-loader</code>缓存 loader 的编译结果，避免在源码没有变动时反复编译</p>
</li>
<li><p>开启多线程编译</p>
<p>可以利用<code>thread-loader</code>开启多线程编译，提升编译效率</p>
</li>
<li><p>动态链接库</p>
<p>对于某些需要打包的第三方库，可以使用 dll 的方式单独对其打包，然后 DLLPlugin 将其整合到当前项目中，这样就避免了在开发中频繁去打包这些库</p>
</li>
</ul>
</li>
<li><p>对开发体验的优化</p>
<ul>
<li><p>lint</p>
<p>使用 eslint、stylelint 等工具保证团队代码风格一致</p>
</li>
<li><p>HMR</p>
<p>使用热替换避免页面刷新导致的状态丢失，提升开发体验</p>
</li>
</ul>
</li>
</ol>
</blockquote>
</li>
<li><p>如果有一个工程打包特别大-如何进行优化？</p>
<blockquote>
<p>参考答案：</p>
<ol>
<li><p>CDN</p>
<p>如果工程中使用了一些知名的第三方库，可以考虑使用 CDN，而不进行打包</p>
</li>
<li><p>抽离公共模块</p>
<p>如果工程中用到了一些大的公共库，可以考虑将其分割出来单独打包</p>
</li>
<li><p>异步加载</p>
<p>对于那些不需要在一开始就执行的模块，可以考虑使用动态导入的方式异步加载它们，以尽量减少主包的体积</p>
</li>
<li><p>压缩、混淆</p>
</li>
<li><p>tree shaking</p>
<p>尽量使用 ESM 语法进行导入导出，充分利用 tree shaking 去除无用代码</p>
</li>
<li><p>gzip</p>
<p>开启 gzip 压缩，进一步减少包体积</p>
</li>
<li><p>环境适配</p>
<p>有些打包结果中包含了大量兼容性处理的代码，但在新版本浏览器中这些代码毫无意义。因此，可以把浏览器分为多个层次，为不同层次的浏览器给予不同的打包结果。</p>
</li>
</ol>
</blockquote>
</li>
<li><p>webpack 怎么进行首屏加载的优化？</p>
<blockquote>
<p>参考答案：</p>
<ol>
<li><p>CDN</p>
<p>如果工程中使用了一些知名的第三方库，可以考虑使用 CDN，而不进行打包</p>
</li>
<li><p>抽离公共模块</p>
<p>如果工程中用到了一些大的公共库，可以考虑将其分割出来单独打包</p>
</li>
<li><p>异步加载</p>
<p>对于那些不需要在一开始就执行的模块，可以考虑使用动态导入的方式异步加载它们，以尽量减少主包的体积</p>
</li>
<li><p>压缩、混淆</p>
</li>
<li><p>tree shaking</p>
<p>尽量使用 ESM 语法进行导入导出，充分利用 tree shaking 去除无用代码</p>
</li>
<li><p>gzip</p>
<p>开启 gzip 压缩，进一步减少包体积</p>
</li>
<li><p>环境适配</p>
<p>有些打包结果中包含了大量兼容性处理的代码，但在新版本浏览器中这些代码毫无意义。因此，可以把浏览器分为多个层次，为不同层次的浏览器给予不同的打包结果。</p>
</li>
</ol>
</blockquote>
</li>
<li><p>介绍一下 webpack scope hoisting？</p>
<blockquote>
<p>参考答案：</p>
<p>scope hoisting 是 webpack 的内置优化，它是针对模块的优化，在生产环境打包时会自动开启。</p>
<p>在未开启scope hoisting时，webpack 会将每个模块的代码放置在一个独立的函数环境中，这样是为了保证模块的作用域互不干扰。</p>
<p>而 scope hoisting 的作用恰恰相反，是把多个模块的代码合并到一个函数环境中执行。在这一过程中，webpack 会按照顺序正确的合并模块代码，同时对涉及的标识符做适当处理以避免重名。</p>
<p>这样做的好处是减少了函数调用，对运行效率有一定提升，同时也降低了打包体积。</p>
<p>但 scope hoisting 的启用是有前提的，如果遇到某些模块多次被其他模块引用，或者使用了动态导入的模块，或者是非 ESM 的模块，都不会有 scope hoisting。</p>
</blockquote>
</li>
<li><p>webpack proxy 工作原理，为什么能解决跨域？</p>
<blockquote>
<p>说明：</p>
<p>严格来说，webpack 只是一个打包工具，它并没有 proxy 的功能，甚至连服务器的功能都没有。之所以能够在 webpack 中使用 proxy 配置，是因为它的一个插件，即 webpack-dev-server 的能力。</p>
<p>所以，此题应该问做：「webpack-dev-server 工作原理，为什么能解决跨域？」</p>
</blockquote>
<blockquote>
<p>参考答案：</p>
<p>首先，proxy 配置是针对开发环境的，对生产环境没有任何意义。</p>
<p>当我们通过 webpack-dev-server 启动开发服务器后，所有的打包资源都可以通过访问开发服务器获得。</p>
<p>与此同时，我们又配置了 proxy，当我们向开发服务器请求特定的地址时，开发服务器会将其代理到目标地址。因此，后续对代理地址的请求，就可以变为直接请求开发服务器。</p>
<p>这样一来，我们请求静态页面的域和请求代理地址的域就同源了，因为都是请求开发服务器，所以就不会产生跨域问题。</p>
</blockquote>
</li>
<li><p>组件发布的是不是所有依赖这个组件库的项目都需要升级？</p>
<blockquote>
<p>参考答案：</p>
<p>实际上就是一个版本管理的问题。</p>
<p>如果此次模块升级只是修复了某一些 bug，作为补丁版本升级即可，不影响主版本和次版本号</p>
<p>如果此次模块升级会新增一些内容，完全兼容之前的 API，作为次版本升级即可</p>
<p>如果此次模块升级会修改之前的 API，则作为主版本升级</p>
<p>在开发项目时，让项目依赖模块的主版本，因此，当模块更新时，只要不是主版本更新，项目都可以非常方便的升级模块版本，无须改动任何代码。但若涉及主版本更新，项目可以完全无视此次版本更新，仍然使用之前的旧版本，无须改动任何代码；当然也可以升级主版本，但就会涉及代码的改动，这就好比跟将 vue2 升级到 vue3 会涉及大量改动一样。</p>
<p>而在开发模块时，在一开始就要精心设计 API，尽量保证 API 的接口稳定，不要经常变动主版本号。如果实在要更新主版本，就需要在一段时间内同时维护两个版本（新的主版本，旧的主版本），给予其他项目一定的升级时间。</p>
</blockquote>
</li>
<li><p>开发过程中，如何进行公共组件的设计？（字节跳动）</p>
<blockquote>
<p>参考答案：</p>
<ol>
<li><p>确定使用场景</p>
<p>明确这个公共组件的需求是怎么产生的，它目前的使用场景有哪些，将来还可能出现哪些使用场景。</p>
<p>明确使用场景至关重要，它决定了这个组件的使用边界在哪，通用到什么程度，从而决定了这个组件的开发难度</p>
</li>
<li><p>设计组件功能</p>
<p>根据其使用场景，设计出组件的属性、事件、使用说明文档</p>
</li>
<li><p>测试用例</p>
<p>根据使用说明文档编写组件测试用例</p>
</li>
<li><p>完成开发</p>
<p>根据使用说明文档、测试用例完成开发</p>
</li>
</ol>
</blockquote>
</li>
<li><p>说一下项目里有做过哪些 webpack 上的优化（字节跳动）</p>
<blockquote>
<p>参考答案：</p>
<ol>
<li><p>对传输性能的优化</p>
<ul>
<li><p>压缩和混淆</p>
<p>使用 Uglifyjs 或其他类似工具对打包结果进行压缩、混淆，可以有效的减少包体积</p>
</li>
<li><p>tree shaking</p>
<p>项目中尽量使用 ESM，可以有效利用 tree shaking 优化，降低包体积</p>
</li>
<li><p>抽离公共模块</p>
<p>将一些公共代码单独打包，这样可以充分利用浏览器缓存，其他代码变动后，不影响公共代码，浏览器可以直接从缓存中找到公共代码。</p>
<p>具体方式有多种，比如 dll、splitChunks</p>
</li>
<li><p>异步加载</p>
<p>对一些可以延迟执行的模块可以使用动态导入的方式异步加载它们，这样在打包结果中，它们会形成单独的包，同时，在页面一开始解析时并不需要加载它们，而是页面解析完成后，执行 JS 的过程中去加载它们。</p>
<p>这样可以显著提高页面的响应速度，在单页应用中尤其有用。</p>
</li>
<li><p>CDN</p>
<p>对一些知名的库使用 CDN，不仅可以节省打包时间，还可以显著提升库的加载速度</p>
</li>
<li><p>gzip</p>
<p>目前浏览器普遍支持 gzip 格式，因此可以将静态文件均使用 gzip 进行压缩</p>
</li>
<li><p>环境适配</p>
<p>有些打包结果中包含了大量兼容性处理的代码，但在新版本浏览器中这些代码毫无意义。因此，可以把浏览器分为多个层次，为不同层次的浏览器给予不同的打包结果。</p>
</li>
</ul>
</li>
<li><p>对打包过程的优化</p>
<ul>
<li><p>noParse</p>
<p>很多第三方库本身就是已经打包好的代码，对于这种代码无须再进行解析，可以使用 noParse 配置排除掉这些第三方库</p>
</li>
<li><p>externals</p>
<p>对于一些知名的第三方库可以使用 CDN，这部分库可以通过 externals 配置不进行打包</p>
</li>
<li><p>限制 loader 的范围</p>
<p>在使用 loader 的时候，可以通过 exclude 排除掉一些不必要的编译，比如 babel-loader 对于那些已经完成打包的第三方库没有必要再降级一次，可以排除掉</p>
</li>
<li><p>开启 loader 缓存</p>
<p>可以利用<code>cache-loader</code>缓存 loader 的编译结果，避免在源码没有变动时反复编译</p>
</li>
<li><p>开启多线程编译</p>
<p>可以利用<code>thread-loader</code>开启多线程编译，提升编译效率</p>
</li>
<li><p>动态链接库</p>
<p>对于某些需要打包的第三方库，可以使用 dll 的方式单独对其打包，然后 DLLPlugin 将其整合到当前项目中，这样就避免了在开发中频繁去打包这些库</p>
</li>
</ul>
</li>
<li><p>对开发体验的优化</p>
<ul>
<li><p>lint</p>
<p>使用 eslint、stylelint 等工具保证团队代码风格一致</p>
</li>
<li><p>HMR</p>
<p>使用热替换避免页面刷新导致的状态丢失，提升开发体验</p>
</li>
</ul>
</li>
</ol>
</blockquote>
</li>
<li><p>具体说一下 splitchunksplugin 的使用场景及使用方法。（字节跳动）</p>
<blockquote>
<p>参考答案：</p>
<ol>
<li><p>公共模块</p>
<p>比如某些多页应用会有多个入口，从而形成多个 chunk，而这些 chunk 中用到了一些公共模块，为了减少整体的包体积，可以使用 splitchunksplugin 将公共模块分离出来。</p>
<p>可以配置 minChunks 来指定被多少个 chunk 引用时进行分包</p>
</li>
<li><p>并行下载</p>
<p>由于 HTML5 支持 defer 和 async，因此可以同时下载多个 JS 文件以充分利用带宽。如果打包结果是一个很大的文件，就无法利用到这一点。</p>
<p>可以利用 splitchunks 插件将文件进行拆分，通过配置 maxSize 属性指定包体积达到多大时进行拆分</p>
</li>
</ol>
</blockquote>
</li>
<li><p>描述一下 webpack 的构建流程？（CVTE）</p>
<blockquote>
<p>参考答案：</p>
<ol>
<li><strong>初始化参数</strong>：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数</li>
<li><strong>开始编译</strong>：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 <code>run</code> 方法开始执行编译</li>
<li><strong>确定入口</strong>：根据配置中的 <code>entry</code> 找出所有的入口文件</li>
<li><strong>编译模块</strong>：从入口文件出发，调用所有配置的 <code>loader</code> 对模块进行翻译，再把翻译后的内容转换成 AST，通过对 AST 的分析找出该模块依赖的模块，再 <code>递归</code> 本步骤直到所有入口依赖的文件都经过了本步骤的处理</li>
<li><strong>完成模块编译</strong>：在经过第 4 步使用 <code>loader</code> 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的 <code>依赖关系图</code></li>
<li><strong>输出资源</strong>：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 <code>Chunk</code>，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会</li>
<li><strong>输出完成</strong>：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统</li>
</ol>
</blockquote>
</li>
<li><p>解释一下 webpack 插件的实现原理？（CVTE）</p>
<blockquote>
<p>参考答案：</p>
<p>本质上，webpack 的插件是一个带有<code>apply</code>函数的对象。当 webpack 创建好 compiler 对象后，会执行注册插件的 apply 函数，同时将 compiler 对象作为参数传入。</p>
<p>在 apply 函数中，开发者可以通过 compiler 对象监听多个钩子函数的执行，不同的钩子函数对应 webpack 编译的不同阶段。当 webpack 进行到一定阶段后，会调用这些监听函数，同时将 compilation 对象传入。开发者可以使用 compilation 对象获取和改变 webpack 的各种信息，从而影响构建过程。</p>
</blockquote>
</li>
<li><p>有用过哪些插件做项目的分析吗？（CVTE）</p>
<blockquote>
<p>参考答案：</p>
<p>用过 webpack-bundle-analyzer 分析过打包结果，主要用于优化项目打包体积</p>
</blockquote>
</li>
<li><p>什么是 babel，有什么作用？</p>
<blockquote>
<p>参考答案：</p>
<p>babel 是一个 JS 编译器，主要用于将下一代的 JS 语言代码编译成兼容性更好的代码。</p>
<p>它其实本身做的事情并不多，它负责将 JS 代码编译成为 AST，然后依托其生态中的各种插件对 AST 中的语法和 API 进行处理</p>
</blockquote>
</li>
<li><p>解释一下 npm 模块安装机制是什么？</p>
<blockquote>
<p>参考答案：</p>
<ol>
<li>npm 会检查本地的 node_modules 目录中是否已经安装过该模块，如果已经安装，则不再重新安装</li>
<li>npm 检查缓存中是否有相同的模块，如果有，直接从缓存中读取安装</li>
<li>如果本地和缓存中均不存在，npm 会从 registry 指定的地址下载安装包，然后将其写入到本地的 node_modules 目录中，同时缓存起来。</li>
</ol>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>面试题</category>
        <category>工程化</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>面试题</tag>
        <tag>工程化</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题网络面试题汇总一</title>
    <url>/135xyq.github.io/2022/05/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%BD%91%E7%BB%9C-%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B8%80/</url>
    <content><![CDATA[<ol>
<li><p>简述 TCP 连接的过程（淘系）</p>
<blockquote>
<p>参考答案：</p>
<p>TCP 协议通过三次握手建立可靠的点对点连接，具体过程是：</p>
<p>首先服务器进入监听状态，然后即可处理连接</p>
<p>第一次握手：建立连接时，客户端发送 syn 包到服务器，并进入 SYN_SENT 状态，等待服务器确认。在发送的包中还会包含一个初始序列号 seq。此次握手的含义是客户端希望与服务器建立连接。</p>
<p>第二次握手：服务器收到 syn 包，然后回应给客户端一个 SYN+ACK 包，此时服务器进入 SYN_RCVD 状态。此次握手的含义是服务端回应客户端，表示已收到并同意客户端的连接请求。</p>
<p>第三次握手：客户端收到服务器的 SYN 包后，向服务器再次发送 ACK 包，并进入 ESTAB_LISHED 状态。</p>
<p>最后，服务端收到客户端的 ACK 包，于是也进入 ESTAB_LISHED 状态，至此，连接建立完成</p>
</blockquote>
</li>
<li><p>介绍下 HTTPS 中间人攻击</p>
<blockquote>
<p>参考答案：</p>
<p>针对 HTTPS 攻击主要有 SSL 劫持攻击和 SSL 剥离攻击两种。</p>
<p>SSL 劫持攻击是指攻击者劫持了客户端和服务器之间的连接，将服务器的合法证书替换为伪造的证书，从而获取客户端和服务器之间传递的信息。这种方式一般容易被用户发现，浏览器会明确的提示证书错误，但某些用户安全意识不强，可能会点击继续浏览，从而达到攻击目的。</p>
<p>SSL 剥离攻击是指攻击者劫持了客户端和服务器之间的连接，攻击者保持自己和服务器之间的 HTTPS 连接，但发送给客户端普通的 HTTP 连接，由于 HTTP 连接是明文传输的，即可获取客户端传输的所有明文数据。</p>
</blockquote>
</li>
<li><p>介绍下 <code>http1.0</code>、<code>http1.1</code>、<code>http2.0</code> 协议的区别？</p>
<blockquote>
<p>参考答案：</p>
<p>首先说 http1.0</p>
<p>它的特点是每次请求和响应完毕后都会销毁 TCP 连接，同时规定前一个响应完成后才能发送下一个请求。这样做有两个问题：</p>
<ol>
<li><p>无法复用连接</p>
<p>每次请求都要创建新的 TCP 连接，完成三次握手和四次挥手，网络利用率低</p>
</li>
<li><p>队头阻塞</p>
<p>如果前一个请求被某种原因阻塞了，会导致后续请求无法发送。</p>
</li>
</ol>
<p>然后是 http1.1</p>
<p>http1.1 是 http1.0 的改进版，它做出了以下改进：</p>
<ol>
<li><p>长连接</p>
<p>http1.1 允许在请求时增加请求头<code>connection:keep-alive</code>，这样便允许后续的客户端请求在一段时间内复用之前的 TCP 连接</p>
</li>
<li><p>管道化</p>
<p>基于长连接的基础，管道化可以不等第一个请求响应继续发送后面的请求，但响应的顺序还是按照请求的顺序返回。</p>
</li>
<li><p>缓存处理</p>
<p>新增响应头 cache-control，用于实现客户端缓存。</p>
</li>
<li><p>断点传输</p>
<p>在上传/下载资源时，如果资源过大，将其分割为多个部分，分别上传/下载，如果遇到网络故障，可以从已经上传/下载好的地方继续请求，不用从头开始，提高效率</p>
</li>
</ol>
<p>最后是 http2.0</p>
<p>http2.0 进一步优化了传输效率，它主要有以下改进：</p>
<ol>
<li><p>二进制分帧</p>
<p>将传输的消息分为更小的二进制帧，每帧有自己的标识序号，即便被随意打乱也能在另一端正确组装</p>
</li>
<li><p>多路复用</p>
<p>基于二进制分帧，在同一域名下所有访问都是从同一个 tcp 连接中走，并且不再有队头阻塞问题，也无须遵守响应顺序</p>
</li>
<li><p>头部压缩</p>
<p>http2.0 通过字典的形式，将头部中的常见信息替换为更少的字符，极大的减少了头部的数据量，从而实现更小的传输量</p>
</li>
<li><p>服务器推</p>
<p>http2.0 允许服务器直接推送消息给客户端，无须客户端明确的请求</p>
</li>
</ol>
</blockquote>
</li>
<li><p>为什么 HTTP1.1 不能实现多路复用（腾讯）</p>
<blockquote>
<p>参考答案：</p>
<p>HTTP/1.1 不是二进制传输，而是通过文本进行传输。由于没有流的概念，在使用并行传输（多路复用）传递数据时，接收端在接收到响应后，并不能区分多个响应分别对应的请求，所以无法将多个响应的结果重新进行组装，也就实现不了多路复用。</p>
</blockquote>
</li>
<li><p>简单讲解一下 http2 的多路复用（网易）</p>
<blockquote>
<p>参考答案：</p>
<p>在 HTTP/2 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。 帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。 多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。</p>
</blockquote>
</li>
<li><p>谈谈你对 TCP 三次握手和四次挥手的理解</p>
<blockquote>
<p>TCP 协议通过三次握手建立可靠的点对点连接，具体过程是：</p>
<p>首先服务器进入监听状态，然后即可处理连接</p>
<p>第一次握手：建立连接时，客户端发送 syn 包到服务器，并进入 SYN_SENT 状态，等待服务器确认。在发送的包中还会包含一个初始序列号 seq。此次握手的含义是客户端希望与服务器建立连接。</p>
<p>第二次握手：服务器收到 syn 包，然后回应给客户端一个 SYN+ACK 包，此时服务器进入 SYN_RCVD 状态。此次握手的含义是服务端回应客户端，表示已收到并同意客户端的连接请求。</p>
<p>第三次握手：客户端收到服务器的 SYN 包后，向服务器再次发送 ACK 包，并进入 ESTAB_LISHED 状态。</p>
<p>最后，服务端收到客户端的 ACK 包，于是也进入 ESTAB_LISHED 状态，至此，连接建立完成</p>
<p>当需要关闭连接时，需要进行四次挥手才能关闭</p>
<ol>
<li>Client 向 Server 发送 FIN 包，表示 Client 主动要关闭连接，然后进入 FIN_WAIT_1 状态，等待 Server 返回 ACK 包。此后 Client 不能再向 Server 发送数据，但能读取数据。</li>
<li>Server 收到 FIN 包后向 Client 发送 ACK 包，然后进入 CLOSE_WAIT 状态，此后 Server 不能再读取数据，但可以继续向 Client 发送数据。</li>
<li>Client 收到 Server 返回的 ACK 包后进入 FIN_WAIT_2 状态，等待 Server 发送 FIN 包。</li>
<li>Server 完成数据的发送后，将 FIN 包发送给 Client，然后进入 LAST_ACK 状态，等待 Client 返回 ACK 包，此后 Server 既不能读取数据，也不能发送数据。</li>
<li>Client 收到 FIN 包后向 Server 发送 ACK 包，然后进入 TIME_WAIT 状态，接着等待足够长的时间（2MSL）以确保 Server 接收到 ACK 包，最后回到 CLOSED 状态，释放网络资源。</li>
<li>Server 收到 Client 返回的 ACK 包后便回到 CLOSED 状态，释放网络资源。</li>
</ol>
</blockquote>
</li>
<li><p>介绍 HTTPS 握手过程</p>
<blockquote>
<p>参考答案：</p>
<ol>
<li>客户端请求服务器，并告诉服务器自身支持的加密算法以及密钥长度等信息</li>
<li>服务器响应公钥和服务器证书</li>
<li>客户端验证证书是否合法，然后生成一个会话密钥，并用服务器的公钥加密密钥，把加密的结果通过请求发送给服务器</li>
<li>服务器使用私钥解密被加密的会话密钥并保存起来，然后使用会话密钥加密消息响应给客户端，表示自己已经准备就绪</li>
<li>客户端使用会话密钥解密消息，知道了服务器已经准备就绪。</li>
<li>后续客户端和服务器使用会话密钥加密信息传递消息</li>
</ol>
</blockquote>
</li>
<li><p>HTTPS 握手过程中，客户端如何验证证书的合法性</p>
<blockquote>
<p>参考答案：</p>
<ol>
<li>校验证书的颁发机构是否受客户端信任。</li>
<li>通过 CRL 或 OCSP 的方式校验证书是否被吊销。</li>
<li>对比系统时间，校验证书是否在有效期内。</li>
<li>通过校验对方是否存在证书的私钥，判断证书的网站域名是否与证书颁发的域名一致。</li>
</ol>
</blockquote>
</li>
<li><p>Http 状态码 301 和 302 的应用场景分别是什么</p>
<blockquote>
<p>参考答案：</p>
<p>301 表示永久重定向，302 表示临时重定向。</p>
<p>如果浏览器收到的是 301，则会缓存重定向的地址，之后不会再重新请求服务器，直接使用缓存的地址请求，这样可以减少请求次数。</p>
<p>但如果浏览器收到的是 302，则不会缓存重定向地址，浏览器将来会继续以原有地址请求。</p>
<p>因此，301 适合地址永久转移的场景，比如域名变更；而 302 适合临时转移的场景，比如首页临时跳转到活动页</p>
</blockquote>
</li>
<li><p>cookie 和 token 都存放在 header 中，为什么不会劫持 token？</p>
<blockquote>
<p>参考答案：</p>
<p>由于浏览器会自动发送 cookie 到服务器，因此攻击者可以利用这种特点进行 csrf 攻击。</p>
<p>而通常 token 是不放到 cookie 中的，需要浏览器端使用 JS 自行保存到 localstorage 中，在请求时也需要手动的加入到请求头中，因此不容易引发 csrf 攻击。</p>
</blockquote>
</li>
<li><p>介绍下如何实现 token 加密</p>
<blockquote>
<p>参考答案：</p>
<p>以最常见的 token 格式 jwt 为例</p>
<p>token 分为三段，分别是 header、payload、signature</p>
<p>其中，header 标识签名算法和令牌类型；payload 标识主体信息，包含令牌过期时间、发布时间、发行者、主体内容等；signature 是使用特定的算法对前面两部分进行加密，得到的加密结果。</p>
<p>token 有防篡改的特点，如果攻击者改动了前面两个部分，就会导致和第三部分对应不上，使得 token 失效。而攻击者不知道加密秘钥，因此又无法修改第三部分的值。</p>
<p>所以，在秘钥不被泄露的前提下，一个验证通过的 token 是值得被信任的。</p>
</blockquote>
</li>
<li><p>说下单点登录（新东方）</p>
<blockquote>
<p>参考答案：</p>
<p>SSO 一般都需要一个独立的认证中心（passport），子系统的登录均得通过 passport，子系统本身将不参与登录操作，当一个系统成功登录以后，passport 将会颁发一个令牌给各个子系统，子系统可以拿着令牌会获取各自的受保护资源，为了减少频繁认证，各个子系统在被 passport 授权以后，会建立一个局部会话，在一定时间内可以无需再次向 passport 发起认证。</p>
<p>具体流程是：</p>
<ol>
<li>用户访问系统 1 的受保护资源，系统 1 发现用户未登录，跳转至 sso 认证中心，并将自己的地址作为参数</li>
<li>sso 认证中心发现用户未登录，将用户引导至登录页面</li>
<li>用户输入用户名密码提交登录申请</li>
<li>sso 认证中心校验用户信息，创建用户与 sso 认证中心之间的会话，称为全局会话，同时创建授权令牌</li>
<li>sso 认证中心带着令牌跳转会最初的请求地址（系统 1）</li>
<li>系统 1 拿到令牌，去 sso 认证中心校验令牌是否有效</li>
<li>sso 认证中心校验令牌，返回有效，注册系统 1</li>
<li>系统 1 使用该令牌创建与用户的会话，称为局部会话，返回受保护资源</li>
<li>用户访问系统 2 的受保护资源</li>
<li>系统 2 发现用户未登录，跳转至 sso 认证中心，并将自己的地址作为参数</li>
<li>sso 认证中心发现用户已登录，跳转回系统 2 的地址，并附上令牌</li>
<li>系统 2 拿到令牌，去 sso 认证中心校验令牌是否有效</li>
<li>sso 认证中心校验令牌，返回有效，注册系统 2</li>
<li>系统 2 使用该令牌创建与用户的局部会话，返回受保护资源</li>
</ol>
</blockquote>
</li>
<li><p>http1.1 是如何复用 tcp 连接的？（网易）</p>
<blockquote>
<p>参考答案：</p>
<p>客户端请求服务器时，通过请求行告诉服务器使用的协议是 http1.1，同时在请求头中附带<code>connection:keep-alive</code>（为保持兼容），告诉服务器这是一个长连接，后续请求可以重复使用这一次的 TCP 连接。</p>
<p>这样做的好处是减少了三次握手和四次挥手的次数，一定程度上提升了网络利用率。但由于 http1.1 不支持多路复用，响应顺序必须按照请求顺序抵达客户端，不能真正实现并行传输，因此在 http2.0 出现之前，实际项目中往往把静态资源，比如图片，分发到不同域名下的资源服务器，以便实现真正的并行传输。</p>
</blockquote>
</li>
<li><p>文件上传如何做断点续传（网易）</p>
<blockquote>
<p>参考答案：</p>
<p>客户端将文件的二进制内容进行分片，每片数据按顺序进行序号标识，上传每片数据时同时附带其序号。服务器接收到每片数据时，将其保存成一个临时文件，并记录每个文件的 hash 和序号。</p>
<p>若上传中止，将来再次上传时，可以向服务器索要已上传的分片序号，客户端仅需上传剩余分片即可。</p>
<p>当全部分片上传完成后，服务器按照分片的顺序组装成完整的文件，并删除分片文件。</p>
</blockquote>
</li>
<li><p>介绍 SSL 和 TLS（寺库）</p>
<blockquote>
<p>参考答案：</p>
<p>它们都是用于保证传输安全的协议，介于传输层和应用层之间，TLS 是 SSL 的升级版。</p>
<p>它们的基本流程一致：</p>
<ol>
<li>客户端向服务器端索要公钥，并使用数字证书验证公钥。</li>
<li>客户端使用公钥加密会话密钥，服务端用私钥解密会话密钥，于是得到一个双方都认可的会话密钥</li>
<li>传输的数据使用会话密钥加密，然后再传输，接收消息方使用会话密钥解密得到原始数据</li>
</ol>
</blockquote>
</li>
<li><p>说说网络的五层模型（寺库）</p>
<blockquote>
<p>参考答案：</p>
<p>从上到下分别为：应用层、传输层、网络层、数据链路层、物理层。在发送消息时，消息从上到下进行打包，每一层会在上一层基础上加包，而接受消息时，从下到上进行解包，最终得到原始信息。</p>
<p>其中：</p>
<p>应用层主要面向互联网中的应用场景，比如网页、邮件、文件中心等等，它的代表协议有 http、smtp、pop3、ftp、DNS 等等</p>
<p>传输层主要面向传输过程，比如 TCP 协议是为了保证可靠的传输，而 UDP 协议则是一种无连接的广播，它们提供了不同的传输方式</p>
<p>网络层主要解决如何定位目标的问题，比如 IP、ICMP、ARP 等等</p>
<p>数据链路层的作用是将数据可靠的传输到目标，比如常见的以太网协议、P2P 协议</p>
<p>物理层是要规范网络两端使用的物理设备，比如蓝牙、wifi、光纤、网线接头等等</p>
</blockquote>
</li>
<li><p>GET 和 POST 的区别（流利说）</p>
<blockquote>
<p>参考答案：</p>
<p>从 http 协议的角度来说，GET 和 POST 它们都只是请求行中的第一个单词，除了语义不同，其实没有本质的区别。</p>
<p>之所以在实际开发中会产生各种区别，主要是因为浏览器的默认行为造成的。</p>
<p>受浏览器的影响，在实际开发中，GET 和 POST 有以下区别：</p>
<ol>
<li>浏览器在发送 GET 请求时，不会附带请求体</li>
<li>GET 请求的传递信息量有限，适合传递少量数据；POST 请求的传递信息量是没有限制的，适合传输大量数据。</li>
<li>GET 请求只能传递 ASCII 数据，遇到非 ASCII 数据需要进行编码；POST 请求没有限制</li>
<li>大部分 GET 请求传递的数据都附带在 path 参数中，能够通过分享地址完整的重现页面，但同时也暴露了数据，若有敏感数据传递，不应该使用 GET 请求，至少不应该放到 path 中</li>
<li>刷新页面时，若当前的页面是通过 POST 请求得到的，则浏览器会提示用户是否重新提交。若是 GET 请求得到的页面则没有提示。</li>
<li>GET 请求的地址可以被保存为浏览器书签，POST 不可以</li>
</ol>
</blockquote>
</li>
<li><p>http 劫持是什么？</p>
<blockquote>
<p>参考答案：</p>
<p>是指攻击者在客户端和服务器之间同时建立了连接通道，通过某种方式，让客户端请求发送到自己的服务器，然后自己就拥有了控制响应内容的能力，从而给客户端展示错误的信息。</p>
</blockquote>
</li>
<li><p>HTTP 劫持、DNS 劫持与 XSS</p>
<blockquote>
<p>参考答案：</p>
<p>http 劫持是指攻击者在客户端和服务器之间同时建立了连接通道，通过某种方式，让客户端请求发送到自己的服务器，然后自己就拥有了控制响应内容的能力，从而给客户端展示错误的信息，比如在页面中加入一些广告内容。</p>
<p>DNS 劫持是指攻击者劫持了 DNS 服务器，获得了修改 DNS 解析记录的权限，从而导致客户端请求的域名被解析到了错误的 IP 地址，攻击者通过这种方式窃取用户资料或破坏原有正常服务。</p>
<p>XSS 是指跨站脚本攻击。攻击者利用站点的漏洞，在表单提交时，在表单内容中加入一些恶意脚本，当其他正常用户浏览页面，而页面中刚好出现攻击者的恶意脚本时，脚本被执行，从而使得页面遭到破坏，或者用户信息被窃取。</p>
<p>要防范 XSS 攻击，需要在服务器端过滤脚本代码，将一些危险的元素和属性去掉或对元素进行HTML实体编码。</p>
</blockquote>
</li>
<li><p>介绍 xss csrf 攻击</p>
<blockquote>
<p>参考答案：</p>
<p>XSS：</p>
<p>XSS 是指跨站脚本攻击。攻击者利用站点的漏洞，在表单提交时，在表单内容中加入一些恶意脚本，当其他正常用户浏览页面，而页面中刚好出现攻击者的恶意脚本时，脚本被执行，从而使得页面遭到破坏，或者用户信息被窃取。</p>
<p>要防范 XSS 攻击，需要在服务器端过滤脚本代码，将一些危险的元素和属性去掉或对元素进行HTML实体编码。</p>
<p>CSRF：</p>
<p>CSRF 是跨站请求伪造，是一种挟制用户在当前已登录的Web应用上执行非本意的操作的攻击方法</p>
<p>它首先引导用户访问一个危险网站，当用户访问网站后，网站会发送请求到被攻击的站点，这次请求会携带用户的cookie发送，因此就利用了用户的身份信息完成攻击</p>
<p>防御 CSRF 攻击有多种手段：</p>
<ol>
<li>不使用cookie</li>
<li>为表单添加校验的 token 校验</li>
<li>cookie中使用sameSite字段</li>
<li>服务器检查 referer 字段</li>
</ol>
</blockquote>
</li>
<li><p>https 验证身份也就是 TSL/SSL 身份验证的过程</p>
<blockquote>
<p>参考答案：</p>
<ol>
<li>客户端请求服务器，并告诉服务器自身支持的加密算法以及密钥长度等信息</li>
<li>服务器响应公钥和服务器证书</li>
<li>客户端验证证书是否合法，然后生成一个会话密钥，并用服务器的公钥加密密钥，把加密的结果通过请求发送给服务器</li>
<li>服务器使用私钥解密被加密的会话密钥并保存起来，然后使用会话密钥加密消息响应给客户端，表示自己已经准备就绪</li>
<li>客户端使用会话密钥解密消息，知道了服务器已经准备就绪。</li>
<li>后续客户端和服务器使用会话密钥加密信息传递消息</li>
</ol>
</blockquote>
</li>
<li><p>为什么需要 CA 机构对证书签名</p>
<blockquote>
<p>参考答案：</p>
<p>主要是为了解决证书的可信问题。如果没有权威机构对证书进行签名，客户端就无法知晓证书是否是伪造的，从而增加了中间人攻击的风险，https 就变得毫无意义。</p>
</blockquote>
</li>
<li><p>身份验证过程中会涉及到密钥，对称加密，非对称加密，摘要的概念，请解释一下</p>
<blockquote>
<p>参考答案：</p>
<p>密钥</p>
<p>密钥是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的参数。密钥分为对称密钥与非对称密钥，分别应用在对称加密和非对称加密上。</p>
<p>对称加密</p>
<p>对称加密又叫做私钥加密，即信息的发送方和接收方使用同一个密钥去加密和解密数据。对称加密的特点是算法公开、加密和解密速度快，适合于对大数据量进行加密，常见的对称加密算法有 DES、3DES、TDEA、Blowfish、RC5 和 IDEA。</p>
<p>非对称加密</p>
<p>非对称加密也叫做公钥加密。非对称加密与对称加密相比，其安全性更好。对称加密的通信双方使用相同的密钥，如果一方的密钥遭泄露，那么整个通信就会被破解。而非对称加密使用一对密钥，即公钥和私钥，且二者成对出现。私钥被自己保存，不能对外泄露。公钥指的是公共的密钥，任何人都可以获得该密钥。用公钥或私钥中的任何一个进行加密，用另一个进行解密。</p>
<p>摘要</p>
<p>摘要算法又称哈希/散列算法。它通过一个函数，把任意长度的数据转换为一个长度固定的数据串（通常用 16 进制的字符串表示）。算法不可逆。</p>
</blockquote>
</li>
<li><p>webSocket 协议是什么，能简述一下吗？</p>
<blockquote>
<p>参考答案：</p>
<p>websocket 协议 HTML5 带来的新协议，相对于 http，它是一个持久连接的协议，它利用 http 协议完成握手，然后通过 TCP 连接通道发送消息，使用 websocket 协议可以实现服务器主动推送消息。</p>
<p>首先，客户端若要发起 websocket 连接，首先必须向服务器发送 http 请求以完成握手，请求行中的 path 需要使用<code>ws:</code>开头的地址，请求头中要分别加入<code>upgrade、connection、Sec-WebSocket-Key、Sec-WebSocket-Version</code>标记</p>
<p>然后，服务器收到请求后，发现这是一个 websocket 协议的握手请求，于是响应行中包含<code>Switching Protocols</code>，同时响应头中包含<code>upgrade、connection、Sec-WebSocket-Accept</code>标记</p>
<p>当客户端收到响应后即可完成握手，随后使用建立的 TCP 连接直接发送和接收消息。</p>
</blockquote>
</li>
<li><p>webSocket 与传统的 http 有什么优势</p>
<blockquote>
<p>参考答案：</p>
<p>当页面中需要观察实时数据的变化（比如聊天、k 线图）时，过去我们往往使用两种方式完成</p>
<p>第一种是短轮询，即客户端每隔一段时间就向服务器发送消息，询问有没有新的数据</p>
<p>第二种是长轮询，发起一次请求询问服务器，服务器可以将该请求挂起，等到有新消息时再进行响应。响应后，客户端立即又发起一次请求，重复整个流程。</p>
<p>无论是哪一种方式，都暴露了 http 协议的弱点，即响应必须在请求之后发生，服务器是被动的，无法主动推送消息。而让客户端不断的发起请求又白白的占用了资源。</p>
<p>websocket 的出现就是为了解决这个问题，它利用 http 协议完成握手之后，就可以与服务器建立持久的连接，服务器可以在任何需要的时候，主动推送消息给客户端，这样占用的资源最少，同时实时性也最高。</p>
</blockquote>
</li>
<li><p>如何劫持 https 的请求，提供思路</p>
<blockquote>
<p>参考答案：</p>
<p>https 有防篡改的特点，只要浏览器证书验证过程是正确的，很难在用户不察觉的情况下进行攻击。但若能够更改浏览器的证书验证过程，便有机会实现 https 中间人攻击。</p>
<p>所以，要劫持 https，首先要伪造一个证书，并且要想办法让用户信任这个证书，可以有多种方式，比如病毒、恶意软件、诱导等。一旦证书被信任后，就可以利用普通中间人攻击的方式，使用伪造的证书进行攻击。</p>
</blockquote>
</li>
<li><p>怎样解决跨域问题？</p>
<blockquote>
<p>参考答案：</p>
<ol>
<li><p>使用 JSONP</p>
<p>这是一种古老的解决跨域问题的思路。</p>
<p>在需要跨域请求时，事先准备好一个处理服务器数据的函数，然后生成一个<code>&lt;script&gt;</code>元素，<code>src</code>指向跨域站点，同时把准备好的函数名通过地址参数传递到服务器。</p>
<p>跨域站点返回一段调用该函数的脚本，当客户端接收到脚本后就会运行事先准备的函数，从而实现跨域获取数据。</p>
<p>JSONP 实现简单、兼容性好，但缺点也很明显，它只支持 get 请求，同时也有安全性问题，并且对服务器端代码侵入性比较强。</p>
</li>
<li><p>使用 cors</p>
<p>在请求时，客户端使用一些特殊的请求头向服务器申请跨域访问，并通过这些请求头告诉服务器自己的行为。服务器根据自身的规则决定是否允许跨域，如果允许，则通过响应头告诉客户端可以发送跨域请求。</p>
<p>cors 协议已被各种主流浏览器支持，它安全性高，同时也不会侵入服务器代码，是目前最主流的跨域方式</p>
</li>
</ol>
<p>除此之外，远古时期的跨域处理还包括 iframe、form 等，由于它们缺陷非常明显，故很少使用了。</p>
</blockquote>
</li>
<li><p>前端如何实现即时通讯？</p>
<blockquote>
<p>参考答案：</p>
<ol>
<li>短轮询。即客户端每隔一段时间就向服务器发送消息，询问有没有新的数据</li>
<li>长轮询，发起一次请求询问服务器，服务器可以将该请求挂起，等到有新消息时再进行响应。响应后，客户端立即又发起一次请求，重复整个流程。</li>
<li>websocket，握手完毕后会建立持久性的连接通道，随后服务器可以在任何时候推送新消息给客户端</li>
</ol>
</blockquote>
</li>
<li><p>HTTP 常用状态码 301 302 304 403</p>
<blockquote>
<p>参考答案：</p>
<p>301 永久重定向，浏览器会把重定向后的地址缓存起来，将来用户再次访问原始地址时，直接引导用户访问新地址</p>
<p>302 临时重定向，浏览器会引导用户进入新地址，但不会缓存原始地址，下一次用户访问源地址时，浏览器仍然要请求原地址的服务器</p>
<p>304 资源未修改，服务器通过该状态码告诉客户端，请求的资源和过去一样，并没有任何变化，建议自行使用过去的缓存。通常，304 状态码的响应中，服务器不会附带任何的响应体。</p>
<p>403 不允许访问。服务器通过该状态码告诉客户端，这个资源目前不允许访问。这种状态码通常出现在权限不足的情况下。</p>
</blockquote>
</li>
<li><p>在浏览器地址栏输入地址，并按下回车键后，发生了哪些事情？</p>
<blockquote>
<ol>
<li><p>参考答案：</p>
<ol>
<li>浏览器自动补全协议、端口</li>
<li>浏览器自动完成url编码</li>
<li>浏览器根据url地址查找本地缓存，根据缓存规则看是否命中缓存，若命中缓存则直接使用缓存，不再发出请求</li>
<li>通过DNS解析找到服务器的IP地址</li>
<li>浏览器向服务器发出建立TCP连接的申请，完成三次握手后，连接通道建立</li>
<li>若使用了HTTPS协议，则还会进行SSL握手，建立加密信道。使用SSL握手时，会确定是否使用HTTP2</li>
<li>浏览器决定要附带哪些cookie到请求头中</li>
<li>浏览器自动设置好请求头、协议版本、cookie，发出GET请求</li>
<li>服务器处理请求，进入后端处理流程。完成处理后，服务器响应一个HTTP报文给浏览器。</li>
<li>浏览器根据使用的协议版本，以及Connection字段的约定，决定是否要保留TCP连接。</li>
<li>浏览器根据响应状态码决定如何处理这一次响应</li>
<li>浏览器根据响应头中的Content-Type字段识别响应类型，如果是text/html，则对响应体的内容进行HTML解析，否则做其他处理</li>
<li>浏览器根据响应头的其他内容完成缓存、cookie的设置</li>
<li>浏览器开始从上到下解析HTML，若遇到外部资源链接，则进一步请求资源</li>
<li>解析过程中生成DOM树、CSSOM树，然后一边生成，一边把二者合并为渲染树（rendering tree），随后对渲染树中的每个节点计算位置和大小（reflow），最后把每个节点利用GPU绘制到屏幕（repaint）</li>
<li>在解析过程中还会触发一系列的事件，当DOM树完成后会触发DOMContentLoaded事件，当所有资源加载完毕后会触发load事件</li>
</ol>
</li>
</ol>
</blockquote>
</li>
<li><p>HTTPS 握手</p>
<blockquote>
<p>参考答案：</p>
<ol>
<li>客户端请求服务器，并告诉服务器自身支持的加密算法以及密钥长度等信息</li>
<li>服务器响应公钥和服务器证书</li>
<li>客户端验证证书是否合法，然后生成一个会话密钥，并用服务器的公钥加密密钥，把加密的结果通过请求发送给服务器</li>
<li>服务器使用私钥解密被加密的会话密钥并保存起来，然后使用会话密钥加密消息响应给客户端，表示自己已经准备就绪</li>
<li>客户端使用会话密钥解密消息，知道了服务器已经准备就绪。</li>
<li>后续客户端和服务器使用会话密钥加密信息传递消息</li>
</ol>
</blockquote>
</li>
<li><p>网页验证码是干嘛的，是为了解决什么安全问题？</p>
<blockquote>
<p>参考答案：</p>
<p>验证码主要用于让服务器区分请求是人还是机器发送的。这样做是为了避免某些程序恶意的提交大量信息到服务器，进而导致服务器产生大量的垃圾数据。有时，验证码也可以防止机器暴力破解用户密码，它通过在短时间内不断提交登录信息，尝试各种密码组合来达到破解的目的。</p>
</blockquote>
</li>
<li><p>http1.0、http2.0、http3.0 之间的区别</p>
<blockquote>
<p>参考答案：</p>
<p>http1.0</p>
<p>每次请求和响应完毕后都会销毁 TCP 连接，同时规定前一个响应完成后才能发送下一个请求。这样做有两个问题：</p>
<ol>
<li><p>无法复用连接</p>
<p>每次请求都要创建新的 TCP 连接，完成三次握手和四次挥手，网络利用率低</p>
</li>
<li><p>队头阻塞</p>
<p>如果前一个请求被某种原因阻塞了，会导致后续请求无法发送。</p>
</li>
</ol>
<p>http2.0</p>
<p>http2.0 优化了传输效率，它主要有以下改进：</p>
<ol>
<li><p>二进制分帧</p>
<p>将传输的消息分为更小的二进制帧，每帧有自己的标识序号，即便被随意打乱也能在另一端正确组装</p>
</li>
<li><p>多路复用</p>
<p>基于二进制分帧，在同一域名下所有访问都是从同一个 tcp 连接中走，并且不再有队头阻塞问题，也无须遵守响应顺序</p>
</li>
<li><p>头部压缩</p>
<p>http2.0 通过字典的形式，将头部中的常见信息替换为更少的字符，极大的减少了头部的数据量，从而实现更小的传输量</p>
</li>
<li><p>服务器推</p>
<p>http2.0 允许服务器直接推送消息给客户端，无须客户端明确的请求</p>
</li>
</ol>
<p>http3.0</p>
<p>http3.0 目前还在草案阶段，它完全抛弃了 TCP 协议，转而使用 UDP 协议，是为了进一步提升性能。</p>
<p>虽然 http2.0 进行了大量的优化，但它无法摆脱 TCP 协议本身的问题，比如建立连接时间长、对头阻塞问题等等。</p>
<p>为了保证传输的可靠性，http3.0 使用了 QUIC 协议。</p>
</blockquote>
</li>
<li><p>cookie/sessionStorage/localStorage 的区别</p>
<blockquote>
<p>参考答案：</p>
<p>cookie、sessionStorage、localStorage 都是保存本地数据的方式</p>
<p>其中，cookie 兼容性较好，所有浏览器均支持。浏览器针对 cookie 会有一些默认行为，比如当响应头中出现<code>set-cookie</code>字段时，浏览器会自动保存 cookie 的值；再比如，浏览器发送请求时，会附带匹配的 cookie 到请求头中。这些默认行为，使得 cookie 长期以来担任着维持登录状态的责任。与此同时，也正是因为浏览器的默认行为，给了恶意攻击者可乘之机，CSRF 攻击就是一个典型的利用 cookie 的攻击方式。虽然 cookie 不断的改进，但前端仍然需要另一种更加安全的保存数据的方式</p>
<p>HTML5 新增了 sessionStorage 和 localStorage，前者用于保存会话级别的数据，后者用于更持久的保存数据。浏览器针对它们没有任何默认行为，这样一来，就把保存数据、读取数据的工作交给了前端开发者，这就让恶意攻击者难以针对登录状态进行攻击。<br>cookie 的大小是有限制的，一般浏览器会限制同一个域下的 cookie 总量为 4M，而 sessionStorage 和 localStorage 则没有限制<br>cookie 会与 domain、path 关联，而 sessionStorage 和 localStorage 只与 domain 关联</p>
</blockquote>
</li>
<li><p>post 请求什么时候用 form data 什么时候用 request payload</p>
<blockquote>
<p>参考答案：</p>
<p>form data 适合传递简单的键值对信息，由于传递的信息比较扁平，难以传递深层次嵌套的数据</p>
<p>request payload 适合传递任意格式的数据，包括单个数字、布尔、深层次嵌套的对象、数组等，但 request payload 不适合传递文件数据</p>
<p>在前后端分离的项目中，对于非文件数据的传递，都推荐使用 request payload 的形式，以传递最明确的数据类型和数据结构，而对于文件上传，则推荐使用传统的 form data</p>
</blockquote>
</li>
<li><p>http 常见请求方法有哪些？</p>
<blockquote>
<p>参考答案：</p>
<ul>
<li>GET，表示向服务器获取资源</li>
<li>POST，表示向服务器提交信息，通常用于产生新的数据，比如注册</li>
<li>PUT，表示希望修改服务器的数据，通常用于修改</li>
<li>DELETE，表示希望删除服务器的数据</li>
<li>OPTIONS，发生在跨域的预检请求中，表示客户端向服务器申请跨域提交</li>
<li>TRACE，回显服务器收到的请求，主要用于测试和诊断</li>
<li>CONNECT，用于建立连接管道，通常在代理场景中使用，网页中很少用到</li>
</ul>
</blockquote>
</li>
<li><p>列举优化网络性能方法</p>
<blockquote>
<p>参考答案：</p>
<ul>
<li><p>优化打包体积</p>
<p>利用一些工具压缩、混淆最终打包代码，减少包体积</p>
</li>
<li><p>多目标打包</p>
<p>利用一些打包插件，针对不同的浏览器打包出不同的兼容性版本，这样一来，每个版本中的兼容性代码就会大大减少，从而减少包体积</p>
</li>
<li><p>压缩</p>
<p>现代浏览器普遍支持压缩格式，因此服务端的各种文件可以压缩后再响应给客户端，只要解压时间小于优化的传输时间，压缩就是可行的</p>
</li>
<li><p>CDN</p>
<p>利用 CDN 可以大幅缩减静态资源的访问时间，特别是对于公共库的访问，可以使用知名的 CDN 资源，这样可以实现跨越站点的缓存</p>
</li>
<li><p>缓存</p>
<p>对于除 HTML 外的所有静态资源均可以开启协商缓存，利用构建工具打包产生的文件 hash 值来置换缓存</p>
</li>
<li><p>http2</p>
<p>开启 http2 后，利用其多路复用、头部压缩等特点，充分利用带宽传递大量的文件数据</p>
</li>
<li><p>雪碧图</p>
<p>对于不使用 HTTP2 的场景，可以将多个图片合并为雪碧图，以达到减少文件的目的</p>
</li>
<li><p>defer、async</p>
<p>通过 defer 和 async 属性，可以让页面尽早加载 js 文件</p>
</li>
<li><p>prefetch、preload</p>
<p>通过 prefetch 属性，可以让页面在空闲时预先下载其他页面可能要用到的资源</p>
<p>通过 preload 属性，可以让页面预先下载本页面可能要用到的资源</p>
</li>
<li><p>多个静态资源域</p>
<p>对于不使用 HTTP2 的场景，将相对独立的静态资源分到多个域中保存，可以让浏览器同时开启多个 TCP 连接，并行下载</p>
</li>
</ul>
</blockquote>
</li>
<li><p>session 怎么消除</p>
<blockquote>
<p>参考答案：</p>
<ol>
<li><p>过期时间</p>
<p>当客户端长时间没有传递 sessionid 过来时，服务器可以在过期时间之后自动清除 session</p>
</li>
<li><p>客户端主动通知</p>
<p>可以使用 JS 监听客户端页面关闭或其他退出操作，然后通知服务器清除 session</p>
</li>
</ol>
</blockquote>
</li>
<li><p>什么是 DNS 域名解析？</p>
<blockquote>
<p>参考答案：</p>
<p>DNS 域名解析是指把域名解析成 IP 地址的过程。</p>
<p>在具体的实现上，域名解析是由多个层级的服务器共同完成的。在查询域名时，客户端会先检查自身的 DNS 映射表，若找不到解析记录，则使用用户配置的 DNS 服务器，若目标 DNS 服务器中找不到记录，则继续往上一个层级寻找，直到到达根域名服务器，根域名服务器会根据域名的类型，将解析任务分发到对应的子域名服务器依次查找，直到找到解析记录为止。</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>面试题</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>面试题</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>常用的git操作</title>
    <url>/135xyq.github.io/2021/04/15/%E5%B7%A5%E5%85%B7-git%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h1 id="git-常用命令。"><a href="#git-常用命令。" class="headerlink" title="git 常用命令。"></a>git 常用命令。</h1><h2 id="SSH-Key"><a href="#SSH-Key" class="headerlink" title="SSH Key"></a>SSH Key</h2><blockquote>
<p>创建SSH key</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t rsa -C <span class="string">&quot;youremail@example.com&quot;</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>测试SSH key配对成功</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -T git@gitee.com</span></span><br></pre></td></tr></table></figure>
<h2 id="配置用户信息"><a href="#配置用户信息" class="headerlink" title="配置用户信息"></a>配置用户信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.name <span class="string">&quot;Your Name&quot;</span></span>             </span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.email <span class="string">&quot;email@example.com&quot;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><blockquote>
<p>在当前目录新建一个Git代码库</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>新建一个目录，将其初始化为Git代码库</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git init [project-name]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>下载一个项目和它的整个代码历史</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> [url]</span></span><br></pre></td></tr></table></figure>
<h2 id="增加-删除文件"><a href="#增加-删除文件" class="headerlink" title="增加/删除文件"></a>增加/删除文件</h2><blockquote>
<p>添加指定文件到暂存区</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add [file1] [file2] ...</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>添加指定目录到暂存区，包括子目录</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add [dir]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>添加当前目录的所有文件到暂存区</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>添加每个变化前，都会要求确认<br>对于同一个文件的多处变化，可以实现分次提交</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add -p</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>删除工作区文件，并且将这次删除放入暂存区</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rm [file1] [file2] ...</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>停止追踪指定文件，但该文件会保留在工作区</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rm --cached [file]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>改名文件，并且将这个改名放入暂存区</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git mv [file-original] [file-renamed]</span></span><br></pre></td></tr></table></figure>
<h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h2><blockquote>
<p>提交暂存区到仓库区</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -m [message]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>提交工作区自上次commit之后的变化，直接到仓库区</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -a</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>提交时显示所有diff信息</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -v</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用一次新的commit，替代上一次提交<br>如果代码没有任何新变化，则用来改写上一次commit的提交信息</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend -m [message]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>重做上一次commit，并包括指定文件的新变化</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend [file1] [file2] ...</span></span><br></pre></td></tr></table></figure>
<h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><blockquote>
<p>显示有变更的文件</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>显示当前分支的版本历史</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>显示commit历史，以及每次commit发生变更的文件</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --<span class="built_in">stat</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>搜索提交历史，根据关键词</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -S [keyword]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>显示某个commit之后的所有变动，每个commit占据一行</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> [tag] HEAD --pretty=format:%s</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> [tag] HEAD --grep feature</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>显示某个文件的版本历史，包括文件改名</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --follow [file]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>显示指定文件相关的每一次diff</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -p [file]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>显示过去5次提交</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -5 --pretty --oneline</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>显示所有提交过的用户，按提交次数排序</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git shortlog -sn</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>显示指定文件是什么人在什么时间修改过</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git blame [file]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>显示暂存区和工作区的差异</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>显示暂存区和上一个commit的差异</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff --cached [file]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>显示工作区与当前分支最新commit之间的差异</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff HEAD</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>显示两次提交之间的差异</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff [first-branch]...[second-branch]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>显示今天你写了多少行代码</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff --shortstat <span class="string">&quot;@&#123;0 day ago&#125;&quot;</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>显示某次提交的元数据和内容变化</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git show [commit]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>显示某次提交发生变化的文件</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git show --name-only [commit]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>显示某次提交时，某个文件的内容</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git show [commit]:[filename]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>显示当前分支的最近几次提交</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reflog</span></span><br></pre></td></tr></table></figure>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><blockquote>
<p>列出所有本地分支</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>列出所有远程分支</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -r</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>列出所有本地分支和远程分支</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -a</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>新建一个分支，但依然停留在当前分支</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch [branch-name]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>新建一个分支，并切换到该分支</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b [branch]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>新建一个分支，指向指定commit</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch [branch] [commit]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>新建一个分支，与指定的远程分支建立追踪关系</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch --track [branch] [remote-branch]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>切换到指定分支，并更新工作区</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout [branch-name]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>切换到上一个分支</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>建立追踪关系，在现有分支与指定的远程分支之间</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch --set-upstream [branch] [remote-branch]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>合并指定分支到当前分支</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git merge [branch]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>选择一个commit，合并进当前分支</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git cherry-pick [commit]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>删除分支</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -d [branch-name]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>删除远程分支</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin --delete [branch-name]</span></span><br></pre></td></tr></table></figure>

<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><blockquote>
<p>列出所有tag</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>新建一个tag在当前commit</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag [tag]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>新建一个tag在指定commit</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag [tag] [commit]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>删除本地tag</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag -d [tag]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>删除远程tag</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin :refs/tags/[tagName]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看tag信息</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git show [tag]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>提交指定tag</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] [tag]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>提交所有tag</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] --tags</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>新建一个分支，指向某个tag</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b [branch] [tag]</span></span><br></pre></td></tr></table></figure>

<h2 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h2><blockquote>
<p>下载远程仓库的所有变动</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git fetch [remote]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>显示所有远程仓库</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>显示某个远程仓库的信息</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote show [remote]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>增加一个新的远程仓库，并命名</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote add [shortname] [url]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>取回远程仓库的变化，并与本地分支合并</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull [remote] [branch]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>允许不相关历史提交,并强制合并</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull origin master --allow-unrelated-histories</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>上传本地指定分支到远程仓库</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] [branch]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin 分支名</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>强行推送当前分支到远程仓库，即使有冲突</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] --force</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>推送所有分支到远程仓库</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] --all</span></span><br></pre></td></tr></table></figure>
<h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><blockquote>
<p>恢复暂存区的指定文件到工作区</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout [file]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>恢复某个commit的指定文件到暂存区和工作区</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout [commit] [file]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>恢复暂存区的所有文件到工作区</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout .</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset [file]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>重置暂存区与工作区，与上一次commit保持一致</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard</span> </span><br></pre></td></tr></table></figure>

<blockquote>
<p>重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset [commit]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard [commit]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>重置当前HEAD为指定commit，但保持暂存区和工作区不变</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --keep [commit]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>新建一个commit，用来撤销指定commit<br>后者的所有变化都将被前者抵消，并且应用到当前分支</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git revert [commit]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>暂时将未提交的变化移除，稍后再移入</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git stash</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash pop</span></span><br></pre></td></tr></table></figure>

<h2 id="忽略文件配置（-gitignore"><a href="#忽略文件配置（-gitignore" class="headerlink" title="忽略文件配置（.gitignore)"></a>忽略文件配置（.gitignore)</h2><p>1、配置语法:</p>
<ul>
<li><p>以斜杠“/”开头表示目录；</p>
</li>
<li><p>以星号“*”通配多个字符；</p>
</li>
<li><p>以问号“?”通配单个字符</p>
</li>
<li><p>以方括号“[]”包含单个字符的匹配列表；</p>
</li>
<li><p>以叹号“!”表示不忽略(跟踪)匹配到的文件或目录；</p>
</li>
</ul>
<p>此外，git 对于 .ignore 配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效；</p>
<p>2、示例：</p>
<ol>
<li><p>规则：<code>fd1/*</code><br>说明：忽略目录 fd1 下的全部内容；注意，不管是根目录下的 /fd1/ 目录，还是某个子目录 /child/fd1/ 目录，都会被忽略；</p>
</li>
<li><p>规则：<code>/fd1/*</code><br>说明：忽略根目录下的 /fd1/ 目录的全部内容；</p>
</li>
<li><p>规则：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">!.gitignore</span><br><span class="line">!/fw/bin/</span><br><span class="line">!/fw/sf/</span><br></pre></td></tr></table></figure></li>
</ol>
<p>说明：忽略全部内容，但是不忽略 .gitignore 文件、根目录下的 /fw/bin/ 和 /fw/sf/ 目录；</p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>git</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>CommonJS、ES6 Module</title>
    <url>/135xyq.github.io/2021/06/01/%E5%B7%A5%E7%A8%8B%E5%8C%96-CommonJS%E5%92%8CES6%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/</url>
    <content><![CDATA[<h1 id="CommonJS、ES6-Module"><a href="#CommonJS、ES6-Module" class="headerlink" title="CommonJS、ES6 Module"></a>CommonJS、ES6 Module</h1><hr>
<h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><blockquote>
<p>标准类型：社区规范</p>
<p>支持环境：node</p>
<p>依赖类型：动态依赖</p>
</blockquote>
<h3 id="如何导出"><a href="#如何导出" class="headerlink" title="如何导出"></a>如何导出</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = 导出的值</span><br></pre></td></tr></table></figure>

<h3 id="如何导入"><a href="#如何导入" class="headerlink" title="如何导入"></a>如何导入</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;模块路径&quot;</span>) <span class="comment">// 函数返回模块导出的值</span></span><br></pre></td></tr></table></figure>

<h2 id="ES-Module"><a href="#ES-Module" class="headerlink" title="ES Module"></a>ES Module</h2><blockquote>
<p>标准类型：官方标准</p>
<p>支持环境：node，浏览器</p>
<p>依赖类型：静态依赖，动态依赖</p>
</blockquote>
<h3 id="如何导出-1"><a href="#如何导出-1" class="headerlink" title="如何导出"></a>如何导出</h3><p><strong>ES Module</strong>的导出</p>
<p>ES Module分为两种导出方式：</p>
<ul>
<li>具名导出（普通导出），可以导出多个</li>
<li>默认导出，只能导出一个</li>
</ul>
<p>一个模块可以同时存在两种导出方式，最终会合并为一个「对象」导出</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="number">1</span>; <span class="comment">// 具名，常用</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// 具名，常用</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> c = <span class="function">() =&gt;</span> &#123;&#125;  <span class="comment">// 具名，常用</span></span><br><span class="line"><span class="keyword">const</span> d = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; d &#125; <span class="comment">// 具名</span></span><br><span class="line"><span class="keyword">const</span> k = <span class="number">10</span></span><br><span class="line"><span class="keyword">export</span> &#123; k <span class="keyword">as</span> temp &#125; <span class="comment">// 具名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// export default 3 // 默认，常用</span></span><br><span class="line"><span class="comment">// export default function() &#123;&#125; // 默认，常用</span></span><br><span class="line"><span class="comment">// const e = 4;</span></span><br><span class="line"><span class="comment">// export &#123; e as default &#125; // 默认</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f = <span class="number">4</span>, g = <span class="number">5</span>, h = <span class="number">6</span></span><br><span class="line"><span class="keyword">export</span> &#123; f, g, h <span class="keyword">as</span> <span class="keyword">default</span>&#125; <span class="comment">// 基本 + 默认</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上代码将导出下面的对象</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	a: 1,</span></span><br><span class="line"><span class="comment">	b: fn,</span></span><br><span class="line"><span class="comment">	c: fn,</span></span><br><span class="line"><span class="comment">	d: 2,</span></span><br><span class="line"><span class="comment">	temp: 10,</span></span><br><span class="line"><span class="comment">	f: 4,</span></span><br><span class="line"><span class="comment">	g: 5,</span></span><br><span class="line"><span class="comment">	default: 6</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：导出代码必须为顶级代码，即不可放到代码块中</strong></p>
<h3 id="如何导入-1"><a href="#如何导入-1" class="headerlink" title="如何导入"></a>如何导入</h3><p>针对具名导出和默认导出，有不同的导入语法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 仅运行一次该模块，不导入任何内容</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;模块路径&quot;</span></span><br><span class="line"><span class="comment">// 常用，导入属性 a、b，放到变量a、b中。a-&gt;a, b-&gt;b</span></span><br><span class="line"><span class="keyword">import</span> &#123; a, b &#125; <span class="keyword">from</span> <span class="string">&quot;模块路径&quot;</span>   </span><br><span class="line"><span class="comment">// 常用，导入属性 default，放入变量c中。default-&gt;c</span></span><br><span class="line"><span class="keyword">import</span> c <span class="keyword">from</span> <span class="string">&quot;模块路径&quot;</span>  </span><br><span class="line"><span class="comment">// 常用，default-&gt;c，a-&gt;a, b-&gt;b</span></span><br><span class="line"><span class="keyword">import</span> c, &#123; a, b &#125; <span class="keyword">from</span> <span class="string">&quot;模块路径&quot;</span> </span><br><span class="line"><span class="comment">// 常用，将模块对象放入到变量obj中</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> obj <span class="keyword">from</span> <span class="string">&quot;模块路径&quot;</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入属性a、b，放到变量temp1、temp2 中</span></span><br><span class="line"><span class="keyword">import</span> &#123;a <span class="keyword">as</span> temp1, b <span class="keyword">as</span> temp2&#125; <span class="keyword">from</span> <span class="string">&quot;模块路径&quot;</span> </span><br><span class="line"><span class="comment">// 导入属性default，放入变量a中，default是关键字，不能作为变量名，必须定义别名</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> a&#125; <span class="keyword">from</span> <span class="string">&quot;模块路径&quot;</span> </span><br><span class="line"><span class="comment">//导入属性default、b，放入变量a、b中</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> a, b&#125; <span class="keyword">from</span> <span class="string">&quot;模块路径&quot;</span> </span><br><span class="line"><span class="comment">// 以上均为静态导入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(<span class="string">&quot;模块路径&quot;</span>) <span class="comment">// 动态导入，返回一个Promise，完成时的数据为模块对象</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CommonJS</tag>
      </tags>
  </entry>
  <entry>
    <title>npm简介</title>
    <url>/135xyq.github.io/2021/06/20/%E5%B7%A5%E7%A8%8B%E5%8C%96-npm%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h1><h2 id="包的安装"><a href="#包的安装" class="headerlink" title="包的安装"></a>包的安装</h2><blockquote>
<p>安装（install）即下载包<br>由于 npm 的官方 registry 服务器位于国外，可能受网速影响导致下载缓慢或失败。因此，安装好 npm 之后，需要重新设置 registry 的地址为国内地址。目前，淘宝 <a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a> 提供了国内的 registry 地址，先设置到该地址。设置方式为<code>npm config set registry https://registry.npm.taobao.org</code>。设置好后，通过命令<code>npm config get registry</code>进行检查</p>
</blockquote>
<p>npm 安装一个包，分为两种安装方式：</p>
<ol>
<li>本地安装</li>
<li>全局安装</li>
</ol>
<h3 id="本地安装"><a href="#本地安装" class="headerlink" title="本地安装"></a>本地安装</h3><p>使用命令<code>npm install 包名</code>或<code>npm i 包名</code>即可完成本地安装</p>
<p>本地安装的包出现在当前目录下的<code>node_modules</code>目录中</p>
<blockquote>
<p>随着开发的进展，<code>node_modules</code>目录会变得异常庞大，目录下的内容不适合直接传输到生产环境，因此通常使用<code>.gitignore</code>文件忽略该目录中的内容<br>本地安装适用于绝大部分的包，它会在当前目录及其子目录中发挥作用<br>通常在项目的根目录中使用本地安装<br>安装一个包的时候，npm 会自动管理依赖，它会下载该包的依赖包到<code>node_modules</code>目录中<br>如果本地安装的包带有 CLI，npm 会将它的 CLI 脚本文件放置到<code>node_modules/.bin</code>下，使用命令<code>npx 命令名</code>即可调用</p>
</blockquote>
<h3 id="全局安装"><a href="#全局安装" class="headerlink" title="全局安装"></a>全局安装</h3><p>全局安装的包放置在一个特殊的全局目录，该目录可以通过命令<code>npm config get prefix</code>查看</p>
<p>使用命令<code>npm install --global 包名</code> 或 <code>npm i -g 包名</code></p>
<p>重要：<strong>全局安装的包并非所有工程可用，它仅提供全局的 CLI 工具</strong></p>
<p>大部分情况下，都不需要全局安装包，除非：</p>
<ol>
<li>包的版本非常稳定，很少有大的更新</li>
<li>提供的 CLI 工具在各个工程中使用的非常频繁</li>
<li>CLI 工具仅为开发环境提供支持，而非部署环境</li>
</ol>
<h2 id="包配置"><a href="#包配置" class="headerlink" title="包配置"></a>包配置</h2><p>目前遇到的问题：</p>
<ol>
<li>拷贝工程后如何还原？</li>
<li>如何区分开发依赖和生产依赖？</li>
<li>如果自身的项目也是一个包，如何描述包的信息</li>
</ol>
<p>以上这些问题都需要通过包的<strong>配置文件</strong>解决</p>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>npm 将每个使用 npm 的工程本身都看作是一个包，包的信息需要通过一个名称固定的配置文件来描述</p>
<p><strong>配置文件的名称固定为：package.json</strong></p>
<p>可以手动创建该文件，而更多的时候，是通过命令<code>npm init</code>创建的</p>
<p>配置文件中可以描述大量的信息，包括：</p>
<ul>
<li>name：包的名称，该名称必须是<strong>英文单词字符</strong>，支持连接符</li>
<li>version：版本<ul>
<li>版本规范：主版本号.次版本号.补丁版本号</li>
<li>主版本号：仅当程序发生了重大变化时才会增长，如新增了重要功能、新增了大量的API、技术架构发生了重大变化</li>
<li>次版本号：仅当程序发生了一些小变化时才会增长，如新增了一些小功能、新增了一些辅助型的API</li>
<li>补丁版本号：仅当解决了一些 bug 或 进行了一些局部优化时更新，如修复了某个函数的 bug、提升了某个函数的运行效率</li>
</ul>
</li>
<li>description：包的描述</li>
<li>homepage：官网地址</li>
<li>author：包的作者，必须是有效的 npm 账户名，书写规范是 <code>account &lt;mail&gt;</code>，例如：<code>zhangsan &lt;zhangsan@gmail.com&gt;</code>，不正确的账号和邮箱可能导致发布包时失败</li>
<li>repository：包的仓储地址，通常指 git 或 svn 的地址，它是一个对象<ul>
<li>type：仓储类型，git 或 svn</li>
<li>url：地址</li>
</ul>
</li>
<li>main：包的入口文件，使用包的人默认从该入口文件导入包的内容</li>
<li>keywords: 搜索关键字，发布包后，可以通过该数组中的关键字搜索到包</li>
</ul>
<p>使用<code>npm init --yes</code>或<code>npm init -y</code>可以在生成配置文件时自动填充默认配置</p>
<h3 id="保存依赖关系"><a href="#保存依赖关系" class="headerlink" title="保存依赖关系"></a>保存依赖关系</h3><p>大部分时候，我们仅仅是开发项目，并不会把它打包发布出去，尽管如此，我们仍然需要package.json文件</p>
<p><strong>package.json文件最重要的作用，是记录当前工程的依赖</strong></p>
<ul>
<li>dependencies：生产环境的依赖包</li>
<li>devDependencies：仅开发环境的依赖包</li>
</ul>
<p>配置好依赖后，使用下面的命令即可安装依赖</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">本地安装所有依赖 dependencies + devDependencies</span></span><br><span class="line">npm install</span><br><span class="line">npm i</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 仅安装生产环境的依赖 dependencies</span></span><br><span class="line">npm install --production</span><br></pre></td></tr></table></figure>

<p>这样一来，代码移植就不是问题了，只需要移植源代码和package.json文件，不用移植node_modules目录，然后在移植之后通过命令即可重新恢复安装</p>
<p>为了更加方便的添加依赖，npm支持在使用install命令时，加入一些额外的参数，用于将安装的依赖包保存到package.json文件中</p>
<p>涉及的命令如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装依赖到生产环境</span></span><br><span class="line">npm i 包名</span><br><span class="line">npm i --save 包名</span><br><span class="line">npm i -S 包名</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装依赖到开发环境</span></span><br><span class="line">npm i --save-dev 包名</span><br><span class="line">npm i -D 包名</span><br></pre></td></tr></table></figure>

<blockquote>
<p>自动保存的依赖版本，例如<code>^15.1.3</code>，这种书写方式叫做语义版本号（semver version），具体规则后续讲解</p>
</blockquote>
<h2 id="语义版本"><a href="#语义版本" class="headerlink" title="语义版本"></a>语义版本</h2><p>思考：如果你编写了一个包A，依赖另外一个包B，你在编写代码时，包B的版本是2.4.1，你是希望使用你包的人一定要安装包B，并且是2.4.1版本，还是希望他可以安装更高的版本，如果你希望它安装更高的版本，高的什么程度呢？</p>
<p>回顾：版本号规则</p>
<p>版本规范：主版本号.次版本号.补丁版本号</p>
<ul>
<li>主版本号：仅当程序发生了重大变化时才会增长，如新增了重要功能、新增了大量的API、技术架构发生了重大变化</li>
<li>次版本号：仅当程序发生了一些小变化时才会增长，如新增了一些小功能、新增了一些辅助型的API</li>
<li>补丁版本号：仅当解决了一些 bug 或 进行了一些局部优化时更新，如修复了某个函数的 bug、提升了某个函数的运行效率</li>
</ul>
<p>有的时候，我们希望：安装我的依赖包的时候，次版本号和补丁版本号是可以有提升的，但是主版本号不能变化</p>
<p>有的时候，我们又希望：安装我的依赖包的时候，只有补丁版本号可以提升，其他都不能提升</p>
<p>甚至我们希望依赖包保持固定的版本，尽管这比较少见</p>
<p>这样一来，就需要在配置文件中描述清楚具体的依赖规则，而不是直接写上版本号那么简单。</p>
<p>这种规则的描述，即<strong>语义版本</strong></p>
<p>语义版本的书写规则非常丰富，下面列出了一些常见的书写方式</p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">描述</th>
<th align="center">示例</th>
<th align="center">示例描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&gt;</td>
<td align="center">大于某个版本</td>
<td align="center">&gt;1.2.1</td>
<td align="center">大于1.2.1版本</td>
</tr>
<tr>
<td align="center">&gt;=</td>
<td align="center">大于等于某个版本</td>
<td align="center">&gt;=1.2.1</td>
<td align="center">大于等于1.2.1版本</td>
</tr>
<tr>
<td align="center">&lt;</td>
<td align="center">小于某个版本</td>
<td align="center">&lt;1.2.1</td>
<td align="center">小于1.2.1版本</td>
</tr>
<tr>
<td align="center">&lt;=</td>
<td align="center">小于等于某个版本</td>
<td align="center">&lt;=1.2.1</td>
<td align="center">小于等于1.2.1版本</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">介于两个版本之间</td>
<td align="center">1.2.1 - 1.4.5</td>
<td align="center">介于1.2.1和1.4.5之间</td>
</tr>
<tr>
<td align="center">x</td>
<td align="center">不固定的版本号</td>
<td align="center">1.3.x</td>
<td align="center">只要保证主版本号是1，次版本号是3即可</td>
</tr>
<tr>
<td align="center">~</td>
<td align="center">补丁版本号可增</td>
<td align="center">~1.3.4</td>
<td align="center">保证主版本号是1，次版本号是3，补丁版本号大于等于4</td>
</tr>
<tr>
<td align="center">^</td>
<td align="center">此版本和补丁版本可增</td>
<td align="center">^1.3.4</td>
<td align="center">保证主版本号是1，次版本号可以大于等于3，补丁版本号可以大于等于4</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">最新版本</td>
<td align="center">*</td>
<td align="center">始终安装最新版本</td>
</tr>
</tbody></table>
<h3 id="避免还原的差异"><a href="#避免还原的差异" class="headerlink" title="避免还原的差异"></a>避免还原的差异</h3><p>版本依赖控制始终是一个两难的问题</p>
<p>如果允许版本增加，可以让依赖包的bug得以修复（补丁版本号），可以带来一些意外的惊喜（次版本号），但同样可能带来不确定的风险（新的bug）</p>
<p>如果不允许版本增加，可以获得最好的稳定性，但失去了依赖包自我优化的能力</p>
<p>而有的时候情况更加复杂，如果依赖包升级后，依赖也发生了变化，会有更多不确定的情况出现</p>
<p>基于此，npm 在安装包的时候，会自动生成一个 package-lock.json 文件，该文件记录了安装包时的确切依赖关系</p>
<p>当移植工程时，如果移植了 package-lock.json 文件，恢复安装时，会按照 package-lock.json 文件中的确切依赖进行安装，最大限度的避免了差异</p>
<h2 id="npm的差异版本处理"><a href="#npm的差异版本处理" class="headerlink" title="npm的差异版本处理"></a>npm的差异版本处理</h2><p>如果两个包依赖同一个包的不同版本，如下图</p>
<p><img src="/images/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/npm-%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E7%9A%84%E5%A4%84%E7%90%86.jpg"></p>
<p>面对这种情况，在 node_modules 目录中，不会使用扁平的目录结构，而会形成嵌套的目录，如下图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── node_modules</span><br><span class="line">│   ├── a </span><br><span class="line">│   │   ├── node_modules</span><br><span class="line">│   │   │   ├── c</span><br><span class="line">│   │   │   |   |—— c包的文件</span><br><span class="line">│   │   │── a包的文件     </span><br><span class="line">│   ├── b </span><br><span class="line">│   │   ├── node_modules</span><br><span class="line">│   │   │   ├── c</span><br><span class="line">│   │   │   |   |—— c包的文件</span><br><span class="line">│   │   │── b包的文件           </span><br></pre></td></tr></table></figure>

<h2 id="npm-脚本-（npm-scripts）"><a href="#npm-脚本-（npm-scripts）" class="headerlink" title="npm 脚本 （npm scripts）"></a>npm 脚本 （npm scripts）</h2><p>在开发的过程中，我们可能会反复使用很多的 CLI 命令，例如：</p>
<ul>
<li>启动工程命令（node 或 一些第三方包提供的CLI命令）</li>
<li>部署工程命令（一些第三方包提供的CLI命令）</li>
<li>测试工程命令（一些第三方包提供的CLI命令）</li>
</ul>
<p>这些命令纷繁复杂，根据第三方包的不同命令也会不一样，非常难以记忆</p>
<p>于是，npm 非常贴心的支持了脚本，只需要在 package.json 中配置 scripts 字段，即可配置各种脚本名称</p>
<p>之后，我们就可以运行简单的指令来完成各种操作了</p>
<p>运行方式是 <code>npm run 脚本名称</code></p>
<p>不仅如此，npm 还对某些常用的脚本名称进行了简化，下面的脚本名称是不需要使用run的：</p>
<ul>
<li>start</li>
<li>stop</li>
<li>test</li>
</ul>
<p>一些细节：</p>
<ul>
<li>脚本中可以省略npx</li>
<li>start脚本有默认值：node server.js</li>
</ul>
<h2 id="运行环境配置"><a href="#运行环境配置" class="headerlink" title="运行环境配置"></a>运行环境配置</h2><p>我们书写的代码一般有三种运行环境：</p>
<ol>
<li>开发环境</li>
<li>生产环境</li>
<li>测试环境</li>
</ol>
<p>有的时候，我们可能需要在 node 代码中根据不同的环境做出不同的处理</p>
<p>如何优雅的让 node 知道处于什么环境，是极其重要的</p>
<p>通常我们使用如下的处理方式：</p>
<p>node中有一个全局变量 global (可以类比浏览器环境的window)，该变量是一个对象，对象中的所有属性均可以直接使用</p>
<p>global有一个属性是process，该属性是一个对象，包含了当前运行node程序的计算机的很多信息，其中有一个信息是env，是一个对象，包含了计算机中所有的系统变量</p>
<p>通常，我们通过系统变量 NODE_ENV 的值，来判定node程序处于何种环境</p>
<p>有两种方式设置 NODE_ENV 的值</p>
<ol>
<li>永久设置</li>
<li>临时设置</li>
</ol>
<p>我们一般使用临时设置</p>
<p>因此，我们可以配置 scripts 脚本，在设置好了 NODE_ENV 后启动程序</p>
<blockquote>
<p>为了避免不同系统的设置方式的差异，可以使用第三方库 cross-env 对环境变量进行设置</p>
</blockquote>
<h3 id="在node中读取package-json"><a href="#在node中读取package-json" class="headerlink" title="在node中读取package.json"></a>在node中读取package.json</h3><p>有的时候，我们可能在 package.json 中配置一些自定义的字段，这些字段需要在node中读取</p>
<p>在node 中，可以直接导入一个json格式的文件，它会自动将其转换为js对象</p>
<h2 id="其他npm命令"><a href="#其他npm命令" class="headerlink" title="其他npm命令"></a>其他npm命令</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol>
<li>精确安装最新版本</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save-exact 包名 </span><br><span class="line">npm install -E 包名</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>安装指定版本</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install 包名@版本号</span><br></pre></td></tr></table></figure>

<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ol>
<li>查询包安装路径</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm root [-g]</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查看包信息</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm view 包名 [子信息]</span><br><span class="line"><span class="meta">#</span><span class="bash"> view aliases：v info show</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>查询安装包</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm list [-g] [--depth=依赖深度]</span><br><span class="line"><span class="meta">#</span><span class="bash"> list aliases: ls  la  ll</span></span><br></pre></td></tr></table></figure>

<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><ol>
<li>检查有哪些包需要更新</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm outdated</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>更新包</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm update [-g] [包名]</span><br><span class="line"><span class="meta">#</span><span class="bash"> update 别名（aliases）：up、upgrade</span></span><br></pre></td></tr></table></figure>

<h3 id="卸载包"><a href="#卸载包" class="headerlink" title="卸载包"></a>卸载包</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm uninstall [-g] 包名</span><br><span class="line"><span class="meta">#</span><span class="bash"> uninstall aliases: remove, rm, r, un, unlink</span></span><br></pre></td></tr></table></figure>

<h3 id="npm-配置"><a href="#npm-配置" class="headerlink" title="npm 配置"></a>npm 配置</h3><p>npm的配置会对其他命令产生或多或少的影响</p>
<p>安装好npm之后，最终会产生两个配置文件，一个是用户配置，一个是系统配置，当两个文件的配置项有冲突的时候，用户配置会覆盖系统配置</p>
<p>通常，我们不关心具体的配置文件，而只关心最终生效的配置</p>
<p>通过下面的命令可以查询目前生效的各种配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config ls [-l] [--json]</span><br></pre></td></tr></table></figure>

<p>另外，可以通过下面的命令操作配置</p>
<ol>
<li>获取某个配置项</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config get 配置项</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>设置某个配置项</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config set 配置项=值</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>移除某个配置项</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config delete 配置项</span><br></pre></td></tr></table></figure>

<h2 id="发布包"><a href="#发布包" class="headerlink" title="发布包"></a>发布包</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol>
<li>移除淘宝镜像源</li>
<li>到npm官网注册一个账号，并完成邮箱认证</li>
<li>本地使用 npm cli 进行登录<ol>
<li>使用命令<code>npm login</code>登录</li>
<li>使用命令<code>npm whoami</code>查看当前登录的账号</li>
<li>使用命令<code>npm logout</code>注销</li>
</ol>
</li>
<li>创建工程根目录</li>
<li>使用npm init进行初始化</li>
</ol>
<h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><ol>
<li>开发</li>
<li>确定版本</li>
<li>使用命令<code>npm publish</code>完成发布</li>
</ol>
<h3 id="开源协议"><a href="#开源协议" class="headerlink" title="开源协议"></a>开源协议</h3><p><img src="/images/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/npm-%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE.jpg"></p>
<p>可以通过网站 <a href="http://choosealicense.online/appendix/">http://choosealicense.online/appendix/</a> 选择协议，并复制协议内容</p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>yarn简介</title>
    <url>/135xyq.github.io/2021/06/16/%E5%B7%A5%E7%A8%8B%E5%8C%96-yarn%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="yarn"><a href="#yarn" class="headerlink" title="yarn"></a>yarn</h1><hr>
<h2 id="yarn-简介"><a href="#yarn-简介" class="headerlink" title="yarn 简介"></a>yarn 简介</h2><p><strong><a href="https://www.yarnpkg.com/zh-Hans/">yarn 官网</a></strong></p>
<p>yarn 是由Facebook、Google、Exponent 和 Tilde 联合推出了一个新的 JS 包管理工具，<strong>它仍然使用 npm 的registry</strong>，不过提供了全新 CLI 来对包进行管理</p>
<p>过去，yarn 的出现极大的抢夺了 npm 的市场，甚至有人戏言，npm 只剩下一个 registry 了。</p>
<p>之所以会出现这种情况，是因为在过去，npm 存在下面的问题：</p>
<ul>
<li>依赖目录嵌套层次深：过去，npm 的依赖是嵌套的，这在 windows 系统上是一个极大的问题，由于众所周知的原因，windows 系统无法支持太深的目录</li>
<li>下载速度慢<ul>
<li>由于嵌套层次的问题，所以npm对包的下载只能是串行的，即前一个包下载完后才会下载下一个包，导致带宽资源没有完全利用</li>
<li>多个相同版本的包被重复的下载</li>
</ul>
</li>
<li>控制台输出繁杂：过去，npm 安装包的时候，每安装一个依赖，就会输出依赖的详细信息，导致一次安装有大量的信息输出到控制台，遇到错误极难查看</li>
<li>工程移植问题：由于 npm 的版本依赖可以是模糊的，可能会导致工程移植后，依赖的确切版本不一致。</li>
</ul>
<p>针对上述问题，yarn 从诞生那天就已经解决，它用到了以下的手段：</p>
<ul>
<li>使用扁平的目录结构</li>
<li>并行下载</li>
<li>使用本地缓存</li>
<li>控制台仅输出关键信息</li>
<li>使用yarn-lock文件记录确切依赖</li>
</ul>
<p>不仅如此，yarn还优化了以下内容：</p>
<ul>
<li>增加了某些功能强大的命令</li>
<li>让既有的命令更加语义化</li>
<li>本地安装的CLI工具可以使用 yarn 直接启动</li>
<li>将全局安装的目录当作一个普通的工程，生成package.json文件，便于全局安装移植</li>
</ul>
<p>yarn 的出现给 npm 带来了巨大的压力，很快，npm 学习了 yarn 先进的理念，不断的对自身进行优化，到了目前的npm6版本，几乎完全解决了上面的问题：</p>
<ul>
<li>目录扁平化</li>
<li>并行下载</li>
<li>本地缓存</li>
<li>使用package-lock记录确切依赖</li>
<li>增加了大量的命令别名</li>
<li>内置了npx，可以启动本地的CLI工具</li>
<li>极大的简化了控制台输出</li>
</ul>
<p><strong>总结</strong></p>
<p>npm6 之后，可以说npm已经和yarn非常接近，甚至没有差距了。很多新的项目，又重新从yarn转回到npm。</p>
<h2 id="yarn-的核心命令"><a href="#yarn-的核心命令" class="headerlink" title="yarn 的核心命令"></a>yarn 的核心命令</h2><ol>
<li><strong>初始化</strong></li>
</ol>
<p>初始化：<code>yarn init [--yes/-y]</code></p>
<ol start="2">
<li><strong>安装</strong></li>
</ol>
<p>添加指定包：<code>yarn [global] add package-name [--dev/-D] [--exact/-E]</code></p>
<p>安装package.json中的所有依赖：<code>yarn install [--production/--prod]</code></p>
<ol start="3">
<li><strong>脚本和本地CLI</strong></li>
</ol>
<p>运行脚本：<code>yarn run 脚本名</code> </p>
<blockquote>
<p>start、stop、test可以省略run</p>
</blockquote>
<p>运行本地安装的CLI：<code>yarn run CLI名</code></p>
<ol start="4">
<li><strong>查询</strong></li>
</ol>
<p>查看bin目录：<code>yarn [global] bin</code></p>
<p>查询包信息：<code>yarn info 包名 [子字段]</code></p>
<p>列举已安装的依赖：<code>yarn [global] list [--depth=依赖深度]</code></p>
<blockquote>
<p>yarn的list命令和npm的list不同，yarn输出的信息更加丰富，包括顶级目录结构、每个包的依赖版本号</p>
</blockquote>
<ol start="5">
<li><strong>更新</strong></li>
</ol>
<p>列举需要更新的包：<code>yarn outdated</code></p>
<p>更新包：<code>yarn [global] upgrade [包名]</code></p>
<ol start="6">
<li><strong>卸载</strong></li>
</ol>
<p>卸载包：<code>yarn remove 包名</code></p>
<h2 id="yarn-的特别礼物"><a href="#yarn-的特别礼物" class="headerlink" title="yarn 的特别礼物"></a>yarn 的特别礼物</h2><p>在终端命令上，yarn不仅仅是对npm的命令做了一个改名，还增加了一些原本没有的命令，这些命令在某些时候使用起来非常方便</p>
<ol>
<li><strong>yarn check</strong></li>
</ol>
<p>使用<code>yarn check</code>命令，可以验证package.json文件的依赖记录和lock文件是否一致</p>
<p>这对于防止篡改非常有用</p>
<ol start="2">
<li><strong>yarn audit</strong></li>
</ol>
<p>使用<code>yarn audit</code>命令，可以检查本地安装的包有哪些已知漏洞，以表格的形式列出，漏洞级别分为以下几种：</p>
<ul>
<li>INFO：信息级别</li>
<li>LOW: 低级别</li>
<li>MODERATE：中级别</li>
<li>HIGH：高级别</li>
<li>CRITICAL：关键级别</li>
</ul>
<ol start="3">
<li><strong>yarn why</strong></li>
</ol>
<p>使用<code>yarn why 包名</code>命令，可以在控制台打印出为什么安装了这个包，哪些包会用到它</p>
<ol start="4">
<li><strong>yarn create</strong></li>
</ol>
<p>非常有趣的命令</p>
<p>今后，我们会学习一些脚手架，所谓脚手架，就是使用一个命令来搭建一个工程结构</p>
<p>过去，我们都是使用如下的做法：</p>
<ol>
<li>全局安装脚手架工具</li>
<li>使用全局命令搭建脚手架</li>
</ol>
<p>由于大部分脚手架工具都是以<code>create-xxx</code>的方式命名的，比如react的官方脚手架名称为<code>create-react-app</code></p>
<p>因此，可以使用<code>yarn create</code>命令来一步完成安装和搭建</p>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn create react-app my-app</span><br><span class="line"><span class="meta">#</span><span class="bash"> 等同于下面的两条命令</span></span><br><span class="line">yarn global add create-react-app</span><br><span class="line">create-react-app my-app</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>yarn</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题JavaScript面试题汇总</title>
    <url>/135xyq.github.io/2022/04/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98-JavaScript-%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B8%80/</url>
    <content><![CDATA[<h1 id="JavaScript-面试题汇总"><a href="#JavaScript-面试题汇总" class="headerlink" title="JavaScript 面试题汇总"></a><em>JavaScript</em> 面试题汇总</h1><h3 id="1-根据下面-ES6-构造函数的书写方式，要求写出-ES5-的"><a href="#1-根据下面-ES6-构造函数的书写方式，要求写出-ES5-的" class="headerlink" title="1. 根据下面 ES6 构造函数的书写方式，要求写出 ES5 的"></a>1. 根据下面 <em>ES6</em> 构造函数的书写方式，要求写出 <em>ES5</em> 的</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123; </span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line">    <span class="keyword">const</span> fun = <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="built_in">this</span>.name) &#125;</span><br><span class="line">    fun(); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> e = <span class="keyword">new</span> Example(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line">e.init();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考答案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"><span class="meta">      &#x27;use strict&#x27;</span>;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">new</span>.target) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Class constructor cannot be invoked without new&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Example.prototype, <span class="string">&#x27;init&#x27;</span>, &#123;</span><br><span class="line">      <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">value</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">           &#x27;use strict&#x27;</span>;</span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">new</span>.target) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;init is not a constructor&#x27;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">var</span> fun = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">               <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">           &#125;</span><br><span class="line">           fun.call(<span class="built_in">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</blockquote>
<blockquote>
<p>解析：</p>
<p>此题的关键在于是否清楚 <em>ES6</em> 的 <em>class</em> 和普通构造函数的区别，记住它们有以下区别，就不会有遗漏：</p>
<ol>
<li><em>ES6</em> 中的 <em>class</em> 必须通过 <em>new</em> 来调用，不能当做普通函数调用，否则报错 因此，在答案中，加入了 <em>new.target</em> 来判断调用方式</li>
<li><em>ES6</em> 的 <em>class</em> 中的所有代码均处于严格模式之下</li>
</ol>
<p>   因此，在答案中，无论是构造函数本身，还是原型方法，都使用了严格模式</p>
<ol start="3">
<li><em>ES6</em> 中的原型方法是不可被枚举的 因此，在答案中，定义原型方法使用了属性描述符，让其不可枚举</li>
<li>原型上的方法不允许通过 <em>new</em> 来调用因此，在答案中，原型方法中加入了 <em>new.target</em> 来判断调用方式</li>
</ol>
</blockquote>
<h3 id="2-数组去重有哪些方法？（美团-19-年）"><a href="#2-数组去重有哪些方法？（美团-19-年）" class="headerlink" title="2. 数组去重有哪些方法？（美团 19 年）"></a>2. 数组去重有哪些方法？（美团 <em>19</em> 年）</h3><blockquote>
<p>参考答案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数字或字符串数组去重，效率高</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> result = &#123;&#125;; <span class="comment">// 利用对象属性名的唯一性来保证不重复</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (!result[arr[i]]) &#123;</span><br><span class="line">               result[arr[i]] = <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.keys(result); <span class="comment">// 获取对象所有属性名的数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任意数组去重，适配范围光，效率低</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> result = []; <span class="comment">// 结果数组</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (!result.includes(arr[i])) &#123;</span><br><span class="line">               result.push(arr[i]);</span><br><span class="line">           &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用ES6的Set去重，适配范围广，效率一般，书写简单</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> [...new <span class="built_in">Set</span>(arr)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="3-描述下列代码的执行结果"><a href="#3-描述下列代码的执行结果" class="headerlink" title="3. 描述下列代码的执行结果"></a>3. 描述下列代码的执行结果</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">foo(<span class="keyword">typeof</span> a);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(p);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> b);</span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考答案：</p>
<p>报错，报错的位置在 <code>console.log(typeof b);</code></p>
<p>报错原因：<em>ReferenceError: Cannot access ‘b’ before initialization</em></p>
</blockquote>
<blockquote>
<p>解析：</p>
<p>这道题考查的是 <em>ES6</em> 新增的声明变量关键字 <em>let</em> 以及暂时性死区的知识。<em>let</em> 和以前的 <em>var</em> 关键字不一样，无法在 <em>let</em> 声明变量之前访问到该变量，所以在 <em>typeof b</em> 的地方就会报错。</p>
</blockquote>
<h3 id="4-描述下列代码的执行结果"><a href="#4-描述下列代码的执行结果" class="headerlink" title="4. 描述下列代码的执行结果"></a>4. 描述下列代码的执行结果</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">arr</span>)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.arr = arr; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">bar</span>(<span class="params">n</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.arr.slice(<span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Foo([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(f.bar(<span class="number">1</span>));</span><br><span class="line"><span class="built_in">console</span>.log(f.bar(<span class="number">2</span>).splice(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line"><span class="built_in">console</span>.log(f.arr);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考答案：</p>
<p>[ 0 ]<br>[ 1 ]<br>[ 0, 1, 2, 3 ]</p>
</blockquote>
<blockquote>
<p>解析：</p>
<p>主要考察的是数组相关的知识。 <em>f</em> 对象上面有一个属性 <em>arr</em>，<em>arr</em> 的值在初始化的时候会被初始化为 *[0, 1, 2, 3]*，之后就完全是考察数组以及数组方法的使用了。</p>
</blockquote>
<h3 id="5-描述下列代码的执行结果"><a href="#5-描述下列代码的执行结果" class="headerlink" title="5. 描述下列代码的执行结果"></a>5. 描述下列代码的执行结果</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">01</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">count</span>) </span>&#123;</span><br><span class="line"><span class="number">02</span>    <span class="built_in">console</span>.log(<span class="string">`foo<span class="subst">$&#123;count&#125;</span>`</span>);</span><br><span class="line"><span class="number">03</span>    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">`bar<span class="subst">$&#123;count&#125;</span>`</span>); &#125;);</span><br><span class="line"><span class="number">04</span> &#125;</span><br><span class="line"><span class="number">05</span> f(<span class="number">1</span>);</span><br><span class="line"><span class="number">06</span> f(<span class="number">2</span>);</span><br><span class="line"><span class="number">07</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; f(<span class="number">3</span>); &#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考答案：</p>
<p>foo1<br>foo2<br>bar1<br>bar2<br>foo3<br>bar3</p>
</blockquote>
<blockquote>
<p>解析：</p>
<p>这个完全是考察的异步的知识。调用 <em>f(1)</em> 的时候，会执行同步代码，打印出 <em>foo1</em>，然后 <em>03</em> 行的 <em>setTimeout</em> 被放入到异步执行队列，接下来调用 <em>f(2)</em> 的时候，打印出 <em>foo2</em>，后面 <em>03</em> 行的 <em>setTimeout</em> 又被放入到异步执行队列。然后执行 <em>07</em> 行的语句，被放入到异步执行队列。至此，所有同步代码就都执行完毕了。</p>
<p>接下来开始执行异步代码，那么大家时间没写，就都是相同的，所以谁先被放入到异步队列，谁就先执行，所以先打印出 <em>bar1</em>、然后是 <em>bar2</em>，接下来执行之前 <em>07</em> 行放入到异步队列里面的 <em>setTimeout</em>，先执行 <em>f</em> 函数里面的同步代码，打印出 <em>foo3</em>，然后是最后一个异步，打印出 <em>bar3</em></p>
</blockquote>
<h3 id="6-描述下列代码的执行结果"><a href="#6-描述下列代码的执行结果" class="headerlink" title="6. 描述下列代码的执行结果"></a>6. 描述下列代码的执行结果</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a === <span class="number">2</span> || <span class="number">1</span> &amp;&amp; b === <span class="number">3</span> || <span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考答案：</p>
<p><em>true</em></p>
<p>考察的是逻辑运算符。在 || 里面，只要有一个为真，后面的直接短路，都不用去计算。所以 <em>a === 2</em> 得到 <em>true</em> 之后直接短路了，返回 <em>true</em>。</p>
</blockquote>
<h3 id="7-描述下列代码的执行结果"><a href="#7-描述下列代码的执行结果" class="headerlink" title="7. 描述下列代码的执行结果"></a>7. 描述下列代码的执行结果</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ButtonWrapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">domBtnEl, hash</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.domBtnEl = domBtnEl;</span><br><span class="line">        <span class="built_in">this</span>.hash = hash;</span><br><span class="line">        <span class="built_in">this</span>.bindEvent();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">bindEvent</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.domBtnEl.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="built_in">this</span>.clickEvent, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">detachEvent</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.domBtnEl.removeEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="built_in">this</span>.clickEvent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">clickEvent</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`The hash of the button is: <span class="subst">$&#123;<span class="built_in">this</span>.hash&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考答案：</p>
<p>上面的代码导出了一个 <em>ButtonWrapper</em> 类，该类在被实例化的时候，实例化对象上面有两个属性，分别是 <em>domBtnEl</em> 和 <em>hash</em>，<em>domBtnEl</em> 是一个 <em>DOM</em> 节点，之后为这个 <em>domBtnEl</em> 绑定了点击事件，点击后打印出 <em>The hash of the button is: hash</em> 那句话。<em>detachEvent</em> 是移除点击事件，当调用实例化对象的 <em>detachEvent</em> 方法时，点击事件就会被移除。</p>
</blockquote>
<h3 id="8-箭头函数有哪些特点"><a href="#8-箭头函数有哪些特点" class="headerlink" title="8. 箭头函数有哪些特点"></a>8. 箭头函数有哪些特点</h3><blockquote>
<p>参考答案：</p>
<ol>
<li>更简洁的语法，例如<ul>
<li>只有一个形参就不需要用括号括起来</li>
<li>如果函数体只有一行，就不需要放到一个块中</li>
<li>如果 <em>return</em> 语句是函数体内唯一的语句，就不需要 <em>return</em> 关键字</li>
</ul>
</li>
<li>箭头函数没有自己的 <em>this</em>，<em>arguments</em>，<em>super</em></li>
<li>箭头函数 <em>this</em> 只会从自己的作用域链的上一层继承 <em>this</em>。</li>
</ol>
</blockquote>
<h3 id="9-说一说类的继承"><a href="#9-说一说类的继承" class="headerlink" title="9. 说一说类的继承"></a>9. 说一说类的继承</h3><blockquote>
<p>参考答案：</p>
<p>继承是面向对象编程中的三大特性之一。</p>
<p><em>JavaScript</em> 中的继承经过不断的发展，从最初的对象冒充慢慢发展到了今天的圣杯模式继承。</p>
<p>其中最需要掌握的就是<strong>伪经典继承</strong>和<strong>圣杯模式</strong>的继承。</p>
<p>很长一段时间，JS 继承使用的都是<strong>组合继承</strong>。这种继承也被称之为伪经典继承，该继承方式综合了原型链和盗用构造函数的方式，将两者的优点集中了起来。</p>
<p>组合继承弥补了之前原型链和盗用构造函数这两种方式各自的不足，是 <em>JavaScript</em> 中使用最多的继承方式。</p>
<p>组合继承最大的问题就是效率问题。最主要就是父类的构造函数始终会被调用两次：一次是在创建子类原型时调用，另一次是在子类构造函数中调用。</p>
<p>本质上，子类原型最终是要包含超类对象的所有实例属性，子类构造函数只要在执行时重写自己的原型就行了。</p>
<p>圣杯模式的继承解决了这一问题，其基本思路就是不通过调用父类构造函数来给子类原型赋值，而是取得父类原型的一个副本，然后将返回的新对象赋值给子类原型。</p>
</blockquote>
<blockquote>
<p>解析：该题主要考察就是对 <em>js</em> 中的继承是否了解，以及常见的继承的形式有哪些。最常用的继承就是<strong>组合继承</strong>（伪经典继承）和圣杯模式继承。下面附上 <em>js</em> 中这两种继承模式的详细解析。</p>
<p>下面是一个组合继承的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.test = <span class="string">&quot;this is a test&quot;</span>;</span><br><span class="line">Person.prototype.testFunc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;this is a testFunc&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">var</span> Student = <span class="function"><span class="keyword">function</span> (<span class="params">name, age, gender, score</span>) </span>&#123;</span><br><span class="line">    Person.apply(<span class="built_in">this</span>, [name, age]); <span class="comment">// 盗用构造函数</span></span><br><span class="line">    <span class="built_in">this</span>.gender = gender;</span><br><span class="line">    <span class="built_in">this</span>.score = score;</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype = <span class="keyword">new</span> Person(); <span class="comment">// 改变 Student 构造函数的原型对象</span></span><br><span class="line">Student.prototype.testStuFunc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;this is a testStuFunc&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">var</span> zhangsan = <span class="keyword">new</span> Student(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">console</span>.log(zhangsan.name); <span class="comment">// 张三</span></span><br><span class="line"><span class="built_in">console</span>.log(zhangsan.age); <span class="comment">// 18</span></span><br><span class="line"><span class="built_in">console</span>.log(zhangsan.gender); <span class="comment">// 男</span></span><br><span class="line"><span class="built_in">console</span>.log(zhangsan.score); <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">console</span>.log(zhangsan.test); <span class="comment">// this is a test</span></span><br><span class="line">zhangsan.testFunc(); <span class="comment">// this is a testFunc</span></span><br><span class="line">zhangsan.testStuFunc(); <span class="comment">// this is a testStuFunc</span></span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们使用了组合继承的方式来实现继承，可以看到无论是基类上面的属性和方法，还是子类自己的属性和方法，都得到了很好的实现。</p>
<p>但是在组合继承中存在效率问题，比如在上面的代码中，我们其实调用了两次 <em>Person</em>，产生了两组 <em>name</em> 和 <em>age</em> 属性，一组在原型上，一组在实例上。</p>
<p>也就是说，我们在执行 <em>Student.prototype = new Person( )</em> 的时候，我们是想要 <em>Person</em> 原型上面的方法，属性是不需要的，因为属性之后可以通过 <em>Person.apply(this, [name, age])</em> 拿到，但是当你 <em>new Person( )</em> 的时候，会实例化一个 <em>Person</em> 对象出来，这个对象上面，属性和方法都有。</p>
<p>圣杯模式的继承解决了这一问题，其基本思路就是不通过调用父类构造函数来给子类原型赋值，而是取得父类原型的一个副本，然后将返回的新对象赋值给子类原型。</p>
<p>下面是一个圣杯模式的示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// target 是子类，origin 是基类</span></span><br><span class="line"><span class="comment">// target ---&gt; Student, origin ---&gt; Person</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">target, origin</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123; &#125;; <span class="comment">// 没有任何多余的属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// origin.prototype === Person.prototype, origin.prototype.constructor === Person 构造函数</span></span><br><span class="line">    F.prototype = origin.prototype;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设 new F() 出来的对象叫小 f</span></span><br><span class="line">    <span class="comment">// 那么这个 f 的原型对象 === F.prototype === Person.prototype</span></span><br><span class="line">    <span class="comment">// 那么 f.constructor === Person.prototype.constructor === Person 的构造函数</span></span><br><span class="line">    target.prototype = <span class="keyword">new</span> F();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 而 f 这个对象又是 target 对象的原型对象</span></span><br><span class="line">    <span class="comment">// 这意味着 target.prototype.constructor === f.constructor</span></span><br><span class="line">    <span class="comment">// 所以 target 的 constructor 会指向 Person 构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们要让子类的 constructor 重新指向自己</span></span><br><span class="line">    <span class="comment">// 若不修改则会发现 constructor 指向的是父类的构造函数</span></span><br><span class="line">    target.prototype.constructor = target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.test = <span class="string">&quot;this is a test&quot;</span>;</span><br><span class="line">Person.prototype.testFunc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;this is a testFunc&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">var</span> Student = <span class="function"><span class="keyword">function</span> (<span class="params">name, age, gender, score</span>) </span>&#123;</span><br><span class="line">    Person.apply(<span class="built_in">this</span>, [name, age]);</span><br><span class="line">    <span class="built_in">this</span>.gender = gender;</span><br><span class="line">    <span class="built_in">this</span>.score = score;</span><br><span class="line">&#125;</span><br><span class="line">inherit(Student, Person); <span class="comment">// 使用圣杯模式实现继承</span></span><br><span class="line"><span class="comment">// 在子类上面添加方法</span></span><br><span class="line">Student.prototype.testStuFunc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;this is a testStuFunc&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">var</span> zhangsan = <span class="keyword">new</span> Student(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(zhangsan.name); <span class="comment">// 张三</span></span><br><span class="line"><span class="built_in">console</span>.log(zhangsan.age); <span class="comment">// 18</span></span><br><span class="line"><span class="built_in">console</span>.log(zhangsan.gender); <span class="comment">// 男</span></span><br><span class="line"><span class="built_in">console</span>.log(zhangsan.score); <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">console</span>.log(zhangsan.test); <span class="comment">// this is a test</span></span><br><span class="line">zhangsan.testFunc(); <span class="comment">// this is a testFunc</span></span><br><span class="line">zhangsan.testStuFunc(); <span class="comment">// this is a testStuFunc</span></span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们在 <em>inherit</em> 方法中创建了一个中间层，之后让 <em>F</em> 的原型和父类的原型指向同一地址，再让子类的原型指向这个 <em>F</em> 的实例化对象来实现了继承。</p>
<p>这样我们的继承，属性就不会像之前那样实例对象上一份，原型对象上一份，拥有两份。圣杯模式继承是目前 <em>js</em> 继承的最优解。</p>
<p>最后我再画个图帮助大家理解，如下图：</p>
<p>组合模式（伪经典模式）下的继承示意图：</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-08-08-022111.png" alt="image-20210808102111003" style="zoom:50%;" />

<p>圣杯模式下的继承示意图：</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-08-08-021304.png" alt="image-20210808101303180" style="zoom:50%;" />


</blockquote>
<h3 id="10-new-操作符都做了哪些事？"><a href="#10-new-操作符都做了哪些事？" class="headerlink" title="10. new 操作符都做了哪些事？"></a>10. <em>new</em> 操作符都做了哪些事？</h3><blockquote>
<p>参考答案：</p>
<p><em>new</em> 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。</p>
<p><em>new</em> 关键字会进行如下的操作：<br>步骤 <em>1</em>：创建一个空的简单 <em>JavaScript</em> 对象，即 { } ;<br>步骤 <em>2</em>：链接该对象到另一个对象（即设置该对象的原型对象）；<br>步骤 <em>3</em>：将步骤 <em>1</em> 新创建的对象作为 <em>this</em> 的上下文；<br>步骤 <em>4</em>：如果该函数没有返回对象，则返回 <em>this</em>。</p>
</blockquote>
<h3 id="11-call、apply、bind-的区别-？"><a href="#11-call、apply、bind-的区别-？" class="headerlink" title="11. call、apply、bind 的区别 ？"></a>11. <em>call、apply、bind</em> 的区别 ？</h3><blockquote>
<p>参考答案：</p>
<p><em>call</em> 和 <em>apply</em> 的功能相同，区别在于传参的方式不一样:</p>
<ul>
<li><em>fn.call(obj, arg1, arg2, …)</em> 调用一个函数, 具有一个指定的 <em>this</em> 值和分别地提供的参数(参数的列表)。</li>
<li><em>fn.apply(obj, [argsArray])</em> 调用一个函数，具有一个指定的 <em>this</em> 值，以及作为一个数组（或类数组对象）提供的参数。</li>
</ul>
<p><em>bind</em> 和 <em>call/apply</em> 有一个很重要的区别，一个函数被 <em>call/apply</em> 的时候，会直接调用，但是 <em>bind</em> 会创建一个新函数。当这个新函数被调用时，<em>bind( )</em> 的第一个参数将作为它运行时的 <em>this</em>，之后的一序列参数将会在传递的实参前传入作为它的参数。</p>
</blockquote>
<h3 id="12-事件循环机制（宏任务、微任务）"><a href="#12-事件循环机制（宏任务、微任务）" class="headerlink" title="12. 事件循环机制（宏任务、微任务）"></a>12. 事件循环机制（宏任务、微任务）</h3><blockquote>
<p>参考答案：</p>
<p>在 <em>js</em> 中任务会分为同步任务和异步任务。</p>
<p>如果是同步任务，则会在主线程（也就是 <em>js</em> 引擎线程）上进行执行，形成一个执行栈。但是一旦遇到异步任务，则会将这些异步任务交给异步模块去处理，然后主线程继续执行后面的同步代码。</p>
<p>当异步任务有了运行结果以后，就会在任务队列里面放置一个事件，这个任务队列由事件触发线程来进行管理。</p>
<p>一旦执行栈中所有的同步任务执行完毕，就代表着当前的主线程（<em>js</em> 引擎线程）空闲了，系统就会读取任务队列，将可以运行的异步任务添加到执行栈中，开始执行。</p>
<p>在 <em>js</em> 中，任务队列中的任务又可以被分为 <em>2</em> 种类型：宏任务（<em>macrotask</em>）与微任务（<em>microtask</em>）</p>
<p>宏任务可以理解为每次执行栈所执行的代码就是一个宏任务，包括每次从事件队列中获取一个事件回调并放到执行栈中所执行的任务。</p>
<p>微任务可以理解为当前宏任务执行结束后立即执行的任务。</p>
</blockquote>
<h3 id="13-你了解-node-中的事件循环机制吗？node11-版本以后有什么改变"><a href="#13-你了解-node-中的事件循环机制吗？node11-版本以后有什么改变" class="headerlink" title="13. 你了解 node 中的事件循环机制吗？node11 版本以后有什么改变"></a>13. 你了解 <em>node</em> 中的事件循环机制吗？<em>node11</em> 版本以后有什么改变</h3><blockquote>
<p>参考答案：</p>
<p><em>Node.js</em> 在主线程里维护了一个<strong>事件队列，</strong>当接到请求后，就将该请求作为一个事件放入这个队列中，然后继续接收其他请求。当主线程空闲时（没有请求接入时），就开始循环事件队列，检查队列中是否有要处理的事件，这时要分两种情况：如果是非 <em>I/O</em> 任务，就亲自处理，并通过回调函数返回到上层调用；如果是 <em>I/O</em> 任务，就从<strong>线程池</strong>中拿出一个线程来处理这个事件，并指定回调函数，然后继续循环队列中的其他事件。</p>
<p>当线程中的 <em>I/O</em> 任务完成以后，就执行指定的回调函数，并把这个完成的事件放到事件队列的尾部，等待事件循环，当主线程再次循环到该事件时，就直接处理并返回给上层调用。 这个过程就叫 <strong>事件循环</strong> (<em>Event Loop</em>)。</p>
<p>无论是 <em>Linux</em> 平台还是 <em>Windows</em> 平台，<em>Node.js</em> 内部都是通过<strong>线程池</strong>来完成异步 <em>I/O</em> 操作的，而 <em>LIBUV</em> 针对不同平台的差异性实现了统一调用。因此，<strong><em>Node.js</em> 的单线程仅仅是指 <em>JavaScript</em> 运行在单线程中，而并非 <em>Node.js</em> 是单线程。</strong></p>
<p><em>Node.JS</em> 的事件循环分为 <em>6</em> 个阶段：</p>
<ul>
<li><em>timers</em> 阶段：这个阶段执行 <em>timer</em>（ <em>setTimeout、setInterval</em> ）的回调</li>
<li><em>I/O callbacks</em> 阶段：处理一些上一轮循环中的少数未执行的 <em>I/O</em> 回调</li>
<li><em>idle、prepare</em> 阶段：仅 <em>Node.js</em> 内部使用</li>
<li><em>poll</em> 阶段：获取新的 <em>I/O</em> 事件, 适当的条件下 <em>Node.js</em> 将阻塞在这里</li>
<li><em>check</em> 阶段：执行 <em>setImmediate( )</em> 的回调</li>
<li><em>close callbacks</em> 阶段：执行 <em>socket</em> 的 <em>close</em> 事件回调</li>
</ul>
<p>事件循环的执行顺序为：</p>
<p>外部输入数据 –-&gt; 轮询阶段（ <em>poll</em> ）-–&gt; 检查阶段（ <em>check</em> ）-–&gt; 关闭事件回调阶段（ <em>close callback</em> ）–-&gt; 定时器检测阶段（ <em>timer</em> ）–-&gt; <em>I/O</em> 事件回调阶段（ <em>I/O callbacks</em> ）-–&gt;闲置阶段（ <em>idle、prepare</em> ）–-&gt;轮询阶段（按照该顺序反复运行）…</p>
<p>浏览器和 <em>Node.js</em> 环境下，微任务任务队列的执行时机不同</p>
<ul>
<li><em>Node.js</em> 端，微任务在事件循环的各个阶段之间执行</li>
<li>浏览器端，微任务在事件循环的宏任务执行完之后执行</li>
</ul>
<p><em>Node.js v11.0.0</em> 版本于 <em>2018</em> 年 <em>10</em> 月，主要有以下变化：</p>
<ol>
<li><em>V8</em> 引擎更新至版本 <em>7.0</em></li>
<li><em>http、https</em> 和 <em>tls</em> 模块默认使用 <em>WHESWG URL</em> 解析器。</li>
<li>隐藏子进程的控制台窗口默认改为了 <em>true</em>。</li>
<li><em>FreeBSD 10</em>不再支持。</li>
<li>增加了多线程 <em>Worker Threads</em></li>
</ol>
</blockquote>
<h3 id="14-什么是函数柯里化？"><a href="#14-什么是函数柯里化？" class="headerlink" title="14. 什么是函数柯里化？"></a>14. 什么是函数柯里化？</h3><blockquote>
<p>参考答案：</p>
<p>柯里化（<em>currying</em>）又称部分求值。一个柯里化的函数首先会接受一些参数，接受了这些参数之后，该函数并不会立即求值，而是继续返回另外一个函数，刚才传入的参数在函数形成的闭包中被保存起来。待到函数被真正需要求值的时候，之前传入的所有参数都会被一次性用于求值。</p>
<p>举个例子，就是把原本：</p>
<p><em>function(arg1,arg2)</em> 变成 <em>function(arg1)(arg2)</em><br><em>function(arg1,arg2,arg3)</em> 变成 <em>function(arg1)(arg2)(arg3)</em><br><em>function(arg1,arg2,arg3,arg4)</em> 变成 <em>function(arg1)(arg2)(arg3)(arg4)</em></p>
<p>总而言之，就是将：</p>
<p><em>function(arg1,arg2,…,argn)</em> 变成 <em>function(arg1)(arg2)…(argn)</em></p>
</blockquote>
<h3 id="15-promise-all-方法的使用场景？数组中必须每一项都是-promise-对象吗？不是-promise-对象会如何处理-？"><a href="#15-promise-all-方法的使用场景？数组中必须每一项都是-promise-对象吗？不是-promise-对象会如何处理-？" class="headerlink" title="15. promise.all 方法的使用场景？数组中必须每一项都是 promise 对象吗？不是 promise 对象会如何处理 ？"></a>15. <em>promise.all</em> 方法的使用场景？数组中必须每一项都是 <em>promise</em> 对象吗？不是 <em>promise</em> 对象会如何处理 ？</h3><blockquote>
<p>参考答案：</p>
<p><em><strong>promise.all(promiseArray)</strong></em> 方法是 <em>promise</em> 对象上的静态方法，该方法的作用是将多个 <em>promise</em> 对象实例包装，生成并返回一个新的 <em>promise</em> 实例。</p>
<p>此方法在集合多个 <em>promise</em> 的返回结果时很有用。</p>
<p>返回值将会按照参数内的 <em>promise</em> 顺序排列，而不是由调用 <em>promise</em> 的完成顺序决定。</p>
<p><strong><em>promise.all</em> 的特点</strong></p>
<p>接收一个<em>Promise</em>实例的数组或具有<em>Iterator</em>接口的对象</p>
<p>如果元素不是<em>Promise</em>对象，则使用<em>Promise.resolve</em>转成<em>Promise</em>对象</p>
<p>如果全部成功，状态变为<em>resolved</em>，返回值将组成一个数组传给回调</p>
<p>只有有一个失败，状态就变为 <em>rejected</em>，返回值将直接传递给回调  *all( )*的返回值，也是新的 <em>promise</em> 对象</p>
</blockquote>
<h3 id="16-this-的指向哪几种-？"><a href="#16-this-的指向哪几种-？" class="headerlink" title="16. this 的指向哪几种 ？"></a>16. <em>this</em> 的指向哪几种 ？</h3><blockquote>
<p>参考答案：</p>
<p>总结起来，<em>this</em> 的指向规律有如下几条：</p>
<ul>
<li>在函数体中，非显式或隐式地简单调用函数时，在严格模式下，函数内的 <em>this</em> 会被绑定到 <em>undefined</em> 上，在非严格模式下则会被绑定到全局对象 <em>window/global</em> 上。</li>
<li>一般使用 <em>new</em> 方法调用构造函数时，构造函数内的 <em>this</em> 会被绑定到新创建的对象上。</li>
<li>一般通过 <em>call/apply/bind</em> 方法显式调用函数时，函数体内的 <em>this</em> 会被绑定到指定参数的对象上。</li>
<li>一般通过上下文对象调用函数时，函数体内的 <em>this</em> 会被绑定到该对象上。</li>
<li>在箭头函数中，<em>this</em> 的指向是由外层（函数或全局）作用域来决定的。</li>
</ul>
</blockquote>
<h3 id="17-JS-中继承实现的几种方式"><a href="#17-JS-中继承实现的几种方式" class="headerlink" title="17. JS 中继承实现的几种方式"></a>17. <em>JS</em> 中继承实现的几种方式</h3><blockquote>
<p>参考答案：</p>
<p><em>JS</em> 的继承随着语言的发展，从最早的对象冒充到现在的圣杯模式，涌现出了很多不同的继承方式。每一种新的继承方式都是对前一种继承方式不足的一种补充。</p>
<ol>
<li>原型链继承</li>
</ol>
<ul>
<li>重点：让新实例的原型等于父类的实例。</li>
<li>特点：实例可继承的属性有：实例的构造函数的属性，父类构造函数属性，父类原型的属性。（新实例不会继承父类实例的属性！）</li>
<li>缺点：<ul>
<li>1、新实例无法向父类构造函数传参。</li>
<li>2、继承单一。</li>
<li>3、所有新实例都会共享父类实例的属性。（原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原型属性也会被修改！）</li>
</ul>
</li>
</ul>
<ol start="2">
<li>借用构造函数继承</li>
</ol>
<ul>
<li>重点：用 <em>call( )</em> 和 <em>apply( )</em> 将父类构造函数引入子类函数（在子类函数中做了父类函数的自执行（复制））</li>
<li>特点：<br>　　　- 1、只继承了父类构造函数的属性，没有继承父类原型的属性。<ul>
<li>2、解决了原型链继承缺点1、2、3。</li>
<li>3、可以继承多个构造函数属性（call多个）。</li>
<li>4、在子实例中可向父实例传参。</li>
</ul>
</li>
<li>缺点：<br>　　　- 1、只能继承父类构造函数的属性。<ul>
<li>2、无法实现构造函数的复用。（每次用每次都要重新调用）</li>
<li>3、每个新实例都有父类构造函数的副本，臃肿。</li>
</ul>
</li>
</ul>
<ol start="3">
<li>组合模式（又被称之为伪经典模式）</li>
</ol>
<ul>
<li>重点：结合了两种模式的优点，传参和复用</li>
<li>特点：<br>　　　- 1、可以继承父类原型上的属性，可以传参，可复用。<pre><code>  　　　- 2、每个新实例引入的构造函数属性是私有的。
</code></pre>
</li>
<li>缺点：调用了两次父类构造函数（耗内存），子类的构造函数会代替原型上的那个父类构造函数。</li>
</ul>
<ol start="4">
<li>寄生组合式继承（圣杯模式）</li>
</ol>
<ul>
<li>重点：修复了组合继承的问题</li>
</ul>
</blockquote>
<h3 id="18-什么是事件监听"><a href="#18-什么是事件监听" class="headerlink" title="18. 什么是事件监听"></a>18. 什么是事件监听</h3><blockquote>
<p>参考答案：</p>
<p>首先需要区别清楚事件监听和事件监听器。</p>
<p>在绑定事件的时候，我们需要对应的书写一个事件处理程序，来应对事件发生时的具体行为。</p>
<p>这个事件处理程序我们也称之为事件监听器。</p>
<p>当事件绑定好后，程序就会对事件进行监听，当用户触发事件时，就会执行对应的事件处理程序。</p>
<p>关于事件监听，<em>W3C</em> 规范中定义了 <em>3</em> 个事件阶段，依次是捕获阶段、目标阶段、冒泡阶段。</p>
<ul>
<li><p><strong>捕获</strong>阶段：在事件对象到达事件目标之前，事件对象必须从 <em>window</em> 经过目标的祖先节点传播到事件目标。 这个阶段被我们称之为捕获阶段。在这个阶段注册的事件监听器在事件到达其目标前必须先处理事件。</p>
</li>
<li><p><strong>目标</strong> 阶段：事件对象到达其事件目标。 这个阶段被我们称为目标阶段。一旦事件对象到达事件目标，该阶段的事件监听器就要对它进行处理。如果一个事件对象类型被标志为不能冒泡。那么对应的事件对象在到达此阶段时就会终止传播。</p>
</li>
<li><p><strong>冒泡</strong> 阶段：事件对象以一个与捕获阶段相反的方向从事件目标传播经过其祖先节点传播到 <em>window</em>。这个阶段被称之为冒泡阶段。在此阶段注册的事件监听器会对相应的冒泡事件进行处理。</p>
</li>
</ul>
</blockquote>
<h3 id="19-什么是-js-的闭包？有什么作用？"><a href="#19-什么是-js-的闭包？有什么作用？" class="headerlink" title="19. 什么是 js 的闭包？有什么作用？"></a>19. 什么是 <em>js</em> 的闭包？有什么作用？</h3><blockquote>
<p>参考答案：</p>
<p>一个函数和对其周围状态（<em>lexical environment</em>，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是<strong>闭包</strong>（<em>closure</em>）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 <em>JavaScript</em> 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。</p>
<p>闭包的用处：</p>
<ol>
<li>匿名自执行函数</li>
<li>结果缓存</li>
<li>封装</li>
<li>实现类和继承</li>
</ol>
</blockquote>
<h3 id="20-事件委托以及冒泡原理"><a href="#20-事件委托以及冒泡原理" class="headerlink" title="20. 事件委托以及冒泡原理"></a>20. 事件委托以及冒泡原理</h3><blockquote>
<p>参考答案：</p>
<p>事件委托，又被称之为事件代理。在 <em>JavaScript</em> 中，添加到页面上的事件处理程序数量将直接关系到页面整体的运行性能。导致这一问题的原因是多方面的。</p>
<p>首先，每个函数都是对象，都会占用内存。内存中的对象越多，性能就越差。其次，必须事先指定所有事件处理程序而导致的 <em>DOM</em> 访问次数，会延迟整个页面的交互就绪时间。</p>
<p>对事件处理程序过多问题的解决方案就是事件委托。</p>
<p>事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。例如，<em>click</em> 事件会一直冒泡到 <em>document</em> 层次。也就是说，我们可以为整个页面指定一个 <em>onclick</em> 事件处理程序，而不必给每个可单击的元素分别添加事件处理程序。</p>
<p>事件冒泡（<em>event bubbling</em>），是指事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。</p>
</blockquote>
<h3 id="21-let-const-var-的区别？什么是块级作用域？如何用？"><a href="#21-let-const-var-的区别？什么是块级作用域？如何用？" class="headerlink" title="21. let const var 的区别？什么是块级作用域？如何用？"></a>21. <em>let const var</em> 的区别？什么是块级作用域？如何用？</h3><blockquote>
<p>参考答案：</p>
<ol>
<li><em>var</em> 定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问，有变量提升。</li>
<li><em>let</em> 定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问，无变量提升，不可以重复声明。</li>
<li><em>const</em> 用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改，无变量提升，不可以重复声明。</li>
</ol>
<p>最初在 <em>JS</em> 中作用域有：全局作用域、函数作用域。没有块作用域的概念。</p>
<p><em>ES6</em> 中新增了块级作用域。块作用域由 { } 包括，<em>if</em> 语句和 <em>for</em> 语句里面的 { } 也属于块作用域。</p>
<p>在以前没有块作用域的时候，在 if 或者 for 循环中声明的变量会泄露成全局变量，其次就是 { } 中的内层变量可能会覆盖外层变量。块级作用域的出现解决了这些问题。</p>
</blockquote>
<h3 id="22-ES5-的方法实现块级作用域（立即执行函数）-ES6-呢？"><a href="#22-ES5-的方法实现块级作用域（立即执行函数）-ES6-呢？" class="headerlink" title="22. ES5 的方法实现块级作用域（立即执行函数） ES6 呢？"></a>22. <em>ES5</em> 的方法实现块级作用域（立即执行函数） <em>ES6</em> 呢？</h3><blockquote>
<p>参考答案：</p>
<p><em>ES6</em> 原生支持块级作用域。块作用域由 { } 包括，<em>if</em> 语句和 <em>for</em> 语句里面的 { } 也属于块作用域。</p>
<p>使用 <em>let</em> 声明的变量或者使用 <em>const</em> 声明的常量，只能在块作用域里访问，不能跨块访问。</p>
</blockquote>
<h3 id="23-ES6-箭头函数的特性"><a href="#23-ES6-箭头函数的特性" class="headerlink" title="23. ES6 箭头函数的特性"></a>23. <em>ES6</em> 箭头函数的特性</h3><blockquote>
<p>参考答案：</p>
<ol>
<li>更简洁的语法，例如<ul>
<li>只有一个形参就不需要用括号括起来</li>
<li>如果函数体只有一行，就不需要放到一个块中</li>
<li>如果 <em>return</em> 语句是函数体内唯一的语句，就不需要 <em>return</em> 关键字</li>
</ul>
</li>
<li>箭头函数没有自己的 <em>this</em>，<em>arguments</em>，<em>super</em></li>
<li>箭头函数 <em>this</em> 只会从自己的作用域链的上一层继承 <em>this</em>。</li>
</ol>
</blockquote>
<h3 id="24-箭头函数与普通函数的区别-？"><a href="#24-箭头函数与普通函数的区别-？" class="headerlink" title="24. 箭头函数与普通函数的区别 ？"></a>24. 箭头函数与普通函数的区别 ？</h3><blockquote>
<p>参考答案：</p>
<ol>
<li><p>外形不同。箭头函数使用箭头定义，普通函数中没有</p>
</li>
<li><p>普通函数可以有匿名函数，也可以有具体名函数，但是箭头函数都是匿名函数。</p>
</li>
<li><p>**箭头函数不能用于构造函数，不能使用 <em>new</em>，**普通函数可以用于构造函数，以此创建对象实例。</p>
</li>
<li><p><strong>箭头函数中 <em>this</em> 的指向不同，</strong>在普通函数中，<em>this</em> 总是指向调用它的对象，如果用作构造函数，<em>this</em> 指向创建的对象实例。<br>箭头函数本身不创建 <em>this</em>，也可以说箭头函数本身没有 <em>this</em>，但是它在声明时可以捕获其所在上下文的 <em>this</em> 供自己使用。</p>
</li>
<li><p>每一个普通函数调用后都具有一个 <em>arguments</em> 对象，用来存储实际传递的参数。</p>
<p>但是箭头函数并没有此对象。<strong>取而代之用rest参数来解决</strong>。</p>
</li>
<li><p>箭头函数不能用于 <em>Generator</em> 函数，不能使用 <em>yeild</em> 关键字。</p>
</li>
<li><p>箭头函数不具有 <em>prototype</em> 原型对象。而普通函数具有 <em>prototype</em> 原型对象。</p>
</li>
<li><p>箭头函数不具有 <em>super</em>。</p>
</li>
<li><p>箭头函数不具有 <em>new.target</em>。</p>
</li>
</ol>
</blockquote>
<h3 id="25-JS-的基本数据类型有哪些？基本数据类型和引用数据类型的区别"><a href="#25-JS-的基本数据类型有哪些？基本数据类型和引用数据类型的区别" class="headerlink" title="25. JS 的基本数据类型有哪些？基本数据类型和引用数据类型的区别"></a>25. <em>JS</em> 的基本数据类型有哪些？基本数据类型和引用数据类型的区别</h3><blockquote>
<p>参考答案：</p>
<p>在 <em>JavaScript</em> 中，数据类型整体上来讲可以分为两大类：<strong>基本类型</strong>和<strong>引用数据类型</strong></p>
<p>基本数据类型，一共有 <em>6</em> 种：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string，symbol，number，boolean，undefined，null</span><br></pre></td></tr></table></figure>

<p>其中 <em>symbol</em> 类型是在 <em>ES6</em> 里面新添加的基本数据类型。</p>
<p>引用数据类型，就只有 <em>1</em> 种：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">object</span><br></pre></td></tr></table></figure>

<p>基本数据类型的值又被称之为原始值或简单值，而引用数据类型的值又被称之为复杂值或引用值。</p>
<p>两者的区别在于：</p>
<p><strong>原始值是表示 <em>JavaScript</em> 中可用的数据或信息的最底层形式或最简单形式。</strong>简单类型的值被称为原始值，是因为它们是<strong>不可细化</strong>的。</p>
<p>也就是说，数字是数字，字符是字符，布尔值是 <em>true</em> 或 <em>false</em>，<em>null</em> 和 <em>undefined</em> 就是 <em>null</em> 和 <em>undefined</em>。这些值本身很简单，不能够再进行拆分。由于原始值的数据大小是固定的，所以<strong>原始值的数据是存储于内存中的栈区里面的。</strong></p>
<p>在 <em>JavaScript</em> 中，对象就是一个引用值。因为对象可以向下拆分，拆分成多个简单值或者复杂值。<strong>引用值在内存中的大小是未知的，因为引用值可以包含任何值，而不是一个特定的已知值，所以引用值的数据都是存储于堆区里面。</strong></p>
<p>最后总结一下两者的区别：</p>
<ol>
<li><p>访问方式</p>
<ul>
<li>原始值：访问到的是值</li>
<li>引用值：访问到的是引用地址</li>
</ul>
</li>
<li><p>比较方式</p>
<ul>
<li>原始值：比较的是值</li>
<li>引用值：比较的是地址</li>
</ul>
</li>
<li><p>动态属性</p>
<ul>
<li>原始值：无法添加动态属性</li>
<li>引用值：可以添加动态属性</li>
</ul>
</li>
<li><p>变量赋值</p>
<ul>
<li>原始值：赋值的是值</li>
<li>引用值：赋值的是地址</li>
</ul>
</li>
</ol>
</blockquote>
<h3 id="26-NaN-是什么的缩写"><a href="#26-NaN-是什么的缩写" class="headerlink" title="26. NaN 是什么的缩写"></a>26. <em>NaN</em> 是什么的缩写</h3><blockquote>
<p>参考答案：</p>
<p><em>NaN</em> 的全称为 <em>Not a Number</em>，表示非数，或者说不是一个数。虽然 NaN 表示非数，但是它却属于 <em>number</em> 类型。</p>
<p><em>NaN</em> 有两个特点：</p>
<ol>
<li>任何涉及 <em>NaN</em> 的操作都会返回 <em>NaN</em></li>
<li><em>NaN</em> 和任何值都不相等，包括它自己本身</li>
</ol>
</blockquote>
<h3 id="27-JS-的作用域类型"><a href="#27-JS-的作用域类型" class="headerlink" title="27. JS 的作用域类型"></a>27. <em>JS</em> 的作用域类型</h3><blockquote>
<p>参考答案：</p>
<p>在 <em>JavaScript</em> 里面，作用域一共有 4 种：全局作用域，局部作用域、函数作用域以及 <em>eval</em> 作用域。</p>
<p><strong>全局作用域：</strong>这个是默认的代码运行环境，一旦代码被载入，引擎最先进入的就是这个环境。</p>
<p><strong>局部作用域：</strong>当使用 <em>let</em> 或者 <em>const</em> 声明变量时，这些变量在一对花括号中存在局部作用域，只能够在花括号内部进行访问使用。</p>
<p><strong>函数作用域：</strong>当进入到一个函数的时候，就会产生一个函数作用域。函数作用域里面所声明的变量只在函数中提供访问使用。</p>
<p><strong><em>eval</em> 作用域：</strong>当调用 <em>eval( )</em> 函数的时候，就会产生一个 <em>eval</em> 作用域。</p>
</blockquote>
<h3 id="28-undefined-null-返回的结果是什么？undefined-与-null-的区别在哪？"><a href="#28-undefined-null-返回的结果是什么？undefined-与-null-的区别在哪？" class="headerlink" title="28. undefined==null 返回的结果是什么？undefined 与 null 的区别在哪？"></a>28. <em>undefined==null</em> 返回的结果是什么？<em>undefined</em> 与 <em>null</em> 的区别在哪？</h3><blockquote>
<p>参考答案：</p>
<p>返回 <em>true</em>。</p>
<p>这两个值都表示“无”的意思。</p>
<p>通常情况下， 当我们试图访问某个不存在的或者没有赋值的变量时，就会得到一个 <em>undefined</em> 值。<em>Javascript</em> 会自动将声明是没有进行初始化的变量设为 <em>undifined</em>。</p>
<p>而 <em>null</em> 值表示空，<em>null</em> 不能通过 <em>Javascript</em> 来自动赋值，也就是说必须要我们自己手动来给某个变量赋值为 <em>null</em>。</p>
</blockquote>
<blockquote>
<p>解析：</p>
<p>那么为什么 <em>JavaScript</em> 要设置两个表示”无”的值呢？这其实是历史原因。</p>
<p><em>1995</em> 年 <em>JavaScript</em> 诞生时，最初像 <em>Java</em> 一样，只设置了 <em>null</em> 作为表示”无”的值。根据 <em>C</em> 语言的传统，<em>null</em> 被设计成可以自动转为<em>0</em>。</p>
<p>但是，<em>JavaScript</em> 的设计者，觉得这样做还不够，主要有以下两个原因。</p>
<ol>
<li><em>null</em> 像在 <em>Java</em> 里一样，被当成一个对象。但是，<em>JavaScript</em> 的数据类型分成原始类型（<em>primitive</em>）和合成类型（<em>complex</em>）两大类，作者觉得表示”无”的值最好不是对象。</li>
<li><em>JavaScript</em> 的最初版本没有包括错误处理机制，发生数据类型不匹配时，往往是自动转换类型或者默默地失败。作者觉得，如果 <em>null</em> 自动转为 <em>0</em>，很不容易发现错误。</li>
</ol>
<p>因此，作者又设计了一个 <em>undefined</em>。</p>
<p><strong>这里注意：先有 <em>null</em> 后有 <em>undefined</em> 出来，<em>undefined</em> 是为了填补之前的坑。</strong></p>
<p><em>JavaScript</em> 的最初版本是这样区分的：</p>
<p><em>null</em> 是一个表示”无”的对象（空对象指针），转为数值时为 <em>0</em>；</p>
<p>典型用法是：</p>
<ul>
<li><p>作为函数的参数，表示该函数的参数不是对象。</p>
</li>
<li><p>作为对象原型链的终点。</p>
</li>
</ul>
<p><em>undefined</em> 是一个表示”无”的原始值，转为数值时为 <em>NaN</em>。</p>
<p>典型用法是：</p>
<ul>
<li>变量被声明了，但没有赋值时，就等于 <em>undefined</em>。 </li>
<li>调用函数时，应该提供的参数没有提供，该参数等于 <em>undefined</em>。</li>
<li>对象没有赋值的属性，该属性的值为 <em>undefined</em>。</li>
<li>函数没有返回值时，默认返回 <em>undefined</em>。</li>
</ul>
</blockquote>
<h3 id="29-写一个函数判断变量类型"><a href="#29-写一个函数判断变量类型" class="headerlink" title="29. 写一个函数判断变量类型"></a>29. 写一个函数判断变量类型</h3><blockquote>
<p>参考答案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> type = <span class="keyword">typeof</span> data;</span><br><span class="line">    <span class="keyword">if</span>(type !== <span class="string">&quot;object&quot;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> type</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(data).replace(<span class="regexp">/^\[object (\S+)\]$/</span>,<span class="string">&#x27;$1&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getType(<span class="number">1</span>)); <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(getType(<span class="literal">true</span>)); <span class="comment">// boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(getType([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])); <span class="comment">// Array</span></span><br><span class="line"><span class="built_in">console</span>.log(getType(<span class="regexp">/abc/</span>)); <span class="comment">// RegExp</span></span><br><span class="line"><span class="built_in">console</span>.log(getType(<span class="keyword">new</span> <span class="built_in">Date</span>)); <span class="comment">// Date</span></span><br><span class="line"><span class="built_in">console</span>.log(getType(<span class="keyword">new</span> Person)); <span class="comment">// Object</span></span><br><span class="line"><span class="built_in">console</span>.log(getType(&#123;&#125;)); <span class="comment">// Object</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="30-js-的异步处理函数"><a href="#30-js-的异步处理函数" class="headerlink" title="30. js 的异步处理函数"></a>30. <em>js</em> 的异步处理函数</h3><blockquote>
<p>参考答案：</p>
<p>在最早期的时候，<em>JavaScript</em> 中要实现异步操作，使用的就是 <em>Callback</em> 回调函数。</p>
<p>但是回调函数会产生回调地狱（<em>Callback Hell</em>）</p>
<p>之后 ES6 推出了 <em>Promise</em> 解决方案来解决回调地狱的问题。不过，虽然 <em>Promise</em> 作为 <em>ES6</em> 中提供的一种新的异步编程解决方案，但是它也有问题。比如，代码并没有因为新方法的出现而减少，反而变得更加复杂，同时理解难度也加大。</p>
<p>之后，就出现了基于 <em>Generator</em> 的异步解决方案。不过，这种方式需要编写外部的执行器，而执行器的代码写起来一点也不简单。当然也可以使用一些插件，比如 <em>co</em> 模块来简化执行器的编写。</p>
<p><em>ES7</em> 提出的 <em>async</em> 函数，终于让 <em>JavaScript</em> 对于异步操作有了终极解决方案。</p>
<p>实际上，<em>async</em> 只是生成器的一种语法糖而已，简化了外部执行器的代码，同时利用 <em>await</em> 替代 <em>yield</em>，<em>async</em> 替代生成器的<code>*</code>号。</p>
</blockquote>
<h3 id="31-defer-与-async-的区别"><a href="#31-defer-与-async-的区别" class="headerlink" title="31. defer 与 async 的区别"></a>31. <em>defer</em> 与 <em>async</em> 的区别</h3><blockquote>
<p>参考答案：</p>
<p>按照惯例，所有 <em>script</em> 元素都应该放在页面的 <em>head</em> 元素中。这种做法的目的就是把<strong>所有外部文件（<em>CSS</em> 文件和 <em>JavaScript</em> 文件）的引用都放在相同的地方</strong>。可是，在文档的 <em>head</em> 元素中包含所有 <em>JavaScript</em> 文件，意味着必须等到全部 <em>JavaScript</em> 代码都被下载、解析和执行完成以后，才能开始呈现页面的内容（浏览器在遇到 <em>body</em> 标签时才开始呈现内容）。</p>
<p>对于那些需要很多 <em>JavaScript</em> 代码的页面来说，这无疑会导致浏览器在呈现页面时出现明显的延迟，而延迟期间的浏览器窗口中将是一片空白。为了避免这个问题，现在 <strong><em>Web</em> 应用程序一般都全部 <em>JavaScript</em> 引用放在 <em>body</em> 元素中页面的内容后面</strong>。这样一来，在解析包含的 <em>JavaScript</em> 代码之前，页面的内容将完全呈现在浏览器中。而用户也会因为浏览器窗口显示空白页面的时间缩短而感到打开页面的速度加快了。</p>
<p>有了 <em>defer</em> 和 <em>async</em> 后，这种局面得到了改善。</p>
<p><strong><em>defer</em> （延迟脚本）</strong></p>
<p>延迟脚本：<em>defer</em> 属性只适用于外部脚本文件。</p>
<p>如果给 <em>script</em> 标签定义了<em>defer</em> 属性，这个属性的作用是表明脚本在执行时不会影响页面的构造。也就是说，脚本会被延迟到整个页面都解析完毕后再运行。因此，如果 <em>script</em> 元素中设置了 <em>defer</em> 属性，相当于告诉浏览器立即下载，但延迟执行。</p>
<p><strong><em>async</em>（异步脚本）</strong></p>
<p>异步脚本：<em>async</em> 属性也只适用于外部脚本文件，并告诉浏览器立即下载文件。</p>
<p><strong>但与 <em>defer</em> 不同的是：标记为 <em>async</em> 的脚本并不保证按照指定它们的先后顺序执行。</strong></p>
<p>所以总结起来，两者之间最大的差异就是在于脚本下载完之后何时执行，显然 <em>defer</em> 是最接近我们对于应用脚本加载和执行的要求的。</p>
<p><em>defer</em> 是立即下载但延迟执行，加载后续文档元素的过程将和脚本的加载并行进行（异步），但是脚本的执行要在所有元素解析完成之后，<em>DOMContentLoaded</em> 事件触发之前完成。<em>async</em> 是立即下载并执行，加载和渲染后续文档元素的过程将和 <em>js</em> 脚本的加载与执行并行进行（异步）。</p>
</blockquote>
<h3 id="32-浏览器事件循环和任务队列"><a href="#32-浏览器事件循环和任务队列" class="headerlink" title="32. 浏览器事件循环和任务队列"></a>32. 浏览器事件循环和任务队列</h3><blockquote>
<p>参考答案：</p>
<p><em>JavaScript</em> 的异步机制由事件循环和任务队列构成。</p>
<p><em>JavaScript</em> 本身是单线程语言，所谓异步依赖于浏览器或者操作系统等完成。<em>JavaScript</em> 主线程拥有一个执行栈以及一个任务队列，主线程会依次执行代码，当遇到函数时，会先将函数入栈，函数运行完毕后再将该函数出栈，直到所有代码执行完毕。</p>
<p>遇到异步操作（例如：<em>setTimeout、Ajax</em>）时，异步操作会由浏览器(<em>OS</em>)执行，浏览器会在这些任务完成后，将事先定义的回调函数推入主线程的任务队列(<em>task queue</em>)中,当主线程的执行栈清空之后会读取任务队列中的回调函数,当任务队列被读取完毕之后,主线程接着执行,从而进入一个无限的循环，这就是事件循环。</p>
</blockquote>
<h3 id="33-原型与原型链-（美团-19年）"><a href="#33-原型与原型链-（美团-19年）" class="headerlink" title="33. 原型与原型链 （美团 19年）"></a>33. 原型与原型链 （美团 19年）</h3><blockquote>
<p>参考答案：</p>
<ul>
<li>每个对象都有一个 <code>__proto__ </code> 属性，该属性指向自己的原型对象</li>
<li>每个构造函数都有一个 <code>prototype </code> 属性，该属性指向实例对象的原型对象</li>
<li>原型对象里的 <code>constructor</code> 指向构造函数本身</li>
</ul>
<p>如下图：</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-08-12-081402.png" alt="image-20210812161401493" style="zoom: 45%;" />

<p>每个对象都有自己的原型对象，而原型对象本身，也有自己的原型对象，从而形成了一条原型链条。</p>
<p>当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。</p>
</blockquote>
<h3 id="34-作用域与作用域链-（美团-19年）"><a href="#34-作用域与作用域链-（美团-19年）" class="headerlink" title="34. 作用域与作用域链 （美团 19年）"></a>34. 作用域与作用域链 （美团 19年）</h3><blockquote>
<p>参考答案：</p>
<p>作用域是在运行时代码中的某些特定部分中变量，函数和对象的可访问性。换句话说，作用域决定了代码区块中变量和其他资源的可见性。<em>ES6</em> 之前 <em>JavaScript</em> 没有块级作用域，只有全局作用域和函数作用域。<em>ES6</em> 的到来，为我们提供了块级作用域。</p>
<p>作用域链指的是作用域与作用域之间形成的链条。当我们查找一个当前作用域没有定义的变量（自由变量）的时候，就会向上一级作用域寻找，如果上一级也没有，就再一层一层向上寻找，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是作用域链 。</p>
</blockquote>
<h3 id="35-闭包及应用场景以及闭包缺点-（美团-19年）"><a href="#35-闭包及应用场景以及闭包缺点-（美团-19年）" class="headerlink" title="35. 闭包及应用场景以及闭包缺点 （美团 19年）"></a>35. 闭包及应用场景以及闭包缺点 （美团 19年）</h3><blockquote>
<p>参考答案：</p>
<p>闭包的应用场景：</p>
<ol>
<li>匿名自执行函数</li>
<li>结果缓存</li>
<li>封装</li>
<li>实现类和继承</li>
</ol>
<p>闭包的缺点：</p>
<p>因为闭包的作用域链会引用包含它的函数的活动对象，导致这些活动对象不会被销毁，因此会占用更多的内存。</p>
</blockquote>
<h3 id="36-继承方式-（美团-19年）"><a href="#36-继承方式-（美团-19年）" class="headerlink" title="36. 继承方式 （美团 19年）"></a>36. 继承方式 （美团 19年）</h3><blockquote>
<p>参考答案：</p>
<p>参阅前面第 <em>9</em> 题以及第 <em>18</em> 题答案。</p>
</blockquote>
<h3 id="37-原始值与引用值-（美团-19年）"><a href="#37-原始值与引用值-（美团-19年）" class="headerlink" title="37. 原始值与引用值 （美团 19年）"></a>37. 原始值与引用值 （美团 19年）</h3><blockquote>
<p>参考答案：</p>
<p><strong>原始值是表示 <em>JavaScript</em> 中可用的数据或信息的最底层形式或最简单形式。</strong>简单类型的值被称为原始值，是因为它们是<strong>不可细化</strong>的。</p>
<p>也就是说，数字是数字，字符是字符，布尔值是 <em>true</em> 或 <em>false</em>，<em>null</em> 和 <em>undefined</em> 就是 <em>null</em> 和 <em>undefined</em>。这些值本身很简单，不能够再进行拆分。由于原始值的数据大小是固定的，所以<strong>原始值的数据是存储于内存中的栈区里面的。</strong></p>
<p>在 <em>JavaScript</em> 中，对象就是一个引用值。因为对象可以向下拆分，拆分成多个简单值或者复杂值。<strong>引用值在内存中的大小是未知的，因为引用值可以包含任何值，而不是一个特定的已知值，所以引用值的数据都是存储于堆区里面。</strong></p>
<p>最后总结一下两者的区别：</p>
<ol>
<li><p>访问方式</p>
<ul>
<li>原始值：访问到的是值</li>
<li>引用值：访问到的是引用地址</li>
</ul>
</li>
<li><p>比较方式</p>
<ul>
<li>原始值：比较的是值</li>
<li>引用值：比较的是地址</li>
</ul>
</li>
<li><p>动态属性</p>
<ul>
<li>原始值：无法添加动态属性</li>
<li>引用值：可以添加动态属性</li>
</ul>
</li>
<li><p>变量赋值</p>
<ul>
<li>原始值：赋值的是值</li>
<li>引用值：赋值的是地址</li>
</ul>
</li>
</ol>
</blockquote>
<h3 id="38-描述下列代码的执行结果"><a href="#38-描述下列代码的执行结果" class="headerlink" title="38. 描述下列代码的执行结果"></a>38. 描述下列代码的执行结果</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> first = <span class="function">() =&gt;</span> (<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">7</span>);</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">            resolve(<span class="number">3</span>);</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">        resolve(<span class="number">4</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    resolve(<span class="number">2</span>);</span><br><span class="line">    p.then(<span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(arg, <span class="number">5</span>); <span class="comment">// 1 bb</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;))</span><br><span class="line">first().then(<span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg, <span class="number">7</span>); <span class="comment">// 2 aa</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">8</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">9</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考答案：</p>
<p>3<br>7<br>10<br>4 5<br>2 7<br>1<br>2<br>6<br>9<br>8</p>
</blockquote>
<h3 id="39-如何判断数组或对象（美团-19年）"><a href="#39-如何判断数组或对象（美团-19年）" class="headerlink" title="39. 如何判断数组或对象（美团 19年）"></a>39. 如何判断数组或对象（美团 19年）</h3><blockquote>
<p>参考答案：</p>
<ol>
<li>通过 <em>instanceof</em> 进行判断</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>通过对象的 <em>constructor</em> 属性</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.constructor === <span class="built_in">Array</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><em>Object.prototype.toString.call(arr)</em></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(&#123;<span class="attr">name</span>: <span class="string">&quot;jerry&quot;</span>&#125;));<span class="comment">//[object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call([]));<span class="comment">//[object Array]</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>可以通过 <em>ES6</em> 新提供的方法 <em>Array.isArray( )</em></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArray([]) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="40-对象深拷贝与浅拷贝，单独问了-Object-assign（美团-19年）"><a href="#40-对象深拷贝与浅拷贝，单独问了-Object-assign（美团-19年）" class="headerlink" title="40. 对象深拷贝与浅拷贝，单独问了 Object.assign（美团 19年）"></a>40. 对象深拷贝与浅拷贝，单独问了 <em>Object.assign</em>（美团 19年）</h3><blockquote>
<p>参考答案：</p>
<ul>
<li><p><strong>浅拷贝</strong>：只是拷贝了基本类型的数据，而引用类型数据，复制后也是会发生引用，我们把这种拷贝叫做浅拷贝（浅复制）</p>
<p>  浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。</p>
</li>
<li><p><strong>深拷贝</strong>：在堆中重新分配内存，并且把源对象所有属性都进行新建拷贝，以保证深拷贝的对象的引用图不包含任何原有对象或对象图上的任何对象，拷贝后的对象与原来的对象是完全隔离，互不影响。</p>
</li>
</ul>
<p><em>Object.assign</em> 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是 <em>Object.assign</em> 方法进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。</p>
</blockquote>
<h3 id="42-说说-instanceof-原理，并回答下面的题目（美团-19年）"><a href="#42-说说-instanceof-原理，并回答下面的题目（美团-19年）" class="headerlink" title="42. 说说 instanceof 原理，并回答下面的题目（美团 19年）"></a>42. 说说 <em>instanceof</em> 原理，并回答下面的题目（美团 19年）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">A.prototype = <span class="keyword">new</span> B(); </span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> A(); </span><br><span class="line"><span class="built_in">console</span>.log(a <span class="keyword">instanceof</span> B) <span class="comment">// true of false ?</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考答案：</p>
<p>答案为 <em>true</em>。</p>
<p><em>instanceof</em> 原理：</p>
<p><em>instanceof</em>  用于检测一个对象是否为某个构造函数的实例。</p>
<p>例如：<em>A instanceof B</em><br><em>instanceof</em> 用于检测对象 <em>A</em> 是不是 <em>B</em> 的实例，而检测是基于原型链进行查找的，也就是说 <em>B</em> 的 <em>prototype</em> 有没有在对象 <em>A</em> 的_<em><em>proto</em></em>_ 原型链上，如果有就返回 <em>true</em>，否则返回 <em>false</em></p>
</blockquote>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="43-内存泄漏（美团-19-年）"><a href="#43-内存泄漏（美团-19-年）" class="headerlink" title="43. 内存泄漏（美团 19 年）"></a>43. 内存泄漏（美团 19 年）</h3><blockquote>
<p>参考答案：</p>
<p>内存泄漏（<em>Memory Leak</em>）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。</p>
<p><em>Javascript</em> 是一种高级语言，它不像 <em>C</em> 语言那样要手动申请内存，然后手动释放，<em>Javascript</em> 在声明变量的时候自动会分配内存，普通的类型比如 <em>number</em>，一般放在栈内存里，对象放在堆内存里，声明一个变量，就分配一些内存，然后定时进行垃圾回收。垃圾回收的任务由 <em>JavaScript</em> 引擎中的垃圾回收器来完成，它监视所有对象，并删除那些不可访问的对象。</p>
<p>基本的垃圾回收算法称为<strong>“标记-清除”</strong>，定期执行以下“垃圾回收”步骤:</p>
<ul>
<li>垃圾回收器获取根并<strong>“标记”</strong>(记住)它们。</li>
<li>然后它访问并“标记”所有来自它们的引用。</li>
<li>然后它访问标记的对象并标记它们的引用。所有被访问的对象都被记住，以便以后不再访问同一个对象两次。</li>
<li>以此类推，直到有未访问的引用(可以从根访问)为止。</li>
<li>除标记的对象外，所有对象都被删除。</li>
</ul>
</blockquote>
<h3 id="44-ES6-新增哪些东西？让你自己说（美团-19-年）"><a href="#44-ES6-新增哪些东西？让你自己说（美团-19-年）" class="headerlink" title="44. ES6 新增哪些东西？让你自己说（美团 19 年）"></a>44. <em>ES6</em> 新增哪些东西？让你自己说（美团 19 年）</h3><blockquote>
<p>参考答案：</p>
<p><em>ES6</em> 新增内容众多，这里列举出一些关键的以及平时常用的新增内容：</p>
<ol>
<li>箭头函数</li>
<li>字符串模板</li>
<li>支持模块化（<em>import、export</em>）</li>
<li>类（<em>class、constructor、extends</em>）</li>
<li><em>let、const</em> 关键字</li>
<li>新增一些数组、字符串等内置构造函数方法，例如 <em>Array.from</em>、<em>Array.of</em> 、<em>Math.sign</em>、<em>Math.trunc</em> 等</li>
<li>新增一些语法，例如扩展操作符、解构、函数默认参数等</li>
<li>新增一种基本数据类型 <em>Symbol</em></li>
<li>新增元编程相关，例如 <em>proxy</em>、<em>Reflect</em></li>
<li><em>Set</em> 和 <em>Map</em> 数据结构</li>
<li><em>Promise</em></li>
<li><em>Generator</em> 生成器</li>
</ol>
</blockquote>
<h3 id="45-weakmap、weakset（美团-19-年）"><a href="#45-weakmap、weakset（美团-19-年）" class="headerlink" title="45. weakmap、weakset（美团 19 年）"></a>45. <em>weakmap、weakset</em>（美团 <em>19</em> 年）</h3><blockquote>
<p>参考答案：</p>
<p><em>WeakSet</em> 对象是一些对象值的集合, 并且其中的每个对象值都只能出现一次。在 <em>WeakSet</em> 的集合中是唯一的</p>
<p>它和 <em>Set</em> 对象的区别有两点:</p>
<ul>
<li>与 <em>Set</em> 相比，<em>WeakSet</em> 只能是<strong>对象的集合</strong>，而不能是任何类型的任意值。</li>
<li><em>WeakSet</em> 持弱引用：集合中对象的引用为弱引用。 如果没有其他的对 <em>WeakSet</em> 中对象的引用，那么这些对象会被当成垃圾回收掉。 这也意味着 <em>WeakSet</em> 中没有存储当前对象的列表。 正因为这样，<em>WeakSet</em> 是不可枚举的。</li>
</ul>
<p><em>WeakMap</em> 对象也是键值对的集合。它的<strong>键必须是对象类型</strong>，值可以是任意类型。它的键被弱保持，也就是说，当其键所指对象没有其他地方引用的时候，它会被 <em>GC</em> 回收掉。<em>WeakMap</em> 提供的接口与 <em>Map</em> 相同。</p>
<p>与 <em>Map</em> 对象不同的是，<em>WeakMap</em> 的键是不可枚举的。不提供列出其键的方法。列表是否存在取决于垃圾回收器的状态，是不可预知的。</p>
</blockquote>
<h3 id="46-为什么-ES6-会新增-Promise（美团-19年）"><a href="#46-为什么-ES6-会新增-Promise（美团-19年）" class="headerlink" title="46. 为什么 ES6 会新增 Promise（美团 19年）"></a>46. 为什么 <em>ES6</em> 会新增 <em>Promise</em>（美团 19年）</h3><blockquote>
<p>参考答案：</p>
<p>在 <em>ES6</em> 以前，解决异步的方法是回调函数。但是回调函数有一个最大的问题就是回调地狱（<em>callback hell</em>），当我们的回调函数嵌套的层数过多时，就会导致代码横向发展。</p>
<p><em>Promise</em> 的出现就是为了解决回调地狱的问题。</p>
</blockquote>
<h3 id="47-ES5-实现继承？（虾皮）"><a href="#47-ES5-实现继承？（虾皮）" class="headerlink" title="47. ES5 实现继承？（虾皮）"></a>47. <em>ES5</em> 实现继承？（虾皮）</h3><blockquote>
<p>参考答案：</p>
<ol>
<li>借用构造函数实现继承</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;parent1&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Parent1.call(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">this</span>.type = <span class="string">&quot;child1&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：<em>Child1</em> 无法继承 <em>Parent1</em> 的原型对象，并没有真正的实现继承 (部分继承)。</p>
<ol start="2">
<li>借用原型链实现继承</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;parent2&quot;</span>;</span><br><span class="line">    <span class="built_in">this</span>.play = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.type = <span class="string">&quot;child2&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">Child2.prototype = <span class="keyword">new</span> Parent2();</span><br></pre></td></tr></table></figure>

<p>缺点：原型对象的属性是共享的。</p>
<ol start="3">
<li>组合式继承</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;parent3&quot;</span>;</span><br><span class="line">    <span class="built_in">this</span>.play = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Parent3.call(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">this</span>.type = <span class="string">&quot;child3&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">Child3.prototype = <span class="built_in">Object</span>.create(Parent3.prototype);</span><br><span class="line">Child3.prototype.constructor = Child3;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="48-科里化？（搜狗）"><a href="#48-科里化？（搜狗）" class="headerlink" title="48. 科里化？（搜狗）"></a>48. 科里化？（搜狗）</h3><blockquote>
<p>参考答案：</p>
<p>柯里化，英语全称 <em>Currying</em>，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p>
<p>举个例子，就是把原本：</p>
<p><em>function(arg1,arg2)</em> 变成 <em>function(arg1)(arg2)</em><br><em>function(arg1,arg2,arg3)</em> 变成 <em>function(arg1)(arg2)(arg3)</em><br><em>function(arg1,arg2,arg3,arg4)</em> 变成 <em>function(arg1)(arg2)(arg3)(arg4)</em></p>
<p>总而言之，就是将：</p>
<p><em>function(arg1,arg2,…,argn)</em> 变成 <em>function(arg1)(arg2)…(argn)</em></p>
</blockquote>
<h3 id="49-防抖和节流？（虾皮）"><a href="#49-防抖和节流？（虾皮）" class="headerlink" title="49. 防抖和节流？（虾皮）"></a>49. 防抖和节流？（虾皮）</h3><blockquote>
<p>参考答案：</p>
<p>我们在平时开发的时候，会有很多场景会频繁触发事件，比如说搜索框实时发请求，<em>onmousemove、resize、onscroll</em> 等，有些时候，我们并不能或者不想频繁触发事件，这时候就应该用到函数防抖和函数节流。</p>
<p>函数防抖(<em>debounce</em>)，指的是短时间内多次触发同一事件，只执行最后一次，或者只执行最开始的一次，中间的不执行。</p>
<p>函数节流(<em>throttle</em>)，指连续触发事件但是在 <em>n</em> 秒中只执行一次函数。即 <em>2n</em> 秒内执行 <em>2</em> 次… 。节流如字面意思，会稀释函数的执行频率。</p>
</blockquote>
<h3 id="50-闭包？（好未来—探讨了-40-分钟）"><a href="#50-闭包？（好未来—探讨了-40-分钟）" class="headerlink" title="50. 闭包？（好未来—探讨了 40 分钟）"></a>50. 闭包？（好未来—探讨了 <em>40</em> 分钟）</h3><blockquote>
<p>参考答案：</p>
<p>请参阅前面第 <em>20</em> 题以及第 <em>36</em> 题答案。</p>
</blockquote>
<h3 id="51-原型和原型链？（字节）"><a href="#51-原型和原型链？（字节）" class="headerlink" title="51. 原型和原型链？（字节）"></a>51. 原型和原型链？（字节）</h3><blockquote>
<p>参考答案：</p>
<p>请参阅前面第 <em>34</em> 题答案。</p>
</blockquote>
<h3 id="52-排序算法—（时间复杂度、空间复杂度）"><a href="#52-排序算法—（时间复杂度、空间复杂度）" class="headerlink" title="52. 排序算法—（时间复杂度、空间复杂度）"></a>52. 排序算法—（时间复杂度、空间复杂度）</h3><blockquote>
<p>参考答案：</p>
<p>算法（<em>Algorithm</em>）是指用来操作数据、解决程序问题的一组方法。对于同一个问题，使用不同的算法，也许最终得到的结果是一样的，但在过程中消耗的资源和时间却会有很大的区别。</p>
<p>主要还是从算法所占用的「时间」和「空间」两个维度去考量。</p>
<ul>
<li>时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。</li>
<li>空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述。</li>
</ul>
<p>因此，评价一个算法的效率主要是看它的时间复杂度和空间复杂度情况。然而，有的时候时间和空间却又是「鱼和熊掌」，不可兼得的，那么我们就需要从中去取一个平衡点。</p>
<p>排序也称排序算法(<em>Sort Algorithm</em>)，排序是将<strong>一组数据</strong>，依<strong>指定的顺序</strong>进行<strong>排列的过程</strong>。</p>
<p>排序的分类分为<strong>内部排序</strong>和<strong>外部排序法</strong>。</p>
<ul>
<li>内部排序：指将需要处理的所有数据都加载到**内部存储器(内存)**中进行排序。</li>
<li>外部排序：<strong>数据量过大</strong>，无法全部加载到内存中，需要借助**外部存储(文件等)**进行排序。</li>
</ul>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-08-13-054747.png" alt="image-20210813134746501" style="zoom:50%;" />
</blockquote>
<h3 id="53-浏览器事件循环和-node-事件循环（搜狗）"><a href="#53-浏览器事件循环和-node-事件循环（搜狗）" class="headerlink" title="53. 浏览器事件循环和 node 事件循环（搜狗）"></a>53. 浏览器事件循环和 <em>node</em> 事件循环（搜狗）</h3><blockquote>
<p>参考答案：</p>
<ol>
<li>浏览器中的 <em>Event Loop</em></li>
</ol>
<p>事件循环中的异步队列有两种：<em>macro</em>（宏任务）队列和 <em>micro</em>（微任务）队列。<strong>宏任务队列可以有多个，微任务队列只有一个</strong>。</p>
<ul>
<li>常见的 <em>macro-task</em> 比如：<em>setTimeout、setInterval、 setImmediate、script</em>（整体代码）、 <em>I/O</em> 操作、<em>UI</em> 渲染等。</li>
<li>常见的 <em>micro-task</em> 比如: <em>process.nextTick、new Promise( ).then</em>(回调)、<em>MutationObserver</em>(<em>html5</em> 新特性) 等。</li>
</ul>
<p>当某个宏任务执行完后,会查看是否有微任务队列。如果有，先执行微任务队列中的所有任务，如果没有，会读取宏任务队列中排在最前的任务，执行宏任务的过程中，遇到微任务，依次加入微任务队列。栈空后，再次读取微任务队列里的任务，依次类推。</p>
<ol start="2">
<li><em>Node</em> 中的事件循环</li>
</ol>
<p><em>Node</em> 中的 <em>Event Loop</em> 和浏览器中的是完全不相同的东西。<em>Node.js</em> 采用 <em>V8</em> 作为 <em>js</em> 的解析引擎，而 <em>I/O</em> 处理方面使用了自己设计的 <em>libuv</em>，<em>libuv</em> 是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的 <em>API</em>，事件循环机制也是它里面的实现。</p>
<p><em>Node.JS</em> 的事件循环分为 <em>6</em> 个阶段：</p>
<ul>
<li><em>timers</em> 阶段：这个阶段执行 <em>timer</em>（ <em>setTimeout、setInterval</em> ）的回调</li>
<li><em>I/O callbacks</em> 阶段：处理一些上一轮循环中的少数未执行的 <em>I/O</em> 回调</li>
<li><em>idle、prepare</em> 阶段：仅 <em>Node.js</em> 内部使用</li>
<li><em>poll</em> 阶段：获取新的 <em>I/O</em> 事件, 适当的条件下 <em>Node.js</em> 将阻塞在这里</li>
<li><em>check</em> 阶段：执行 <em>setImmediate( )</em> 的回调</li>
<li><em>close callbacks</em> 阶段：执行 <em>socket</em> 的 <em>close</em> 事件回调</li>
</ul>
<p><em>Node.js</em> 的运行机制如下:</p>
<ul>
<li><em>V8</em> 引擎解析 <em>JavaScript</em> 脚本。</li>
<li>解析后的代码，调用 <em>Node API</em>。</li>
<li><em>libuv</em> 库负责 <em>Node API</em> 的执行。它将不同的任务分配给不同的线程，形成一个 <em>Event Loop</em>（事件循环），以异步的方式将任务的执行结果返回给 <em>V8</em> 引擎。</li>
<li><em>V8</em> 引擎再将结果返回给用户。</li>
</ul>
</blockquote>
<h3 id="54-闭包的好处"><a href="#54-闭包的好处" class="headerlink" title="54. 闭包的好处"></a>54. 闭包的好处</h3><blockquote>
<p>参考答案：</p>
<p>请参阅前面第 <em>20</em> 题以及第 <em>36</em> 题答案。</p>
</blockquote>
<h3 id="55-let、const、var-的区别"><a href="#55-let、const、var-的区别" class="headerlink" title="55. let、const、var 的区别"></a>55. <em>let、const、var</em> 的区别</h3><blockquote>
<p>参考答案：</p>
<ol>
<li><em>var</em> 定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问，有变量提升。</li>
<li><em>let</em> 定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问，无变量提升，不可以重复声明。</li>
<li><em>const</em> 用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改，无变量提升，不可以重复声明。</li>
</ol>
</blockquote>
<h3 id="56-闭包、作用域（可以扩充到作用域链）"><a href="#56-闭包、作用域（可以扩充到作用域链）" class="headerlink" title="56. 闭包、作用域（可以扩充到作用域链）"></a>56. 闭包、作用域（可以扩充到作用域链）</h3><blockquote>
<p>参考答案：</p>
<p><strong>什么是作业域?</strong></p>
<p>ES5 中只存在两种作用域：全局作用域和函数作用域。在 JavaScript 中，我们将作用域定义为一套规则，这套规则用来管理引擎如何在当前作用域以及嵌套子作用域中根据标识符名称进行变量(变量名或者函数名)查找。</p>
<p><strong>什么是作用域链?</strong></p>
<p>当访问一个变量时，编译器在执行这段代码时，会首先从当前的作用域中查找是否有这个标识符，如果没有找到，就会去父作用域查找，如果父作用域还没找到继续向上查找，直到全局作用域为止,，而作用域链，就是有当前作用域与上层作用域的一系列变量对象组成，它保证了当前执行的作用域对符合访问权限的变量和函数的有序访问。</p>
<p><strong>闭包产生的本质</strong></p>
<p>当前环境中存在指向父级作用域的引用</p>
<p><strong>什么是闭包</strong></p>
<p>闭包是一种特殊的对象，它由两部分组成：执行上下文(代号 A)，以及在该执行上下文中创建的函数 (代号 B)，当 B 执行时，如果访问了 A 中变量对象的值，那么闭包就会产生，且在 Chrome 中使用这个执行上下文 A 的函数名代指闭包。</p>
<p><strong>一般如何产生闭包</strong></p>
<ul>
<li>返回函数</li>
<li>函数当做参数传递</li>
</ul>
<p><strong>闭包的应用场景</strong></p>
<ul>
<li>柯里化 bind</li>
<li>模块</li>
</ul>
</blockquote>
<h3 id="57-Promise"><a href="#57-Promise" class="headerlink" title="57. Promise"></a>57. <em>Promise</em></h3><blockquote>
<p>参考答案：</p>
<p><em>Promise</em> 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理且更强大。它最早由社区提出并实现，<em>ES6</em>将其写进了语言标准，统一了用法，并原生提供了<em>Promise</em>对象。</p>
<p><strong>特点</strong></p>
<ol>
<li><p>对象的状态不受外界影响 （<em>3</em> 种状态）</p>
<ul>
<li><p><em>Pending</em> 状态（进行中）</p>
</li>
<li><p><em>Fulfilled</em> 状态（已成功）</p>
</li>
<li><p><em>Rejected</em> 状态（已失败）</p>
</li>
</ul>
</li>
<li><p>一旦状态改变就不会再变 （两种状态改变：成功或失败）</p>
<ul>
<li><em>Pending</em> -&gt; <em>Fulfilled</em></li>
<li><em>Pending</em> -&gt; <em>Rejected</em></li>
</ul>
</li>
</ol>
<p><strong>用法</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ... some code</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>) &#123;</span><br><span class="line">        resolve(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="58-实现一个函数-对一个url进行请求-失败就再次请求-超过最大次数就走失败回调-任何一次成功都走成功回调"><a href="#58-实现一个函数-对一个url进行请求-失败就再次请求-超过最大次数就走失败回调-任何一次成功都走成功回调" class="headerlink" title="58. 实现一个函数,对一个url进行请求,失败就再次请求,超过最大次数就走失败回调,任何一次成功都走成功回调"></a>58. 实现一个函数,对一个url进行请求,失败就再次请求,超过最大次数就走失败回调,任何一次成功都走成功回调</h3><blockquote>
<p>参考答案：</p>
<p>示例代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    <span class="doctag">@params </span>url: 请求接口地址;</span></span><br><span class="line"><span class="comment">    <span class="doctag">@params </span>body: 设置的请求体;</span></span><br><span class="line"><span class="comment">    <span class="doctag">@params </span>succ: 请求成功后的回调</span></span><br><span class="line"><span class="comment">    <span class="doctag">@params </span>error: 请求失败后的回调</span></span><br><span class="line"><span class="comment">    <span class="doctag">@params </span>maxCount: 设置请求的数量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url, body, succ, error, maxCount = <span class="number">5</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fetch(url, body)</span><br><span class="line">        .then(<span class="function"><span class="params">res</span> =&gt;</span> succ(res))</span><br><span class="line">        .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxCount &lt;= <span class="number">0</span>) <span class="keyword">return</span> error(<span class="string">&#x27;请求超时&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span> request(url, body, succ, error, --maxCount);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用请求函数</span></span><br><span class="line">request(<span class="string">&#x27;https://java.some.com/pc/reqCount&#x27;</span>, &#123; <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>, <span class="attr">headers</span>: &#123;&#125; &#125;,</span><br><span class="line">    <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res.data);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="59-冒泡排序"><a href="#59-冒泡排序" class="headerlink" title="59. 冒泡排序"></a>59. 冒泡排序</h3><blockquote>
<p>参考答案：</p>
<p>冒泡排序的核心思想是：</p>
<ol>
<li>比较相邻的两个元素，如果前一个比后一个大或者小（取决于排序的顺序是小到大还是大到小），则交换位置。</li>
<li>比较完第一轮的时候，最后一个元素是最大或最小的元素。</li>
<li>这时候最后一个元素已经是最大或最小的了，所以下一次冒泡的时候最后一个元素不需要参与比较。</li>
</ol>
<p>示例代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = arr.length;</span><br><span class="line">    <span class="comment">// 外层 for 循环控制冒泡的次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="comment">// 内层 for 循环控制每一次冒泡需要比较的次数</span></span><br><span class="line">            <span class="comment">// 因为之后每一次冒泡的两两比较次数会越来越少，所以 -i</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">var</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//举个数组</span></span><br><span class="line">myArr = [<span class="number">20</span>, -<span class="number">1</span>, <span class="number">27</span>, -<span class="number">7</span>, <span class="number">35</span>];</span><br><span class="line"><span class="comment">//使用函数</span></span><br><span class="line"><span class="built_in">console</span>.log(bSort(myArr)); <span class="comment">// [ -7, -1, 20, 27, 35 ]</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="60-数组降维"><a href="#60-数组降维" class="headerlink" title="60. 数组降维"></a>60. 数组降维</h3><blockquote>
<p>参考答案：</p>
<p>数组降维就是将一个嵌套多层的数组进行降维操作，也就是对数组进行扁平化。在 <em>ES5</em> 时代我们需要自己手写方法或者借助函数库来完成，但是现在可以使用 <em>ES6</em> 新提供的数组方法 <em>flat</em> 来完成数组降维操作。</p>
</blockquote>
<blockquote>
<p>解析：使用 <em>flat</em> 方法会接收一个参数，这个参数是数值类型，是要处理扁平化数组的深度，生成后的新数组是独立存在的，不会对原数组产生影响。</p>
<p><em>flat</em> 方法的语法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newArray = arr.flat([depth])</span><br></pre></td></tr></table></figure>

<p>其中 <em>depth</em> 指定要提取嵌套数组结构的深度，默认值为 <em>1</em>。</p>
<p>示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>]]];</span><br><span class="line"><span class="built_in">console</span>.log(arr.flat());      <span class="comment">// [1, 2, 3, 4, [5, 6]]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.flat(<span class="number">2</span>));     <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>

<p>上面的代码定义了一个层嵌套的数组，默认情况下只会拍平一层数组，也就是把原来的三维数组降低到了二维数组。在传入的参数为 <em>2</em> 时，则会降低两维，成为一个一维数组。</p>
<p>使用 <em>Infinity</em>，可展开任意深度的嵌套数组，示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>, [<span class="number">7</span>, <span class="number">8</span>]]]];</span><br><span class="line"><span class="built_in">console</span>.log(arr.flat(<span class="literal">Infinity</span>));  <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure>

<p>在数组中有空项的时候，使用 <em>flat</em> 方法会将中的空项进行移除。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, , <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.flat()); <span class="comment">// [1, 2, 4, 5]</span></span><br></pre></td></tr></table></figure>

<p>上面的代码中，数组中第三项是空值，在使用 <em>flat</em> 后会对空项进行移除。</p>
</blockquote>
<h3 id="61-call-apply-bind"><a href="#61-call-apply-bind" class="headerlink" title="61. call apply bind"></a>61. <em>call apply bind</em></h3><blockquote>
<p>参考答案：</p>
<p>请参阅前面第 <em>11</em> 题答案。</p>
</blockquote>
<h3 id="62-promise-代码题"><a href="#62-promise-代码题" class="headerlink" title="62. promise 代码题"></a>62. promise 代码题</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    resolve(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(res) &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">res</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;reject1&#x27;</span>) &#125;)</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&#x27;error&#x27;</span></span><br><span class="line">    &#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(res) &#125;)</span><br><span class="line">        .catch(<span class="function"><span class="params">res</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;reject2&#x27;</span>) &#125;)</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考答案：</p>
<p>2<br>4<br>reject1<br>reject2</p>
<p>直播课或者录播课进行解析。</p>
</blockquote>
<h3 id="63-proxy-是实现代理，可以改变-js-底层的实现方式-然后说了一下和-Object-defineProperty-的区别"><a href="#63-proxy-是实现代理，可以改变-js-底层的实现方式-然后说了一下和-Object-defineProperty-的区别" class="headerlink" title="63. proxy 是实现代理，可以改变 js 底层的实现方式, 然后说了一下和 Object.defineProperty 的区别"></a>63. <em>proxy</em> 是实现代理，可以改变 <em>js</em> 底层的实现方式, 然后说了一下和 <em>Object.defineProperty</em> 的区别</h3><blockquote>
<p>参考答案：</p>
<p>两者的区别总结如下：</p>
<ul>
<li>代理原理：Object.defineProperty的原理是通过将数据属性转变为存取器属性的方式实现的属性读写代理。而Proxy则是因为这个内置的Proxy对象内部有一套监听机制，在传入handler对象作为参数构造代理对象后，一旦代理对象的某个操作触发，就会进入handler中对应注册的处理函数，此时我们就可以有选择的使用Reflect将操作转发被代理对象上。</li>
<li>代理局限性：Object.defineProperty始终还是局限于属性层面的读写代理，对于对象层面以及属性的其它操作代理它都无法实现。鉴于此，由于数组对象push、pop等方法的存在，它对于数组元素的读写代理实现的并不完全。而使用Proxy则可以很方便的监视数组操作。</li>
<li>自我代理：Object.defineProperty方式可以代理到自身（代理之后使用对象本身即可），也可以代理到别的对象身上（代理之后需要使用代理对象）。Proxy方式只能代理到Proxy实例对象上。这一点在其它说法中是Proxy对象不需要侵入对象就可以实现代理，实际上Object.defineProperty方式也可以不侵入。</li>
</ul>
</blockquote>
<h3 id="64-使用-ES5-与-ES6-分别实现继承"><a href="#64-使用-ES5-与-ES6-分别实现继承" class="headerlink" title="64. 使用 ES5 与 ES6 分别实现继承"></a>64. 使用 <em>ES5</em> 与 <em>ES6</em> 分别实现继承</h3><blockquote>
<p>参考答案：</p>
<p>如果是使用 <em>ES5</em> 来实现继承，那么现在的最优解是使用圣杯模式。圣杯模式的核心思想就是不通过调用父类构造函数来给子类原型赋值，而是取得父类原型的一个副本，然后将返回的新对象赋值给子类原型。具体代码可以参阅前面第 <em>9</em> 题的解析。</p>
<p><em>ES6</em> 新增了 <em>extends</em> 关键字，直接使用该关键字就能够实现继承。</p>
</blockquote>
<h3 id="65-深拷贝"><a href="#65-深拷贝" class="headerlink" title="65. 深拷贝"></a>65. 深拷贝</h3><blockquote>
<p>参考答案：</p>
<p>有深拷贝就有浅拷贝。</p>
<p>浅拷贝就是只拷贝对象的引用，而不深层次的拷贝对象的值，多个对象指向堆内存中的同一对象，任何一个修改都会使得所有对象的值修改，因为它们共用一条数据。</p>
<p>深拷贝不是单纯的拷贝一份引用数据类型的引用地址，而是将引用类型的值全部拷贝一份，形成一个新的引用类型，这样就不会发生引用错乱的问题，使得我们可以多次使用同样的数据，而不用担心数据之间会起冲突。</p>
</blockquote>
<blockquote>
<p>解析：</p>
<p>「深拷贝」就是在拷贝数据的时候，将数据的所有<strong>引用结构</strong>都拷贝一份。简单的说就是，在内存中存在两个数据结构完全相同又相互独立的数据，将引用型类型进行复制，而不是只复制其引用关系。</p>
<p>分析下怎么做「深拷贝」：</p>
<ol>
<li>首先假设深拷贝这个方法已经完成，为 deepClone</li>
<li>要拷贝一个数据，我们肯定要去遍历它的属性，如果这个对象的属性仍是对象，继续使用这个方法，如此往复</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function deepClone(o1, o2) &#123;</span><br><span class="line">    for (let k in o2) &#123;</span><br><span class="line">        if (typeof o2[k] === &#x27;object&#x27;) &#123;</span><br><span class="line">            o1[k] = &#123;&#125;;</span><br><span class="line">            deepClone(o1[k], o2[k]);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            o1[k] = o2[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 测试用例</span><br><span class="line">let obj = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: [1, 2, 3],</span><br><span class="line">    c: &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">let emptyObj = Object.create(null);</span><br><span class="line">deepClone(emptyObj, obj);</span><br><span class="line">console.log(emptyObj.a == obj.a);</span><br><span class="line">console.log(emptyObj.b == obj.b);</span><br></pre></td></tr></table></figure>

<p>递归容易造成爆栈，尾部调用可以解决递归的这个问题，<em>Chrome</em> 的 <em>V8</em> 引擎做了尾部调用优化，我们在写代码的时候也要注意尾部调用写法。递归的爆栈问题可以通过将递归改写成枚举的方式来解决，就是通过 <em>for</em> 或者 <em>while</em> 来代替递归。</p>
</blockquote>
<h3 id="66-async-与-await-的作用"><a href="#66-async-与-await-的作用" class="headerlink" title="66. async 与 await 的作用"></a>66. <em>async</em> 与 <em>await</em> 的作用</h3><blockquote>
<p>参考答案：</p>
<p><em>async</em> 是一个修饰符，<em>async</em> 定义的函数会默认的返回一个 <em>Promise</em> 对象 <em>resolve</em> 的值，因此对 <em>async</em> 函数可以直接进行 <em>then</em> 操作，返回的值即为 <em>then</em> 方法的传入函数。</p>
<p><em>await</em> 关键字只能放在 <em>async</em> 函数内部， <em>await</em> 关键字的作用就是获取 <em>Promise</em> 中返回的内容， 获取的是 <em>Promise</em> 函数中 <em>resolve</em> 或者 <em>reject</em> 的值。</p>
</blockquote>
<h3 id="67-数据的基础类型（原始类型）有哪些"><a href="#67-数据的基础类型（原始类型）有哪些" class="headerlink" title="67. 数据的基础类型（原始类型）有哪些"></a>67. 数据的基础类型（原始类型）有哪些</h3><blockquote>
<p>参考答案：</p>
<p><em>JavaScript</em> 中的基础数据类型，一共有 <em>6</em> 种：</p>
<p><em>string，symbol，number，boolean，undefined，null</em></p>
<p>其中 <em>symbol</em> 类型是在 <em>ES6</em> 里面新添加的基本数据类型。</p>
</blockquote>
<h3 id="68-typeof-null-返回结果"><a href="#68-typeof-null-返回结果" class="headerlink" title="68. typeof null 返回结果"></a>68. <em>typeof null</em> 返回结果</h3><blockquote>
<p>参考答案：</p>
<p>返回 <em>object</em></p>
</blockquote>
<blockquote>
<p>解析：至于为什么会返回 <em>object</em>，这实际上是来源于 <em>JavaScript</em> 从第一个版本开始时的一个 <em>bug</em>，并且这个 <em>bug</em> 无法被修复。修复会破坏现有的代码。</p>
<p>原理这是这样的，不同的对象在底层都表现为二进制，在 <em>JavaScript</em> 中二进制前三位都为 <em>0</em> 的话会被判断为 <em>object</em> 类型，<em>null</em> 的二进制全部为 <em>0</em>，自然前三位也是 <em>0</em>，所以执行 <em>typeof</em> 值会返回 <em>object</em>。</p>
</blockquote>
<h3 id="69-对变量进行类型判断的方式有哪些"><a href="#69-对变量进行类型判断的方式有哪些" class="headerlink" title="69. 对变量进行类型判断的方式有哪些"></a>69. 对变量进行类型判断的方式有哪些</h3><blockquote>
<p>参考答案：</p>
<p>常用的方法有 <em>4</em> 种：</p>
<ol>
<li><em>typeof</em></li>
</ol>
<p><em>typeof</em> 是一个操作符，其右侧跟一个一元表达式，并返回这个表达式的数据类型。返回的结果用该类型的字符串(全小写字母)形式表示，包括以下 <em>7</em> 种：<em>number、boolean、symbol、string、object、undefined、function</em> 等。</p>
<ol start="2">
<li><em>instanceof</em></li>
</ol>
<p><em>instanceof</em> 是用来判断 <em>A</em> 是否为 <em>B</em> 的实例，表达式为：<em>A instanceof B</em>，如果 <em>A</em> 是 <em>B</em> 的实例，则返回 <em>true</em>,否则返回 <em>false</em>。 在这里需要特别注意的是：<em>instanceof</em> 检测的是原型。</p>
<ol start="3">
<li><em>constructor</em></li>
</ol>
<p>当一个函数 <em>F</em> 被定义时，<em>JS</em> 引擎会为 <em>F</em> 添加 <em>prototype</em> 原型，然后再在 <em>prototype</em> 上添加一个 <em>constructor</em> 属性，并让其指向 <em>F</em> 的引用。</p>
<ol start="4">
<li><em>toString</em></li>
</ol>
<p><em>toString( )</em> 是 <em>Object</em> 的原型方法，调用该方法，默认返回当前对象的 <em>[[Class]]</em> 。这是一个内部属性，其格式为 <em>[object Xxx]</em> ，其中 <em>Xxx</em> 就是对象的类型。</p>
<p>对于 <em>Object</em> 对象，直接调用 <em>toString( )</em> 就能返回 <em>[object Object]</em> 。而对于其他对象，则需要通过 <em>call / apply</em> 来调用才能返回正确的类型信息。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">&#x27;&#x27;</span>) ;  <span class="comment">// [object String]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">1</span>) ;   <span class="comment">// [object Number]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>) ;<span class="comment">// [object Boolean]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Symbol</span>());<span class="comment">//[object Symbol]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>) ;<span class="comment">// [object Undefined]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>) ;<span class="comment">// [object Null]</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="70-typeof-与-instanceof-的区别？-instanceof-是如何实现？"><a href="#70-typeof-与-instanceof-的区别？-instanceof-是如何实现？" class="headerlink" title="70. typeof 与 instanceof 的区别？ instanceof 是如何实现？"></a>70. <em>typeof</em> 与 <em>instanceof</em> 的区别？ <em>instanceof</em> 是如何实现？</h3><blockquote>
<p>参考答案：</p>
<ol>
<li><em>typeof</em></li>
</ol>
<p><em>typeof</em> 是一个操作符，其右侧跟一个一元表达式，并返回这个表达式的数据类型。返回的结果用该类型的字符串(全小写字母)形式表示，包括以下 <em>7</em> 种：<em>number、boolean、symbol、string、object、undefined、function</em> 等。</p>
<ol start="2">
<li><em>instanceof</em></li>
</ol>
<p><em>instanceof</em> 是用来判断 <em>A</em> 是否为 <em>B</em> 的实例，表达式为：<em>A instanceof B</em>，如果 <em>A</em> 是 <em>B</em> 的实例，则返回 <em>true</em>,否则返回 <em>false</em>。 在这里需要特别注意的是：<em>instanceof</em> 检测的是原型。</p>
<p>用一段伪代码来模拟其内部执行过程：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">instanceof</span> (A,B) = &#123;</span><br><span class="line">    varL = A.__proto__;</span><br><span class="line">    varR = B.prototype;</span><br><span class="line">    <span class="keyword">if</span>(L === R) &#123;</span><br><span class="line">        <span class="comment">// A的内部属性 __proto__ 指向 B 的原型对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上述过程可以看出，当 <em>A</em> 的 _<em><em>proto</em></em>_ 指向 <em>B</em> 的 <em>prototype</em> 时，就认为 <em>A</em> 就是 <em>B</em> 的实例。</p>
<p>需要注意的是，<em>instanceof</em> 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。</p>
<p>例如：*[ ] instanceof Object* 返回的也会是 <em>true</em>。</p>
</blockquote>
<h3 id="71-引用类型有哪些，有什么特点"><a href="#71-引用类型有哪些，有什么特点" class="headerlink" title="71. 引用类型有哪些，有什么特点"></a>71. 引用类型有哪些，有什么特点</h3><blockquote>
<p>参考答案：</p>
<p>JS 中七种内置类型（<em>null，undefined，boolean，number，string，symbol，object</em>）又分为两大类型</p>
<p>两大类型：</p>
<ul>
<li>基本类型： <code>null</code>，<code>undefined</code>，<code>boolean</code>，<code>number</code>，<code>string</code>，<code>symbol</code></li>
<li>引用类型Object： <code>Array</code> ，<code>Function</code>， <code>Date</code>， <code>RegExp</code>等</li>
</ul>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-08-13-073833.png" alt="image-20210813153833385" style="zoom:50%;" />

<p>基本类型和引用类型的主要区别有以下几点：</p>
<p><strong>存放位置：</strong></p>
<ul>
<li>基本数据类型：基本类型值在内存中占据固定大小，直接存储在<strong>栈内存</strong>中的数据</li>
<li>引用数据类型：引用类型在栈中存储了指针，这个指针指向堆内存中的地址，真实的数据存放在<strong>堆内存</strong>里。</li>
</ul>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-08-13-074040.png" alt="image-20210813154040287" style="zoom:50%;" />

<p><strong>值的可变性：</strong></p>
<ul>
<li><p>基本数据类型： 值不可变，<em>javascript</em> 中的原始值（<em>undefined、null</em>、布尔值、数字和字符串）是不可更改的</p>
</li>
<li><p>引用数据类型：引用类型是可以直接改变其值的</p>
</li>
</ul>
<p><strong>比较：</strong></p>
<ul>
<li><p>基本数据类型： 基本类型的比较是值的比较，只要它们的值相等就认为他们是相等的</p>
</li>
<li><p>引用数据类型： 引用数据类型的比较是引用的比较，看其的引用是否指向同一个对象</p>
</li>
</ul>
</blockquote>
<h3 id="72-如何得到一个变量的类型—指函数封装实现"><a href="#72-如何得到一个变量的类型—指函数封装实现" class="headerlink" title="72. 如何得到一个变量的类型—指函数封装实现"></a>72. 如何得到一个变量的类型—指函数封装实现</h3><blockquote>
<p>参考答案：</p>
<p>请参阅前面第 <em>30</em> 题答案。</p>
</blockquote>
<h3 id="73-什么是作用域、闭包"><a href="#73-什么是作用域、闭包" class="headerlink" title="73. 什么是作用域、闭包"></a>73. 什么是作用域、闭包</h3><blockquote>
<p>参考答案：</p>
<p>请参阅前面第 <em>56</em> 题。</p>
</blockquote>
<h3 id="74-闭包的缺点是什么？闭包的应用场景有哪些？怎么销毁闭包？"><a href="#74-闭包的缺点是什么？闭包的应用场景有哪些？怎么销毁闭包？" class="headerlink" title="74. 闭包的缺点是什么？闭包的应用场景有哪些？怎么销毁闭包？"></a>74. 闭包的缺点是什么？闭包的应用场景有哪些？怎么销毁闭包？</h3><blockquote>
<p>参考答案：</p>
<p>闭包是指有权访问另外一个函数作用域中的变量的函数。</p>
<p>因为闭包引用着另一个函数的变量，导致另一个函数已经不使用了也无法销毁，所以<strong>闭包使用过多，会占用较多的内存，这也是一个副作用，内存泄漏。</strong></p>
<p>如果要销毁一个闭包，可以 把被引用的变量设置为<em>null</em>，即手动清除变量，这样下次 <em>js</em> 垃圾回收机制回收时，就会把设为 <em>null</em> 的量给回收了。</p>
<p>闭包的应用场景：</p>
<ol>
<li>匿名自执行函数</li>
<li>结果缓存</li>
<li>封装</li>
<li>实现类和继承</li>
</ol>
</blockquote>
<h3 id="75-JS的垃圾回收站机制"><a href="#75-JS的垃圾回收站机制" class="headerlink" title="75. JS的垃圾回收站机制"></a>75. <em>JS</em>的垃圾回收站机制</h3><blockquote>
<p>参考答案：</p>
<p><em>JS</em> 具有自动垃圾回收机制。垃圾收集器会按照固定的时间间隔周期性的执行。</p>
<p><em>JS</em> 常见的垃圾回收方式：标记清除、引用计数方式。</p>
<p>1、标记清除方式：</p>
<ul>
<li><p>工作原理：当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。</p>
</li>
<li><p>工作流程：</p>
</li>
<li><p>垃圾回收器，在运行的时候会给存储在内存中的所有变量都加上标记；</p>
</li>
<li><p>去掉环境中的变量以及被环境中的变量引用的变量的标记；</p>
</li>
<li><p>被加上标记的会被视为准备删除的变量；</p>
</li>
<li><p>垃圾回收器完成内存清理工作，销毁那些带标记的值并回收他们所占用的内存空间。</p>
</li>
</ul>
<p>2、引用计数方式：</p>
<ul>
<li><p>工作原理：跟踪记录每个值被引用的次数。</p>
</li>
<li><p>工作流程：</p>
</li>
<li><p>声明了一个变量并将一个引用类型的值赋值给这个变量，这个引用类型值的引用次数就是 <em>1</em>；</p>
</li>
<li><p>同一个值又被赋值给另一个变量，这个引用类型值的引用次数加1；</p>
</li>
<li><p>当包含这个引用类型值的变量又被赋值成另一个值了，那么这个引用类型值的引用次数减 <em>1</em>；</p>
</li>
<li><p>当引用次数变成 <em>0</em> 时，说明没办法访问这个值了；</p>
</li>
<li><p>当垃圾收集器下一次运行时，它就会释放引用次数是0的值所占的内存。</p>
</li>
</ul>
</blockquote>
<h3 id="76-什么是作用域链、原型链"><a href="#76-什么是作用域链、原型链" class="headerlink" title="76. 什么是作用域链、原型链"></a>76. 什么是作用域链、原型链</h3><blockquote>
<p>参考答案：</p>
<p><strong>什么是作用域链?</strong></p>
<p>当访问一个变量时，编译器在执行这段代码时，会首先从当前的作用域中查找是否有这个标识符，如果没有找到，就会去父作用域查找，如果父作用域还没找到继续向上查找，直到全局作用域为止,，而作用域链，就是有当前作用域与上层作用域的一系列变量对象组成，它保证了当前执行的作用域对符合访问权限的变量和函数的有序访问。</p>
<p><strong>什么原型链?</strong></p>
<p>每个对象都可以有一个原型__<em>proto</em>__，这个原型还可以有它自己的原型，以此类推，形成一个原型链。查找特定属性的时候，我们先去这个对象里去找，如果没有的话就去它的原型对象里面去，如果还是没有的话再去向原型对象的原型对象里去寻找。这个操作被委托在整个原型链上，这个就是我们说的原型链。</p>
</blockquote>
<h3 id="77-new-一个构造函数发生了什么"><a href="#77-new-一个构造函数发生了什么" class="headerlink" title="77. new 一个构造函数发生了什么"></a>77. <em>new</em> 一个构造函数发生了什么</h3><blockquote>
<p>参考答案：</p>
<p><em>new</em> 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。</p>
<p><em>new</em> 关键字会进行如下的操作：<br>步骤 <em>1</em>：创建一个空的简单 <em>JavaScript</em> 对象，即 { } ;<br>步骤 <em>2</em>：链接该对象到另一个对象（即设置该对象的原型对象）；<br>步骤 <em>3</em>：将步骤 <em>1</em> 新创建的对象作为 <em>this</em> 的上下文；<br>步骤 <em>4</em>：如果该函数没有返回对象，则返回 <em>this</em>。</p>
</blockquote>
<h3 id="78-对一个构造函数实例化后-它的原型链指向什么"><a href="#78-对一个构造函数实例化后-它的原型链指向什么" class="headerlink" title="78. 对一个构造函数实例化后. 它的原型链指向什么"></a>78. 对一个构造函数实例化后. 它的原型链指向什么</h3><blockquote>
<p>参考答案：</p>
<p>指向该构造函数实例化出来对象的原型对象。</p>
<p>对于构造函数来讲，可以通过 <em>prototype</em> 访问到该对象。</p>
<p>对于实例对象来讲，可以通过隐式属性 _<em><em>proto</em></em>_ 来访问到。</p>
</blockquote>
<h3 id="79-什么是变量提升"><a href="#79-什么是变量提升" class="headerlink" title="79. 什么是变量提升"></a>79. 什么是变量提升</h3><blockquote>
<p>参考答案：</p>
<p>当 <em>JavaScript</em> 编译所有代码时，所有使用 <em>var</em> 的变量声明都被提升到它们的函数/局部作用域的顶部(如果在函数内部声明的话)，或者提升到它们的全局作用域的顶部(如果在函数外部声明的话)，而不管实际的声明是在哪里进行的。这就是我们所说的“提升”。</p>
<p>请记住，这种“提升”实际上并不发生在你的代码中，而只是一种比喻，与 <em>JavaScript</em> 编译器如何读取你的代码有关。记住当我们想到“提升”的时候，我们可以想象任何被提升的东西都会被移动到顶部，但是实际上你的代码并不会被修改。</p>
<p>函数声明也会被提升，但是被提升到了最顶端，所以将位于所有变量声明之上。</p>
<p>在编译阶段变量和函数声明会被放入内存中，但是你在代码中编写它们的位置会保持不变。</p>
</blockquote>
<h3 id="80-和-的区别是什么"><a href="#80-和-的区别是什么" class="headerlink" title="80. == 和 === 的区别是什么"></a>80. == 和 === 的区别是什么</h3><blockquote>
<p>参考答案：</p>
<p>简单来说： == 代表相同， === 代表严格相同（数据类型和值都相等）。</p>
<p>当进行双等号比较时候，先检查两个操作数数据类型，如果相同，则进行===比较，如果不同，则愿意为你进行一次类型转换，转换成相同类型后再进行比较，而 === 比较时，如果类型不同，直接就是false。</p>
<p>从这个过程来看，大家也能发现，某些情况下我们使用 === 进行比较效率要高些，因此，没有歧义的情况下，不会影响结果的情况下，在 <em>JS</em> 中首选 === 进行逻辑比较。</p>
</blockquote>
<h3 id="81-Object-is-方法比较的是什么"><a href="#81-Object-is-方法比较的是什么" class="headerlink" title="81. Object.is 方法比较的是什么"></a>81. <em>Object.is</em> 方法比较的是什么</h3><blockquote>
<p>参考答案：</p>
<p><em>Object.is</em> 方法是 <em>ES6</em> 新增的用来比较两个值是否严格相等的方法，与 === (严格相等)的行为基本一致。不过有两处不同：</p>
<ul>
<li>+0 不等于 -0。</li>
<li><em>NaN</em> 等于自身。</li>
</ul>
<p>所以可以将<em>Object.is</em> 方法看作是加强版的严格相等。</p>
</blockquote>
<h3 id="82-基础数据类型和引用数据类型，哪个是保存在栈内存中？哪个是在堆内存中？"><a href="#82-基础数据类型和引用数据类型，哪个是保存在栈内存中？哪个是在堆内存中？" class="headerlink" title="82. 基础数据类型和引用数据类型，哪个是保存在栈内存中？哪个是在堆内存中？"></a>82. 基础数据类型和引用数据类型，哪个是保存在栈内存中？哪个是在堆内存中？</h3><blockquote>
<p>参考答案：</p>
<p>在 <em>ECMAScript</em> 规范中，共定义了 <em>7</em> 种数据类型，分为 <strong>基本类型</strong> 和 <strong>引用类型</strong> 两大类，如下所示：</p>
<ul>
<li><p><strong>基本类型</strong>：<em>String、Number、Boolean、Symbol、Undefined、Null</em> </p>
</li>
<li><p><strong>引用类型</strong>：<em>Object</em></p>
</li>
</ul>
<p>基本类型也称为简单类型，由于其占据空间固定，是简单的数据段，为了便于提升变量查询速度，将其存储在栈中，即按值访问。</p>
<p>引用类型也称为复杂类型，由于其值的大小会改变，所以不能将其存放在栈中，否则会降低变量查询速度，因此，其值存储在堆(<em>heap</em>)中，而存储在变量处的值，是一个指针，指向存储对象的内存处，即按址访问。引用类型除 <em>Object</em> 外，还包括 <em>Function 、Array、RegExp、Date</em> 等等。</p>
</blockquote>
<h3 id="83-箭头函数解决了什么问题？"><a href="#83-箭头函数解决了什么问题？" class="headerlink" title="83. 箭头函数解决了什么问题？"></a>83. 箭头函数解决了什么问题？</h3><blockquote>
<p>参考答案：</p>
<p>箭头函数主要解决了 <em>this</em> 的指向问题。</p>
</blockquote>
<blockquote>
<p>解析：</p>
<p>在 <em>ES5</em> 时代，一旦对象的方法里面又存在函数，则 <em>this</em> 的指向往往会让开发人员抓狂。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//错误案例，this 指向会指向 Windows 或者 undefined</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">getAge</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> a = <span class="built_in">this</span>.age; <span class="comment">// 18</span></span><br><span class="line">        <span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear() - <span class="built_in">this</span>.age; <span class="comment">// this 指向 window 或 undefined</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> fn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.getAge()); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<p>然而，箭头函数没有 <em>this</em>，箭头函数的 <em>this</em> 是继承父执行上下文里面的 <em>this</em></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">getAge</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> a = <span class="built_in">this</span>.age; <span class="comment">// 18</span></span><br><span class="line">        <span class="keyword">var</span> fn = <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear() - <span class="built_in">this</span>.age; <span class="comment">// this 指向 obj 对象</span></span><br><span class="line">        <span class="keyword">return</span> fn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.getAge()); <span class="comment">// 2003</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="84-new-一个箭头函数后，它的-this-指向什么？"><a href="#84-new-一个箭头函数后，它的-this-指向什么？" class="headerlink" title="84. new 一个箭头函数后，它的 this 指向什么？"></a>84. <em>new</em> 一个箭头函数后，它的 <em>this</em> 指向什么？</h3><blockquote>
<p>参考答案：</p>
<p>我不知道这道题是出题人写错了还是故意为之。</p>
<p>箭头函数无法用来充当构造函数，所以是无法 <em>new</em> 一个箭头函数的。</p>
<p>当然，也有可能是面试官故意挖的一个坑，等着你往里面跳。</p>
</blockquote>
<h3 id="85-promise-的其他方法有用过吗？如-all、race。请说下这两者的区别"><a href="#85-promise-的其他方法有用过吗？如-all、race。请说下这两者的区别" class="headerlink" title="85. promise 的其他方法有用过吗？如 all、race。请说下这两者的区别"></a>85. <em>promise</em> 的其他方法有用过吗？如 <em>all、race</em>。请说下这两者的区别</h3><blockquote>
<p>参考答案：</p>
<p><em>promise.all</em> 方法参数是一个 <em>promise</em> 的数组,只有当所有的 <em>promise</em> 都完成并返回成功，才会调用 <em>resolve</em>，当有一个失败，都会进<em>catch</em>，被捕获错误，<em>promise.all</em> 调用成功返回的结果是每个 <em>promise</em> 单独调用成功之后返回的结果组成的数组,如果调用失败的话，返回的则是第一个 <em>reject</em> 的结果</p>
<p><em>promise.race</em> 也会调用所有的 <em>promise</em>，返回的结果则是所有 <em>promise</em> 中最先返回的结果，不关心是成功还是失败。</p>
</blockquote>
<h3 id="86-class-是如何实现的"><a href="#86-class-是如何实现的" class="headerlink" title="86. class 是如何实现的"></a>86. <em>class</em> 是如何实现的</h3><blockquote>
<p>参考答案：</p>
<p><em>class</em> 是 <em>ES6</em> 新推出的关键字，它是一个语法糖，本质上就是基于这个原型实现的。只不过在以前 <em>ES5</em> 原型实现的基础上，添加了一些 <em>_classCallCheck、_defineProperties、_createClass</em>等方法来做出了一些特殊的处理。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;<span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="title">constructor</span>(<span class="params">x</span>)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.x = x;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="title">greet</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">&quot;Hello, &quot;</span> + <span class="built_in">this</span>.x)</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;<span class="string">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="keyword">function</span> <span class="title">_classCallCheck</span>(<span class="params">instance, Constructor</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (!(instance <span class="keyword">instanceof</span> Constructor)) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Cannot call a class as a function&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="keyword">function</span> <span class="title">_defineProperties</span>(<span class="params">target, props</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; props.length; i++) &#123;</span><br><span class="line">         <span class="keyword">var</span> descriptor = props[i];</span><br><span class="line">         descriptor.enumerable = descriptor.enumerable || <span class="literal">false</span>;</span><br><span class="line">         descriptor.configurable = <span class="literal">true</span>;</span><br><span class="line">         <span class="keyword">if</span> (<span class="string">&quot;value&quot;</span> <span class="keyword">in</span> descriptor)</span><br><span class="line">             descriptor.writable = <span class="literal">true</span>;</span><br><span class="line">         <span class="built_in">Object</span>.defineProperty(target, descriptor.key, descriptor);</span><br><span class="line">     &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="keyword">function</span> <span class="title">_createClass</span>(<span class="params">Constructor, protoProps, staticProps</span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&quot;Constructor::&quot;</span>,Constructor);</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&quot;protoProps::&quot;</span>,protoProps);</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&quot;staticProps::&quot;</span>,staticProps);</span><br><span class="line">     <span class="keyword">if</span> (protoProps)</span><br><span class="line">         _defineProperties(Constructor.prototype, protoProps);</span><br><span class="line">     <span class="keyword">if</span> (staticProps)</span><br><span class="line">         _defineProperties(Constructor, staticProps);</span><br><span class="line">     <span class="keyword">return</span> Constructor;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">var</span> Hello = <span class="comment">/*#__PURE__*/</span><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">Hello</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">       _classCallCheck(<span class="built_in">this</span>, Hello);</span><br><span class="line"></span><br><span class="line">       <span class="built_in">this</span>.x = x;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   _createClass(Hello, [&#123;</span><br><span class="line">       <span class="attr">key</span>: <span class="string">&quot;greet&quot;</span>,</span><br><span class="line">       <span class="attr">value</span>: <span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">&quot;Hello, &quot;</span> + <span class="built_in">this</span>.x);</span><br><span class="line">       &#125;</span><br><span class="line"> 	&#125;]);</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">return</span> Hello;</span><br><span class="line">&gt;&#125;();</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="87-let、const、var-的区别"><a href="#87-let、const、var-的区别" class="headerlink" title="87. let、const、var 的区别"></a>87. <em>let、const、var</em> 的区别</h3><blockquote>
<p>参考答案：</p>
<p>请参阅前面第 <em>22</em> 题答案。</p>
</blockquote>
<h3 id="88-ES6-中模块化导入和导出与-common-js-有什么区别"><a href="#88-ES6-中模块化导入和导出与-common-js-有什么区别" class="headerlink" title="88. ES6 中模块化导入和导出与 common.js 有什么区别"></a>88. <em>ES6</em> 中模块化导入和导出与 <em>common.js</em> 有什么区别</h3><blockquote>
<p>参考答案：</p>
<p>CommonJs模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化不会影响到这个值.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;// common.js</span><br><span class="line">&gt;var count = 1;</span><br><span class="line"></span><br><span class="line">&gt;var printCount = () =&gt;&#123; </span><br><span class="line">  return ++count;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;module.exports = &#123;</span><br><span class="line">    printCount: printCount,</span><br><span class="line">    count: count</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;// index.js</span><br><span class="line">&gt;let v = require(&#x27;./common&#x27;);</span><br><span class="line">&gt;console.log(v.count); // 1</span><br><span class="line">&gt;console.log(v.printCount()); // 2</span><br><span class="line">&gt;console.log(v.count); // 1</span><br></pre></td></tr></table></figure>

<p>你可以看到明明common.js里面改变了count，但是输出的结果还是原来的。这是因为count是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动的值。将common.js里面的module.exports 改写成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;module.exports = &#123;</span><br><span class="line">    printCount: printCount,</span><br><span class="line">    get count()&#123;</span><br><span class="line">        return count</span><br><span class="line">    &#125;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure>

<p>这样子的输出结果是 1，2，2</p>
<p>而在ES6当中，写法是这样的，是利用export 和import导入的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;// es6.js</span><br><span class="line">&gt;export let count = 1;</span><br><span class="line">&gt;export function printCount() &#123;</span><br><span class="line">    ++count;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;// main1.js</span><br><span class="line">&gt;import  &#123; count, printCount &#125; from &#x27;./es6&#x27;;</span><br><span class="line">&gt;console.log(count)</span><br><span class="line">&gt;console.log(printCount());</span><br><span class="line">&gt;console.log(count)</span><br></pre></td></tr></table></figure>

<p>ES6 模块是动态引用，并且不会缓存，模块里面的变量绑定其所有的模块，而是动态地去加载值，并且不能重新赋值，</p>
<p>ES6 输入的模块变量，只是一个“符号连接符”，所以这个变量是只读的，对它进行重新赋值会报错。如果是引用类型，变量指向的地址是只读的，但是可以为其添加属性或成员。</p>
<p>另外还想说一个 <em>export default</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let count = 1;</span><br><span class="line">function printCount() &#123;</span><br><span class="line">    ++count;</span><br><span class="line">&gt;&#125; </span><br><span class="line">&gt;export default &#123; count, printCount&#125;</span><br><span class="line">&gt;// main3.js</span><br><span class="line">&gt;import res form &#x27;./main3.js&#x27;</span><br><span class="line">&gt;console.log(res.count)</span><br></pre></td></tr></table></figure>

<p>export与export default的区别及联系：</p>
<ol>
<li><p>export与export default均可用于导出常量、函数、文件、模块等</p>
</li>
<li><p>你可以在其它文件或模块中通过 import + (常量 | 函数 | 文件 | 模块)名的方式，将其导入，以便能够对其进行使用 </p>
</li>
<li><p>在一个文件或模块中，export、import可以有多个，export default仅有一个</p>
</li>
<li><p>通过export方式导出，在导入时要加{ }，export default则不需要。</p>
</li>
</ol>
</blockquote>
<h3 id="89-说一下普通函数和箭头函数的区别"><a href="#89-说一下普通函数和箭头函数的区别" class="headerlink" title="89. 说一下普通函数和箭头函数的区别"></a>89. 说一下普通函数和箭头函数的区别</h3><blockquote>
<p>参考答案：</p>
<p>请参阅前面第 <em>8、25、83</em> 题答案。</p>
</blockquote>
<h3 id="90-说一下-promise-和-async-和-await-什么关系"><a href="#90-说一下-promise-和-async-和-await-什么关系" class="headerlink" title="90. 说一下 promise 和 async 和 await 什么关系"></a>90. 说一下 <em>promise</em> 和 <em>async</em> 和 <em>await</em> 什么关系</h3><blockquote>
<p>参考答案：</p>
<p><em>await</em> 表达式会造成异步函数停止执行并且等待<em>promise</em>的解决，当值被<em>resolved</em>，异步函数会恢复执行以及返回<em>resolved</em>值。如果该值不是一个<em>promise</em>，它将会被转换成一个<em>resolved</em>后的<em>promise</em>。如果<em>promise</em>被<em>rejected</em>，<em>await</em> 表达式会抛出异常值。</p>
</blockquote>
<h3 id="91-说一下你学习过的有关-ES6-的知识点"><a href="#91-说一下你学习过的有关-ES6-的知识点" class="headerlink" title="91. 说一下你学习过的有关 ES6 的知识点"></a>91. 说一下你学习过的有关 <em>ES6</em> 的知识点</h3><blockquote>
<p>参考答案：</p>
<p>这种题目是开放题，可以简单列举一下 <em>ES6</em> 的新增知识点。（ <em>ES6</em> 的新增知识点参阅前面第 <em>44</em> 题）</p>
<p>然后说一下自己平时开发中用得比较多的是哪些即可。</p>
<p>一般面试官会针对你所说的内容进行二次提问。例如：你回答平时开发中箭头函数用得比较多，那么面试官极大可能针对箭头函数展开二次提问，询问你箭头函数有哪些特性？箭头函数 <em>this</em> 特点之类的问题。</p>
</blockquote>
<h3 id="92-了解过-js-中-arguments-吗？接收的是实参还是形参？"><a href="#92-了解过-js-中-arguments-吗？接收的是实参还是形参？" class="headerlink" title="92. 了解过 js 中 arguments 吗？接收的是实参还是形参？"></a>92. 了解过 <em>js</em> 中 <em>arguments</em> 吗？接收的是实参还是形参？</h3><blockquote>
<p>参考答案：</p>
<p><em>JS</em> 中的 <em>arguments</em> 是一个伪数组对象。这个伪数组对象将包含调用函数时传递的所有的实参。</p>
<p>与之相对的，<em>JS</em> 中的函数还有一个 <em>length</em> 属性，返回的是函数形参的个数。</p>
</blockquote>
<h3 id="93-ES6-相比于-ES5-有什么变化"><a href="#93-ES6-相比于-ES5-有什么变化" class="headerlink" title="93. ES6 相比于 ES5 有什么变化"></a>93. <em>ES6</em> 相比于 <em>ES5</em> 有什么变化</h3><blockquote>
<p>参考答案：</p>
<p><em>ES6</em> 相比 <em>ES5</em> 新增了很多新特性，这里可以自己简述几个。</p>
<p>具体的新增特性可以参阅前面第 <em>44</em> 题。</p>
</blockquote>
<h3 id="94-强制类型转换方法有哪些？"><a href="#94-强制类型转换方法有哪些？" class="headerlink" title="94. 强制类型转换方法有哪些？"></a>94. 强制类型转换方法有哪些？</h3><blockquote>
<p>参考答案：</p>
<p>JavaScript 中的数据类型转换，主要有三种方式：</p>
<ol>
<li>转换函数</li>
</ol>
<p><em>js</em> 提供了诸如 <em>parseInt</em> 和 <em>parseFloat</em> 这些转换函数，通过这些转换函数可以进行数据类型的转换 。</p>
<ol start="2">
<li>强制类型转换</li>
</ol>
<p>还可使用强制类型转换（<em>type casting</em>）处理转换值的类型。</p>
<p>例如：</p>
<ul>
<li><em>Boolean</em>(<em>value</em>) 把给定的值转换成 <em>Boolean</em> 型；</li>
<li><em>Number</em>(<em>value</em>)——把给定的值转换成数字（可以是整数或浮点数）；</li>
<li><em>String</em>(<em>value</em>)——把给定的值转换成字符串。</li>
</ul>
<ol start="3">
<li>利用 <em>js</em> 变量弱类型转换。</li>
</ol>
<p>例如：</p>
<ul>
<li><p>转换字符串：直接和一个空字符串拼接，例如：<code>a = &quot;&quot; + 数据</code></p>
</li>
<li><p>转换布尔：!!数据类型，例如：<code>!!&quot;Hello&quot;</code></p>
</li>
<li><p>转换数值：数据*1 或 /1，例如：<code>&quot;Hello * 1&quot;</code></p>
</li>
</ul>
</blockquote>
<h3 id="95-纯函数"><a href="#95-纯函数" class="headerlink" title="95. 纯函数"></a>95. 纯函数</h3><blockquote>
<p>参考答案：</p>
<p>一个函数，如果符合以下两个特点，那么它就可以称之为<strong>纯函数</strong>：</p>
<ol>
<li>对于相同的输入，永远得到相同的输出</li>
<li>没有任何可观察到的副作用</li>
</ol>
</blockquote>
<blockquote>
<p>解析：</p>
<p>针对上面的两个特点，我们一个一个来看。</p>
<ul>
<li>相同输入得到相同输出</li>
</ul>
<p>我们先来看一个不纯的反面典型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let greeting = &#x27;Hello&#x27;</span><br><span class="line"></span><br><span class="line">function greet (name) &#123;</span><br><span class="line">  return greeting + &#x27; &#x27; + name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(greet(&#x27;World&#x27;)) // Hello World</span><br></pre></td></tr></table></figure>

<p>上面的代码中，<em>greet(‘World’)</em> 是不是永远返回 <em>Hello World</em> ? 显然不是，假如我们修改 <em>greeting</em> 的值，就会影响 <em>greet</em> 函数的输出。即函数 <em>greet</em> 其实是 <strong>依赖外部状态</strong> 的。</p>
<p>那我们做以下修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function greet (greeting, name) &#123;</span><br><span class="line">  return greeting + &#x27; &#x27; + name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(greet(&#x27;Hi&#x27;, &#x27;Savo&#x27;)) // Hi Savo</span><br></pre></td></tr></table></figure>

<p>将 <em>greeting</em> 参数也传入，这样对于任何输入参数，都有与之对应的唯一的输出参数了，该函数就符合了第一个特点。</p>
<ul>
<li>没有副作用</li>
</ul>
<p>副作用的意思是，这个函数的运行，<strong>不会修改外部的状态</strong>。</p>
<p>下面再看反面典型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const user = &#123;</span><br><span class="line">  username: &#x27;savokiss&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let isValid = false</span><br><span class="line"></span><br><span class="line">function validate (user) &#123;</span><br><span class="line">  if (user.username.length &gt; 4) &#123;</span><br><span class="line">    isValid = true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见，执行函数的时候会修改到 <em>isValid</em> 的值（注意：如果你的函数没有任何返回值，那么它很可能就具有副作用！）</p>
<p>那么我们如何移除这个副作用呢？其实不需要修改外部的 <em>isValid</em> 变量，我们只需要在函数中将验证的结果 <em>return</em> 出来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const user = &#123;</span><br><span class="line">  username: &#x27;savokiss&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function validate (user) &#123;</span><br><span class="line">  return user.username.length &gt; 4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const isValid = validate(user)</span><br></pre></td></tr></table></figure>

<p>这样 <em>validate</em> 函数就不会修改任何外部的状态了~</p>
</blockquote>
<h3 id="96-JS-模块化"><a href="#96-JS-模块化" class="headerlink" title="96. JS 模块化"></a>96. <em>JS</em> 模块化</h3><blockquote>
<p>参考答案：</p>
<p>模块化主要是用来抽离公共代码，隔离作用域，避免变量冲突等。</p>
<p>模块化的整个发展历史如下：</p>
<p><strong>IIFE</strong>： 使用自执行函数来编写模块化，特点：<strong>在一个单独的函数作用域中执行代码，避免变量冲突</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> &#123;</span><br><span class="line"><span class="attr">data</span>:[]</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;)()</span><br></pre></td></tr></table></figure>

<p><strong>AMD</strong>： 使用requireJS 来编写模块化，特点：<strong>依赖必须提前声明好</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;define(<span class="string">&#x27;./index.js&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">code</span>)</span>&#123;</span><br><span class="line"><span class="comment">// code 就是index.js 返回的内容</span></span><br><span class="line">&gt;&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>CMD</strong>： 使用seaJS 来编写模块化，特点：<strong>支持动态引入依赖文件</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;  </span><br><span class="line"> <span class="keyword">var</span> indexCode = <span class="built_in">require</span>(<span class="string">&#x27;./index.js&#x27;</span>);</span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>CommonJS</strong>： nodejs 中自带的模块化。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>UMD</strong>：兼容AMD，CommonJS 模块化语法。</p>
<p>**webpack(require.ensure)**：webpack 2.x 版本中的代码分割。</p>
<p><strong>ES Modules</strong>： ES6 引入的模块化，支持import 来引入另一个 js 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">import</span> a <span class="keyword">from</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="97-看过-jquery-源码吗？"><a href="#97-看过-jquery-源码吗？" class="headerlink" title="97. 看过 jquery 源码吗？"></a>97. 看过 <em>jquery</em> 源码吗？</h3><blockquote>
<p>参考答案：</p>
<p>开放题，但是需要注意的是，如果看过 <em>jquery</em> 源码，不要简单的回答一个“看过”就完了，应该继续乘胜追击，告诉面试官例如哪个哪个部分是怎么怎么实现的，并针对这部分的源码实现，可以发表一些自己的看法和感想。</p>
</blockquote>
<h3 id="98-说一下-js-中的-this"><a href="#98-说一下-js-中的-this" class="headerlink" title="98. 说一下 js 中的 this"></a>98. 说一下 <em>js</em> 中的 <em>this</em></h3><blockquote>
<p>参考答案：</p>
<p>请参阅前面第 <em>17</em> 题答案。</p>
</blockquote>
<h3 id="99-apply-call-bind-区别，手写"><a href="#99-apply-call-bind-区别，手写" class="headerlink" title="99. apply call bind 区别，手写"></a>99. <em>apply call bind</em> 区别，手写</h3><blockquote>
<p>参考答案：</p>
<p>apply call bind 区别 ？</p>
<p><em>call</em> 和 <em>apply</em> 的功能相同，区别在于传参的方式不一样:</p>
<ul>
<li><em>fn.call(obj, arg1, arg2, …)</em> 调用一个函数, 具有一个指定的 <em>this</em> 值和分别地提供的参数(参数的列表)。</li>
<li><em>fn.apply(obj, [argsArray])</em> 调用一个函数，具有一个指定的 <em>this</em> 值，以及作为一个数组（或类数组对象）提供的参数。</li>
</ul>
<p><em>bind</em> 和 <em>call/apply</em> 有一个很重要的区别，一个函数被 <em>call/apply</em> 的时候，会直接调用，但是 <em>bind</em> 会创建一个新函数。当这个新函数被调用时，<em>bind( )</em> 的第一个参数将作为它运行时的 <em>this</em>，之后的一序列参数将会在传递的实参前传入作为它的参数。</p>
<p>实现 <em>call</em> 方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;<span class="built_in">Function</span>.prototype.call2 = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">   <span class="comment">//没传参数或者为 null 是默认是 window</span></span><br><span class="line">   <span class="keyword">var</span> context = context || (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">&#x27;undefined&#x27;</span> ? <span class="built_in">window</span> : <span class="built_in">global</span>)</span><br><span class="line">   <span class="comment">// 首先要获取调用 call 的函数，用 this 可以获取</span></span><br><span class="line">   context.fn = <span class="built_in">this</span></span><br><span class="line">   <span class="keyword">var</span> args = []</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">       args.push(<span class="string">&#x27;arguments[&#x27;</span> + i + <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">eval</span>(<span class="string">&#x27;context.fn(&#x27;</span> + args + <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">   <span class="keyword">delete</span> context.fn</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 测试</span></span><br><span class="line">&gt;<span class="keyword">var</span> value = <span class="number">3</span></span><br><span class="line">&gt;<span class="keyword">var</span> foo = &#123;</span><br><span class="line">   <span class="attr">value</span>: <span class="number">2</span></span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">this</span>.value)</span><br><span class="line">   <span class="built_in">console</span>.log(name)</span><br><span class="line">   <span class="built_in">console</span>.log(age)</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;bar.call2(<span class="literal">null</span>)</span><br><span class="line">&gt;<span class="comment">// 浏览器环境： 3 undefinde undefinde   </span></span><br><span class="line">&gt;<span class="comment">// Node环境：undefinde undefinde undefinde</span></span><br><span class="line"></span><br><span class="line">&gt;bar.call2(foo, <span class="string">&#x27;cc&#x27;</span>, <span class="number">18</span>) <span class="comment">// 2  cc 18</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>实现 <em>apply</em> 方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;<span class="built_in">Function</span>.prototype.apply2 = <span class="function"><span class="keyword">function</span> (<span class="params">context, arr</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> context = context || (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">&#x27;undefined&#x27;</span> ? <span class="built_in">window</span> : <span class="built_in">global</span>)</span><br><span class="line">   context.fn = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> result;</span><br><span class="line">   <span class="keyword">if</span> (!arr) &#123;</span><br><span class="line">       result = context.fn();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">var</span> args = [];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">           args.push(<span class="string">&#x27;arr[&#x27;</span> + i + <span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       result = <span class="built_in">eval</span>(<span class="string">&#x27;context.fn(&#x27;</span> + args + <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">delete</span> context.fn</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 测试：</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">var</span> value = <span class="number">3</span></span><br><span class="line">&gt;<span class="keyword">var</span> foo = &#123;</span><br><span class="line">   <span class="attr">value</span>: <span class="number">2</span></span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">this</span>.value)</span><br><span class="line">   <span class="built_in">console</span>.log(name)</span><br><span class="line">   <span class="built_in">console</span>.log(age)</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;bar.apply2(<span class="literal">null</span>)</span><br><span class="line">&gt;<span class="comment">// 浏览器环境： 3 undefinde undefinde   </span></span><br><span class="line">&gt;<span class="comment">// Node环境：undefinde undefinde undefinde</span></span><br><span class="line"></span><br><span class="line">&gt;bar.apply2(foo, [<span class="string">&#x27;cc&#x27;</span>, <span class="number">18</span>]) <span class="comment">// 2  cc 18</span></span><br></pre></td></tr></table></figure>



<p>实现 <em>bind</em> 方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;<span class="built_in">Function</span>.prototype.bind2 = <span class="function"><span class="keyword">function</span> (<span class="params">oThis</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">       <span class="comment">// closest thing possible to the ECMAScript 5 internal IsCallable function</span></span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> aArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>),</span><br><span class="line">       fToBind = <span class="built_in">this</span>,</span><br><span class="line">       fNOP = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;,</span><br><span class="line">       fBound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> fToBind.apply(<span class="built_in">this</span> <span class="keyword">instanceof</span> fNOP &amp;&amp; oThis</span><br><span class="line">               ? <span class="built_in">this</span></span><br><span class="line">               : oThis || <span class="built_in">window</span>,</span><br><span class="line">               aArgs.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)));</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">   fNOP.prototype = <span class="built_in">this</span>.prototype;</span><br><span class="line">   fBound.prototype = <span class="keyword">new</span> fNOP();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> fBound;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 测试</span></span><br><span class="line">&gt;<span class="keyword">var</span> test = &#123;</span><br><span class="line">   <span class="attr">name</span>: <span class="string">&quot;jack&quot;</span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">var</span> demo = &#123;</span><br><span class="line">   <span class="attr">name</span>: <span class="string">&quot;rose&quot;</span>,</span><br><span class="line">   <span class="attr">getName</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">this</span>.name; &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="built_in">console</span>.log(demo.getName()); <span class="comment">// 输出 rose  这里的 this 指向 demo</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 运用 bind 方法更改 this 指向</span></span><br><span class="line">&gt;<span class="keyword">var</span> another2 = demo.getName.bind2(test);</span><br><span class="line">&gt;<span class="built_in">console</span>.log(another2()); <span class="comment">// 输出 jack  这里 this 指向了 test 对象了</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="100-手写-reduce-flat"><a href="#100-手写-reduce-flat" class="headerlink" title="100. 手写 reduce flat"></a>100. 手写 <em>reduce flat</em></h3><blockquote>
<p>参考答案：</p>
<p><em>reduce</em> 实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.my_reduce = <span class="function"><span class="keyword">function</span> (<span class="params">callback, initialValue</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(<span class="built_in">this</span>) || !<span class="built_in">this</span>.length || <span class="keyword">typeof</span> callback !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否有初始值</span></span><br><span class="line">        <span class="keyword">let</span> hasInitialValue = initialValue !== <span class="literal">undefined</span>;</span><br><span class="line">        <span class="keyword">let</span> value = hasInitialValue ? initialValue : tihs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> index = hasInitialValue ? <span class="number">0</span> : <span class="number">1</span>; index &lt; <span class="built_in">this</span>.length; index++) &#123;</span><br><span class="line">            <span class="keyword">const</span> element = <span class="built_in">this</span>[index];</span><br><span class="line">            value = callback(value, element, index, <span class="built_in">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> res = arr.my_reduce(<span class="function">(<span class="params">pre, cur, i, arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(pre, cur, i, arr)</span><br><span class="line">    <span class="keyword">return</span> pre + cur</span><br><span class="line">&#125;, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">console</span>.log(res)<span class="comment">//25</span></span><br></pre></td></tr></table></figure>



<p><em>flat</em> 实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, [<span class="number">12</span>, <span class="number">3</span>, <span class="string">&quot;zs&quot;</span>], <span class="number">7</span>, [<span class="number">8</span>, <span class="number">9</span>, [<span class="number">10</span>, <span class="number">11</span>, [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]]]]]];</span><br><span class="line"></span><br><span class="line"><span class="comment">//万能的类型检测方法</span></span><br><span class="line"><span class="keyword">const</span> checkType = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(arr).slice(<span class="number">8</span>, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自定义flat方法，注意：不可以使用箭头函数，使用后内部的this会指向window</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.myFlat = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//判断第一层数组的类型</span></span><br><span class="line">    <span class="keyword">let</span> type = checkType(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">//创建一个新数组，用于保存拆分后的数组</span></span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="comment">//若当前对象非数组则返回undefined</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Object</span>.is(type, <span class="string">&quot;Array&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历所有子元素并判断类型，若为数组则继续递归，若不为数组则直接加入新数组</span></span><br><span class="line">    <span class="built_in">this</span>.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> cellType = checkType(item);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Object</span>.is(cellType, <span class="string">&quot;Array&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">//形参num，表示当前需要拆分多少层数组，传入Infinity则将多维直接降为一维</span></span><br><span class="line">            num--;</span><br><span class="line">            <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">let</span> newArr = result.push(item);</span><br><span class="line">                <span class="keyword">return</span> newArr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//使用三点运算符解构，递归函数返回的数组，并加入新数组</span></span><br><span class="line">            result.push(...item.myFlat(num));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.push(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.time();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.flat(<span class="literal">Infinity</span>)); <span class="comment">//[1, 2, 3, 4, 5, 12, 3, &quot;zs&quot;, 7, 8, 9, 10, 11, 1, 2, 3, 4];</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.myFlat(<span class="literal">Infinity</span>)); <span class="comment">//[1, 2, 3, 4, 5, 12, 3, &quot;zs&quot;, 7, 8, 9, 10, 11, 1, 2, 3, 4];</span></span><br><span class="line"><span class="comment">//自定义方法和自带的flat返回结果一致!!!!</span></span><br><span class="line"><span class="built_in">console</span>.timeEnd();</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="101-隐试转换的原理？是怎么转换的"><a href="#101-隐试转换的原理？是怎么转换的" class="headerlink" title="101. == 隐试转换的原理？是怎么转换的"></a>101. == 隐试转换的原理？是怎么转换的</h3><blockquote>
<p>参考答案：</p>
<p><strong>两个与类型转换有关的函数：valueOf()和toString()</strong></p>
<ul>
<li>valueOf()的语义是，返回这个对象逻辑上对应的原始类型的值。比如说，String包装对象的valueOf()，应该返回这个对象所包装的字符串。</li>
<li>toString()的语义是，返回这个对象的字符串表示。用一个字符串来描述这个对象的内容。</li>
</ul>
<p>valueOf()和toString()是定义在Object.prototype上的方法，也就是说，所有的对象都会继承到这两个方法。但是在Object.prototype上定义的这两个方法往往不能满足我们的需求（Object.prototype.valueOf()仅仅返回对象本身），因此js的许多内置对象都重写了这两个函数，以实现更适合自身的功能需要（比如说，String.prototype.valueOf就覆盖了在Object.prototype中定义的valueOf）。当我们自定义对象的时候，最好也重写这个方法。重写这个方法时要遵循上面所说的语义。</p>
<p><strong>js内部用于实现类型转换的4个函数</strong></p>
<p>这4个方法实际上是ECMAScript定义的4个抽象的操作，它们在js内部使用，进行类型转换。js的使用者不能直接调用这些函数。</p>
<ul>
<li>ToPrimitive ( input [ , PreferredType ] )</li>
<li>ToBoolean ( argument )</li>
<li>ToNumber ( argument )</li>
<li>ToString ( argument )</li>
</ul>
<p>需要区分这里的 ToString() 和上文谈到的 toString()，一个是 js 引擎内部使用的函数，另一个是定义在对象上的函数。</p>
<p>（1）ToPrimitive ( input [ , PreferredType ] )</p>
<p>将 input 转化成一个原始类型的值。PreferredType参数要么不传入，要么是Number 或 String。<strong>如果PreferredType参数是Number</strong>，ToPrimitive这样执行：</p>
<ol>
<li>如果input本身就是原始类型，直接返回input。</li>
<li>调用**input.valueOf()**，如果结果是原始类型，则返回这个结果。</li>
<li>调用**input.toString()**，如果结果是原始类型，则返回这个结果。</li>
<li>抛出TypeError异常。</li>
</ol>
<p><strong>以下是PreferredType不为Number时的执行顺序。</strong></p>
<ul>
<li>如果PreferredType参数是String，则交换上面这个过程的第2和第3步的顺序，其他执行过程相同。</li>
<li>如果PreferredType参数没有传入<ul>
<li>如果input是内置的Date类型，PreferredType 视为String</li>
<li>否则PreferredType 视为 Number</li>
</ul>
</li>
</ul>
<p><strong>可以看出，ToPrimitive依赖于valueOf和toString的实现。</strong></p>
<p>（2）ToBoolean ( argument )</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-08-19-084743.png" alt="image-20210819164742154" style="zoom:50%;" />

<p>只需要记忆 <em>0, null, undefined, NaN, “”</em> 返回 <em>false</em> 就可以了，其他一律返回 <em>true</em>。</p>
<p>（3）ToNumber ( argument )</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-08-19-084928.png" alt="image-20210819164927980" style="zoom:50%;" />

<p>ToNumber的转化并不总是成功，有时会转化成NaN，有时则直接抛出异常。</p>
<p>（4）ToString ( argument )</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-08-19-085006.png" alt="image-20210819165004906" style="zoom:50%;" />

<p>当js期望得到某种类型的值，而实际在那里的值是其他的类型，就会发生隐式类型转换。系统内部会自动调用我们前面说ToBoolean ( argument )、ToNumber ( argument )、ToString ( argument )，尝试转换成期望的数据类型。</p>
</blockquote>
<h3 id="102-‘1’-‘2’-‘3’-map-parseInt-结果是什么，为什么-（字节）"><a href="#102-‘1’-‘2’-‘3’-map-parseInt-结果是什么，为什么-（字节）" class="headerlink" title="102. [‘1’, ‘2’, ‘3’].map(parseInt) 结果是什么，为什么 （字节）"></a>102. [‘1’, ‘2’, ‘3’].map(parseInt) 结果是什么，为什么 （字节）</h3><blockquote>
<p>参考答案：</p>
<p>[1, NaN, NaN]</p>
</blockquote>
<blockquote>
<p>解析：</p>
<p>一、为什么会是这个结果？</p>
<ol>
<li><em>map</em> 函数</li>
</ol>
<p>将数组的每个元素传递给指定的函数处理，并返回处理后的数组，所以 <em>[‘1’,’2’,’3’].map(parseInt)</em> 就是将字符串 <em>1，2，3</em> 作为元素；<em>0，1，2</em> 作为下标分别调用 <em>parseInt</em> 函数。即分别求出 <em>parseInt(‘1’,0), parseInt(‘2’,1), parseInt(‘3’,2)</em> 的结果。</p>
<ol start="2">
<li><em>parseInt</em> 函数（重点）</li>
</ol>
<p>概念：以第二个参数为基数来解析第一个参数字符串，通常用来做十进制的向上取整（省略小数）如：parseInt(2.7) //结果为2</p>
<p>特点：接收两个参数 <em>parseInt(string,radix)</em></p>
<p><em>string</em>：字母（大小写均可）、数组、特殊字符（不可放在开头,特殊字符及特殊字符后面的内容不做解析）的任意字符串，如 ‘2’、’2w’、’2!’</p>
<p><em>radix</em>：解析字符串的基数，基数规则如下：</p>
<p>  1）   区间范围介于 <em>2~36</em> 之间；</p>
<p>  2 ）  当参数为 <em>0</em>，<em>parseInt( )</em> 会根据十进制来解析；</p>
<p>  3 ）  如果忽略该参数，默认的基数规则：</p>
<p>​        如果 <em>string</em> 以 “0x” 开头，parseInt() 会把 string 的其余部分解析为十六进制的整数；parseInt(“0xf”)   // 15<br>​        如果 <em>string</em> 以 0 开头，其后的字符解析为八进制或十六进制的数字；parseInt(“08”)   // 8<br>​        如果 <em>string</em> 以 1 ~ 9 的数字开头，parseInt() 将把它解析为十进制的整数；parseInt(“88.99f”)   // 88<br>​        只有字符串中的第一个数字会被返回。parseInt(“10.33”)   // 返回10；<br>​        开头和结尾的空格是允许的。parseInt(“ 69 10 “)   // 返回69<br>​        如果字符串的第一个字符不能被转换为数字，返回 NaN。parseInt(“f”)  // 返回 NaN  而 parseInt(“f”，16)  // 返回15</p>
<p>二、<em>parseInt</em> 方法解析的运算过程</p>
<p>parseInt(‘101.55’,10); // 以十进制解析，运算过程：向上取整数(不做四舍五入，省略小数)，结果为 101。</p>
<p>parseInt(‘101’,2);  // 以二进制解析，运算过程：1<em>2的2次方+0</em>2的1次方+1*2的0次方=4+0+1=5，结果为 5。</p>
<p>parseInt(‘101’,8);  // 以八进制解析，运算过程：1<em>8的2次方+0</em>8的1次方+1*8的0次方=64+0+1=65，结果为 65。</p>
<p>parseInt(‘101’,16);  // 以十六进制解析，运算过程：1<em>16的2次方+0</em>16的1次方+1*16的0次方=256+0+1=257，结果为 257。</p>
<p>三、再来分析一下结果</p>
<p><em>[‘1’,’2’,’3’].map(parseInt)</em> 即</p>
<p>parseInt(‘1’,0); radix 为 0，parseInt( ) 会根据十进制来解析，所以结果为 <em>1</em>；</p>
<p>parseInt(‘2’,1); radix 为 1，超出区间范围，所以结果为 <em>NaN</em>；</p>
<p>parseInt(‘3’,2); radix 为 2，用2进制来解析，应以 <em>0</em> 和 <em>1</em> 开头，所以结果为 <em>NaN</em>。</p>
</blockquote>
<h3 id="103-防抖，节流是什么，如何实现-（字节）"><a href="#103-防抖，节流是什么，如何实现-（字节）" class="headerlink" title="103. 防抖，节流是什么，如何实现 （字节）"></a>103. 防抖，节流是什么，如何实现 （字节）</h3><blockquote>
<p>参考答案：</p>
<p>我们在平时开发的时候，会有很多场景会频繁触发事件，比如说搜索框实时发请求，<em>onmousemove、resize、onscroll</em> 等，有些时候，我们并不能或者不想频繁触发事件，这时候就应该用到函数防抖和函数节流。</p>
<p>函数防抖(<em>debounce</em>)，指的是短时间内多次触发同一事件，只执行最后一次，或者只执行最开始的一次，中间的不执行。</p>
<p>具体实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 函数防抖</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;function&#125;</span> </span>func 一段时间后，要调用的函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> </span>wait 等待的时间，单位毫秒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 设置变量，记录 setTimeout 得到的 id</span></span><br><span class="line">    <span class="keyword">let</span> timerId = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(timerId)&#123;</span><br><span class="line">            <span class="comment">// 如果有值，说明目前正在等待中，清除它</span></span><br><span class="line">            <span class="built_in">clearTimeout</span>(timerId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重新开始计时</span></span><br><span class="line">        timerId = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            func(...args);</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>函数节流(<em>throttle</em>)，指连续触发事件但是在 <em>n</em> 秒中只执行一次函数。即 <em>2n</em> 秒内执行 <em>2</em> 次… 。节流如字面意思，会稀释函数的执行频率。</p>
<p>具体实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> context, args;</span><br><span class="line">    <span class="keyword">let</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        context = <span class="built_in">this</span>;</span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (now - previous &gt; wait) &#123;</span><br><span class="line">            func.apply(context, args);</span><br><span class="line">            previous = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="104-介绍下-Set、Map、WeakSet-和-WeakMap-的区别（字节）"><a href="#104-介绍下-Set、Map、WeakSet-和-WeakMap-的区别（字节）" class="headerlink" title="104. 介绍下 Set、Map、WeakSet 和 WeakMap 的区别（字节）"></a>104. 介绍下 <em>Set、Map、WeakSet</em> 和 <em>WeakMap</em> 的区别（字节）</h3><blockquote>
<p>参考答案：</p>
<p><strong>Set</strong></p>
<ul>
<li><p>成员唯一、无序且不重复</p>
</li>
<li><p>键值与键名是一致的（或者说只有键值，没有键名）</p>
</li>
<li><p>可以遍历，方法有 <em>add, delete,has</em></p>
</li>
</ul>
<p><strong>WeakSet</strong></p>
<ul>
<li><p>成员都是对象</p>
</li>
<li><p>成员都是弱引用，可以被垃圾回收机制回收，可以用来保存 <em>DOM</em> 节点，不容易造成内存泄漏</p>
</li>
<li><p>不能遍历，方法有 <em>add, delete,has</em></p>
</li>
</ul>
<p><strong>Map</strong></p>
<ul>
<li><p>本质上是健值对的集合，类似集合</p>
</li>
<li><p>可以遍历，方法很多，可以跟各种数据格式转换</p>
</li>
</ul>
<p><strong>WeakMap</strong></p>
<ul>
<li><p>只接受对象作为健名（<em>null</em> 除外），不接受其他类型的值作为健名</p>
</li>
<li><p>键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾机制回收，此时键名是无效的</p>
</li>
<li><p>不能遍历，方法有 <em>get、set、has、delete</em></p>
</li>
</ul>
</blockquote>
<h3 id="105-setTimeout、Promise、Async-Await-的区别（字节）"><a href="#105-setTimeout、Promise、Async-Await-的区别（字节）" class="headerlink" title="105. setTimeout、Promise、Async/Await 的区别（字节）"></a>105. <em>setTimeout、Promise、Async/Await</em> 的区别（字节）</h3><blockquote>
<p>参考答案：</p>
<p>事件循环中分为宏任务队列和微任务队列。</p>
<p>其中 <em>setTimeout</em> 的回调函数放到宏任务队列里，等到执行栈清空以后执行；</p>
<p><em>promise.then</em> 里的回调函数会放到相应宏任务的微任务队列里，等宏任务里面的同步代码执行完再执行；</p>
<p><em>async</em> 函数表示函数里面可能会有异步方法，<em>await</em> 后面跟一个表达式，<em>async</em> 方法执行时，遇到 <em>await</em> 会立即执行表达式，然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码先执行。</p>
</blockquote>
<h3 id="106-Promise-构造函数是同步执行还是异步执行，那么-then-方法呢？（字节）"><a href="#106-Promise-构造函数是同步执行还是异步执行，那么-then-方法呢？（字节）" class="headerlink" title="106. Promise 构造函数是同步执行还是异步执行，那么 then 方法呢？（字节）"></a>106. <em>Promise</em> 构造函数是同步执行还是异步执行，那么 <em>then</em> 方法呢？（字节）</h3><blockquote>
<p>参考答案：</p>
<p><em>promise</em> 构造函数是同步执行的，<em>then</em> 方法是异步执行，<em>then</em> 方法中的内容加入微任务中。</p>
</blockquote>
<h3 id="107-情人节福利题，如何实现一个-new-（字节）"><a href="#107-情人节福利题，如何实现一个-new-（字节）" class="headerlink" title="107. 情人节福利题，如何实现一个 new （字节）"></a>107. 情人节福利题，如何实现一个 <em>new</em> （字节）</h3><blockquote>
<p>参考答案：<br>首先我们需要明白 <em>new</em> 的原理。关于 <em>new</em> 的原理，主要分为以下几步：</p>
<ul>
<li><p>创建一个空对象 。</p>
</li>
<li><p>由 <em>this</em> 变量引用该对象 。</p>
</li>
<li><p>该对象继承该函数的原型(更改原型链的指向) 。</p>
</li>
<li><p>把属性和方法加入到 <em>this</em> 引用的对象中。</p>
</li>
<li><p>新创建的对象由 <em>this</em> 引用 ，最后隐式地返回 <em>this</em></p>
</li>
</ul>
<p>明白了这个原理后，我们就可以尝试来实现一个 <em>new</em> 方法，参考示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造器函数</span></span><br><span class="line"><span class="keyword">let</span> Parent = <span class="function"><span class="keyword">function</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.name = name;</span><br><span class="line">   <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;;</span><br><span class="line">Parent.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//自己定义的new方法</span></span><br><span class="line"><span class="keyword">let</span> newMethod = <span class="function"><span class="keyword">function</span> (<span class="params">Parent, ...rest</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 1.以构造器的prototype属性为原型，创建新对象；</span></span><br><span class="line">   <span class="keyword">let</span> child = <span class="built_in">Object</span>.create(Parent.prototype);</span><br><span class="line">   <span class="comment">// 2.将this和调用参数传给构造器执行</span></span><br><span class="line">   <span class="keyword">let</span> result = Parent.apply(child, rest);</span><br><span class="line">   <span class="comment">// 3.如果构造器没有手动返回对象，则返回第一步的对象</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">typeof</span> result === <span class="string">&#x27;object&#x27;</span> ? result : child;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//创建实例，将构造函数Parent与形参作为参数传入</span></span><br><span class="line"><span class="keyword">const</span> child = newMethod(Parent, <span class="string">&#x27;echo&#x27;</span>, <span class="number">26</span>);</span><br><span class="line">child.sayName() <span class="comment">//&#x27;echo&#x27;;</span></span><br><span class="line"><span class="comment">//最后检验，与使用new的效果相同</span></span><br><span class="line"><span class="built_in">console</span>.log(child <span class="keyword">instanceof</span> Parent)<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(child.hasOwnProperty(<span class="string">&#x27;name&#x27;</span>))<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(child.hasOwnProperty(<span class="string">&#x27;age&#x27;</span>))<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(child.hasOwnProperty(<span class="string">&#x27;sayName&#x27;</span>))<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="108-实现一个-sleep-函数（字节）"><a href="#108-实现一个-sleep-函数（字节）" class="headerlink" title="108. 实现一个 sleep 函数（字节）"></a>108. 实现一个 <em>sleep</em> 函数（字节）</h3><blockquote>
<p>参考答案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> start = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line">    <span class="keyword">while</span> ((<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime() - start &lt; delay) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;111&#x27;</span>);</span><br><span class="line">    sleep(<span class="number">2000</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;222&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test()</span><br></pre></td></tr></table></figure>

<p>这种实现方式是利用一个伪死循环阻塞主线程。因为 <em>JS</em> 是单线程的。所以通过这种方式可以实现真正意义上的 <em>sleep</em>。</p>
</blockquote>
<h3 id="109-使用-sort-对数组-3-15-8-29-102-22-进行排序，输出结果-（字节）"><a href="#109-使用-sort-对数组-3-15-8-29-102-22-进行排序，输出结果-（字节）" class="headerlink" title="109. 使用 sort() 对数组 [3, 15, 8, 29, 102, 22] 进行排序，输出结果 （字节）"></a>109. 使用 sort() 对数组 [3, 15, 8, 29, 102, 22] 进行排序，输出结果 （字节）</h3><blockquote>
<p>参考答案：</p>
<p><em>sort</em> 方法默认按照 <em>ASCII</em> 码来排序，如果要按照数字大小来排序，需要传入一个回调函数，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">3</span>, <span class="number">15</span>, <span class="number">8</span>, <span class="number">29</span>, <span class="number">102</span>, <span class="number">22</span>].sort(<span class="function">(<span class="params">a,b</span>) =&gt;</span> &#123;<span class="keyword">return</span> a - b&#125;);</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="110-实现-5-add-3-sub-2-百度"><a href="#110-实现-5-add-3-sub-2-百度" class="headerlink" title="110. 实现 5.add(3).sub(2) (百度)"></a>110. 实现 5.add(3).sub(2) (百度)</h3><blockquote>
<p>参考答案：</p>
<p>这里想要实现的是链式操作，那么我们可以考虑在 <em>Number</em> 类型的原型上添加 <em>add</em> 和 <em>sub</em> 方法，这两个方法返回新的数</p>
<p>示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.prototype.add = <span class="function"><span class="keyword">function</span> (<span class="params">number</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> number !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;请输入数字～&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.valueOf() + number;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Number</span>.prototype.minus = <span class="function"><span class="keyword">function</span> (<span class="params">number</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> number !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;请输入数字～&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.valueOf() - number;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">5</span>).add(<span class="number">3</span>).minus(<span class="number">2</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="111-给定两个数组，求交集"><a href="#111-给定两个数组，求交集" class="headerlink" title="111. 给定两个数组，求交集"></a>111. 给定两个数组，求交集</h3><blockquote>
<p>参考答案：</p>
<p>示例代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">intersect</span>(<span class="params">nums1, nums2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i = j = <span class="number">0</span>,</span><br><span class="line">        len1 = nums1.length,</span><br><span class="line">        len2 = nums2.length,</span><br><span class="line">        newArr = [];</span><br><span class="line">    <span class="keyword">if</span> (len1 === <span class="number">0</span> || len2 === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> newArr;</span><br><span class="line">    &#125;</span><br><span class="line">    nums1.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;);</span><br><span class="line">    nums2.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">while</span> (i &lt; len1 || j &lt; len2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &lt; nums2[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i] === nums2[j]) &#123;</span><br><span class="line">                newArr.push(nums1[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; len1 - <span class="number">1</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; len2 - <span class="number">1</span>) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="built_in">console</span>.log(intersect([<span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>]));</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="112-为什么普通-for-循环的性能远远高于-forEach-的性能，请解释其中的原因。"><a href="#112-为什么普通-for-循环的性能远远高于-forEach-的性能，请解释其中的原因。" class="headerlink" title="112. 为什么普通 for 循环的性能远远高于 forEach 的性能，请解释其中的原因。"></a>112. 为什么普通 <em>for</em> 循环的性能远远高于 <em>forEach</em> 的性能，请解释其中的原因。</h3><blockquote>
<p>参考答案：</p>
<p><em>for</em> 循环按顺序遍历，<em>forEach</em> 使用 <em>iterator</em> 迭代器遍历</p>
<p>下面是一段性能测试的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrs = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">100000</span>);</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">&#x27;for&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arrs.length; i++) &#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">&#x27;for&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">&#x27;forEach&#x27;</span>);</span><br><span class="line">arrs.forEach(<span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">&#x27;forEach&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>: <span class="number">2.</span>263ms</span><br><span class="line"><span class="attr">forEach</span>: <span class="number">0.</span>254ms</span><br></pre></td></tr></table></figure>

<p>在10万这个级别下，<code>forEach</code>的性能是<code>for</code>的十倍</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>: <span class="number">2.</span>263ms</span><br><span class="line"><span class="attr">forEach</span>: <span class="number">0.</span>254ms</span><br></pre></td></tr></table></figure>

<p>在100万这个量级下，<code>forEach</code>的性能是和<code>for</code>的一致</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>: <span class="number">2.</span>844ms</span><br><span class="line"><span class="attr">forEach</span>: <span class="number">2.</span>652ms</span><br></pre></td></tr></table></figure>

<p>在1000万级以上的量级上 ，<code>forEach</code>的性能远远低于<code>for</code>的性能</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>: <span class="number">8.</span>422ms</span><br><span class="line"><span class="attr">forEach</span>: <span class="number">30.</span>328m</span><br></pre></td></tr></table></figure>

<p>我们从语法上面来观察：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.forEach(callback(currentValue [, index [, array]])[, thisArg])</span><br></pre></td></tr></table></figure>

<p>可以看到 <em>forEach</em> 是有回调的，它会按升序为数组中含有效值的每一项执行一次 <em>callback</em>，且除了抛出异常以外，也没有办法中止或者跳出 <em>forEach</em> 循环。那这样的话执行就会额外的调用栈和函数内的上下文。</p>
<p>而 <em>for</em> 循环则是底层写法，不会产生额外的消耗。</p>
<p>在实际业务中没有很大的数组时，<em>for</em> 和 <em>forEach</em> 的性能差距其实很小，<em>forEach</em> 甚至会优于 <em>for</em> 的时间，且更加简洁，可读性也更高，一般也会优先使用 <em>forEach</em> 方法来进行数组的循环处理。</p>
</blockquote>
<h3 id="113-实现一个字符串匹配算法，从长度为-n-的字符串-S-中，查找是否存在字符串-T，T-的长度是-m，若存在返回所在位置。"><a href="#113-实现一个字符串匹配算法，从长度为-n-的字符串-S-中，查找是否存在字符串-T，T-的长度是-m，若存在返回所在位置。" class="headerlink" title="113. 实现一个字符串匹配算法，从长度为 n 的字符串 S 中，查找是否存在字符串 T，T 的长度是 m，若存在返回所在位置。"></a>113. 实现一个字符串匹配算法，从长度为 n 的字符串 S 中，查找是否存在字符串 T，T 的长度是 m，若存在返回所在位置。</h3><blockquote>
<p>参考答案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 完全不用 API</span></span><br><span class="line"><span class="keyword">var</span> getIndexOf = <span class="function"><span class="keyword">function</span> (<span class="params">s, t</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> n = s.length;</span><br><span class="line">    <span class="keyword">let</span> m = t.length;</span><br><span class="line">    <span class="keyword">if</span> (!n || !m || n &lt; m) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> k = i;</span><br><span class="line">        <span class="keyword">if</span> (s[k] === t[j]) &#123;</span><br><span class="line">            k++; j++;</span><br><span class="line">            <span class="keyword">while</span> (k &lt; n &amp;&amp; j &lt; m) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[k] !== t[j]) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    k++; j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j === m) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="built_in">console</span>.log(getIndexOf(<span class="string">&quot;Hello World&quot;</span>, <span class="string">&quot;rl&quot;</span>))</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="114-使用-JavaScript-Proxy-实现简单的数据绑定"><a href="#114-使用-JavaScript-Proxy-实现简单的数据绑定" class="headerlink" title="114. 使用 JavaScript Proxy 实现简单的数据绑定"></a>114. 使用 <em>JavaScript Proxy</em> 实现简单的数据绑定</h3><blockquote>
<p>参考答案：</p>
<p>示例代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  hello,world</span><br><span class="line">  &lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;model&quot;</span>&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;word&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&lt;/body&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="keyword">const</span> model = <span class="built_in">document</span>.getElementById(<span class="string">&quot;model&quot;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="keyword">const</span> word = <span class="built_in">document</span>.getElementById(<span class="string">&quot;word&quot;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="keyword">var</span> obj= &#123;&#125;;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="keyword">const</span> newObj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target, key, receiver</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="built_in">console</span>.log(<span class="string">`getting <span class="subst">$&#123;key&#125;</span>!`</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target, key, value, receiver</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="built_in">console</span>.log(<span class="string">&#x27;setting&#x27;</span>,target, key, value, receiver);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">if</span> (key === <span class="string">&quot;text&quot;</span>) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          model.value = value;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          word.innerHTML = value;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  model.addEventListener(<span class="string">&quot;keyup&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    newObj.text = e.target.value</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="115-数组里面有-10-万个数据，取第一个元素和第-10-万个元素的时间相差多少（字节）"><a href="#115-数组里面有-10-万个数据，取第一个元素和第-10-万个元素的时间相差多少（字节）" class="headerlink" title="115. 数组里面有 10 万个数据，取第一个元素和第 10 万个元素的时间相差多少（字节）"></a>115. 数组里面有 <em>10</em> 万个数据，取第一个元素和第 <em>10</em> 万个元素的时间相差多少（字节）</h3><blockquote>
<p>参考答案：</p>
<p>消耗时间几乎一致，差异可以忽略不计</p>
</blockquote>
<blockquote>
<p>解析：</p>
<ul>
<li>数组可以直接根据索引取的对应的元素，所以不管取哪个位置的元素的时间复杂度都是 O(1)</li>
<li><em>JavaScript</em> 没有真正意义上的数组，所有的数组其实是对象，其“索引”看起来是数字，其实会被转换成字符串，作为属性名（对象的 <em>key</em>）来使用。所以无论是取第 <em>1</em> 个还是取第 <em>10</em> 万个元素，都是用 <em>key</em> 精确查找哈希表的过程，其消耗时间大致相同。</li>
</ul>
</blockquote>
<h3 id="116-打印出-1-10000-以内的对称数"><a href="#116-打印出-1-10000-以内的对称数" class="headerlink" title="116. 打印出 1~10000 以内的对称数"></a>116. 打印出 <em>1~10000</em> 以内的对称数</h3><blockquote>
<p>参考答案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isSymmetryNum</span>(<span class="params">start, end</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = start; i &lt; end + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> iInversionNumber = +(i.toString().split(<span class="string">&quot;&quot;</span>).reverse().join(<span class="string">&quot;&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (iInversionNumber === i &amp;&amp; i &gt; <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">isSymmetryNum(<span class="number">1</span>, <span class="number">10000</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="117-简述同步和异步的区别"><a href="#117-简述同步和异步的区别" class="headerlink" title="117. 简述同步和异步的区别"></a>117. 简述同步和异步的区别</h3><blockquote>
<p>参考答案：</p>
<p>同步意味着每一个操作必须等待前一个操作完成后才能执行。<br> 异步意味着操作不需要等待其他操作完成后才开始执行。<br> 在 <em>JavaScript</em> 中，由于单线程的特性导致所有代码都是同步的。但是，有些异步操作（例如：<code>XMLHttpRequest</code> 或 <code>setTimeout</code>）并不是由主线程进行处理的，他们由本机代码（浏览器 API）所控制，并不属于程序的一部分。但程序中被执行的回调部分依旧是同步的。</p>
<p>加分回答：</p>
<ul>
<li><em>JavaScript</em> 中的同步任务是指在主线程上排队执行的任务，只有前一个任务执行完成后才能执行后一个任务；异步任务是指进入任务队列（<em>task queue</em>）而非主线程的任务，只有当任务队列通知主线程，某个异步任务可以执行了，该任务才会进入主线程中进行执行。</li>
<li><em>JavaScript</em> 的并发模型是基于 “<em>event loop</em>”。</li>
<li>像 <code>alert</code> 这样的方法回阻塞主线程，以致用户关闭他后才能继续进行后续的操作。</li>
<li><em>JavaScript</em> 主要用于和用户互动及操作 DOM，多线程的情况和异步操作带来的复杂性相比决定了他单线程的特性。</li>
<li><em>Web Worker</em> 虽然允许 <em>JavaScript</em> 创建多个线程，但子线程完全受主线程控制，且不能操作 <em>DOM</em>。因此他还是保持了单线程的特性。</li>
</ul>
</blockquote>
<h3 id="118-怎么添加、移除、复制、创建、和查找节点"><a href="#118-怎么添加、移除、复制、创建、和查找节点" class="headerlink" title="118. 怎么添加、移除、复制、创建、和查找节点"></a>118. 怎么添加、移除、复制、创建、和查找节点</h3><blockquote>
<p>参考答案：</p>
<p>1）创建新节点</p>
<p><em>createDocumentFragment</em>( )  // 创建一个<em>DOM</em> 片段</p>
<p><em>createElement</em>( )  // 创建一个具体的元素</p>
<p><em>createTextNode</em>( ) // 创建一个文本节点</p>
<p>（2）添加、移除、替换、插入</p>
<p><em>appendChild</em>( )</p>
<p><em>removeChild</em>( )</p>
<p><em>replaceChild</em>( )</p>
<p><em>insertBefore</em>( ) // 在已有的子节点前插入一个新的子节点</p>
<p>（3）查找</p>
<p><em>getElementsByTagName</em>( )  //通过标签名称</p>
<p><em>getElementsByName</em>( ) // 通过元素的 <em>Name</em> 属性的值</p>
<p><em>getElementById</em>( ) // 通过元素 <em>Id</em>，唯一性</p>
<p><em>querySelector</em>( ) // 用于接收一个 <em>CSS</em> 选择符，返回与该模式匹配的第一个元素</p>
<p><em>querySelectorAll</em>( ) // 用于选择匹配到的所有元素</p>
</blockquote>
<h3 id="119-实现一个函数-clone-可以对-Javascript-中的五种主要数据类型（Number、string、-Object、Array、Boolean）进行复制"><a href="#119-实现一个函数-clone-可以对-Javascript-中的五种主要数据类型（Number、string、-Object、Array、Boolean）进行复制" class="headerlink" title="119. 实现一个函数 clone 可以对 Javascript 中的五种主要数据类型（Number、string、 Object、Array、Boolean）进行复制"></a>119. 实现一个函数 <em>clone</em> 可以对 <em>Javascript</em> 中的五种主要数据类型（<em>Number、string、 Object、Array、Boolean</em>）进行复制</h3><blockquote>
<p>参考答案：</p>
<p>示例代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 对象克隆</span></span><br><span class="line"><span class="comment">* 支持基本数据类型及对象</span></span><br><span class="line"><span class="comment">* 递归方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">typeof</span> obj) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;undefined&quot;</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;string&quot;</span>:</span><br><span class="line">            o = obj + <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;number&quot;</span>:</span><br><span class="line">            o = obj - <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;boolean&quot;</span>:</span><br><span class="line">            o = obj;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;object&quot;</span>: <span class="comment">// object 分为两种情况 对象（Object）或数组（Array）</span></span><br><span class="line">            <span class="keyword">if</span> (obj === <span class="literal">null</span>) &#123;</span><br><span class="line">                o = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(obj).slice(<span class="number">8</span>, -<span class="number">1</span>) === <span class="string">&quot;Array&quot;</span>) &#123;</span><br><span class="line">                    o = [];</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; obj.length; i++) &#123;</span><br><span class="line">                        o.push(clone(obj[i]));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    o = &#123;&#125;;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> obj) &#123;</span><br><span class="line">                        o[k] = clone(obj[k]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            o = obj;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="120-如何消除一个数组里面重复的元素"><a href="#120-如何消除一个数组里面重复的元素" class="headerlink" title="120. 如何消除一个数组里面重复的元素"></a>120. 如何消除一个数组里面重复的元素</h3><blockquote>
<p>参考答案：</p>
<p>请参阅前面第 <em>2</em> 题。</p>
</blockquote>
<h3 id="121-写一个返回闭包的函数"><a href="#121-写一个返回闭包的函数" class="headerlink" title="121. 写一个返回闭包的函数"></a>121. 写一个返回闭包的函数</h3><blockquote>
<p>参考答案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f1 = foo();</span><br><span class="line">f1(); <span class="comment">// 0</span></span><br><span class="line">f1(); <span class="comment">// 1</span></span><br><span class="line">f1(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="122-使用递归完成-1-到-100-的累加"><a href="#122-使用递归完成-1-到-100-的累加" class="headerlink" title="122. 使用递归完成 1 到 100 的累加"></a>122. 使用递归完成 1 到 100 的累加</h3><blockquote>
<p>参考答案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x === y)&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> y + add(x, y-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">100</span>))</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="123-Javascript-有哪几种数据类型"><a href="#123-Javascript-有哪几种数据类型" class="headerlink" title="123. Javascript 有哪几种数据类型"></a>123. <em>Javascript</em> 有哪几种数据类型</h3><blockquote>
<p>参考答案：</p>
<p>请参阅前面第 <em>26</em> 题。</p>
</blockquote>
<h3 id="124-如何判断数据类型"><a href="#124-如何判断数据类型" class="headerlink" title="124. 如何判断数据类型"></a>124. 如何判断数据类型</h3><blockquote>
<p>参考答案：</p>
<p>请参阅前面第 <em>69</em> 题。</p>
</blockquote>
<h3 id="125-console-log-1-’2’-和-console-log-1-‘2’-的打印结果"><a href="#125-console-log-1-’2’-和-console-log-1-‘2’-的打印结果" class="headerlink" title="125. console.log(1+’2’)和 console.log(1-‘2’)的打印结果"></a>125. console.log(1+’2’)和 console.log(1-‘2’)的打印结果</h3><blockquote>
<p>参考答案：</p>
<p>第一个打印出 ‘12’，是一个 <em>string</em> 类型的值。</p>
<p>第二个打印出 -1，是一个 <em>number</em> 类型的值</p>
</blockquote>
<h3 id="126-JS-的事件委托是什么，原理是什么"><a href="#126-JS-的事件委托是什么，原理是什么" class="headerlink" title="126. JS 的事件委托是什么，原理是什么"></a>126. <em>JS</em> 的事件委托是什么，原理是什么</h3><blockquote>
<p>参考答案：</p>
<p>事件委托，又被称之为事件代理。在 <em>JavaScript</em> 中，添加到页面上的事件处理程序数量将直接关系到页面整体的运行性能。导致这一问题的原因是多方面的。</p>
<p>首先，每个函数都是对象，都会占用内存。内存中的对象越多，性能就越差。其次，必须事先指定所有事件处理程序而导致的 <em>DOM</em> 访问次数，会延迟整个页面的交互就绪时间。</p>
<p>对事件处理程序过多问题的解决方案就是事件委托。</p>
<p>事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。例如，<em>click</em> 事件会一直冒泡到 <em>document</em> 层次。也就是说，我们可以为整个页面指定一个 <em>onclick</em> 事件处理程序，而不必给每个可单击的元素分别添加事件处理程序。</p>
</blockquote>
<h3 id="127-如何改变函数内部的-this-指针的指向"><a href="#127-如何改变函数内部的-this-指针的指向" class="headerlink" title="127. 如何改变函数内部的 this 指针的指向"></a>127. 如何改变函数内部的 <em>this</em> 指针的指向</h3><blockquote>
<p>参考答案：</p>
<p>可以通过 <em>call、apply、bind</em> 方法来改变 <em>this</em> 的指向，关于 <em>call、apply、bind</em> 方法的具体使用，请参阅前面 <em>102</em> 题</p>
</blockquote>
<h3 id="128-JS-延迟加载的方式有哪些？"><a href="#128-JS-延迟加载的方式有哪些？" class="headerlink" title="128. JS 延迟加载的方式有哪些？"></a>128. <em>JS</em> 延迟加载的方式有哪些？</h3><blockquote>
<p>参考答案：</p>
<ul>
<li><em>defer</em> 属性</li>
<li><em>async</em> 属性</li>
<li>使用 <em>jQuery</em> 的 <em>getScript</em>( ) 方法</li>
<li>使用 <em>setTimeout</em> 延迟方法</li>
<li>把 <em>JS</em> 外部引入的文件放到页面底部，来让 <em>JS</em> 最后引入</li>
</ul>
</blockquote>
<h3 id="129-说说严格模式的限制"><a href="#129-说说严格模式的限制" class="headerlink" title="129. 说说严格模式的限制"></a>129. 说说严格模式的限制</h3><blockquote>
<p>参考答案：</p>
<p>什么是严格模式？</p>
<p>严格模式对 <em>JavaScript</em> 的语法和行为都做了一些更改，消除了语言中一些不合理、不确定、不安全之处；提供高效严谨的差错机制，保证代码安全运行；禁用在未来版本中可能使用的语法，为新版本做好铺垫。在脚本文件第一行或函数内第一行中引入”use strict”这条指令，就能触发严格模式，这是一条没有副作用的指令，老版的浏览器会将其作为一行字符串直接忽略。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;<span class="comment">//脚本第一行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line"><span class="meta">	&quot;use strict&quot;</span>;<span class="comment">//函数内第一行</span></span><br><span class="line">	<span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>进入严格模式后的限制</p>
<ul>
<li>变量必须声明后再赋值</li>
<li>不能有重复的参数名，函数的参数也不能有同名属性</li>
<li>不能使用<em>with</em>语句</li>
<li>不能对只读属性赋值</li>
<li>不能使用前缀  <em>0</em>表示八进制数</li>
<li>不能删除不可删除的属性</li>
<li><em>eval</em> 不会在它的外层作用域引入变量。</li>
<li><em>eval</em>和<em>arguments</em>不能被重新赋值</li>
<li><em>arguments</em> 不会自动反应函数的变化</li>
<li>不能使用 <em>arguments.callee</em></li>
<li>不能使用 <em>arguments.caller</em></li>
<li>禁止 <em>this</em> 指向全局对象</li>
<li>不能使用 <em>fn.caller</em> 和 <em>fn.arguments</em> 获取函数调用的堆栈</li>
<li>增加了保留字</li>
</ul>
</blockquote>
<h3 id="130-attribute-和-property-的区别是什么？"><a href="#130-attribute-和-property-的区别是什么？" class="headerlink" title="130. attribute 和 property 的区别是什么？"></a>130. <em>attribute</em> 和 <em>property</em> 的区别是什么？</h3><blockquote>
<p>参考答案：</p>
<p>property 和 attribute 非常容易混淆，两个单词的中文翻译也都非常相近（property：属性，attribute：特性），但实际上，二者是不同的东西，属于不同的范畴。</p>
<ul>
<li>property是DOM中的属性，是JavaScript里的对象；</li>
<li>attribute是HTML标签上的特性，它的值只能够是字符串；</li>
</ul>
<p>简单理解，Attribute就是dom节点自带的属性，例如html中常用的id、class、title、align等。</p>
<p>而Property是这个DOM元素作为对象，其附加的内容，例如childNodes、firstChild等。</p>
</blockquote>
<h3 id="131-ES6-能写-class-么，为什么会出现-class-这种东西"><a href="#131-ES6-能写-class-么，为什么会出现-class-这种东西" class="headerlink" title="131. ES6 能写 class 么，为什么会出现 class 这种东西?"></a>131. <em>ES6</em> 能写 <em>class</em> 么，为什么会出现 <em>class</em> 这种东西?</h3><blockquote>
<p>参考答案：</p>
<p>在 <em>ES6</em> 中，可以书写 <em>class</em>。因为在 <em>ES6</em> 规范中，引入了 <em>class</em> 的概念。使得 <em>JS</em> 开发者终于告别了直接使用原型对象模仿面向对象中的类和类继承时代。</p>
<p>但是 <em>JS</em> 中并没有一个真正的 <em>class</em> 原始类型， <em>class</em> 仅仅只是对原型对象运用语法糖。</p>
<p>之所以出现 <em>class</em> 关键字，是为了使 <em>JS</em> 更像面向对象，所以 <em>ES6</em> 才引入 <em>class</em> 的概念。</p>
</blockquote>
<h3 id="132-常见兼容性问题"><a href="#132-常见兼容性问题" class="headerlink" title="132. 常见兼容性问题"></a>132. 常见兼容性问题</h3><blockquote>
<p>参考答案：</p>
<p>常见的兼容性问题很多，这里列举一些：</p>
<ol>
<li>关于获取行外样式 <em>currentStyle</em> 和 <em>getComputedStyle</em> 出现的兼容问题</li>
</ol>
<p>我们都知道 <em>JS</em> 通过 <em>style</em> 不可以获取行外样式，如果我们需要获取行外样式就会使用这两种</p>
<ul>
<li><p>IE 下：<em>currentStyle</em></p>
</li>
<li><p>chrome、FF 下：<em>getComputedStyle</em> 第二个参数的作用是获取伪类元素的属性值</p>
</li>
</ul>
<ol start="2">
<li>关于“索引”获取字符串每一项出现的兼容性的问题</li>
</ol>
<p>对于字符串也有类似于数组这样通过下标索引获取每一项的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;abcd&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure>

<p>但是低版本的浏览器 <em>IE6、7</em> 不兼容</p>
<ol start="3">
<li>关于使用 <em>firstChild、lastChild</em> 等，获取第一个/最后一个元素节点是产生的问题</li>
</ol>
<ul>
<li>IE6-8下： <em>firstChild,lastChild,nextSibling,previousSibling</em> 获取第一个元素节点</li>
<li>高版本浏览器IE9+、FF、Chrome：获取的空白文本节点</li>
</ul>
<ol start="4">
<li>关于使用 <em>event</em> 对象，出现兼容性问题</li>
</ol>
<p>在 <em>IE8</em> 及之前的版本浏览器中，<em>event</em> 事件对象是作为 <em>window</em> 对象的一个属性。</p>
<p>所以兼容的写法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    event = event || <span class="built_in">window</span>.event;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="5">
<li>关于事件绑定的兼容性问题</li>
</ol>
<ul>
<li><p><em>IE8</em> 以下用: attachEvent(‘事件名’,fn);</p>
</li>
<li><p><em>FF、Chrome、IE9-10</em> 用: attachEventLister(‘事件名’,fn,false);</p>
</li>
</ul>
<ol start="6">
<li>关于获取滚动条距离而出现的问题</li>
</ol>
<p>当我们获取滚动条滚动距离时:</p>
<ul>
<li><p><em>IE、Chrome: document.body.scrollTop</em></p>
</li>
<li><p><em>FF: document.documentElement.scrollTop</em></p>
</li>
</ul>
<p>兼容处理:</p>
<p><em>var scrollTop = document.documentElement.scrollTop||document.body.scrollTop</em></p>
</blockquote>
<h3 id="133-函数防抖节流的原理"><a href="#133-函数防抖节流的原理" class="headerlink" title="133. 函数防抖节流的原理"></a>133. 函数防抖节流的原理</h3><blockquote>
<p>参考答案：</p>
<p>请参阅前面第 <em>49、106</em> 题。</p>
</blockquote>
<h3 id="134-原始类型有哪几种？null-是对象吗？"><a href="#134-原始类型有哪几种？null-是对象吗？" class="headerlink" title="134. 原始类型有哪几种？null 是对象吗？"></a>134. 原始类型有哪几种？<em>null</em> 是对象吗？</h3><blockquote>
<p>参考答案：</p>
<p>在 <em>JavaScript</em> 中，数据类型整体上来讲可以分为两大类：<strong>基本类型</strong>和<strong>引用数据类型</strong></p>
<p>基本数据类型，一共有 <em>6</em> 种：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string，symbol，number，boolean，undefined，null</span><br></pre></td></tr></table></figure>

<p>其中 <em>symbol</em> 类型是在 <em>ES6</em> 里面新添加的基本数据类型。</p>
<p>引用数据类型，就只有 <em>1</em> 种：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">object</span><br></pre></td></tr></table></figure>

<p>基本数据类型的值又被称之为原始值或简单值，而引用数据类型的值又被称之为复杂值或引用值。</p>
<p>关于原始类型和引用类型的区别，可以参阅第 <em>26</em> 题。</p>
<p><em>null</em> 表示空，但是当我们使用 <em>typeof</em> 来进行数据类型检测的时候，得到的值是 <em>object</em>。</p>
<p>具体原因可以参阅前面第 <em>68</em> 题。</p>
</blockquote>
<h3 id="135-为什么-console-log-0-2-0-1-0-3-false"><a href="#135-为什么-console-log-0-2-0-1-0-3-false" class="headerlink" title="135. 为什么 console.log(0.2+0.1==0.3)  // false"></a>135. 为什么 <em>console.log(0.2+0.1==0.3)  // false</em></h3><blockquote>
<p>参考答案：</p>
<p>因为浮点数的计算存在 <em>round-off</em>  问题，也就是浮点数不能够进行精确的计算。并且：</p>
<ul>
<li>不仅 <em>JavaScript</em>，所有遵循 <em>IEEE 754</em> 规范的语言都是如此；</li>
<li>在 <em>JavaScript</em> 中，所有的 <em>Number</em> 都是以 <em>64-bit</em> 的双精度浮点数存储的；</li>
<li>双精度的浮点数在这 <em>64</em> 位上划分为 <em>3</em> 段，而这 <em>3</em> 段也就确定了一个浮点数的值，<em>64bit</em> 的划分是“<em>1-11-52</em>”的模式，具体来说：<ul>
<li>就是 <em>1</em> 位最高位（最左边那一位）表示符号位，<em>0</em> 表示正，<em>1</em> 表示负；</li>
<li><em>11</em> 位表示指数部分；</li>
<li><em>52</em> 位表示尾数部分，也就是有效域部分</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="136-说一下-JS-中类型转换的规则？"><a href="#136-说一下-JS-中类型转换的规则？" class="headerlink" title="136. 说一下 JS 中类型转换的规则？"></a>136. 说一下 <em>JS</em> 中类型转换的规则？</h3><blockquote>
<p>参考答案：</p>
<p>类型转换可以分为两种，<strong>隐性转换</strong>和<strong>显性转换</strong>。</p>
<p><strong>1. 隐性转换</strong></p>
<p>当不同数据类型之间进行相互运算，或者当对非布尔类型的数据求布尔值的时候，会发生隐性转换。</p>
<p>预期为数字的时候：算术运算的时候，我们的结果和运算的数都是数字，数据会转换为数字来进行计算。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>转换前</th>
<th>转换后</th>
</tr>
</thead>
<tbody><tr>
<td>number</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>string</td>
<td>“1”</td>
<td>1</td>
</tr>
<tr>
<td>string</td>
<td>“abc”</td>
<td>NaN</td>
</tr>
<tr>
<td>string</td>
<td>“”</td>
<td>0</td>
</tr>
<tr>
<td>boolean</td>
<td>true</td>
<td>1</td>
</tr>
<tr>
<td>boolean</td>
<td>false</td>
<td>0</td>
</tr>
<tr>
<td>undefined</td>
<td>undefined</td>
<td>NaN</td>
</tr>
<tr>
<td>null</td>
<td>null</td>
<td>0</td>
</tr>
</tbody></table>
<p>预期为字符串的时候：如果有一个操作数为字符串时，使用<code>+</code>符号做相加运算时，会自动转换为字符串。</p>
<p>预期为布尔的时候：前面在介绍布尔类型时所提到的 9 个值会转为 false，其余转为 true</p>
<p><strong>2. 显性转换</strong></p>
<p>所谓显性转换，就是只程序员强制将一种类型转换为另外一种类型。显性转换往往会使用到一些转换方法。常见的转换方法如下：</p>
<ul>
<li><p>转换为数值类型：<code>Number()</code>，<code>parseInt()</code>，<code>parseFloat()</code></p>
</li>
<li><p>转换为布尔类型：<code>Boolean()</code></p>
</li>
<li><p>转换为字符串类型：<code>toString()</code>，<code>String()</code></p>
</li>
</ul>
<p>当然，除了使用上面的转换方法，我们也可以通过一些快捷方式来进行数据类型的显性转换，如下：</p>
<ul>
<li><p>转换字符串：直接和一个空字符串拼接，例如：<code>a = &quot;&quot; + 数据</code></p>
</li>
<li><p>转换布尔：!!数据类型，例如：<code>!!&quot;Hello&quot;</code></p>
</li>
<li><p>转换数值：数据*1 或 /1，例如：<code>&quot;Hello * 1&quot;</code></p>
</li>
</ul>
</blockquote>
<h3 id="137-深拷贝和浅拷贝的区别？如何实现"><a href="#137-深拷贝和浅拷贝的区别？如何实现" class="headerlink" title="137. 深拷贝和浅拷贝的区别？如何实现"></a>137. 深拷贝和浅拷贝的区别？如何实现</h3><blockquote>
<p>参考答案：</p>
<ul>
<li><p><strong>浅拷贝</strong>：只是拷贝了基本类型的数据，而引用类型数据，复制后也是会发生引用，我们把这种拷贝叫做浅拷贝（浅复制）</p>
<p>浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。</p>
</li>
<li><p><strong>深拷贝</strong>：在堆中重新分配内存，并且把源对象所有属性都进行新建拷贝，以保证深拷贝的对象的引用图不包含任何原有对象或对象图上的任何对象，拷贝后的对象与原来的对象是完全隔离，互不影响。</p>
</li>
</ul>
<p><strong>浅拷贝方法</strong></p>
<ol>
<li>直接赋值</li>
<li><em>Object.assign</em> 方法：可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。当拷贝的 <em>object</em> 只有一层的时候，是深拷贝，但是当拷贝的对象属性值又是一个引用时，换句话说有多层时，就是一个浅拷贝。</li>
<li><em>ES6</em> 扩展运算符，当 <em>object</em> 只有一层的时候，也是深拷贝。有多层时是浅拷贝。</li>
<li><em>Array.prototype.concat</em> 方法</li>
<li><em>Array.prototype.slice</em> 方法</li>
<li><em>jQuery</em> 中的 <em>$.extend</em>：在 <em>jQuery</em> 中，*$.extend(deep,target,object1,objectN)* 方法可以进行深浅拷贝。<em>deep</em> 如过设为 <em>true</em> 为深拷贝，默认是 <em>false</em> 浅拷贝。</li>
</ol>
<p><strong>深拷贝方法</strong></p>
<ol>
<li>*$.extend(deep,target,object1,objectN)*，将 <em>deep</em> 设置为 <em>true</em></li>
<li>*JSON.parse(JSON.stringify)*：用 <em>JSON.stringify</em> 将对象转成 <em>JSON</em> 字符串，再用 <em>JSON.parse</em> 方法把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝。这种方法虽然可以实现数组或对象深拷贝，但不能处理函数。</li>
<li>手写递归</li>
</ol>
<p>示例代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">oldObj, newobj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> oldObj) &#123;</span><br><span class="line">        <span class="keyword">var</span> item = oldObj[key];</span><br><span class="line">        <span class="comment">// 判断是否是对象</span></span><br><span class="line">        <span class="keyword">if</span> (item <span class="keyword">instanceof</span> <span class="built_in">Object</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (item <span class="keyword">instanceof</span> <span class="built_in">Function</span>) &#123;</span><br><span class="line">                newobj[key] = oldObj[key];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                newobj[key] = &#123;&#125;;  <span class="comment">//定义一个空的对象来接收拷贝的内容</span></span><br><span class="line">                deepCopy(item, newobj[key]); <span class="comment">//递归调用</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断是否是数组</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">            newobj[key] = [];  <span class="comment">//定义一个空的数组来接收拷贝的内容</span></span><br><span class="line">            deepCopy(item, newobj[key]); <span class="comment">//递归调用</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newobj[key] = oldObj[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="138-如何判断-this？箭头函数的-this-是什么"><a href="#138-如何判断-this？箭头函数的-this-是什么" class="headerlink" title="138. 如何判断 this？箭头函数的 this 是什么"></a>138. 如何判断 <em>this</em>？箭头函数的 <em>this</em> 是什么</h3><blockquote>
<p>参考答案：</p>
<p>有关如何判断 <em>this</em>，可以参阅前面 17 题。</p>
<p>有关箭头函数的 <em>this</em> 指向，可以参阅前面 <em>24、25</em> 题</p>
</blockquote>
<h3 id="139-call、apply-以及-bind-函数内部实现是怎么样的"><a href="#139-call、apply-以及-bind-函数内部实现是怎么样的" class="headerlink" title="139. call、apply 以及 bind 函数内部实现是怎么样的"></a>139. <em>call、apply</em> 以及 <em>bind</em> 函数内部实现是怎么样的</h3><blockquote>
<p>参考答案：</p>
<p>请参阅前面 <em>102</em> 题。</p>
</blockquote>
<h3 id="140-为什么会出现-setTimeout-倒计时误差？如何减少"><a href="#140-为什么会出现-setTimeout-倒计时误差？如何减少" class="headerlink" title="140. 为什么会出现 setTimeout 倒计时误差？如何减少"></a>140. 为什么会出现 <em>setTimeout</em> 倒计时误差？如何减少</h3><blockquote>
<p>参考答案：</p>
<p>定时器是属于宏任务(<em>macrotask</em>) 。如果当前执行栈所花费的时间大于定时器时间，那么定时器的回调在宏任务(<em>macrotask</em>) 里，来不及去调用，所有这个时间会有误差。</p>
</blockquote>
<h3 id="141-谈谈你对-JS-执行上下文栈和作用域链的理解"><a href="#141-谈谈你对-JS-执行上下文栈和作用域链的理解" class="headerlink" title="141. 谈谈你对 JS 执行上下文栈和作用域链的理解"></a>141. 谈谈你对 <em>JS</em> 执行上下文栈和作用域链的理解</h3><blockquote>
<p>参考答案：</p>
<p><strong>什么是执行上下文？</strong></p>
<p>简而言之，执行上下文是评估和执行 JavaScript 代码的环境的抽象概念。每当 Javascript 代码在运行的时候，它都是在执行上下文中运行。</p>
<p><strong>执行上下文的类型</strong></p>
<p>JavaScript 中有三种执行上下文类型。</p>
<ul>
<li><strong>全局执行上下文</strong> — 这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 <code>this</code> 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。</li>
<li><strong>函数执行上下文</strong> — 每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会按定义的顺序（将在后文讨论）执行一系列步骤。</li>
<li><strong>Eval 函数执行上下文</strong> — 执行在 <code>eval</code> 函数内部的代码也会有它属于自己的执行上下文。</li>
</ul>
<p><strong>调用栈</strong></p>
<p>调用栈是解析器(如浏览器中的的javascript解析器)的一种机制，可以在脚本调用多个函数时，跟踪每个函数在完成执行时应该返回控制的点。（如什么函数正在执行，什么函数被这个函数调用，下一个调用的函数是谁）</p>
<ul>
<li>当脚本要调用一个函数时，解析器把该函数添加到栈中并且执行这个函数。</li>
<li>任何被这个函数调用的函数会进一步添加到调用栈中，并且运行到它们被上个程序调用的位置。</li>
<li>当函数运行结束后，解释器将它从堆栈中取出，并在主代码列表中继续执行代码。</li>
<li>如果栈占用的空间比分配给它的空间还大，那么则会导致“栈溢出”错误。</li>
</ul>
<p><strong>作用域链</strong></p>
<p>当访问一个变量时，编译器在执行这段代码时，会首先从当前的作用域中查找是否有这个标识符，如果没有找到，就会去父作用域查找，如果父作用域还没找到继续向上查找，直到全局作用域为止,，而作用域链，就是有当前作用域与上层作用域的一系列变量对象组成，它保证了当前执行的作用域对符合访问权限的变量和函数的有序访问。</p>
</blockquote>
<h3 id="142-new-的原理是什么？通过-new-的方式创建对象和通过字面量创建有什么区别？"><a href="#142-new-的原理是什么？通过-new-的方式创建对象和通过字面量创建有什么区别？" class="headerlink" title="142. new 的原理是什么？通过 new 的方式创建对象和通过字面量创建有什么区别？"></a>142. <em>new</em> 的原理是什么？通过 <em>new</em> 的方式创建对象和通过字面量创建有什么区别？</h3><blockquote>
<p>参考答案：</p>
<p>关于 <em>new</em> 的原理，主要分为以下几步：</p>
<ul>
<li><p>创建一个空对象 。</p>
</li>
<li><p>由 <em>this</em> 变量引用该对象 。</p>
</li>
<li><p>该对象继承该函数的原型(更改原型链的指向) 。</p>
</li>
<li><p>把属性和方法加入到 <em>this</em> 引用的对象中。</p>
</li>
<li><p>新创建的对象由 <em>this</em> 引用 ，最后隐式地返回 <em>this</em>，过程如下：</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.__proto__ = Base.prototype;</span><br><span class="line">Base.call(obj);</span><br></pre></td></tr></table></figure>

<p>通过 <em>new</em> 的方式创建对象和通过字面量创建的对象，区别在于 <em>new</em> 出来的对象的原型对象为<code>构造函数.prototype</code>，而字面量对象的原型对象为 <code>Object.prototype</code></p>
<p>示例代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Computer</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> Computer();</span><br><span class="line"><span class="keyword">var</span> d = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(c.__proto__ === Computer.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(d.__proto__ === <span class="built_in">Object</span>.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="143-prototype-和-proto-区别是什么？"><a href="#143-prototype-和-proto-区别是什么？" class="headerlink" title="143. prototype 和 _proto_ 区别是什么？"></a>143. <em>prototype</em> 和 _<em><em>proto</em></em>_ 区别是什么？</h3><blockquote>
<p>参考答案：</p>
<p><em>prototype</em> 是构造函数上面的一个属性，指向实例化出来对象的原型对象。</p>
<p>_<em><em>proto</em></em>_ 是对象上面的一个隐式属性，指向自己的原型对象。</p>
</blockquote>
<h3 id="144-使用-ES5-实现一个继承？"><a href="#144-使用-ES5-实现一个继承？" class="headerlink" title="144. 使用 ES5 实现一个继承？"></a>144. 使用 ES5 实现一个继承？</h3><blockquote>
<p>参考答案：</p>
<p>请参阅第 <em>47</em> 题。</p>
</blockquote>
<h3 id="145-取数组的最大值（ES5、ES6）"><a href="#145-取数组的最大值（ES5、ES6）" class="headerlink" title="145. 取数组的最大值（ES5、ES6）"></a>145. 取数组的最大值（<em>ES5、ES6</em>）</h3><blockquote>
<p>参考答案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>];</span><br><span class="line"><span class="comment">// ES5 方式</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, arr)); <span class="comment">// 8</span></span><br><span class="line"><span class="comment">// ES6 方式</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(...arr)); <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="146-ES6-新的特性有哪些？"><a href="#146-ES6-新的特性有哪些？" class="headerlink" title="146. ES6 新的特性有哪些？"></a>146. <em>ES6</em> 新的特性有哪些？</h3><blockquote>
<p>参考答案：</p>
<p>请参阅前面第 <em>44</em> 题。</p>
</blockquote>
<h3 id="147-Promise-有几种状态-Promise-有什么优缺点"><a href="#147-Promise-有几种状态-Promise-有什么优缺点" class="headerlink" title="147. Promise 有几种状态, Promise 有什么优缺点 ?"></a>147. <em>Promise</em> 有几种状态, <em>Promise</em> 有什么优缺点 ?</h3><blockquote>
<p>参考答案：</p>
<p><em>Promise</em> 有三种状态：</p>
<p><em>pending、fulfilled、rejected</em>(未决定，履行，拒绝)，同一时间只能存在一种状态，且状态一旦改变就不能再变。<em>Promise</em> 是一个构造函数，<em>promise</em> 对象代表一项有两种可能结果（成功或失败）的任务，它还持有多个回调，出现不同结果时分别发出相应回调。</p>
<ul>
<li>初始化状态：<em>pending</em></li>
<li>当调用 <em>resolve</em>(成功) 状态：<em>pengding=&gt;fulfilled</em></li>
<li>当调用 <em>reject</em>(失败) 状态：<em>pending=&gt;rejected</em></li>
</ul>
<p><em>Promise</em> 的优点是解决了回调地狱，缺点是代码并没有因为新方法的出现而减少，反而变得更加复杂，同时理解难度也加大。所以后面出现了 <em>async/await</em> 的异步解决方案。</p>
</blockquote>
<h3 id="148-Promise-构造函数是同步还是异步执行，then-呢-Promise-如何实现-then-处理"><a href="#148-Promise-构造函数是同步还是异步执行，then-呢-Promise-如何实现-then-处理" class="headerlink" title="148. Promise 构造函数是同步还是异步执行，then 呢 ? Promise 如何实现 then 处理 ?"></a>148. <em>Promise</em> 构造函数是同步还是异步执行，<em>then</em> 呢 ? <em>Promise</em> 如何实现 <em>then</em> 处理 ?</h3><blockquote>
<p>参考答案：</p>
<p><em>promise</em> 构造函数是同步执行的，<em>then</em> 方法是异步执行，<em>then</em> 方法中的内容加入微任务中。</p>
<p>接下来我们来看 <em>promise</em> 如何实现 <em>then</em> 的处理。</p>
<p>我们知道 <em>then</em> 是用来处理 <em>resolve</em> 和 <em>reject</em> 函数的回调。那么首先我们来定义 <em>then</em> 方法。</p>
<h5 id="1、then方法需要两个参数，其中onFulfilled代表resolve成功的回调，onRejected代表reject失败的回调。"><a href="#1、then方法需要两个参数，其中onFulfilled代表resolve成功的回调，onRejected代表reject失败的回调。" class="headerlink" title="1、then方法需要两个参数，其中onFulfilled代表resolve成功的回调，onRejected代表reject失败的回调。"></a>1、then方法需要两个参数，其中onFulfilled代表resolve成功的回调，onRejected代表reject失败的回调。</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">then</span>(<span class="params">onFulfilled,onRejected</span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、我们知道promise的状态是不可逆的，在状态发生改变后，即不可再次更改，只有状态为FULFILLED才会调用onFulfilled，状态为REJECTED调用onRejected"><a href="#2、我们知道promise的状态是不可逆的，在状态发生改变后，即不可再次更改，只有状态为FULFILLED才会调用onFulfilled，状态为REJECTED调用onRejected" class="headerlink" title="2、我们知道promise的状态是不可逆的，在状态发生改变后，即不可再次更改，只有状态为FULFILLED才会调用onFulfilled，状态为REJECTED调用onRejected"></a>2、我们知道promise的状态是不可逆的，在状态发生改变后，即不可再次更改，只有状态为FULFILLED才会调用onFulfilled，状态为REJECTED调用onRejected</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.status == <span class="built_in">Promise</span>.FULFILLED) &#123;</span><br><span class="line">        onFulfilled(<span class="built_in">this</span>.value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.status == <span class="built_in">Promise</span>.REJECTED) &#123;</span><br><span class="line">        onRejected(<span class="built_in">this</span>.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3、then方法的每个方法都不是必须的，所以我们要处理当没有传递参数时，应该设置默认值"><a href="#3、then方法的每个方法都不是必须的，所以我们要处理当没有传递参数时，应该设置默认值" class="headerlink" title="3、then方法的每个方法都不是必须的，所以我们要处理当没有传递参数时，应该设置默认值"></a>3、then方法的每个方法都不是必须的，所以我们要处理当没有传递参数时，应该设置默认值</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">then</span>(<span class="params">onFulfilled,onRejected</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> onFulfilled !==<span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">        onFulfilled = <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> onRejected  !==<span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">        onRejected = <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.status == <span class="built_in">Promise</span>.FULFILLED)&#123;</span><br><span class="line">         onFulfilled(<span class="built_in">this</span>.value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.status == <span class="built_in">Promise</span>.REJECTED)&#123;</span><br><span class="line">        onRejected(<span class="built_in">this</span>.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4、在执行then方法时，我们要考虑到传递的函数发生异常的情况，如果函数发生异常，我们应该让它进行错误异常处理，统一交给onRejected来处理错误"><a href="#4、在执行then方法时，我们要考虑到传递的函数发生异常的情况，如果函数发生异常，我们应该让它进行错误异常处理，统一交给onRejected来处理错误" class="headerlink" title="4、在执行then方法时，我们要考虑到传递的函数发生异常的情况，如果函数发生异常，我们应该让它进行错误异常处理，统一交给onRejected来处理错误"></a>4、在执行then方法时，我们要考虑到传递的函数发生异常的情况，如果函数发生异常，我们应该让它进行错误异常处理，统一交给onRejected来处理错误</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">then</span>(<span class="params">onFulfilled,onRejected</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">typeof</span> onFulfilled !==<span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">        onFulfilled = <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> onRejected  !==<span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">        onRejected = <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.status == <span class="built_in">Promise</span>.FULFILLED)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;onFulfilled(<span class="built_in">this</span>.value)&#125;<span class="keyword">catch</span>(error)&#123; onRejected(error) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.status == <span class="built_in">Promise</span>.REJECTED)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;onRejected(<span class="built_in">this</span>.value)&#125;<span class="keyword">catch</span>(error)&#123; onRejected(error) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5、但是现在我们自己封装的promise有个小问题，我们知道原生的promise中then方法都是异步执行，在一个同步任务执行之后再调用，而我们的现在的情况则是同步调用，因此我们要使用setTimeout来将onFulfilled和onRejected来做异步宏任务执行。"><a href="#5、但是现在我们自己封装的promise有个小问题，我们知道原生的promise中then方法都是异步执行，在一个同步任务执行之后再调用，而我们的现在的情况则是同步调用，因此我们要使用setTimeout来将onFulfilled和onRejected来做异步宏任务执行。" class="headerlink" title="5、但是现在我们自己封装的promise有个小问题，我们知道原生的promise中then方法都是异步执行，在一个同步任务执行之后再调用，而我们的现在的情况则是同步调用，因此我们要使用setTimeout来将onFulfilled和onRejected来做异步宏任务执行。"></a>5、但是现在我们自己封装的promise有个小问题，我们知道原生的promise中then方法都是异步执行，在一个同步任务执行之后再调用，而我们的现在的情况则是同步调用，因此我们要使用setTimeout来将onFulfilled和onRejected来做异步宏任务执行。</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">this</span>.status=<span class="built_in">Promise</span>.FULFILLED)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;onFulfilled(<span class="built_in">this</span>.value)&#125;<span class="keyword">catch</span>(error)&#123;onRejected(error)&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">this</span>.status=<span class="built_in">Promise</span>.REJECTED)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;onRejected(<span class="built_in">this</span>.value)&#125;<span class="keyword">catch</span>(error)&#123;onRejected(error)&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="现在then方法中，可以处理status为FULFILLED和REJECTED的情况，但是不能处理为pedding的情况，接下来进行几处修改。"><a href="#现在then方法中，可以处理status为FULFILLED和REJECTED的情况，但是不能处理为pedding的情况，接下来进行几处修改。" class="headerlink" title="现在then方法中，可以处理status为FULFILLED和REJECTED的情况，但是不能处理为pedding的情况，接下来进行几处修改。"></a>现在then方法中，可以处理status为FULFILLED和REJECTED的情况，但是不能处理为pedding的情况，接下来进行几处修改。</h5><h5 id="6、在构造函数中，添加callbacks来保存pending状态时处理函数，当状态改变时循环调用"><a href="#6、在构造函数中，添加callbacks来保存pending状态时处理函数，当状态改变时循环调用" class="headerlink" title="6、在构造函数中，添加callbacks来保存pending状态时处理函数，当状态改变时循环调用"></a>6、在构造函数中，添加callbacks来保存pending状态时处理函数，当状态改变时循环调用</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">	...</span><br><span class="line">  <span class="built_in">this</span>.callbacks = [];</span><br><span class="line">  ...</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<h5 id="7、在then方法中，当status等于pending的情况时，将待执行函数存放到callbacks数组中。"><a href="#7、在then方法中，当status等于pending的情况时，将待执行函数存放到callbacks数组中。" class="headerlink" title="7、在then方法中，当status等于pending的情况时，将待执行函数存放到callbacks数组中。"></a>7、在then方法中，当status等于pending的情况时，将待执行函数存放到callbacks数组中。</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">then</span>(<span class="params">onFulfilled,onRejected</span>)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.status==<span class="built_in">Promise</span>.PENDING)&#123;</span><br><span class="line">        <span class="built_in">this</span>.callbacks.push(&#123;</span><br><span class="line">            <span class="attr">onFulfilled</span>:<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  onFulfilled(value);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                  onRejected(error);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="attr">onRejected</span>: <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              onRejected(value);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">              onRejected(error);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="8、当执行resolve和reject时，在堆callacks数组中的函数进行执行"><a href="#8、当执行resolve和reject时，在堆callacks数组中的函数进行执行" class="headerlink" title="8、当执行resolve和reject时，在堆callacks数组中的函数进行执行"></a>8、当执行resolve和reject时，在堆callacks数组中的函数进行执行</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">resolve</span>(<span class="params">vale</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.status==<span class="built_in">Promise</span>.PENDING)&#123;</span><br><span class="line">        <span class="built_in">this</span>.status = <span class="built_in">Promise</span>.FULFILLED;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.callbacks.map(<span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">          callback.onFulfilled(value);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">reject</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.status==<span class="built_in">Promise</span>.PENDING)&#123;</span><br><span class="line">        <span class="built_in">this</span>.status = <span class="built_in">Promise</span>.REJECTED;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.callbacks.map(<span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">          callback.onRejected(value);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="9、then方法中，关于处理pending状态时，异步处理的方法：只需要将resolve与reject执行通过setTimeout定义为异步任务"><a href="#9、then方法中，关于处理pending状态时，异步处理的方法：只需要将resolve与reject执行通过setTimeout定义为异步任务" class="headerlink" title="9、then方法中，关于处理pending状态时，异步处理的方法：只需要将resolve与reject执行通过setTimeout定义为异步任务"></a>9、then方法中，关于处理pending状态时，异步处理的方法：只需要将resolve与reject执行通过setTimeout定义为异步任务</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">resolve</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.status == <span class="built_in">Promise</span>.PENDING) &#123;</span><br><span class="line">   	<span class="built_in">this</span>.status = <span class="built_in">Promise</span>.FULFILLED;</span><br><span class="line">	<span class="built_in">this</span>.value = value;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.callbacks.map(<span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">        callback.onFulfilled(value);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">reject</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.status == <span class="built_in">Promise</span>.PENDING) &#123;</span><br><span class="line">  	<span class="built_in">this</span>.status = <span class="built_in">Promise</span>.REJECTED;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.callbacks.map(<span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">        callback.onRejected(value);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此，promise的then方法的基本实现就结束了。</p>
</blockquote>
<h3 id="149-Promise-和-setTimeout-的区别"><a href="#149-Promise-和-setTimeout-的区别" class="headerlink" title="149. Promise 和 setTimeout 的区别 ?"></a>149. <em>Promise</em> 和 <em>setTimeout</em> 的区别 ?</h3><blockquote>
<p>参考答案：</p>
<p><em>JavaScript</em> 将异步任务分为 <em>MacroTask</em>（宏任务） 和 <em>MicroTask</em>（微任务），那么它们区别何在呢？</p>
<ol>
<li>依次执行同步代码直至执行完毕；</li>
<li>检查MacroTask 队列，若有触发的异步任务，则取第一个并调用其事件处理函数，然后跳至第三步，若没有需处理的异步任务，则直接跳至第三步；</li>
<li>检查MicroTask队列，然后执行所有已触发的异步任务，依次执行事件处理函数，直至执行完毕，然后跳至第二步，若没有需处理的异步任务中，则直接返回第二步，依次执行后续步骤；</li>
<li>最后返回第二步，继续检查MacroTask队列，依次执行后续步骤；</li>
<li>如此往复，若所有异步任务处理完成，则结束；</li>
</ol>
<p><em>Promise</em> 是一个微任务，主线程是一个宏任务，微任务队列会在宏任务后面执行</p>
<p><em>setTimeout</em> 返回的函数是一个新的宏任务，被放入到宏任务队列</p>
<p>所以 <em>Promise</em> 会先于新的宏任务执行</p>
</blockquote>
<h3 id="150-如何实现-Promise-all"><a href="#150-如何实现-Promise-all" class="headerlink" title="150. 如何实现 Promise.all ?"></a>150. 如何实现 <em>Promise.all</em> ?</h3><blockquote>
<p>参考答案：</p>
<p><code>Promise.all</code> 接收一个 <code>promise</code> 对象的数组作为参数，当这个数组里的所有 <code>promise</code> 对象全部变为<code>resolve</code>或 有 <code>reject</code> 状态出现的时候，它才会去调用 <code>.then</code> 方法,它们是并发执行的。</p>
<p>总结 <code>promise.all</code> 的特点</p>
<p>1、接收一个 <code>Promise</code> 实例的数组或具有 <code>Iterator</code> 接口的对象，</p>
<p>2、如果元素不是 <code>Promise</code> 对象，则使用 <code>Promise.resolve</code> 转成 <code>Promise</code> 对象</p>
<p>3、如果全部成功，状态变为 <code>resolved</code>，返回值将组成一个数组传给回调</p>
<p>4、只要有一个失败，状态就变为 <code>rejected</code>，返回值将直接传递给回调<br><code>all()</code> 的返回值也是新的 <code>Promise</code> 对象</p>
<p>实现 <code>Promise.all</code> 方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promiseAll</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isArray(promises)) &#123;</span><br><span class="line">            <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;arguments must be an array&#x27;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> resolvedCounter = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">var</span> promiseNum = promises.length;</span><br><span class="line">        <span class="keyword">var</span> resolvedValues = <span class="keyword">new</span> <span class="built_in">Array</span>(promiseNum);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; promiseNum; i++) &#123;</span><br><span class="line">            (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">Promise</span>.resolve(promises[i]).then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">                    resolvedCounter++</span><br><span class="line">                    resolvedValues[i] = value</span><br><span class="line">                    <span class="keyword">if</span> (resolvedCounter == promiseNum) &#123;</span><br><span class="line">                        <span class="keyword">return</span> resolve(resolvedValues)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> reject(reason)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)(i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="151-如何实现-Promise-finally"><a href="#151-如何实现-Promise-finally" class="headerlink" title="151. 如何实现 Promise.finally ?"></a>151. 如何实现 <em>Promise.finally</em> ?</h3><blockquote>
<p>参考答案：</p>
<p><em>finally</em> 方法是 <em>ES2018</em> 的新特性</p>
<p><em>finally</em> 方法用于指定不管 <em>Promise</em> 对象最后状态如何，都会执行的操作，执行 <em>then</em> 和 <em>catch</em>  后，都会执行 <em>finally</em> 指定的回调函数。</p>
<p>方法一：借助 <em>promise.prototype.finally</em> 包</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install promise-prototype-<span class="keyword">finally</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promiseFinally = <span class="built_in">require</span>(<span class="string">&#x27;promise.prototype.finally&#x27;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 向 Promise.prototype 增加 finally()</span></span><br><span class="line">promiseFinally.shim();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 之后就可以按照上面的使用方法使用了</span></span><br></pre></td></tr></table></figure>



<p>方法二：实现 <em>Promise.finally</em></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.finally = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> P = <span class="built_in">this</span>.constructor;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.then(</span><br><span class="line">    <span class="function"><span class="params">value</span>  =&gt;</span> P.resolve(callback()).then(<span class="function">() =&gt;</span> value),</span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> P.resolve(callback()).then(<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


</blockquote>
<h3 id="152-如何判断-img-加载完成"><a href="#152-如何判断-img-加载完成" class="headerlink" title="152. 如何判断 img 加载完成"></a>152. 如何判断 <em>img</em> 加载完成</h3><blockquote>
<p>参考答案：</p>
<ul>
<li>为 <em>img DOM</em> 节点绑定 <em>load</em> 事件</li>
<li><em>readystatechange</em> 事件：<em>readyState</em> 为 <em>complete</em> 和 <em>loaded</em> 则表明图片已经加载完毕。测试 <em>IE6-IE10</em> 支持该事件，其它浏览器不支持。</li>
<li><em>img</em> 的 <em>complete</em> 属性：轮询不断监测 <em>img</em> 的 <em>complete</em> 属性，如果为 <em>true</em> 则表明图片已经加载完毕，停止轮询。该属性所有浏览器都支持。</li>
</ul>
</blockquote>
<h3 id="153-如何阻止冒泡？"><a href="#153-如何阻止冒泡？" class="headerlink" title="153. 如何阻止冒泡？"></a>153. 如何阻止冒泡？</h3><blockquote>
<p>参考答案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一：IE9+，其他主流浏览器</span></span><br><span class="line">event.stopPropagation()</span><br><span class="line"><span class="comment">// 方法二：火狐未实现</span></span><br><span class="line">event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 方法三：不建议滥用，jq 中可以同时阻止冒泡和默认事件</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="154-如何阻止默认事件？"><a href="#154-如何阻止默认事件？" class="headerlink" title="154. 如何阻止默认事件？"></a>154. 如何阻止默认事件？</h3><blockquote>
<p>参考答案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一：全支持</span></span><br><span class="line">event.preventDefault();</span><br><span class="line"><span class="comment">// 方法二：该特性已经从 Web 标准中删除，虽然一些浏览器目前仍然支持它，但也许会在未来的某个时间停止支持，请尽量不要使用该特性。</span></span><br><span class="line">event.returnValue=<span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 方法三：不建议滥用，jq 中可以同时阻止冒泡和默认事件</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="155-如何用原生-js-给一个按钮绑定两个-onclick-事件？"><a href="#155-如何用原生-js-给一个按钮绑定两个-onclick-事件？" class="headerlink" title="155. 如何用原生 js 给一个按钮绑定两个 onclick 事件？"></a>155. 如何用原生 <em>js</em> 给一个按钮绑定两个 <em>onclick</em> 事件？</h3><blockquote>
<p>参考答案：</p>
<p>使用 <em>addEventListener</em> 方法来绑定事件，就可以绑定多个同种类型的事件。</p>
</blockquote>
<h3 id="156-拖拽会用到哪些事件"><a href="#156-拖拽会用到哪些事件" class="headerlink" title="156. 拖拽会用到哪些事件"></a>156. 拖拽会用到哪些事件</h3><blockquote>
<p>参考答案：</p>
<p>在以前，书写一个拖拽需要用到 <em>mousedown、mousemove、mouseup</em> 这 <em>3</em> 个事件。</p>
<p><em>HTML5</em> 推出后，新推出了一组拖拽相关的 <em>API</em>，涉及到的事件有 <em>dragstart、dragover、drop</em> 这 <em>3</em> 个事件。</p>
</blockquote>
<h3 id="157-document-write-和-innerHTML-的区别"><a href="#157-document-write-和-innerHTML-的区别" class="headerlink" title="157. document.write 和 innerHTML 的区别"></a>157. <em>document.write</em> 和 <em>innerHTML</em> 的区别</h3><blockquote>
<p>参考答案：</p>
<p><em>document.write</em> 是直接写入到页面的内容流，如果在写之前没有调用 <em>document.open</em>,  浏览器会自动调用 <em>open</em>。每次写完关闭之后重新调用该函数，会导致页面全部重绘。 </p>
<p><em>innerHTML</em> 则是 <em>DOM</em> 页面元素的一个属性，代表该元素的 <em>html</em> 内容。你可以精确到某一个具体的元素来进行更改。如果想修改 <em>document</em> 的内容，则需要修改 <em>document.documentElement.innerElement</em>。 </p>
<p><em>innerHTML</em> 很多情况下都优于 <em>document.write</em>，其原因在于不会导致页面全部重绘。</p>
</blockquote>
<h3 id="158-jQuery-的事件委托方法-bind-、live、delegate、one、on-之间有什么区别？"><a href="#158-jQuery-的事件委托方法-bind-、live、delegate、one、on-之间有什么区别？" class="headerlink" title="158. jQuery 的事件委托方法 bind 、live、delegate、one、on 之间有什么区别？"></a>158. <em>jQuery</em> 的事件委托方法 <em>bind 、live、delegate、one、on</em> 之间有什么区别？</h3><blockquote>
<p>参考答案：</p>
<p>这几个方法都可以实现事件处理。其中 <em>on</em> 集成了事件处理的所有功能，也是目前推荐使用的方法。</p>
<p><em>one</em> 是指添加的是一次性事件，意味着只要触发一次该事件，相应的处理方法执行后就自动被删除。</p>
<p><em>bind</em> 是较早版本的绑定事件的方法，现在已被 <em>on</em> 替代。</p>
<p><em>live</em> 和 <em>delegate</em> 主要用来做事件委托。<em>live</em> 的版本较早，现在已被废弃。<em>delegate</em> 目前仍然可用，不过也可用 <em>on</em> 来替代它。</p>
</blockquote>
<h3 id="159-document-ready-方法和-window-onload-有什么区别？"><a href="#159-document-ready-方法和-window-onload-有什么区别？" class="headerlink" title="159. $(document).ready 方法和 window.onload 有什么区别？"></a>159. <em>$(document).ready</em> 方法和 <em>window.onload</em> 有什么区别？</h3><blockquote>
<p>参考答案：</p>
<p>主要有两点区别：</p>
<ol>
<li>执行时机</li>
</ol>
<p><em>window.onload</em> 方法是在网页中的所有的元素（包括元素的所有关联文件）都完全加载到浏览器之后才执行。而通过 <em>jQuery</em> 中的<code>$(document).ready</code>方法注册的事件处理程序，只要在 <em>DOM</em> 完全就绪时，就可以调用了，比如一张图片只要<code>&lt;img&gt;</code>标签完成，不用等这个图片加载完成，就可以设置图片的宽高的属性或样式等。</p>
<p>其实从二者的英文字母可以大概理解上面的话，<em>onload</em> 即加载完成，<em>ready</em> 即 <em>DOM</em> 准备就绪。</p>
<ol start="2">
<li>注册事件　</li>
</ol>
<p><code>$(document).ready</code>方法可以多次使用而注册不同的事件处理程序，而 <em>window.onload</em> 一次只能保存对一个函数的引用，多次绑定函数只会覆盖前面的函数。</p>
</blockquote>
<h3 id="160-jquery-中-get-提交和-post-提交有区别吗？"><a href="#160-jquery-中-get-提交和-post-提交有区别吗？" class="headerlink" title="160. jquery 中$.get()提交和$.post()提交有区别吗？"></a>160. jquery 中$.get()提交和$.post()提交有区别吗？</h3><blockquote>
<p>参考答案：</p>
<p>相同点：都是异步请求的方式来获取服务端的数据</p>
<p>不同点：</p>
<ul>
<li>请求方式不同：<code>$.get()</code> 方法使用 <em>GET</em> 方法来进行异步请求的。<code>$.post()</code> 方法使用 <em>POST</em> 方法来进行异步请求的。</li>
<li>参数传递方式不同： <em>GET</em> 请求会将参数跟在 <em>URL</em> 后进行传递，而 <em>POST</em> 请求则是作为 <em>HTTP</em> 消息的实体内容发送给 <em>Web</em> 服务器 的，这种传递是对用户不可见的。</li>
<li>数据传输大小不同： <em>GET</em> 方式传输的数据大小不能超过 <em>2KB</em> 而 <em>POST</em> 要大的多</li>
<li>安全问题： <em>GET</em> 方式请求的数据会被浏览器缓存起来，因此有安全问题。</li>
</ul>
</blockquote>
<h3 id="161-await-async-如何实现-（阿里）"><a href="#161-await-async-如何实现-（阿里）" class="headerlink" title="161. await async 如何实现 （阿里）"></a>161. <em>await async</em> 如何实现 （阿里）</h3><blockquote>
<p>参考答案：</p>
<p>async 函数只是 promise 的语法糖，它的底层实际使用的是 generator，而 generator 又是基于 promise 的。实际上，在 babel 编译 async 函数的时候，也会转化成 generatora 函数，并使用自动执行器来执行它。</p>
<p>实现代码示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncToGenerator</span>(<span class="params">generatorFunc</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> gen = generatorFunc.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">key, arg</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">let</span> generatorResult</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            generatorResult = gen[key](arg)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="keyword">return</span> reject(error)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">const</span> &#123; value, done &#125; = generatorResult</span><br><span class="line">          <span class="keyword">if</span> (done) &#123;</span><br><span class="line">            <span class="keyword">return</span> resolve(value)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(value).then(<span class="function"><span class="params">val</span> =&gt;</span> step(<span class="string">&#x27;next&#x27;</span>, val), <span class="function"><span class="params">err</span> =&gt;</span> step(<span class="string">&#x27;throw&#x27;</span>, err))</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step(<span class="string">&quot;next&quot;</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于代码的解析，可以参阅：<em><a href="https://blog.csdn.net/xgangzai/article/details/106536325">https://blog.csdn.net/xgangzai/article/details/106536325</a></em></p>
</blockquote>
<h3 id="162-clientWidth-offsetWidth-scrollWidth-的区别"><a href="#162-clientWidth-offsetWidth-scrollWidth-的区别" class="headerlink" title="162. clientWidth,offsetWidth,scrollWidth 的区别"></a>162. <em>clientWidth,offsetWidth,scrollWidth</em> 的区别</h3><blockquote>
<p>参考答案：</p>
<p><em>clientWidth</em> = <em>width</em>+左右 <em>padding</em></p>
<p><em>offsetWidth</em> = <em>width</em> + 左右 <em>padding</em> + 左右 <em>boder</em></p>
<p><em>scrollWidth</em>：获取指定标签内容层的真实宽度(可视区域宽度+被隐藏区域宽度)。</p>
</blockquote>
<h3 id="163-产生一个不重复的随机数组"><a href="#163-产生一个不重复的随机数组" class="headerlink" title="163. 产生一个不重复的随机数组"></a>163. 产生一个不重复的随机数组</h3><blockquote>
<p>参考答案：</p>
<p>示例代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成随机数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomNumBoth</span>(<span class="params">Min, Max</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> Range = Max - Min;</span><br><span class="line">    <span class="keyword">var</span> Rand = <span class="built_in">Math</span>.random();</span><br><span class="line">    <span class="keyword">var</span> num = Min + <span class="built_in">Math</span>.round(Rand * Range); <span class="comment">//四舍五入</span></span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 生成数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomArr</span>(<span class="params">len, min, max</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((max - min) &lt; len) &#123; <span class="comment">//可生成数的范围小于数组长度</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> hash = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (hash.length &lt; len) &#123;</span><br><span class="line">        <span class="keyword">var</span> num = randomNumBoth(min, max);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hash.indexOf(num) == -<span class="number">1</span>) &#123;</span><br><span class="line">            hash.push(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="built_in">console</span>.log(randomArr(<span class="number">10</span>, <span class="number">1</span>, <span class="number">100</span>));</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们封装了一个 <em>randomArr</em> 方法来生成这个不重复的随机数组，该方法接收三个参数，<em>len、min</em> 和 <em>max</em>，分别表示数组的长度、最小值和最大值。<em>randomNumBoth</em> 方法用来生成随机数。</p>
</blockquote>
<h3 id="164-continue-和-break-的区别"><a href="#164-continue-和-break-的区别" class="headerlink" title="164. continue 和 break 的区别"></a>164. <em>continue</em> 和 <em>break</em> 的区别</h3><blockquote>
<p>参考答案：</p>
<ul>
<li><em>break</em>：用于永久终止循环。即不执行本次循环中 <em>break</em> 后面的语句，直接跳出循环。</li>
<li><em>continue</em>：用于终止本次循环。即本次循环中 <em>continue</em> 后面的代码不执行，进行下一次循环的入口判断。</li>
</ul>
</blockquote>
<h3 id="165-如何在-jquery-上扩展插件，以及内部原理（腾讯）"><a href="#165-如何在-jquery-上扩展插件，以及内部原理（腾讯）" class="headerlink" title="165. 如何在 jquery 上扩展插件，以及内部原理（腾讯）"></a>165. 如何在 <em>jquery</em> 上扩展插件，以及内部原理（腾讯）</h3><blockquote>
<p>参考答案：</p>
<p>通过 <em>$.extend(object);</em> 为整个 <em>jQuery</em> 类添加新的方法。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.extend(&#123;</span><br><span class="line">  	 <span class="attr">sayHello</span>: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">&#x27;Hello,&#x27;</span> + (name ? name : <span class="string">&#x27;World&#x27;</span>) + <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="function"><span class="title">showAge</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="number">18</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外部使用</span></span><br><span class="line">$.sayHello(); <span class="comment">// Hello,World!  无参调用</span></span><br><span class="line">$.sayHello(<span class="string">&#x27;zhangsan&#x27;</span>); <span class="comment">// Hello,zhangsan! 带参调用  </span></span><br></pre></td></tr></table></figure>

<p>通过 <em>$.fn.extend(object);</em> 给 <em>jQuery</em> 对象添加方法。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.fn.extend(&#123;</span><br><span class="line">    <span class="attr">swiper</span>: <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> obj = <span class="keyword">new</span> Swiper(options, <span class="built_in">this</span>); <span class="comment">// 实例化 Swiper 对象</span></span><br><span class="line">        obj.init(); <span class="comment">// 调用对象的 init 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外部使用</span></span><br><span class="line">$(<span class="string">&#x27;#id&#x27;</span>).swiper();</span><br></pre></td></tr></table></figure>

<p><strong><em>extend</em> 方法内部原理</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">jQuery.extend( target [, object1 ] [, objectN ] )</span><br></pre></td></tr></table></figure>

<p>对后一个参数进行循环，然后把后面参数上所有的字段都给了第一个字段，若第一个参数里有相同的字段，则进行覆盖操作，否则就添加一个新的字段。</p>
<p>解析如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为与源码的下标对应上，我们把第一个参数称为第0个参数，依次类推</span></span><br><span class="line">jQuery.extend = jQuery.fn.extend = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> options, name, src, copy, copyIsArray, clone,</span><br><span class="line">        target = <span class="built_in">arguments</span>[<span class="number">0</span>] || &#123;&#125;, <span class="comment">// 默认第0个参数为目标参数</span></span><br><span class="line">        i = <span class="number">1</span>,    <span class="comment">// i表示从第几个参数凯斯想目标参数进行合并，默认从第1个参数开始向第0个参数进行合并</span></span><br><span class="line">        length = <span class="built_in">arguments</span>.length,</span><br><span class="line">        deep = <span class="literal">false</span>;  <span class="comment">// 默认为浅度拷贝</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断第0个参数的类型，若第0个参数是boolean类型，则获取其为true还是false</span></span><br><span class="line">    <span class="comment">// 同时将第1个参数作为目标参数，i从当前目标参数的下一个</span></span><br><span class="line">    <span class="comment">// Handle a deep copy situation</span></span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">typeof</span> target === <span class="string">&quot;boolean&quot;</span> ) &#123;</span><br><span class="line">        deep = target;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Skip the boolean and the target</span></span><br><span class="line">        target = <span class="built_in">arguments</span>[ i ] || &#123;&#125;;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  判断目标参数的类型，若目标参数既不是object类型，也不是function类型，则为目标参数重新赋值 </span></span><br><span class="line">    <span class="comment">// Handle case when target is a string or something (possible in deep copy)</span></span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">typeof</span> target !== <span class="string">&quot;object&quot;</span> &amp;&amp; !jQuery.isFunction(target) ) &#123;</span><br><span class="line">        target = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若目标参数后面没有参数了，如$.extend(&#123;_name:&#x27;wenzi&#x27;&#125;), $.extend(true, &#123;_name:&#x27;wenzi&#x27;&#125;)</span></span><br><span class="line">    <span class="comment">// 则目标参数即为jQuery本身，而target表示的参数不再为目标参数</span></span><br><span class="line">    <span class="comment">// Extend jQuery itself if only one argument is passed</span></span><br><span class="line">    <span class="keyword">if</span> ( i === length ) &#123;</span><br><span class="line">        target = <span class="built_in">this</span>;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从第i个参数开始</span></span><br><span class="line">    <span class="keyword">for</span> ( ; i &lt; length; i++ ) &#123;</span><br><span class="line">        <span class="comment">// 获取第i个参数，且该参数不为null，</span></span><br><span class="line">        <span class="comment">// 比如$.extend(target, &#123;&#125;, null);中的第2个参数null是不参与合并的</span></span><br><span class="line">        <span class="comment">// Only deal with non-null/undefined values</span></span><br><span class="line">        <span class="keyword">if</span> ( (options = <span class="built_in">arguments</span>[ i ]) != <span class="literal">null</span> ) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用for~in获取该参数中所有的字段</span></span><br><span class="line">            <span class="comment">// Extend the base object</span></span><br><span class="line">            <span class="keyword">for</span> ( name <span class="keyword">in</span> options ) &#123;</span><br><span class="line">                src = target[ name ];   <span class="comment">// 目标参数中name字段的值</span></span><br><span class="line">                copy = options[ name ]; <span class="comment">// 当前参数中name字段的值</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 若参数中字段的值就是目标参数，停止赋值，进行下一个字段的赋值</span></span><br><span class="line">                <span class="comment">// 这是为了防止无限的循环嵌套，我们把这个称为，在下面进行比较详细的讲解</span></span><br><span class="line">                <span class="comment">// Prevent never-ending loop</span></span><br><span class="line">                <span class="keyword">if</span> ( target === copy ) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 若deep为true，且当前参数中name字段的值存在且为object类型或Array类型，则进行深度赋值</span></span><br><span class="line">                <span class="comment">// Recurse if we&#x27;re merging plain objects or arrays</span></span><br><span class="line">                <span class="keyword">if</span> ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) &#123;</span><br><span class="line">                    <span class="comment">// 若当前参数中name字段的值为Array类型</span></span><br><span class="line">                    <span class="comment">// 判断目标参数中name字段的值是否存在，若存在则使用原来的，否则进行初始化</span></span><br><span class="line">                    <span class="keyword">if</span> ( copyIsArray ) &#123;</span><br><span class="line">                        copyIsArray = <span class="literal">false</span>;</span><br><span class="line">                        clone = src &amp;&amp; jQuery.isArray(src) ? src : [];</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 若原对象存在，则直接进行使用，而不是创建</span></span><br><span class="line">                        clone = src &amp;&amp; jQuery.isPlainObject(src) ? src : &#123;&#125;;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 递归处理，此处为2.2</span></span><br><span class="line">                    <span class="comment">// Never move original objects, clone them                      </span></span><br><span class="line">                    target[ name ] = jQuery.extend( deep, clone, copy );</span><br><span class="line"></span><br><span class="line">                <span class="comment">// deep为false，则表示浅度拷贝，直接进行赋值</span></span><br><span class="line">                <span class="comment">// 若copy是简单的类型且存在值，则直接进行赋值</span></span><br><span class="line">                <span class="comment">// Don&#x27;t bring in undefined values</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( copy !== <span class="literal">undefined</span> ) &#123;</span><br><span class="line">                    <span class="comment">// 若原对象存在name属性，则直接覆盖掉；若不存在，则创建新的属性</span></span><br><span class="line">                    target[ name ] = copy;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回修改后的目标参数</span></span><br><span class="line">    <span class="comment">// Return the modified object</span></span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="166-async-await-如何捕获错误"><a href="#166-async-await-如何捕获错误" class="headerlink" title="166. async/await 如何捕获错误"></a>166. <em>async/await</em> 如何捕获错误</h3><blockquote>
<p>参考答案：</p>
<p>可以使用 <em>try…catch</em> 来进行错误的捕获</p>
<p>示例代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> res = <span class="keyword">await</span> test1()</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="167-Proxy-对比-Object-defineProperty-的优势"><a href="#167-Proxy-对比-Object-defineProperty-的优势" class="headerlink" title="167. Proxy 对比 Object.defineProperty 的优势"></a>167. <em>Proxy</em> 对比 <em>Object.defineProperty</em> 的优势</h3><blockquote>
<p>参考答案：</p>
<p><strong>Proxy 的优势如下:</strong></p>
<ul>
<li><em>Object.defineProperty</em> 只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历，而 <em>Proxy</em> 可以直接监听对象而非属性；</li>
<li><em>Object.defineProperty</em> 无法监控到数组下标的变化，而 <em>Proxy</em> 可以直接监听数组的变化；</li>
<li><em>Proxy</em> 有多达 <em>13</em> 种拦截方法；</li>
<li><em>Proxy</em> 作为新标准将受到浏览器厂商重点持续的性能优化；</li>
</ul>
</blockquote>
<h3 id="168-原型链，可以改变原型链的规则吗"><a href="#168-原型链，可以改变原型链的规则吗" class="headerlink" title="168. 原型链，可以改变原型链的规则吗?"></a>168. 原型链，可以改变原型链的规则吗?</h3><blockquote>
<p>参考答案：</p>
<p>每个对象都可以有一个原型__<em>proto</em>__，这个原型还可以有它自己的原型，以此类推，形成一个原型链。查找特定属性的时候，我们先去这个对象里去找，如果没有的话就去它的原型对象里面去，如果还是没有的话再去向原型对象的原型对象里去寻找。这个操作被委托在整个原型链上，这个就是我们说的原型链。</p>
<p>我们可以通过手动赋值的方式来改变原型链所对应的原型对象。</p>
</blockquote>
<h3 id="169-讲一讲继承的所有方式都有什么？手写一个寄生组合式继承"><a href="#169-讲一讲继承的所有方式都有什么？手写一个寄生组合式继承" class="headerlink" title="169. 讲一讲继承的所有方式都有什么？手写一个寄生组合式继承"></a>169. 讲一讲继承的所有方式都有什么？手写一个寄生组合式继承</h3><blockquote>
<p>参考答案：</p>
<p>可以参阅前面第 <em>9、18、47</em> 题答案。</p>
<p>其中圣杯模式就是寄生组合式继承。</p>
</blockquote>
<h3 id="170-JS-基本数据类型有哪些？栈和堆有什么区别，为什么要这样存储。（快手）"><a href="#170-JS-基本数据类型有哪些？栈和堆有什么区别，为什么要这样存储。（快手）" class="headerlink" title="170.  JS 基本数据类型有哪些？栈和堆有什么区别，为什么要这样存储。（快手）"></a>170.  <em>JS</em> 基本数据类型有哪些？栈和堆有什么区别，为什么要这样存储。（快手）</h3><blockquote>
<p>参考答案：</p>
<p>关于 <em>JS</em> 基本数据类型有哪些这个问题，可以参阅前面 <em>26</em> 题。</p>
<p>栈和堆的区别在于堆是动态分配内存，内存大小不一，也不会自动释放。栈是自动分配相对固定大小的内存空间，并由系统自动释放。</p>
<p>在 <em>js</em> 中，基本数据都是直接按值存储在栈中的，每种类型的数据占用的内存空间的大小是确定的，并由系统自动分配和自动释放。这样带来的好处就是，内存可以及时得到回收，相对于堆来说，更加容易管理内存空间。</p>
<p><em>js</em> 中其他类型的数据被称为引用类型的数据（如对象、数组、函数等），它们是通过拷贝和 <em>new</em> 出来的，这样的数据存储于堆中。其实，说存储于堆中，也不太准确，因为，引用类型的数据的地址指针是存储于栈中的，当我们想要访问引用类型的值的时候，需要先从栈中获得对象的地址指针，然后，在通过地址指针找到堆中的所需要的数据。</p>
</blockquote>
<h3 id="171-setTimeout-gt-0-什么时候执行"><a href="#171-setTimeout-gt-0-什么时候执行" class="headerlink" title="171.  setTimeout(() =&gt; {}, 0)  什么时候执行"></a>171.  <em>setTimeout(() =&gt; {}, 0)</em>  什么时候执行</h3><blockquote>
<p>参考答案：</p>
<p>因为 <em>setTimeout</em> 是异步代码，所以即使后面的时间为 <em>0</em>，也要等到同步代码执行完毕后才会执行。</p>
</blockquote>
<h3 id="172-js-有函数重载吗（网易）"><a href="#172-js-有函数重载吗（网易）" class="headerlink" title="172. js 有函数重载吗（网易）"></a>172. <em>js</em> 有函数重载吗（网易）</h3><blockquote>
<p>参考答案：</p>
<p>所谓函数重载，是方法名称进行重用的一种技术形式，其主要特点是“方法名相同，参数的类型或个数不相同”，在调用时会根据传递的参数类型和个数的不同来执行不同的方法体。</p>
<p>在 <em>JS</em> 中，可以通过在函数内容判断形参的类型或个数来执行不同的代码块，从而达到模拟函数重载的效果。</p>
</blockquote>
<h3 id="173-给你一个数组，计算每个数出现的次数，如果每个数组返回的数都是独一无二的就返回-true-相反则返回的-flase"><a href="#173-给你一个数组，计算每个数出现的次数，如果每个数组返回的数都是独一无二的就返回-true-相反则返回的-flase" class="headerlink" title="173. 给你一个数组，计算每个数出现的次数，如果每个数组返回的数都是独一无二的就返回  true  相反则返回的 flase"></a>173. 给你一个数组，计算每个数出现的次数，如果每个数组返回的数都是独一无二的就返回  <em>true</em>  相反则返回的 <em>flase</em></h3><blockquote>
<p>参考答案：</p>
<p>输入：arr = [1,2,2,1,1,3]</p>
<p>输出：true</p>
<p>解释：在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。</p>
<p>代码示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniqueOccurrences</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> uniqueArr = [...new <span class="built_in">Set</span>(arr)]</span><br><span class="line">    <span class="keyword">let</span> countArr = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; uniqueArr.length; i++) &#123;</span><br><span class="line">        countArr.push(arr.filter(<span class="function"><span class="params">item</span> =&gt;</span> item == uniqueArr[i]).length)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> countArr.length == <span class="keyword">new</span> <span class="built_in">Set</span>(countArr).size</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="built_in">console</span>.log(uniqueOccurrences([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>])); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(uniqueOccurrences([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>])); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="174-封装一个能够统计重复的字符的函数，例如-aaabbbdddddfff-转化为-3a3b5d3f"><a href="#174-封装一个能够统计重复的字符的函数，例如-aaabbbdddddfff-转化为-3a3b5d3f" class="headerlink" title="174. 封装一个能够统计重复的字符的函数，例如  aaabbbdddddfff  转化为 3a3b5d3f"></a>174. 封装一个能够统计重复的字符的函数，例如  <em>aaabbbdddddfff</em>  转化为 <em>3a3b5d3f</em></h3><blockquote>
<p>参考答案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compression</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> len = str.length;</span><br><span class="line">    <span class="keyword">var</span> str2 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str.charAt(i) == str.charAt(i + <span class="number">1</span>)) &#123;</span><br><span class="line">            num++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            str2 += num;</span><br><span class="line">            str2 += str.charAt(i);</span><br><span class="line">            num = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试：</span></span><br><span class="line"><span class="built_in">console</span>.log(compression(<span class="string">&#x27;aaabbbdddddfff&#x27;</span>)); <span class="comment">// 3a3b5d3f</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="175-写出代码的执行结果，并解释为什么？"><a href="#175-写出代码的执行结果，并解释为什么？" class="headerlink" title="175. 写出代码的执行结果，并解释为什么？"></a>175. 写出代码的执行结果，并解释为什么？</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> a); </span><br><span class="line">    a(); </span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考答案：</p>
<p>会报错，<em>a is not a function</em>。</p>
<p>因为立即执行函数里面有函数 <em>a</em>，<em>a</em> 会被提升到该函数作用域的最顶端，但是由于判断条件是 <em>false</em>，所以不会进入到条件语句里面， <em>a</em> 也就没有值。所以 <em>typeof</em> 打印出来是 <em>undefined</em>。而后面在尝试调用方法，自然就会报错。</p>
</blockquote>
<h3 id="176-写出代码的执行结果，并解释为什么？"><a href="#176-写出代码的执行结果，并解释为什么？" class="headerlink" title="176. 写出代码的执行结果，并解释为什么？"></a>176. 写出代码的执行结果，并解释为什么？</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert(a);</span><br><span class="line">a();</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="number">10</span>);</span><br><span class="line">&#125;;</span><br><span class="line">alert(a);</span><br><span class="line">a = <span class="number">6</span>;</span><br><span class="line">a(); </span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考答案：</p>
<p>首先打印 function a() {alert(10);};</p>
<p>然后打印 10</p>
<p>最后打印 3</p>
</blockquote>
<blockquote>
<p>解析：</p>
<p>首先 a 变量会被提升到该全局作用域的最顶端，然后值为对应的函数，所以第一次打印出来的是函数。</p>
<p>接下来调用这个 a 函数，所以打印出 10</p>
<p>最后给这个 a 赋值为 3，然后又 alert，所以打印出 3。</p>
<p>之后 a 的值还会发生改变，但是由于没有 alert，说明不会再打印出其他值了。</p>
</blockquote>
<h3 id="177-写出下面程序的打印顺序，并简要说明原因"><a href="#177-写出下面程序的打印顺序，并简要说明原因" class="headerlink" title="177. 写出下面程序的打印顺序，并简要说明原因"></a>177. 写出下面程序的打印顺序，并简要说明原因</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;set1&quot;</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;then4&quot;</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;then2&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;pr1&#x27;</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;then1&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;set2&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;then3&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考答案：</p>
<p>打印结果为：</p>
<p>pr1<br>2<br>then1<br>then3<br>set1<br>then2<br>then4<br>set2</p>
</blockquote>
<h3 id="178-javascript-中什么是伪数组？如何将伪数组转换为标准数组"><a href="#178-javascript-中什么是伪数组？如何将伪数组转换为标准数组" class="headerlink" title="178. javascript 中什么是伪数组？如何将伪数组转换为标准数组"></a>178. <em>javascript</em> 中什么是伪数组？如何将伪数组转换为标准数组</h3><blockquote>
<p>参考答案：</p>
<p>在 <em>JavaScript</em> 中，<em>arguments</em> 就是一个伪数组对象。关于 <em>arguments</em> 具体可以参阅后面 <em>250</em> 题。</p>
<p>可以使用 <em>ES6</em> 的扩展运算符来将伪数组转换为标准数组</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [...arguments];</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="179-array-和-object-的区别"><a href="#179-array-和-object-的区别" class="headerlink" title="179. array 和 object 的区别"></a>179. <em>array</em> 和 <em>object</em> 的区别</h3><blockquote>
<p>参考答案：</p>
<p>数组表示有序数据的集合，对象表示无序数据的集合。如果数据顺序很重要的话，就用数组，否则就用对象。</p>
</blockquote>
<h3 id="180-jquery-事件委托"><a href="#180-jquery-事件委托" class="headerlink" title="180. jquery 事件委托"></a>180. <em>jquery</em> 事件委托</h3><blockquote>
<p>参考答案：</p>
<p>在 <em>jquery</em> 中使用 <em>on</em> 来绑定事件的时候，传入第二个参数即可。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;ul&quot;</span>).on(<span class="string">&quot;click&quot;</span>,<span class="string">&quot;li&quot;</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="number">1</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="181-JS-基本数据类型"><a href="#181-JS-基本数据类型" class="headerlink" title="181. JS 基本数据类型"></a>181. <em>JS</em> 基本数据类型</h3><blockquote>
<p>参考答案：</p>
<p>请参阅前面第 <em>26</em> 题</p>
</blockquote>
<h3 id="182-请实现一个模块-math，支持链式调用math-add-2-4-minus-3-times-2"><a href="#182-请实现一个模块-math，支持链式调用math-add-2-4-minus-3-times-2" class="headerlink" title="182. 请实现一个模块 math，支持链式调用math.add(2,4).minus(3).times(2);"></a>182. 请实现一个模块 <em>math</em>，支持链式调用<code>math.add(2,4).minus(3).times(2);</code></h3><blockquote>
<p>参考答案：</p>
<p>示例代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Math</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> hasInitValue = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (value === <span class="literal">undefined</span>) &#123;</span><br><span class="line">            value = <span class="literal">NaN</span>;</span><br><span class="line">            hasInitValue = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Object</span>.defineProperties(<span class="built_in">this</span>, &#123;</span><br><span class="line">            <span class="attr">value</span>: &#123;</span><br><span class="line">                <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">value</span>: value,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">hasInitValue</span>: &#123;</span><br><span class="line">                <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="attr">value</span>: hasInitValue,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">add</span>(<span class="params">...args</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> init = <span class="built_in">this</span>.hasInitValue ? <span class="built_in">this</span>.value : args.shift();</span><br><span class="line">        <span class="keyword">const</span> value = args.reduce(<span class="function">(<span class="params">pv, cv</span>) =&gt;</span> pv + cv, init);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Math</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">minus</span>(<span class="params">...args</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> init = <span class="built_in">this</span>.hasInitValue ? <span class="built_in">this</span>.value : args.shift();</span><br><span class="line">        <span class="keyword">const</span> value = args.reduce(<span class="function">(<span class="params">pv, cv</span>) =&gt;</span> pv - cv, init);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Math</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">times</span>(<span class="params">...args</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> init = <span class="built_in">this</span>.hasInitValue ? <span class="built_in">this</span>.value : args.shift();</span><br><span class="line">        <span class="keyword">const</span> value = args.reduce(<span class="function">(<span class="params">pv, cv</span>) =&gt;</span> pv * cv, init);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Math</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">divide</span>(<span class="params">...args</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> init = <span class="built_in">this</span>.hasInitValue ? <span class="built_in">this</span>.value : args.shift();</span><br><span class="line">        <span class="keyword">const</span> value = args.reduce(<span class="function">(<span class="params">pv, cv</span>) =&gt;</span> pv / cv, init);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Math</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">toJSON</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.valueOf();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">String</span>(<span class="built_in">this</span>.valueOf());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">valueOf</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="built_in">Symbol</span>.toPrimitive](hint) &#123;</span><br><span class="line">        <span class="keyword">const</span> value = <span class="built_in">this</span>.value;</span><br><span class="line">        <span class="keyword">if</span> (hint === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">String</span>(value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="built_in">Math</span>();</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="183-请简述-ES6-代码转成-ES5-代码的实现思路。"><a href="#183-请简述-ES6-代码转成-ES5-代码的实现思路。" class="headerlink" title="183. 请简述 ES6 代码转成 ES5 代码的实现思路。"></a>183. 请简述 <em>ES6</em> 代码转成 <em>ES5</em> 代码的实现思路。</h3><blockquote>
<p>参考答案：</p>
<p>说到 <em>ES6</em> 代码转成 <em>ES5</em> 代码，我们肯定会想到 <em>Babel</em>。所以，我们可以参考 <em>Babel</em> 的实现方式。</p>
<p>那么 <em>Babel</em> 是如何把 <em>ES6</em> 转成 <em>ES5</em> 呢，其大致分为三步：</p>
<ul>
<li>将代码字符串解析成抽象语法树，即所谓的 <em>AST</em></li>
<li>对 <em>AST</em> 进行处理，在这个阶段可以对 <em>ES6</em> 代码进行相应转换，即转成 <em>ES5</em> 代码</li>
<li>根据处理后的 <em>AST</em> 再生成代码字符串</li>
</ul>
</blockquote>
<h3 id="184-下列代码的执行结果"><a href="#184-下列代码的执行结果" class="headerlink" title="184. 下列代码的执行结果"></a>184. 下列代码的执行结果</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async1 start&#x27;</span>);</span><br><span class="line">    <span class="keyword">await</span> async2();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async2&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line">async1();</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考答案：</p>
<p>script start<br>async1 start<br>async2<br>promise1<br>script end<br>async1 end<br>promise2<br>setTimeout</p>
</blockquote>
<blockquote>
<p>解析：</p>
<p>在此之前我们需要知道以下几点：</p>
<ul>
<li>setTimeout 属于宏任务</li>
<li>Promise 本身是同步的立即执行函数，Promise.then 属于微任务</li>
<li>async 方法执行时，遇到 await 会立即执行表达式，表达式之后的代码放到微任务执行</li>
</ul>
<p><strong>第一次执行</strong>：执行同步代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Tasks(宏任务)：run script、 <span class="built_in">setTimeout</span> callback</span><br><span class="line">Microtasks(微任务)：<span class="keyword">await</span>、<span class="built_in">Promise</span> then</span><br><span class="line">JS stack(执行栈): script</span><br><span class="line"><span class="attr">Log</span>: script start、async1 start、async2、promise1、script end</span><br></pre></td></tr></table></figure>

<p><strong>第二次执行</strong>：执行宏任务后，检测到<strong>微任务</strong>队列中不为空、一次性执行完所有微任务</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Tasks(宏任务)：run script、 <span class="built_in">setTimeout</span> callback</span><br><span class="line">Microtasks(微任务)：<span class="built_in">Promise</span> then</span><br><span class="line">JS stack(执行栈): <span class="keyword">await</span></span><br><span class="line"><span class="attr">Log</span>: script start、async1 start、async2、promise1、script end、async1 end、promise2</span><br></pre></td></tr></table></figure>

<p><strong>第三次执行</strong>：当<strong>微任务</strong>队列中为空时，执行<strong>宏任务</strong>，执行<code>setTimeout callback</code>，打印日志。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Tasks(宏任务)：<span class="literal">null</span></span><br><span class="line">Microtasks(微任务)：<span class="literal">null</span></span><br><span class="line">JS stack(执行栈):<span class="built_in">setTimeout</span> callback</span><br><span class="line"><span class="attr">Log</span>: script start、async1 start、async2、promise1、script end、async1 end、promise2、<span class="built_in">setTimeout</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="185-JS-有哪些内置对象？"><a href="#185-JS-有哪些内置对象？" class="headerlink" title="185. JS 有哪些内置对象？"></a>185. <em>JS</em> 有哪些内置对象？</h3><blockquote>
<p>参考答案：</p>
<p>数据封装类对象：<em>String，Boolean，Number，Array</em> 和 <em>Object</em></p>
<p>其他对象：<em>Function，Arguments，Math，Date，RegExp，Error</em></p>
</blockquote>
<h3 id="186-DOM-怎样添加、移除、移动、复制、创建和查找节点"><a href="#186-DOM-怎样添加、移除、移动、复制、创建和查找节点" class="headerlink" title="186. DOM 怎样添加、移除、移动、复制、创建和查找节点"></a>186. <em>DOM</em> 怎样添加、移除、移动、复制、创建和查找节点</h3><blockquote>
<p>参考答案：</p>
<p>请参阅前面 <em>121</em> 题。</p>
</blockquote>
<h3 id="187-eval-是做什么的？"><a href="#187-eval-是做什么的？" class="headerlink" title="187. eval 是做什么的？"></a>187. <em>eval</em> 是做什么的？</h3><blockquote>
<p>参考答案：</p>
<p>此函数可以接受一个字符串 <em>str</em> 作为参数，并把此 <em>str</em> 当做一段 <em>javascript</em> 代码去执行，如果 <em>str</em> 执行结果是一个值则返回此值，否则返回 <em>undefined</em>。如果参数不是一个字符串，则直接返回该参数。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;var a=1&quot;</span>);<span class="comment">//声明一个变量a并赋值1。</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;2+3&quot;</span>);<span class="comment">//5执行加运算，并返回运算值。</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;mytest()&quot;</span>);<span class="comment">//执行mytest()函数。</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;&#123;b:2&#125;&quot;</span>);<span class="comment">//声明一个对象。</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="188-null-和-undefined-的区别？"><a href="#188-null-和-undefined-的区别？" class="headerlink" title="188. null 和 undefined 的区别？"></a>188. <em>null</em> 和 <em>undefined</em> 的区别？</h3><blockquote>
<p>参考答案：</p>
<p>请参阅前面第 <em>29</em> 题。</p>
</blockquote>
<h3 id="189-new-操作符具体干了什么呢？"><a href="#189-new-操作符具体干了什么呢？" class="headerlink" title="189. new 操作符具体干了什么呢？"></a>189. <em>new</em> 操作符具体干了什么呢？</h3><blockquote>
<p>参考答案：</p>
<ul>
<li>创建一个空对象 。</li>
<li>由 this 变量引用该对象 。</li>
<li>该对象继承该函数的原型(更改原型链的指向) 。</li>
<li>把属性和方法加入到 this 引用的对象中。</li>
<li>新创建的对象由 this 引用 ，最后隐式地返回 this，过程如下：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.__proto__ = Base.prototype;</span><br><span class="line">Base.call(obj);</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="190-去除字符串中的空格"><a href="#190-去除字符串中的空格" class="headerlink" title="190. 去除字符串中的空格"></a>190. 去除字符串中的空格</h3><blockquote>
<p>参考答案：</p>
<p>方法一：<em>replace</em>正则匹配方法</p>
<p>代码示例：</p>
<ul>
<li>去除字符串内所有的空格：<code>str = str.replace(/\s*/g,&quot;&quot;);</code></li>
<li>去除字符串内两头的空格：<code>str = str.replace(/^\s*|\s*$/g,&quot;&quot;);</code></li>
<li>去除字符串内左侧的空格：<code>str = str.replace(/^\s*/,&quot;&quot;);</code></li>
<li>去除字符串内右侧的空格：<code>str = str.replace(/(\s*$)/g,&quot;&quot;);</code></li>
</ul>
<p>方法二：字符串原生 <em>trim</em> 方法</p>
<p><em>trim</em> 方法能够去掉两侧空格返回新的字符串，不能去掉中间的空格</p>
</blockquote>
<h3 id="191-常见的内存泄露，以及解决方案"><a href="#191-常见的内存泄露，以及解决方案" class="headerlink" title="191. 常见的内存泄露，以及解决方案"></a>191. 常见的内存泄露，以及解决方案</h3><blockquote>
<p>参考答案：</p>
<p><strong>内存泄露概念</strong></p>
<p>内存泄漏指由于疏忽或错误造成程序未能释放已经不再使用的内存。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。</p>
<p>内存泄漏通常情况下只能由获得程序源代码和程序员才能分析出来。然而，有不少人习惯于把任何不需要的内存使用的增加描述为内存泄漏，即使严格意义上来说这是不准确的。</p>
<p><strong><em>JS</em> 垃圾收集机制</strong></p>
<p><em>JS</em> 具有自动回收垃圾的机制，即执行环境会负责管理程序执行中使用的内存。在C和C++等其他语言中，开发者的需要手动跟踪管理内存的使用情况。在编写 <em>JS</em> 代码的时候，开发人员不用再关心内存使用的问题，所需内存的分配 以及无用的回收完全实现了自动管理。</p>
<p>Js中最常用的垃圾收集方式是标记清除(mark-and-sweep)。当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占的内存，因为只要执行流进入相应的环境，就可能用到它们。而当变量离开环境时，这将其 标记为“离开环境”。</p>
<p><strong>常见内存泄漏以及解决方案</strong></p>
<ol>
<li>意外的全局变量</li>
</ol>
<p>Js处理未定义变量的方式比较宽松：未定义的变量会在全局对象创建一个新变量。在浏览器中，全局对象是window。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arg</span>) </span>&#123; </span><br><span class="line">    bar = <span class="string">&quot;this is a hidden global variable&quot;</span>; <span class="comment">//等同于window.bar=&quot;this is a hidden global variable&quot;</span></span><br><span class="line">    <span class="built_in">this</span>.bar2= <span class="string">&quot;potential accidental global&quot;</span>;<span class="comment">//这里的this 指向了全局对象（window）,等同于window.bar2=&quot;potential accidental global&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方法：在 JavaScript 程序中添加，开启严格模式’use strict’，可以有效地避免上述问题。</p>
<p>注意：那些用来临时存储大量数据的全局变量，确保在处理完这些数据后将其设置为null或重新赋值。与全局变量相关的增加内存消耗的一个主因是缓存。缓存数据是为了重用，缓存必须有一个大小上限才有用。高内存消耗导致缓存突破上限，因为缓 存内容无法被回收。</p>
<ol start="2">
<li>循环引用</li>
</ol>
<p>在js的内存管理环境中，对象 A 如果有访问对象 B 的权限，叫做对象 A 引用对象 B。引用计数的策略是将“对象是否不再需要”简化成“对象有没有其他对象引用到它”，如果没有对象引用这个对象，那么这个对象将会被回收 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;; <span class="comment">// 一个对象（称之为 A）被创建，赋值给 obj1，A 的引用个数为 1   </span></span><br><span class="line"><span class="keyword">let</span> obj2 = obj1; <span class="comment">// A 的引用个数变为 2  </span></span><br><span class="line"></span><br><span class="line">obj1 = <span class="number">0</span>; <span class="comment">// A 的引用个数变为 1  </span></span><br><span class="line">obj2 = <span class="number">0</span>; <span class="comment">// A 的引用个数变为 0，此时对象 A 就可以被垃圾回收了</span></span><br></pre></td></tr></table></figure>

<p>但是引用计数有个最大的问题： 循环引用。 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">let</span> obj1 = &#123;&#125;;  </span><br><span class="line">    <span class="keyword">let</span> obj2 = &#123;&#125;;  </span><br><span class="line"></span><br><span class="line">    obj1.a = obj2; <span class="comment">// obj1 引用 obj2  </span></span><br><span class="line">    obj2.a = obj1; <span class="comment">// obj2 引用 obj1  </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当函数 func 执行结束后，返回值为 undefined，所以整个函数以及内部的变量都应该被回收，但根据引用计数方法，obj1 和 obj2 的引用次数都不为 0，所以他们不会被回收。要解决循环引用的问题，最好是在不使用它们的时候手工将它们设为空。上面的例子可以这么做：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">obj1 = <span class="literal">null</span>;  </span><br><span class="line">obj2 = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>被遗忘的计时器和回调函数</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> someResource = getData();  </span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;  </span><br><span class="line">    <span class="keyword">const</span> node = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;Node&#x27;</span>);  </span><br><span class="line">    <span class="keyword">if</span>(node) &#123;  </span><br><span class="line">        node.innerhtml = <span class="built_in">JSON</span>.stringify(someResource));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>上面的例子中，我们每隔一秒就将得到的数据放入到文档节点中去。</p>
<p>但在 <em>setInterval</em> 没有结束前，回调函数里的变量以及回调函数本身都无法被回收。那什么才叫结束呢？</p>
<p>就是调用了 <em>clearInterval</em>。如果回调函数内没有做什么事情，并且也没有被 <em>clear</em> 掉的话，就会造成内存泄漏。</p>
<p>不仅如此，如果回调函数没有被回收，那么回调函数内依赖的变量也没法被回收。上面的例子中，<em>someResource</em> 就没法被回收。同样的，<em>setTiemout</em> 也会有同样的问题。所以，当不需要 <em>interval</em> 或者 <em>timeout</em> 时，最好调用 <em>clearInterval</em> 或者 <em>clearTimeout</em>。  </p>
<ol start="4">
<li><em>DOM</em> 泄漏</li>
</ol>
<p>在 <em>JS</em> 中对<em>DOM</em>操作是非常耗时的。因为<em>JavaScript/ECMAScript</em>引擎独立于渲染引擎，而<em>DOM</em>是位于渲染引擎，相互访问需要消耗一定的资源。  而 <em>IE</em> 的 <em>DOM</em> 回收机制便是采用引用计数的，以下主要针对 <em>IE</em> 而言的。</p>
<p><strong>a. 没有清理的 DOM 元素引用</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> refA = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;refA&#x27;</span>);</span><br><span class="line"><span class="built_in">document</span>.body.removeChild(refA);</span><br><span class="line"><span class="comment">// refA 不能回收，因为存在变量 refA 对它的引用。将其对 refA 引用释放，但还是无法回收 refA。</span></span><br></pre></td></tr></table></figure>

<p>解决办法：<em>refA = null;</em></p>
<p><strong>b. 给 DOM 对象添加的属性是一个对象的引用</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> MyObject = &#123;&#125;; </span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;mydiv&#x27;</span>).myProp = MyObject;</span><br></pre></td></tr></table></figure>

<p>解决方法：<br>在 <em>window.onunload</em> 事件中写上: <em>document.getElementById(‘mydiv’).myProp = null;</em>  </p>
<p><strong>c. DOM 对象与 JS 对象相互引用</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Encapsulator</span>(<span class="params">element</span>) </span>&#123; </span><br><span class="line">	<span class="built_in">this</span>.elementReference = element; </span><br><span class="line">	element.myProp = <span class="built_in">this</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">new</span> Encapsulator(<span class="built_in">document</span>.getElementById(<span class="string">&#x27;myDiv&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>解决方法： 在 onunload 事件中写上: document.getElementById(‘myDiv’).myProp = null;   </p>
<p><strong>d. 给 DOM 对象用 attachEvent 绑定事件</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doClick</span>(<span class="params"></span>) </span>&#123;&#125; </span><br><span class="line">element.attachEvent(<span class="string">&quot;onclick&quot;</span>, doClick);</span><br></pre></td></tr></table></figure>

<p>解决方法： 在onunload事件中写上: element.detachEvent(‘onclick’, doClick);   </p>
<p><strong>e. 从外到内执行 appendChild。这时即使调用 removeChild 也无法释放</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> parentDiv = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>); </span><br><span class="line"><span class="keyword">var</span> childDiv = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>); </span><br><span class="line"><span class="built_in">document</span>.body.appendChild(parentDiv); </span><br><span class="line">parentDiv.appendChild(childDiv);</span><br></pre></td></tr></table></figure>

<p>解决方法： 从内到外执行 appendChild:   </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> parentDiv = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>); </span><br><span class="line"><span class="keyword">var</span> childDiv = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>); </span><br><span class="line">parentDiv.appendChild(childDiv); </span><br><span class="line"><span class="built_in">document</span>.body.appendChild(parentDiv);</span><br></pre></td></tr></table></figure>



<ol start="5">
<li><em>JS</em> 的闭包</li>
</ol>
<p>闭包在 <em>IE6</em> 下会造成内存泄漏，但是现在已经无须考虑了。值得注意的是闭包本身不会造成内存泄漏，但闭包过多很容易导致内存泄漏。闭包会造成对象引用的生命周期脱离当前函数的上下文，如果闭包如果使用不当，可以导致环形引用（<em>circular reference</em>），类似于死锁，只能避免，无法发生之后解决，即使有垃圾回收也还是会内存泄露。  </p>
<ol start="6">
<li><em>console</em></li>
</ol>
<p>控制台日志记录对总体内存配置文件的影响可能是许多开发人员都未想到的极其重大的问题。记录错误的对象可以将大量数据保留在内存中。注意，这也适用于： </p>
<p>(1) 在用户键入 JavaScript 时，在控制台中的一个交互式会话期间记录的对象。<br>(2) 由 console.log 和 console.dir 方法记录的对象。 </p>
</blockquote>
<h3 id="192-箭头函数和普通函数里面的-this-有什么区别"><a href="#192-箭头函数和普通函数里面的-this-有什么区别" class="headerlink" title="192. 箭头函数和普通函数里面的 this 有什么区别"></a>192. 箭头函数和普通函数里面的 <em>this</em> 有什么区别</h3><blockquote>
<p>参考答案：</p>
<p>请参阅前面第 <em>24、25</em> 题</p>
</blockquote>
<h3 id="193-设计⼀个⽅法-isPalindrom-以判断是否回⽂-颠倒后的字符串和原来的字符串⼀样为回⽂"><a href="#193-设计⼀个⽅法-isPalindrom-以判断是否回⽂-颠倒后的字符串和原来的字符串⼀样为回⽂" class="headerlink" title="193. 设计⼀个⽅法(isPalindrom)以判断是否回⽂(颠倒后的字符串和原来的字符串⼀样为回⽂)"></a>193. 设计⼀个⽅法(<em>isPalindrom</em>)以判断是否回⽂(颠倒后的字符串和原来的字符串⼀样为回⽂)</h3><blockquote>
<p>参考答案：</p>
<p>示例代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPalindrome</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> str !== <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>) === str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="built_in">console</span>.log(isPalindrome(<span class="string">&#x27;HelleH&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isPalindrome(<span class="string">&#x27;Hello&#x27;</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="194-设计⼀个⽅法-findMaxDuplicateChar-以统计字符串中出现最多次数的字符"><a href="#194-设计⼀个⽅法-findMaxDuplicateChar-以统计字符串中出现最多次数的字符" class="headerlink" title="194. 设计⼀个⽅法(findMaxDuplicateChar)以统计字符串中出现最多次数的字符"></a>194. 设计⼀个⽅法(<em>findMaxDuplicateChar</em>)以统计字符串中出现最多次数的字符</h3><blockquote>
<p>参考答案：</p>
<p>示例代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findMaxDuplicateChar</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> cnt = &#123;&#125;,	<span class="comment">//用来记录所有的字符的出现频次</span></span><br><span class="line">        c = <span class="string">&#x27;&#x27;</span>;		<span class="comment">//用来记录最大频次的字符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> ci = str[i];</span><br><span class="line">        <span class="keyword">if</span> (!cnt[ci]) &#123;</span><br><span class="line">            cnt[ci] = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cnt[ci]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;&#x27;</span> || cnt[ci] &gt; cnt[c]) &#123;</span><br><span class="line">            c = ci;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(cnt); <span class="comment">// &#123; H: 1, e: 1, l: 3, o: 2, &#x27; &#x27;: 1, W: 1, r: 1, d: 1 &#125;</span></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="built_in">console</span>.log(findMaxDuplicateChar(<span class="string">&#x27;Hello World&#x27;</span>)); <span class="comment">// l</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="195-设计⼀段代码，使得通过点击按钮可以在-span-中显示⽂本框中输⼊的值"><a href="#195-设计⼀段代码，使得通过点击按钮可以在-span-中显示⽂本框中输⼊的值" class="headerlink" title="195. 设计⼀段代码，使得通过点击按钮可以在 span 中显示⽂本框中输⼊的值"></a>195. 设计⼀段代码，使得通过点击按钮可以在 <em>span</em> 中显示⽂本框中输⼊的值</h3><blockquote>
<p>参考答案：</p>
<p>示例代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;showContent&quot;</span>&gt;</span>在右侧输入框中输入内容<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;content&quot;</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>更新内容<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> content = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;content&#x27;</span>).value;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span>(content)&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.getElementById(<span class="string">&#x27;showContent&#x27;</span>).innerHTML = content;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="196-map-和-forEach-的区别？"><a href="#196-map-和-forEach-的区别？" class="headerlink" title="196. map 和 forEach 的区别？"></a>196. <em>map</em> 和 <em>forEach</em> 的区别？</h3><blockquote>
<p>参考答案：</p>
<p><strong>两者区别</strong></p>
<p><code>forEach()</code>方法不会返回执行结果，而是<code>undefined</code>。</p>
<p>也就是说，<code>forEach()</code>会修改原来的数组。而<code>map()</code>方法会得到一个新的数组并返回。</p>
<p><strong>适用场景</strong></p>
<p><code>forEach</code>适合于你并不打算改变数据的时候，而只是想用数据做一些事情 – 比如存入数据库或则打印出来。</p>
<p><code>map()</code>适用于你要改变数据值的时候。不仅仅在于它更快，而且返回一个新的数组。这样的优点在于你可以使用复合(<em>composition</em>)(<em>map, filter, reduce</em> 等组合使用)来玩出更多的花样。</p>
</blockquote>
<h3 id="197-Array-的常用方法"><a href="#197-Array-的常用方法" class="headerlink" title="197. Array 的常用方法"></a>197. <em>Array</em> 的常用方法</h3><blockquote>
<p>参考答案：</p>
<p><em>Array</em> 的常用方法很多，挑选几个自己在实际开发中用的比较多的方法回答即可。</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-08-17-151325.png" alt="image-20210817231325109" style="zoom:50%;" />

<p>更多 <em>Array</em> 相关用法可以参阅：<em><a href="https://www.w3school.com.cn/jsref/jsref_obj_array.asp">https://www.w3school.com.cn/jsref/jsref_obj_array.asp</a></em></p>
</blockquote>
<h3 id="198-数组去重的多种实现方式"><a href="#198-数组去重的多种实现方式" class="headerlink" title="198. 数组去重的多种实现方式"></a>198. 数组去重的多种实现方式</h3><blockquote>
<p>参考答案：</p>
<p>请参阅前面第 <em>2</em> 题答案。</p>
</blockquote>
<h3 id="199-什么是预解析（预编译）"><a href="#199-什么是预解析（预编译）" class="headerlink" title="199. 什么是预解析（预编译）"></a>199. 什么是预解析（预编译）</h3><blockquote>
<p>参考答案：</p>
<p>所谓的预解析（预编译）就是：在当前作用域中，<em>JavaScript</em> 代码执行之前，浏览器首先会默认的把所有带 <em>var</em> 和 <em>function</em> 声明的变量进行提前的声明或者定义。</p>
<p>另外，<em>var</em> 声明的变量和 <em>function</em> 声明的函数在预解析的时候有区别，<em>var</em> 声明的变量在预解析的时候只是提前的声明，<em>function</em> 声明的函数在预解析的时候会提前声明并且会同时定义。也就是说 <em>var</em> 声明的变量和 <em>function</em> 声明的函数的区别是在声明的同时有没有同时进行定义。</p>
</blockquote>
<h3 id="200-原始值类型和引用值类型的区别是什么？"><a href="#200-原始值类型和引用值类型的区别是什么？" class="headerlink" title="200. 原始值类型和引用值类型的区别是什么？"></a>200. 原始值类型和引用值类型的区别是什么？</h3><blockquote>
<p>参考答案：</p>
<p>可以参阅前面第 <em>26</em> 题</p>
</blockquote>
<h3 id="201-冒泡排序的思路，不用-sort"><a href="#201-冒泡排序的思路，不用-sort" class="headerlink" title="201. 冒泡排序的思路，不用 sort"></a>201. 冒泡排序的思路，不用 <em>sort</em></h3><blockquote>
<p>参考答案：</p>
<p>示例代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> examplearr = [<span class="number">8</span>, <span class="number">94</span>, <span class="number">15</span>, <span class="number">88</span>, <span class="number">55</span>, <span class="number">76</span>, <span class="number">21</span>, <span class="number">39</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortarr</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">var</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line">sortarr(examplearr);</span><br><span class="line"><span class="built_in">console</span>.log(examplearr); <span class="comment">// [8, 15, 21, 39, 55, 76, 88, 94]</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="202-symbol-用途"><a href="#202-symbol-用途" class="headerlink" title="202. symbol 用途"></a>202. <em>symbol</em> 用途</h3><blockquote>
<p>参考答案：</p>
<p>可以用来表示一个独一无二的变量防止命名冲突。但是面试官问还有吗?我没想出其他的用处就直接答我不知道了，还可以利用 symbol 不会被常规的方法(除了 Object.getOwnPropertySymbols 外)遍历到，所以可以用来模拟私有变量。</p>
<p>主要用来提供遍历接口，布置了 symbol.iterator 的对象才可以使用 for···of 循环，可以统一处理数据结构。调用之后回返回一个遍历器对象，包含有一个 next 方法，使用 next 方法后有两个返回值 value 和 done 分别表示函数当前执行位置的值和是否遍历完毕。</p>
<p>Symbol.for() 可以在全局访问 symbol</p>
</blockquote>
<h3 id="203-什么是函数式编程，应用场景是什么"><a href="#203-什么是函数式编程，应用场景是什么" class="headerlink" title="203. 什么是函数式编程，应用场景是什么"></a>203. 什么是函数式编程，应用场景是什么</h3><blockquote>
<p>参考答案：</p>
<p>函数式编程和面向对象编程一样，是一种编程范式。强调执行的过程而非结果，通过一系列的嵌套的函数调用，完成一个运算过程。<br> 它主要有以下几个特点：</p>
<ol>
<li>函数是”一等公民”：函数优先，和其他数据类型一样。</li>
<li>只用”表达式”，不用”语句”：通过表达式（<em>expression</em>）计算过程得到一个返回值，而不是通过一个语句（<em>statement</em>）修改某一个状态。</li>
<li>无副作用：不污染变量，同一个输入永远得到同一个数据。</li>
<li>不可变性：前面一提到，不修改变量，返回一个新的值。</li>
</ol>
<p>函数式编程的概念其实出来也已经好几十年了，我们能在很多编程语言身上看到它的身影。比如比较纯粹的 <em>Haskell</em>，以及一些语言开始逐渐成为多范式编程语言，比如 <em>Swift</em>，还有 <em>Kotlin，Java，Js</em> 等都开始具备函数式编程的特性。</p>
<p><strong>函数式编程在前端的应用场景</strong></p>
<ul>
<li><em>Stateless components</em>：<em>React</em> 在 <em>0.14</em> 之后推出的无状态组件</li>
<li><em>Redux</em></li>
</ul>
<p><strong>函数式编程在后端的应用场景</strong></p>
<ul>
<li><em>Lambda</em> 架构</li>
</ul>
</blockquote>
<h3 id="204-事件以及事件相关的兼容性问题"><a href="#204-事件以及事件相关的兼容性问题" class="headerlink" title="204. 事件以及事件相关的兼容性问题"></a>204. 事件以及事件相关的兼容性问题</h3><blockquote>
<p>参考答案：</p>
<p>事件最早是在 <em>IE3</em> 和  <em>Navigator2</em> 中出现的，当时是作为分担服务器运算负担的一种手段。要实现和网页的互动，就需要通过 <em>JavaScript</em> 里面的事件来实现。</p>
<p>每次用户与一个网页进行交互，例如点击链接，按下一个按键或者移动鼠标时，就会触发一个事件。我们的程序可以检测这些事件，然后对此作出响应。从而形成一种交互。</p>
<p>当我们绑定事件时，需要遵循事件三要素</p>
<ul>
<li>事件源：是指那个元素引发的事件。比如当你点击图标的时候，会跳转到百度首页。那么这个图标就是事件源。</li>
<li>事件：事件是指执行的动作。例如，点击，鼠标划过，按下键盘，获得焦点。</li>
<li>事件驱动程序：事件驱动程序即执行的结果。例如，当你点击图标的时候，会跳转到百度首页。那么跳转到百度首页就是事件的处理结果。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">事件源.事件 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    事件处理函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常见的兼容问题，可以参阅前面 <em>135</em> 题。</p>
</blockquote>
<h3 id="205-JS-小数不精准，如何计算"><a href="#205-JS-小数不精准，如何计算" class="headerlink" title="205. JS 小数不精准，如何计算"></a>205. <em>JS</em> 小数不精准，如何计算</h3><blockquote>
<p>参考答案：</p>
<p>方法一：指定要保留的小数位数(0.1+0.2).toFixed(1) = 0.3;这个方法toFixed是进行四舍五入的也不是很精准，对于计算金额这种严谨的问题，不推荐使用，而且不同浏览器对toFixed的计算结果也存在差异。</p>
<p>方法二：把需要计算的数字升级（乘以10的n次幂）成计算机能够精确识别的整数，等计算完毕再降级（除以10的n次幂），这是大部分编程语言处理精度差异的通用方法。 </p>
</blockquote>
<h3 id="206-写一个-mySetInterVal-fn-a-b-，每次间隔-a-a-b-a-2b-的时间，然后写一个-myClear，停止上面的-mySetInterVal"><a href="#206-写一个-mySetInterVal-fn-a-b-，每次间隔-a-a-b-a-2b-的时间，然后写一个-myClear，停止上面的-mySetInterVal" class="headerlink" title="206. 写一个 *mySetInterVal(fn, a, b)*，每次间隔 a,a+b,a+2b 的时间，然后写一个 myClear，停止上面的 mySetInterVal"></a>206. 写一个 *mySetInterVal(fn, a, b)*，每次间隔 <em>a,a+b,a+2b</em> 的时间，然后写一个 <em>myClear</em>，停止上面的 <em>mySetInterVal</em></h3><blockquote>
<p>参考答案：</p>
<p>该题的思路就是每一次在定时器中重启定时器并且在时间每一次都加 <em>b</em>，并且要把定时器返回回来，可以作为<em>myClear</em>的参数。</p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mySetInterVal = <span class="function"><span class="keyword">function</span> (<span class="params">fn, a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">var</span> settimer = <span class="function"><span class="keyword">function</span> (<span class="params">fn, a, b</span>) </span>&#123;</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn();</span><br><span class="line">      settimer(fn, a + b, b);</span><br><span class="line">    &#125;, a);</span><br><span class="line">  &#125;</span><br><span class="line">  settimer(fn, a, b);</span><br><span class="line">  <span class="keyword">return</span> timer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> timer = mySetInterVal(<span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;timer&#x27;</span>) &#125;, <span class="number">1000</span>, <span class="number">1000</span>);</span><br><span class="line"><span class="keyword">var</span> myClear = <span class="function"><span class="keyword">function</span> (<span class="params">timer</span>) </span>&#123;</span><br><span class="line">  timer &amp;&amp; <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="207-合并二维有序数组成一维有序数组，归并排序的思路"><a href="#207-合并二维有序数组成一维有序数组，归并排序的思路" class="headerlink" title="207. 合并二维有序数组成一维有序数组，归并排序的思路"></a>207. 合并二维有序数组成一维有序数组，归并排序的思路</h3><blockquote>
<p>参考答案：</p>
<p>示例代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = []</span><br><span class="line">    <span class="keyword">while</span> (left.length &gt; <span class="number">0</span> &amp;&amp; right.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left[<span class="number">0</span>] &lt; right[<span class="number">0</span>]) &#123;</span><br><span class="line">            result.push(left.shift())</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.push(right.shift())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.concat(left).concat(right)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (arr.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> arrayItem1 = arr.shift();</span><br><span class="line">        <span class="keyword">let</span> arrayItem2 = arr.shift();</span><br><span class="line">        <span class="keyword">let</span> mergeArr = merge(arrayItem1, arrayItem2);</span><br><span class="line">        arr.push(mergeArr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr1 = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]];</span><br><span class="line"><span class="keyword">let</span> arr2 = [[<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">10</span>], [<span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>], [<span class="number">3</span>, <span class="number">7</span>, <span class="number">13</span>], [<span class="number">1</span>, <span class="number">5</span>, <span class="number">12</span>]];</span><br><span class="line"><span class="built_in">console</span>.log(mergeSort(arr1))</span><br><span class="line"><span class="built_in">console</span>.log(mergeSort(arr2))</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="208-给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。"><a href="#208-给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。" class="headerlink" title="208. 给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。"></a>208. 给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。</h3><blockquote>
<p>参考答案：</p>
<p>首先，我们肯定需要封装一个函数，而这个函数接收一个字符串作为参数，返回不含有重复字符的子串长度。来看下面的示例：</p>
<p>示例 1:</p>
<p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p>
<p>示例 2:</p>
<p>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p>
<p>示例 3:</p>
<p>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>请注意，你的答案必须是 子串 的长度，“pwke” 是一个子序列，不是子串。</p>
<p>示例代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = [];</span><br><span class="line">    <span class="keyword">var</span> temp = [];</span><br><span class="line">    <span class="keyword">var</span> maxs = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s.length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp.includes(s[i])) &#123;</span><br><span class="line"></span><br><span class="line">            y.push(temp.length);</span><br><span class="line">            temp.shift();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp.push(s[i])</span><br><span class="line">            y.push(temp.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; y.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (maxs &lt;= y[j]) &#123;</span><br><span class="line">            maxs = y[j]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxs;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="built_in">console</span>.log(lengthOfLongestSubstring(<span class="string">&#x27;abcabcbb&#x27;</span>)); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(lengthOfLongestSubstring(<span class="string">&#x27;bbbbb&#x27;</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(lengthOfLongestSubstring(<span class="string">&#x27;pwwkew&#x27;</span>)); <span class="comment">// 3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="209-有一堆整数，请把他们分成三份，确保每一份和尽量相等（11，42，23，4，5，6-4-5-6-11-23-42-56-78-90）-滴滴-2020"><a href="#209-有一堆整数，请把他们分成三份，确保每一份和尽量相等（11，42，23，4，5，6-4-5-6-11-23-42-56-78-90）-滴滴-2020" class="headerlink" title="209. 有一堆整数，请把他们分成三份，确保每一份和尽量相等（11，42，23，4，5，6 4 5 6 11 23 42 56 78 90）(滴滴 2020)"></a>209. 有一堆整数，请把他们分成三份，确保每一份和尽量相等（11，42，23，4，5，6 4 5 6 11 23 42 56 78 90）(滴滴 <em>2020</em>)</h3><blockquote>
<p>参考答案：</p>
<p>本道题目是一道考察算法的题目，主要是考察编程基本功和一定的想像力。</p>
<p>具体的实现如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">total, n</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//先对整个数组进行排序</span></span><br><span class="line">    total.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求和</span></span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; total.length; i++) &#123;</span><br><span class="line">        sum += total[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> avg = <span class="built_in">Math</span>.ceil(sum / n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//结果数组</span></span><br><span class="line">    <span class="keyword">var</span> result = []; <span class="comment">//长度为n</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        result[i] = [total.pop()];</span><br><span class="line">        result[i].sum = result[i][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//组成一个分数组</span></span><br><span class="line">        <span class="keyword">while</span> (result[i].sum &lt; avg &amp;&amp; total.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; total.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (result[i].sum + total[j] &gt;= avg) &#123;</span><br><span class="line">                    result[i].push(total[j]);</span><br><span class="line">                    result[i].sum += total[j];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (j == total.length) &#123;</span><br><span class="line">                result[i].push(total.pop());</span><br><span class="line">                result[i].sum += result[i][result[i].length - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//从数组中移除此元素</span></span><br><span class="line">                total.splice(j, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sum -= result[i].sum;</span><br><span class="line">        avg = <span class="built_in">Math</span>.ceil(sum / (n - <span class="number">1</span> - i));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">11</span>, <span class="number">42</span>, <span class="number">23</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">11</span>, <span class="number">23</span>, <span class="number">42</span>, <span class="number">56</span>, <span class="number">78</span>, <span class="number">90</span>];</span><br><span class="line"><span class="built_in">console</span>.log(fun(arr, <span class="number">3</span>));</span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//     [ 90, 56, sum: 146 ],</span></span><br><span class="line"><span class="comment">//     [ 78, 42, 11, sum: 131 ],</span></span><br><span class="line"><span class="comment">//     [ 42, 23, 23, 11, 6, 6, 5, 5, 4, 4, sum: 129 ]</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="210-手写发布订阅（头条2020）"><a href="#210-手写发布订阅（头条2020）" class="headerlink" title="210. 手写发布订阅（头条2020）"></a>210. 手写发布订阅（头条2020）</h3><blockquote>
<p>参考答案：</p>
<p>示例代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>this is a test<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        &#123;&#123;msg&#125;&#125;<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;msg&quot;</span>&gt;</span>&#123;&#123;msg&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">el</span> : <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">data</span> : &#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">msg</span> : <span class="string">&#x27;&#x27;</span></span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;);</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 创建 Vue 构造函数</span></span><br><span class="line"><span class="comment">        在 Vue 构造函数中，调用了 observer 函数，该函数的作用就是对数据进行劫持</span></span><br><span class="line"><span class="comment">        劫持具体要做的事儿：复制一份数据，但是不是单纯的复制，而是增加了 getter、setter</span></span><br><span class="line"><span class="comment">    2. 书写 compile 函数。该函数主要作用于模板，从模板里面要提取信息</span></span><br><span class="line"><span class="comment">        提取的东西主要有两个：&#123;&#123;&#125;&#125;  和 v-model</span></span><br><span class="line"><span class="comment">    3. 创建发布者 Dep 的构造函数，如果数据发生变化，发布者就会遍历内部的数组（花名册），通知订阅者修改数据</span></span><br><span class="line"><span class="comment">    4. 创建订阅者 Watcher 的构造函数，如果有数据的变化，发布者就会通知订阅者，订阅者上面存在 update 方法，会进行修改</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span>(<span class="params">options</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// this 代表 Vue 的实例对象，本例中就是 vm</span></span><br><span class="line">    <span class="comment">// options.data 这就是实际的数据 &#123;msg : &#x27;xiejie&#x27;&#125;</span></span><br><span class="line">    observer(<span class="built_in">this</span>,options.data);</span><br><span class="line">    <span class="built_in">this</span>.$el = options.el;</span><br><span class="line">    compile(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于对模板进行信息提取，主要提取 &#123;&#123;&#125;&#125;  和 v-model，然后进行一些操作</span></span><br><span class="line"><span class="comment">// &#123;&#123; &#125;&#125; 会成为观察者，v-model 所对应的控件来绑定事件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compile</span>(<span class="params">vm</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> el = <span class="built_in">document</span>.querySelector(vm.$el); <span class="comment">// el 所对应的值为 &lt;div id=&quot;app&quot;&gt;...&lt;/div&gt;</span></span><br><span class="line">    <span class="keyword">var</span> documentFragment = <span class="built_in">document</span>.createDocumentFragment(); <span class="comment">// 创建了一个空的文档碎片</span></span><br><span class="line">    <span class="keyword">var</span> reg = <span class="regexp">/\&#123;\&#123;(.*)\&#125;\&#125;/</span>; <span class="comment">// 创建正则表达式 匹配 &#123;&#123; &#125;&#125;</span></span><br><span class="line">    <span class="keyword">while</span>(el.childNodes[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">var</span> child = el.childNodes[<span class="number">0</span>]; <span class="comment">// 将第一个子节点存储到 child</span></span><br><span class="line">        <span class="keyword">if</span>(child.nodeType == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 如果能够进入此 if，说明该节点是一个元素节点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> child.attributes)&#123;</span><br><span class="line">                <span class="comment">// 遍历该元素节点的每一个属性，拿到的就是 type=&quot;text&quot; v-model=&quot;msg&quot;</span></span><br><span class="line">                <span class="keyword">var</span> attrName = child.attributes[key].nodeName; <span class="comment">// 获取属性名  type、v-model</span></span><br><span class="line">                <span class="keyword">if</span>(attrName === <span class="string">&#x27;v-model&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">var</span> vmKey = child.attributes[key].nodeValue; <span class="comment">// 先获取属性值，也就是 msg</span></span><br><span class="line">                    <span class="comment">// 为该节点，也就是 &lt;input type=&quot;text&quot; v-model=&quot;msg&quot;&gt; 绑定一个 input 事件</span></span><br><span class="line">                    child.addEventListener(<span class="string">&#x27;input&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">                        vm[vmKey] = event.target.value; <span class="comment">// 获取用户输入的值，然后改变 vm 里面的 msg 属性对应的值，注意这里会触发 setter</span></span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(child.nodeType == <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="comment">// 如果能进入此 if，说明该节点是一个文本节点</span></span><br><span class="line">            <span class="keyword">if</span>(reg.test(child.nodeValue))&#123;</span><br><span class="line">                <span class="comment">// 如果能够进入到此 if，说明是 &#123;&#123; &#125;&#125;，然后我们要让其成为订阅者</span></span><br><span class="line">                <span class="keyword">var</span> vmKey = <span class="built_in">RegExp</span>.$1; <span class="comment">// 获取正则里面的捕获值，也就是 msg</span></span><br><span class="line">                <span class="comment">// 实例化一个 Watcher（订阅者），接收 3 个参数：Vue 实例，该文本节点，捕获值 msg</span></span><br><span class="line">                <span class="keyword">new</span> Watcher(vm, child, vmKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        documentFragment.appendChild(el.childNodes[<span class="number">0</span>]); <span class="comment">// 将第一个子节点添加到文档碎片里面</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将文档碎片中节点重新添加到 el，也就是 &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; 下面</span></span><br><span class="line">    el.appendChild(documentFragment);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建发布者构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dep</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 将观察者添加到发布者内部的数组里面</span></span><br><span class="line">    <span class="comment">// 这样以便于通知所有的观察者去更新数据</span></span><br><span class="line">    <span class="built_in">this</span>.subs = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dep.prototype = &#123;</span><br><span class="line">    <span class="comment">// 将 watcher 添加到发布者内置的数组里面</span></span><br><span class="line">    <span class="attr">addSub</span>: <span class="function"><span class="keyword">function</span> (<span class="params">sub</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.subs.push(sub);</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 遍历数组里面所有的 watcher，通知它们去更新数据</span></span><br><span class="line">    <span class="attr">notify</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.subs.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">sub</span>) </span>&#123;</span><br><span class="line">            sub.update();</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建观察者 Watcher 构造函数</span></span><br><span class="line"><span class="comment">// 接收 3 个参数：Vue 实例，文本节点 &#123;&#123; msg &#125;&#125; 以及捕获内容 msg</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Watcher</span>(<span class="params">vm, child, vmKey</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.vm = vm; <span class="comment">// vm </span></span><br><span class="line">    <span class="built_in">this</span>.child = child; <span class="comment">// &#123;&#123; msg &#125;&#125;</span></span><br><span class="line">    <span class="built_in">this</span>.vmKey = vmKey; <span class="comment">// msg</span></span><br><span class="line">    Dep.target = <span class="built_in">this</span>; <span class="comment">// 将该观察者实例对象添加给 Dep.target</span></span><br><span class="line">    <span class="built_in">this</span>.update(); <span class="comment">// 执行节点更新方法</span></span><br><span class="line">    Dep.target = <span class="literal">null</span>; <span class="comment">// 最后清空 Dep.target</span></span><br><span class="line">&#125;</span><br><span class="line">Watcher.prototype = &#123;</span><br><span class="line">    <span class="comment">// 节点更新方法</span></span><br><span class="line">    <span class="attr">update</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 相当于：&#123;&#123; msg &#125;&#125;.nodeValue = this.vm[&#x27;msg&#x27;]</span></span><br><span class="line">        <span class="comment">// 这样就更新了文本节点的值，由于这里在获取 vm.msg，所以会触发 getter</span></span><br><span class="line">        <span class="built_in">this</span>.child.nodeValue = <span class="built_in">this</span>.vm[<span class="built_in">this</span>.vmKey];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该函数的作用是用于数据侦听</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span>(<span class="params">vm,obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dep = <span class="keyword">new</span> Dep(); <span class="comment">// 新增一个发布者:发布者的作用是告诉订阅者数据已经更改</span></span><br><span class="line">    <span class="comment">// 遍历数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">        <span class="comment">// 将数据的每一项添加到 vm 里面，至此，vm 也有了每一项数据</span></span><br><span class="line">        <span class="comment">// 但是不是单纯的添加，而是设置了 getter 和 setter</span></span><br><span class="line">        <span class="comment">// 在获取数据时触发 getter，在设置数据时触发 setter</span></span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(vm, key, &#123;</span><br><span class="line">            <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;触发get了&quot;</span>);</span><br><span class="line">                <span class="comment">// 触发 getter 时，将该 watcher 添加到发布者维护的数组里面</span></span><br><span class="line">                <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">                    dep.addSub(Dep.target); <span class="comment">// 往发布者的数组里面添加订阅者</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">console</span>.log(dep.subs);</span><br><span class="line">                <span class="keyword">return</span> obj[key];</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="function"><span class="title">set</span>(<span class="params">newVal</span>)</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;触发set了&quot;</span>);</span><br><span class="line">                obj[key] = newVal;</span><br><span class="line">                dep.notify(); <span class="comment">// 发布者发出消息，通知订阅者修改数据</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="211-手写用-ES6proxy-如何实现-arr-1-的访问（滴滴2020）"><a href="#211-手写用-ES6proxy-如何实现-arr-1-的访问（滴滴2020）" class="headerlink" title="211. 手写用 ES6proxy 如何实现 arr[-1] 的访问（滴滴2020）"></a>211. 手写用 <em>ES6proxy</em> 如何实现 <em>arr[-1]</em> 的访问（滴滴2020）</h3><blockquote>
<p>参考答案：</p>
<p>示例代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> proxyArray = <span class="function"><span class="params">arr</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> length = arr.length;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(arr, &#123;</span><br><span class="line">        <span class="function"><span class="title">get</span>(<span class="params">target, key</span>)</span> &#123;</span><br><span class="line">            key = +key;</span><br><span class="line">            <span class="keyword">while</span> (key &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                key += length;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> target[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> a = proxyArray([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(a[<span class="number">1</span>]);  <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(a[-<span class="number">10</span>]);  <span class="comment">// 9</span></span><br><span class="line"><span class="built_in">console</span>.log(a[-<span class="number">20</span>]);  <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="212-下列代码执行结果"><a href="#212-下列代码执行结果" class="headerlink" title="212. 下列代码执行结果"></a>212. 下列代码执行结果</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    process.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">7</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">8</span>);</span><br><span class="line">&#125;);</span><br><span class="line">process.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">9</span>);</span><br><span class="line">    process.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">10</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">11</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">12</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考答案：</p>
<p>1<br>7<br>6<br>8<br>2<br>4<br>3<br>5<br>9<br>11<br>10<br>12</p>
</blockquote>
<h3 id="213-Number-的存储空间是多大？如果后台发送了一个超过最大自己的数字怎么办"><a href="#213-Number-的存储空间是多大？如果后台发送了一个超过最大自己的数字怎么办" class="headerlink" title="213. Number() 的存储空间是多大？如果后台发送了一个超过最大自己的数字怎么办"></a>213. Number() 的存储空间是多大？如果后台发送了一个超过最大自己的数字怎么办</h3><blockquote>
<p>参考答案：</p>
<p>Math.pow(2, 53) ，53 为有效数字，会发生截断，等于 JS 能支持的最大数字。</p>
</blockquote>
<h3 id="214-事件是如何实现的？-字节2020"><a href="#214-事件是如何实现的？-字节2020" class="headerlink" title="214. 事件是如何实现的？(字节2020)"></a>214. 事件是如何实现的？(字节2020)</h3><blockquote>
<p>参考答案：</p>
<p>基于发布订阅模式，就是在浏览器加载的时候会读取事件相关的代码，但是只有实际等到具体的事件触发的时候才会执行。</p>
<p>比如点击按钮，这是个事件(Event)，而负责处理事件的代码段通常被称为事件处理程序(Event Handler)，也就是「启动对话框的显示」这个动作。</p>
<p>在 Web 端，我们常见的就是 DOM 事件：</p>
<ul>
<li>DOM0 级事件，直接在 html 元素上绑定 on-event，比如 onclick，取消的话，dom.onclick = null，同一个事件只能有一个处理程序，后面的会覆盖前面的。</li>
<li>DOM2 级事件，通过 addEventListener 注册事件，通过 removeEventListener 来删除事件，一个事件可以有多个事件处理程序，按顺序执行，捕获事件和冒泡事件</li>
<li>DOM3级事件，增加了事件类型，比如 UI 事件，焦点事件，鼠标事件</li>
</ul>
</blockquote>
<h3 id="215-下列代码执行结果"><a href="#215-下列代码执行结果" class="headerlink" title="215. 下列代码执行结果"></a>215. 下列代码执行结果</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="number">4</span>);</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考答案：</p>
<p>0<br>1<br>2<br>3<br>4<br>5<br>6</p>
</blockquote>
<blockquote>
<p>解析：</p>
<p>照着代码，我们先来看初始任务。</p>
<ul>
<li><p>（初始任务）第一部分 Promise.resolve() 返回 「Promise { undefined }」。</p>
</li>
<li><p>（同任务，下同）继续调用 then，then 发现「Promise { undefined }」已解决，直接 enqueue 包含 console.log(0);return Promise.resolve(4) 的任务，之后返回新的「Promise { &lt;pending&gt; }」（设为 promise0）。被 enqueue 的任务之后会引发 promise0 的 resolve/reject，详见 追加任务一 的 2. 3. 。</p>
</li>
<li><p>继续调用 promise0 上的 then，第二个 then 发现 promise0 还在 pending，因此不能直接 enqueue 新任务，而是将包含 console.log(res) 回调追加到 promise0 的 PromiseFulfillReactions 列表尾部，并返回新的「Promise { <pending> }」（设为 promiseRes）（该返回值在代码中被丢弃，但不影响整个过程）。</p>
</li>
<li><p>第二部分 Promise.resolve().then… 同理，只有包含 console.log(1) 的任务被 enqueue。中间结果分别设为 promise1（=Promise.resolve().then(() =&gt; {console.log(1);})）, promise2, promise3, promise5, promise6。当前任务执行完毕。</p>
</li>
</ul>
<p>此时，任务列队上有两个新任务，分别包含有 console.log(0);return Promise.resolve(4) 和 console.log(1) 。我们用 「Job { ??? }」来指代。</p>
<p>接下来，「Job { console.log(0);return Promise.resolve(4) }」先被 enqueue，所以先运行「Job { console.log(0);return Promise.resolve(4) }」。</p>
<ul>
<li><p>（追加任务一）此时「0」被 console.log(0) 输出。Promise.resolve(4) 返回已解决的「Promise { 4 }」，然后 return Promise.resolve(4) 将这个「Promise { 4 }」作为最开始的 Promise.resolve().then（对应 promise0）的 onfulfill 处理程序（即 then(onfulfill, onreject) 的参数 onfulfill）的返回值返回。</p>
</li>
<li><p>（同任务，下同）onfulfill 处理程序返回，触发了 promise0 的 Promise Resolve Function（以下简称某 promise（实例）的 resolve）。所谓触发，其实是和别的东西一起打包到「Job { console.log(0);return Promise.resolve(4) }」当中，按流程执行，onfulfill 返回后自然就到它了。（onfulfill 抛异常的话会被捕获并触发 reject，正常返回就是 resolve。）</p>
</li>
<li><p>promise0 的 resolve 检查 onfulfill 的返回值，发现该值包含<strong>可调用的</strong>「then」属性。这是当然的，因为是「Promise { 4 }」。无论该 Promise 实例是否解决，都将 enqueue 一个新任务包含调用该返回值的 then 的任务（即规范中的 NewPromiseResolveThenableJob(promiseToResolve, thenable, then)）。而这个任务才会触发后续操作，在本例中，最终会将 promise0 的 PromiseFulfillReactions （其中有包含 console.log(res) 回调）再打包成任务 enqueue 到任务列队上。当前任务执行完毕。</p>
</li>
</ul>
<p>此时，任务列队上还是有两个任务（一进一出），「Job { console.log(1) }」和「NewPromiseResolveThenableJob(promise0, 「Promise { 4 }」, 「Promise { 4 }」.then)」。接下来执行「Job { console.log(1) }」。</p>
<ul>
<li><p>（追加任务二）「1」被输出。</p>
</li>
<li><p>（同任务，下同）onfulfill 处理程序返回 undefined。（JavaScript 的函数默认就是返回 undefined。）</p>
</li>
<li><p>promise1 的 resolve 发现 undefined 连 Object 都不是，自然不会有 then，所以将 undefined 作为 promise1 的解决结果。即 promise1 从「Promise { &lt;pending&gt; }」变为 「Promise { undefined }」（fulfill）。</p>
</li>
<li><p>resolve 继续查看 promise1 的 PromiseFulfillReactions。（reject 则会查看 PromiseRejectReactions。）有一个之前被 promise1.then 调用追加上的包含 console.log(2) 的回调。打包成任务入列。（如有多个则依次序分别打包入列。）当前任务执行完毕。</p>
</li>
</ul>
<p>此时，任务列队上仍然有两个任务（一进一出）。「NewPromiseResolveThenableJob(…)」和 「Job { console.log(2) }」。执行「NewPromiseResolveThenableJob(…)」。</p>
<ul>
<li><p>（追加任务三）调用 「Promise { 4 }」的 then。这个调用的参数（处理程序 onfulfill 和 onreject） 用的正是 promise0 的 resolve 和 reject。</p>
</li>
<li><p>由于「Promise { 4 }」的 then 是标准的，行为和其他的 then 一致。（可参见初始任务的步骤 2. 。）它发现「Promise { 4 }」已解决，结果是 4。于是直接 enqueue 包含 promise0 的 resolve 的任务，参数是 4。理论上同样返回一个「Promise { <pending> }」，由于是在内部，不被外部观察，也不产生别的影响。）当前任务执行完毕。</p>
</li>
</ul>
<p>此时，任务列队上依旧有两个任务（一进一出）。「Job { console.log(2) }」和 「Job { promise0 的 resolve }」。执行「Job { console.log(2) }」。</p>
<ul>
<li>（追加任务四）过程类似「Job { console.log(1) }」的执行。「2」被输出。「Job { console.log(3) }」入列。其余不再赘述。当前任务执行完毕。</li>
</ul>
<p>此时，任务列队上依然有两个任务（一进一出）。「Job { promise0 的 resolve }」和「Job { console.log(3) }」。执行「Job { promise0 的 resolve }」。</p>
<ul>
<li>（追加任务五）promise0 的 resolve 查看 PromiseFulfillReactions 发现有被 promise0.then 追加的回调。打包成任务入列。该任务包含 console.log(res)，其中传递 promise0 解决结果 4 给参数 res。当前任务执行完毕。</li>
</ul>
<p>此时，任务列队上还是两个任务（一进一出）。「Job { console.log(3) }」和「Job { console.log(res) }」。</p>
<ul>
<li>（追加任务六）输出「3」。「Job { console.log(5) }」入列。</li>
</ul>
<p>此时，任务列队上还是两个任务（一进一出）。「Job { console.log(res) }」和「Job { console.log(5) }」。</p>
<ul>
<li>（追加任务七）输出「4」。由于 promiseRes 没有被 then 追加回调。就此打住。</li>
</ul>
<p>此时，任务列队上终于不再是两个任务了。下剩「Job { console.log(5) }」。</p>
<ul>
<li>（追加任务八）输出「5」。「Job { console.log(6) }」入列。</li>
</ul>
<p>最后一个任务（追加任务九）输出「6」。任务列队清空。</p>
<p>因此，输出的顺序是「0 1 2 3 4 5 6」。</p>
<p>总结一下，除去初始任务，总共 enqueue 了 9 个任务。其中，第一串 Promise + then… enqueue 了 4 个。第二串 Promise + then… enqueue 了 5 个。分析可知，每增加一个 then 就会增加一个任务入列。</p>
<p>而且，第一串的 return Promise.resolve(4) 的写法额外 enqueue 了 2 个任务，分别在 promise0 的 resolve 时（追加任务一 3.）和调用「Promise { 4 }」的 then 本身时（追加任务三 2.）。</p>
<p>根据规范，它就该这样。说不上什么巧合，可以算是有意为之。处理程序里返回 thenable 对象就会导致增加两个任务入列。</p>
</blockquote>
<h3 id="216-判断数组的方法，请分别介绍它们之间的区别和优劣"><a href="#216-判断数组的方法，请分别介绍它们之间的区别和优劣" class="headerlink" title="216. 判断数组的方法，请分别介绍它们之间的区别和优劣"></a>216. 判断数组的方法，请分别介绍它们之间的区别和优劣</h3><blockquote>
<p>参考答案：</p>
<p>方法一：<strong>instanceof 操作符判断</strong></p>
<p><strong>用法：arr instanceof Array</strong></p>
<p><strong>instanceof 主要是用来判断某个实例是否属于某个对象</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"><span class="built_in">console</span>.log(arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>缺点：instanceof是判断类型的prototype是否出现在对象的原型链中，但是对象的原型可以随意修改，所以这种判断并不准确。并且也不能判断对象和数组的区别</p>
<p>方法二：<strong>对象构造函数的 constructor判断</strong></p>
<p><strong>用法：arr.constructor === Array</strong></p>
<p><strong>Object的每个实例都有构造函数 constructor，用于保存着用于创建当前对象的函数</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"><span class="built_in">console</span>.log(arr.constructor === <span class="built_in">Array</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>方法三：<strong>Array 原型链上的 isPrototypeOf</strong></p>
<p><strong>用法：Array.prototype.isPrototypeOf(arr</strong>)</p>
<p><strong>Array.prototype  属性表示 Array 构造函数的原型</strong></p>
<p>其中有一个方法是 isPrototypeOf() 用于测试一个对象是否存在于另一个对象的原型链上。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.isPrototypeOf(arr)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>方法四：<strong>Object.getPrototypeOf</strong></p>
<p><strong>用法：Object.getPrototypeOf(arr) === Array.prototype</strong></p>
<p><strong>Object.getPrototypeOf() 方法返回指定对象的原型</strong></p>
<p>所以只要跟Array的原型比较即可</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(arr) === <span class="built_in">Array</span>.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>方法五：<strong>Object.prototype.toString</strong></p>
<p><strong>用法：Object.prototype.toString.call(arr) === ‘[object Array]’</strong></p>
<p>虽然Array也继承自Object，但js在Array.prototype上重写了toString，而我们通过toString.call(arr)实际上是通过原型链调用了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(arr) === <span class="string">&#x27;[object Array]&#x27;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>缺点：不能精准判断自定义对象，对于自定义对象只会返回[object Object]</p>
<p>方法六：<strong>Array.isArray</strong></p>
<p><strong>用法：Array.isArray(arr)</strong></p>
<p><strong>ES5中新增了Array.isArray方法,IE8及以下不支持</strong></p>
<p>Array.isArray ( arg )<br>isArray 函数需要一个参数 arg，如果参数是个对象并且 class 内部属性是 “Array”, 返回布尔值 true；否则它返回 false。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(arr)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>缺点：Array.isArray是ES 5.1推出的，<strong>不支持IE6~8</strong>，所以在使用的时候需要注意兼容性问题。</p>
</blockquote>
<h3 id="217-JavaScript-中的数组和函数在内存中是如何存储的？"><a href="#217-JavaScript-中的数组和函数在内存中是如何存储的？" class="headerlink" title="217. JavaScript 中的数组和函数在内存中是如何存储的？"></a>217. JavaScript 中的数组和函数在内存中是如何存储的？</h3><blockquote>
<p>参考答案：</p>
<p>在 <em>JavaScript</em> 中，数组不是以一段连续的区域存储在内存中，而是一种哈希映射的形式存储在堆内容里面。它可以通过多种数据结构实现，其中一种是链表。如下图所示：</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-08-18-125006.png" alt="image-20210818205006459" style="zoom:50%;" />

<p>JavaScript 中的函数是存储在堆内存中的，具体的步骤如下：</p>
<ol>
<li>开辟堆内存（<em>16</em> 进制得到内存地址）</li>
<li>声明当前函数的作用域（函数创建的上下文才是他的作用域，和在那执行的无关）</li>
<li>把函数的代码以字符串的形式存储在堆内存中（函数再不执行的情况下，只是存储在堆内存中的字符串）</li>
<li>将函数堆的地址，放在栈中供变量调用（函数名）</li>
</ol>
</blockquote>
<h3 id="218-JavaScript-是如何运行的？解释型语言和编译型语言的差异是什么？"><a href="#218-JavaScript-是如何运行的？解释型语言和编译型语言的差异是什么？" class="headerlink" title="218. JavaScript 是如何运行的？解释型语言和编译型语言的差异是什么？"></a>218. <em>JavaScript</em> 是如何运行的？解释型语言和编译型语言的差异是什么？</h3><blockquote>
<p>参考答案：</p>
<p>关于第一个问题，这不是三言两语或者几行文字就能够讲清楚的，这里放上一篇博文地址：</p>
<p><em><a href="https://segmentfault.com/a/1190000019530109">https://segmentfault.com/a/1190000019530109</a></em></p>
<p>之后在直播课或者录屏课进行详细的讲解</p>
<p>第二个问题：解释型语言和编译型语言的差异是什么？</p>
<p>电脑能认得的是二进制数，不能够识别高级语言。所有高级语言在电脑上执行都需要先转变为机器语言。但是高级语言有两种类型：编译型语言和解释型语言。常见的编译型语言语言有C/C++、Pascal/Object 等等。常见的解释性语言有python、JavaScript等等。</p>
<p>编译型语言先要进行编译，然后转为特定的可执行文件，这个可执行文件是针对平台的（CPU类型），可以这么理解你在PC上编译一个C源文件，需要经过预处理，编译，汇编等等过程生成一个可执行的二进制文件。当你需要再次运行改代码时，不需要重新编译代码，只需要运行该可执行的二进制文件。优点，编译一次，永久执行。还有一个优点是，你不需要提供你的源代码，你只需要发布你的可执行文件就可以为客户提供服务，从而保证了你的源代码的安全性。但是，如果你的代码需要迁移到linux、ARM下时，这时你的可执行文件就不起作用了，需要根据新的平台编译出一个可执行的文件。这也就是多个平台需要软件的多个版本。缺点是，跨平台能力差。</p>
<p>解释型语言需要一个解释器，在源代码执行的时候被解释器翻译为一个与平台无关的中间代码，解释器会把这些代码翻译为及其语言。打个比方，编译型中的编译相当于一个翻译官，它只能翻译英语，而且中文文章翻译一次就不需要重新对文章进行二次翻译了，但是如果需要叫这个翻译官翻译德语就不行了。而解释型语言中的解释器相当于一个会各种语言的机器人，而且这个机器人回一句一句的翻译你的语句。对于不同的国家，翻译成不同的语言，所以，你只需要带着这个机器人就可以。解释型语言的有点是，跨平台，缺点是运行时需要源代码，知识产权保护性差，运行效率低。</p>
</blockquote>
<h3 id="219-列举你所了解的编程范式？"><a href="#219-列举你所了解的编程范式？" class="headerlink" title="219. 列举你所了解的编程范式？"></a>219. 列举你所了解的编程范式？</h3><blockquote>
<p>参考答案：</p>
<p>编程范式 <em>Programming paradigm</em> 是指计算机中编程的典范模式或方法。</p>
<p>常见的编程范式有：函数式编程、程序编程、面向对象编程、指令式编程等。</p>
<p>不同的编程语言也会提倡不同的“编程范型”。一些语言是专门为某个特定的范型设计的，如 <em>Smalltalk</em> 和 <em>Java</em> 支持面向对象编程。而 <em>Haskell</em> 和 <em>Scheme</em> 则支持函数式编程。现代编程语言的发展趋势是支持多种范型，例如 <em>ES</em> 支持函数式编程的同时也支持面向对象编程。</p>
</blockquote>
<h3 id="220-什么是面向切面（AOP）的编程？"><a href="#220-什么是面向切面（AOP）的编程？" class="headerlink" title="220. 什么是面向切面（AOP）的编程？"></a>220. 什么是面向切面（AOP）的编程？</h3><blockquote>
<p>参考答案：</p>
<p><strong>什么是AOP？</strong></p>
<p>AOP(面向切面编程)的主要作用是把一些跟核心业务逻辑模块无关的功能抽离出来，这些跟业务逻辑无关的功能通常包括日志统计、安全控制、异常处理等。把这些功能抽离出来之后， 再通过“动态织入”的方式掺入业务逻辑模块中。</p>
<p><strong>AOP能给我们带来什么好处？</strong></p>
<p>AOP的好处首先是可以保持业务逻辑模块的纯净和高内聚性，其次是可以很方便地复用日志统计等功能模块。 </p>
<p><strong>JavaScript实现AOP的思路？</strong></p>
<p>通常，在 JavaScript 中实现 AOP，都是指把一个函数“动态织入”到另外一个函数之中，具体的实现技术有很多，下面我用扩展 Function.prototype 来做到这一点。 </p>
<p>主要就是两个函数，在Function的原型上加上before与after，作用就是字面的意思，在函数的前面或后面执行，相当于<strong>无侵入</strong>把一个函数插入到另一个函数的前面或后面，应用得当可以很好的实现代码的解耦，js中的代码实现如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Aop构造器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Aop</span>(<span class="params">options</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.options = options</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//业务方法执行前钩子</span></span><br><span class="line">Aop.prototype.before = <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">    cb.apply(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//业务方法执行后钩子</span></span><br><span class="line">Aop.prototype.after = <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">    cb.apply(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//业务方法执行器</span></span><br><span class="line">Aop.prototype.execute = <span class="function"><span class="keyword">function</span>(<span class="params">beforeCb,runner,afterCb</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.before(beforeCb)</span><br><span class="line">    runner.apply(<span class="built_in">this</span>)</span><br><span class="line">    <span class="built_in">this</span>.after(afterCb)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> aop = <span class="keyword">new</span> Aop(&#123;</span><br><span class="line">    <span class="attr">afterInfo</span>:<span class="string">&#x27;执行后&#x27;</span>,</span><br><span class="line">    <span class="attr">runnerInfo</span>:<span class="string">&#x27;执行中&#x27;</span>,</span><br><span class="line">    <span class="attr">beforeInfo</span>:<span class="string">&#x27;执行前&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> beforeCb = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.options.beforeInfo)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> afterCb = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.options.afterInfo)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> runnerCb = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.options.runnerInfo)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">aop.execute(beforeCb,runnerCb,afterCb)</span><br></pre></td></tr></table></figure>

<p>应用的一些例子：</p>
<ol>
<li>为 <em>window.onload</em> 添加方法，防止 <em>window.onload</em> 被二次覆盖</li>
<li>无侵入统计某个函数的执行时间</li>
<li>表单校验</li>
<li>统计埋点</li>
<li>防止 <em>csrf</em> 攻击</li>
</ol>
</blockquote>
<h3 id="221-JavaScript-中的-const-数组可以进行-push-操作吗？为什么？"><a href="#221-JavaScript-中的-const-数组可以进行-push-操作吗？为什么？" class="headerlink" title="221. JavaScript 中的 const 数组可以进行 push 操作吗？为什么？"></a>221. <em>JavaScript</em> 中的 <em>const</em> 数组可以进行 <em>push</em> 操作吗？为什么？</h3><blockquote>
<p>参考答案：</p>
<p>可以进行 <em>push</em> 操作。虽然 <em>const</em> 表示常量，但是当我们把一个数组赋值给 <em>const</em> 声明的变量时，实际上是把这个数组的地址赋值给该变量。而 <em>push</em> 操作是在数组地址所指向的堆区添加元素，地址本身并没有发生改变。</p>
<p>示例代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>];</span><br><span class="line">arr.push(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="222-JavaScript-中对象的属性描述符有哪些？分别有什么作用？"><a href="#222-JavaScript-中对象的属性描述符有哪些？分别有什么作用？" class="headerlink" title="222. JavaScript 中对象的属性描述符有哪些？分别有什么作用？"></a>222. JavaScript 中对象的属性描述符有哪些？分别有什么作用？</h3><blockquote>
<p>参考答案：</p>
<p>从<em>ES5</em>开始，添加了对对象<strong>属性描述符</strong>的支持。现在<em>JavaScript</em>中支持 <em>4</em> 种属性描述符:</p>
<ul>
<li><strong>configurable:</strong> 当且仅当该属性的<em>configurable</em>键值为<em>true</em>时，该属性的描述符才能够被改变，同时该属性也能从对应的对象上被删除。</li>
<li><strong>enumerable:</strong> 当且仅当该属性的<em>enumerable</em>键值为<em>true</em>时，该属性才会出现在对象的枚举属性中。</li>
<li><strong>value:</strong> 该属性对应的值。可以是任何有效的 <em>JavaScript</em> 值（数值，对象，函数等）。</li>
<li><strong>writable:</strong> 当且仅当该属性的<em>writable</em>键值为<em>true</em>时，属性的值，也就是上面的value，才能被赋值运算符改变。</li>
</ul>
</blockquote>
<h3 id="223-JavaScript-中-console-有哪些-api"><a href="#223-JavaScript-中-console-有哪些-api" class="headerlink" title="223. JavaScript 中 console 有哪些 api ?"></a>223. <em>JavaScript</em> 中 <em>console</em> 有哪些 <em>api</em> ?</h3><blockquote>
<p>参考答案：</p>
<p><strong>console.assert(expression, object[, object…])</strong></p>
<p>接收至少两个参数，第一个参数的值或返回值为<code>false</code>的时候，将会在控制台上输出后续参数的值。</p>
<p><strong>console.count([label])</strong></p>
<p>输出执行到该行的次数，可选参数 label 可以输出在次数之前。</p>
<p><strong>console.dir(object)</strong></p>
<p>将传入对象的属性，包括子对象的属性以列表形式输出。</p>
<p><strong>console.error(object[, object…])</strong></p>
<p>用于输出错误信息，用法和常见的<code>console.log</code>一样，不同点在于输出内容会标记为错误的样式，便于分辨。</p>
<p><strong>console.group</strong></p>
<p>这是个有趣的方法，它能够让控制台输出的语句产生不同的层级嵌套关系，每一个<code>console.group()</code>会增加一层嵌套，相反要减少一层嵌套可以使用<code>console.groupEnd()</code>方法。</p>
<p><strong>console.info(object[, object…])</strong></p>
<p>此方法与之前说到的<code>console.error</code>一样，用于输出信息，没有什么特别之处。</p>
<p><strong>console.table()</strong></p>
<p>可将传入的对象，或数组以表格形式输出，相比传统树形输出，这种输出方案更适合内部元素排列整齐的对象或数组，不然可能会出现很多的 undefined。</p>
<p><strong>console.log(object[, object…])</strong></p>
<p>输入一段 <em>log</em> 信息。</p>
<p><strong>console.profile([profileLabel])</strong></p>
<p>这是个挺高大上的东西，可用于性能分析。在 JS 开发中，我们常常要评估段代码或是某个函数的性能。在函数中手动打印时间固然可以，但显得不够灵活而且有误差。借助控制台以及<code>console.profile()</code>方法我们可以很方便地监控运行性能。</p>
<p><strong>console.time(name)</strong><br>计时器，可以将成对的<code>console.time()</code>和<code>console.timeEnd()</code>之间代码的运行时间输出到控制台上，<code>name</code>参数可作为标签名。</p>
<p><strong>console.trace()</strong></p>
<p><code>console.trace()</code>用来追踪函数的调用过程。在大型项目尤其是框架开发中，函数的调用轨迹可以十分复杂，<code>console.trace()</code>方法可以将函数的被调用过程清楚地输出到控制台上。</p>
<p><strong>console.warn(object[, object…])</strong></p>
<p>输出参数的内容，作为警告提示。</p>
</blockquote>
<h3 id="224-简单对比一下-Callback、Promise、Generator、Async-几个异步-API-的优劣？"><a href="#224-简单对比一下-Callback、Promise、Generator、Async-几个异步-API-的优劣？" class="headerlink" title="224. 简单对比一下 Callback、Promise、Generator、Async 几个异步 API 的优劣？"></a>224. 简单对比一下 <em>Callback、Promise、Generator、Async</em> 几个异步 <em>API</em> 的优劣？</h3><blockquote>
<p>参考答案：</p>
<p>请参阅前面第 <em>31</em> 题答案。</p>
</blockquote>
<h3 id="225-Object-defineProperty-有哪几个参数？各自都有什么作用"><a href="#225-Object-defineProperty-有哪几个参数？各自都有什么作用" class="headerlink" title="225. Object.defineProperty 有哪几个参数？各自都有什么作用"></a>225. <em>Object.defineProperty</em> 有哪几个参数？各自都有什么作用</h3><blockquote>
<p>参考答案：</p>
<p>在 <em>JavaScript</em> 中，通过 <em>Object.defineProperty</em> 方法可以设置对象属性的特性，选项如下：</p>
<ul>
<li><em>get</em>：一旦目标属性被访问时，就会调用相应的方法</li>
<li><em>set</em>：一旦目标属性被设置时，就会调用相应的方法</li>
<li><em>value</em>：这是属性的值，默认是 <em>undefined</em></li>
<li><em>writable</em>：这是一个布尔值，表示一个属性是否可以被修改，默认是 <em>true</em></li>
<li><em>enumerable</em>：这是一个布尔值，表示在用 <em>for-in</em> 循环遍历对象的属性时，该属性是否可以显示出来，默认值为 <em>true</em></li>
<li><em>configurable</em>：这是一个布尔值，表示我们是否能够删除一个属性或者修改属性的特性，默认值为 <em>true</em></li>
</ul>
</blockquote>
<h3 id="226-Object-defineProperty-和-ES6-的-Proxy-有什么区别？"><a href="#226-Object-defineProperty-和-ES6-的-Proxy-有什么区别？" class="headerlink" title="226. Object.defineProperty 和 ES6 的 Proxy 有什么区别？"></a>226. <em>Object.defineProperty</em> 和 <em>ES6</em> 的 <em>Proxy</em> 有什么区别？</h3><blockquote>
<p>参考答案：</p>
<h5 id="1、Object-defineproperty"><a href="#1、Object-defineproperty" class="headerlink" title="1、Object.defineproperty"></a>1、<em>Object.defineproperty</em></h5><p>可以用于监听对象的数据变化</p>
<p>语法： <em><strong>Object.defineproperty(obj, key, descriptor)</strong></em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="number">11</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> value = <span class="string">&#x27;xiaoxiao&#x27;</span>;</span><br><span class="line"><span class="comment">//defineproperty 有 gettter 和 setter</span></span><br><span class="line"><span class="built_in">Object</span>.defineproperty(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">newValue</span>)</span> &#123;</span><br><span class="line">        value = newValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">obj.name = <span class="string">&#x27;pengpeng&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>此外 还有以下配置项 ：</p>
<ul>
<li><em>configurable</em></li>
<li><em>enumerable</em></li>
<li><em>value</em></li>
</ul>
<p>缺点：</p>
<ol>
<li><p>无法监听数组变化</p>
</li>
<li><p>只能劫持对象的属性，属性值也是对象那么需要深度遍历</p>
</li>
</ol>
<h5 id="2、proxy-：可以理解为在被劫持的对象之前-加了一层拦截"><a href="#2、proxy-：可以理解为在被劫持的对象之前-加了一层拦截" class="headerlink" title="2、proxy ：可以理解为在被劫持的对象之前 加了一层拦截"></a>2、<em>proxy</em> ：可以理解为在被劫持的对象之前 加了一层拦截</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params">obj, prop</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> obj[prop]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">obj, prop, val</span>)</span> &#123;</span><br><span class="line">        obj[prop] = val</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><em>proxy</em> 返回的是一个新对象， 可以通过操作返回的新的对象达到目的</li>
<li><em>proxy</em> 有多达 <em>13</em> 种拦截方法</li>
</ul>
<p><strong>总结：</strong></p>
<ul>
<li><em>Object.defineProperty</em> 无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应</li>
<li><em>Object.defineProperty</em> 只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。<em>Proxy</em> 可以劫持整个对象，并返回一个新的对象。</li>
<li><em>Proxy</em> 不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性。</li>
</ul>
</blockquote>
<h3 id="227-intanceof-操作符的实现原理及实现"><a href="#227-intanceof-操作符的实现原理及实现" class="headerlink" title="227. intanceof 操作符的实现原理及实现"></a>227. <em>intanceof</em> 操作符的实现原理及实现</h3><blockquote>
<p>参考答案：</p>
<p><em>instanceof</em> 主要作用就是判断一个实例是否属于某种类型</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Dog = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> tidy = <span class="keyword">new</span> Dog()</span><br><span class="line">tidy <span class="keyword">instanceof</span> Dog <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p><em>intanceof</em> 操作符实现原理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wonderFulInstanceOf</span>(<span class="params">instance, constructorFn</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">let</span> <span class="title">constructorFnProto</span> = <span class="title">constructorFn</span>.<span class="title">prototype</span>; <span class="comment">// 取右表达式的 prototype 值，函数构造器指向的function </span></span><br><span class="line">    instanceProto = instance.__proto__; <span class="comment">// 取左表达式的__proto__值，实例的__proto__</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    	<span class="keyword">if</span> (instanceProto === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;	</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (instanceProto === <span class="title">constructorFnProto</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;	</span><br><span class="line">        &#125; </span><br><span class="line">        instanceProto = instanceProto.__proto__ </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实 <em>instanceof</em> 主要的实现原理就是只要 <em>constructorFn</em> 的 <em>prototype</em> 在<em>instance</em>的原型链上即可。</p>
<p>因此，<em>instanceof</em> 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 <em>prototype</em>，如果查找失败，则会返回 <em>false</em>，告诉我们左边变量并非是右边变量的实例。</p>
</blockquote>
<h3 id="228-强制类型转换规则？"><a href="#228-强制类型转换规则？" class="headerlink" title="228. 强制类型转换规则？"></a>228. 强制类型转换规则？</h3><blockquote>
<p>参考答案：</p>
<p>首先需要参阅前面第 <em>104</em> 题答案。了解隐式转换所调用的函数。</p>
<p>当程序员显式调用 Boolean(value)、Number(value)、String(value) 完成的类型转换，叫做显示类型转换。</p>
<p>当通过 new Boolean(value)、new Number(value)、new String(value) 传入各自对应的原始类型的值，可以实现“装箱”，将原始类型封装成一个对象。</p>
<p>其实这三个函数不仅仅可以当作构造函数，它们可以直接当作普通的函数来使用，将任何类型的参数转化成原始类型的值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="string">&#x27;sdfsd&#x27;</span>);  <span class="comment">//  true</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&quot;23&quot;</span>);  <span class="comment">//  23</span></span><br><span class="line"><span class="built_in">String</span>(&#123;<span class="attr">a</span>:<span class="number">24</span>&#125;);  <span class="comment">//  &quot;[object Object]&quot;</span></span><br></pre></td></tr></table></figure>

<p>其实这三个函数用于类型转换的时候，调用的就是 js 内部的 <em>ToBoolean ( argument )、ToNumber ( argument )、ToString ( argument )</em> 方法，从而达到显式转换的效果。</p>
</blockquote>
<h3 id="229-Object-is-与比较操作符-“-”、“-”-的区别"><a href="#229-Object-is-与比较操作符-“-”、“-”-的区别" class="headerlink" title="229. Object.is( ) 与比较操作符 “===”、“==” 的区别"></a>229. <em>Object.is</em>( ) 与比较操作符 “===”、“==” 的区别</h3><blockquote>
<p>参考答案：</p>
<p>== (或者 !=) 操作在需要的情况下自动进行了类型转换。=== (或 !==)操作不会执行任何转换。</p>
<p>===在比较值和类型时，可以说比==更快。</p>
<p>而在<em>ES6</em>中，<em>Object.is</em>( ) 类似于 ===，但在三等号判等的基础上特别处理了 <em>NaN</em> 、-0 和 +0 ，保证 -0 和 +0 不再相同，但 <em>Object.is(NaN, NaN)</em> 会返回 <em>true</em>。</p>
</blockquote>
<h3 id="230-操作符什么时候用于字符串的拼接？"><a href="#230-操作符什么时候用于字符串的拼接？" class="headerlink" title="230. + 操作符什么时候用于字符串的拼接？"></a>230. <code>+</code> 操作符什么时候用于字符串的拼接？</h3><blockquote>
<p>参考答案：</p>
<p>在有一边操作数是字符串时会进行字符串拼接。</p>
<p>示例代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span> + <span class="string">&#x27;5&#x27;</span>, <span class="keyword">typeof</span> (<span class="number">5</span> + <span class="string">&#x27;5&#x27;</span>)); <span class="comment">// 55  string</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="231-object-assign-和扩展运算法是深拷贝还是浅拷贝"><a href="#231-object-assign-和扩展运算法是深拷贝还是浅拷贝" class="headerlink" title="231. object.assign 和扩展运算法是深拷贝还是浅拷贝"></a>231. <em>object.assign</em> 和扩展运算法是深拷贝还是浅拷贝</h3><blockquote>
<p>参考答案：</p>
<p>这两个方式都是浅拷贝。</p>
<p>在拷贝的对象只有一层时是深拷贝，但是一旦对象的属性值又是一个对象，也就是有两层或者两层以上时，就会发现这两种方式都是浅拷贝。</p>
</blockquote>
<h3 id="232-const-对象的属性可以修改吗"><a href="#232-const-对象的属性可以修改吗" class="headerlink" title="232. const 对象的属性可以修改吗"></a>232. <em>const</em> 对象的属性可以修改吗</h3><blockquote>
<p>参考答案：</p>
<p>可以修改，具体原因可以参阅前面第 <em>231</em> 题。</p>
</blockquote>
<h3 id="233-如果-new-一个箭头函数的会怎么样"><a href="#233-如果-new-一个箭头函数的会怎么样" class="headerlink" title="233. 如果 new 一个箭头函数的会怎么样"></a>233. 如果 <em>new</em> 一个箭头函数的会怎么样</h3><blockquote>
<p>参考答案：</p>
<p>会报错，因为箭头函数无法作为构造函数。</p>
</blockquote>
<h3 id="234-扩展运算符的作用及使用场景"><a href="#234-扩展运算符的作用及使用场景" class="headerlink" title="234. 扩展运算符的作用及使用场景"></a>234. 扩展运算符的作用及使用场景</h3><blockquote>
<p>参考答案：</p>
<p>扩展运算符是三个点(…)，主要用于展开数组，将一个数组转为参数序列。</p>
<p>扩展运算符使用场景：</p>
<ul>
<li>代替数组的 <em>apply</em> 方法</li>
<li>合并数组</li>
<li>复制数组</li>
<li>把 <em>arguments</em> 或 <em>NodeList</em> 转为数组</li>
<li>与解构赋值结合使用</li>
<li>将字符串转为数组</li>
</ul>
</blockquote>
<h3 id="235-Proxy-可以实现什么功能？"><a href="#235-Proxy-可以实现什么功能？" class="headerlink" title="235. Proxy 可以实现什么功能？"></a>235. <em>Proxy</em> 可以实现什么功能？</h3><blockquote>
<p>参考答案：</p>
<p><em>Proxy</em> 是 <em>ES6</em> 中新增的一个特性。<em>Proxy</em> 让我们能够以简洁易懂的方式控制外部对对象的访问。其功能非常类似于设计模式中的代理模式。</p>
<p><em>Proxy</em> 在目标对象的外层搭建了一层拦截，外界对目标对象的某些操作，必须通过这层拦截。</p>
<p>使用 <em>Proxy</em> 的好处是对象只需关注于核心逻辑，一些非核心的逻辑（如：读取或设置对象的某些属性前记录日志；设置对象的某些属性值前，需要验证；某些属性的访问控制等）可以让 <em>Proxy</em> 来做。从而达到关注点分离，降级对象复杂度的目的。</p>
<p><em>Proxy</em> 的基本语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure>

<p>通过构造函数来生成 <em>Proxy</em> 实例，构造函数接收两个参数。<em>target</em> 参数是要拦截的目标对象，<em>handler</em> 参数也是一个对象，用来定制拦截行为。</p>
<p><em>Vue 3.0</em> 主要就采用的 <em>Proxy</em> 特性来实现响应式，相比以前的 <em>Object.defineProperty</em> 有以下优点：</p>
<ul>
<li>可以劫持整个对象，并返回一个新的对象</li>
<li>有 <em>13</em> 种劫持操作</li>
</ul>
</blockquote>
<h3 id="236-对象与数组的解构的理解"><a href="#236-对象与数组的解构的理解" class="headerlink" title="236. 对象与数组的解构的理解"></a>236. 对象与数组的解构的理解</h3><blockquote>
<p>参考答案：</p>
<p>解构是 <em>ES6</em> 的一种语法规则，可以将一个对象或数组的某个属性提取到某个变量中。</p>
<p>解构对象示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  var/let/const&#123;属性名&#125;=被解构的对象</span></span><br><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">sex</span>: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">    <span class="attr">address</span>: &#123;</span><br><span class="line">        <span class="attr">province</span>: <span class="string">&quot;重庆&quot;</span>,</span><br><span class="line">        <span class="attr">city</span>: <span class="string">&quot;重庆&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; name, age, sex, address&#125; = user;</span><br><span class="line"><span class="built_in">console</span>.log(name, age, sex, address);</span><br></pre></td></tr></table></figure>

<p>解构数组示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="237-如何提取高度嵌套的对象里的指定属性？"><a href="#237-如何提取高度嵌套的对象里的指定属性？" class="headerlink" title="237. 如何提取高度嵌套的对象里的指定属性？"></a>237. 如何提取高度嵌套的对象里的指定属性？</h3><blockquote>
<p>参考答案：</p>
<p>一般会使用递归的方式来进行查找。下面是一段示例代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findKey</span>(<span class="params">data, field</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> finding = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key === field) &#123;</span><br><span class="line">            finding = data[key];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> (data[key]) === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">            finding = findKey(data[key], field);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (finding) &#123;</span><br><span class="line">            <span class="keyword">return</span> finding;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="built_in">console</span>.log(findKey(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">stuInfo</span>: &#123;</span><br><span class="line">        <span class="attr">stuNo</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">classNo</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">score</span>: &#123;</span><br><span class="line">            <span class="attr">htmlScore</span>: <span class="number">100</span>,</span><br><span class="line">            <span class="attr">cssScore</span>: <span class="number">90</span>,</span><br><span class="line">            <span class="attr">jsScore</span>: <span class="number">95</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&#x27;cssScore&#x27;</span>)); <span class="comment">// 90</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="238-Unicode、UTF-8、UTF-16、UTF-32-的区别？"><a href="#238-Unicode、UTF-8、UTF-16、UTF-32-的区别？" class="headerlink" title="238. Unicode、UTF-8、UTF-16、UTF-32 的区别？"></a>238. <em>Unicode、UTF-8、UTF-16、UTF-32</em> 的区别？</h3><blockquote>
<p>参考答案：</p>
<p><em>Unicode</em> <strong>为世界上所有字符都分配了一个唯一的数字编号</strong>，这个编号范围从 <em>0x000000</em> 到 <em>0x10FFFF</em> (十六进制)，有 <em>110</em> 多万，每个字符都有一个唯一的 <em>Unicode</em> 编号，这个编号一般写成 <em>16</em> 进制，在前面加上 U+。例如：“马”的 <em>Unicode</em> 是 <em>U+9A6C</em>。<br><em>Unicode</em> 就相当于一张表，建立了字符与编号之间的联系。</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-08-17-080125.png" alt="image-20210817160125144" style="zoom:50%;" />

<p><strong><em>Unicode</em> 本身只规定了每个字符的数字编号是多少，并没有规定这个编号如何存储。</strong></p>
<p>那我们可以直接把 <em>Unicode</em> 编号直接转换成二进制进行存储，怎么对应到二进制表示呢？</p>
<p><em>Unicode</em> 可以使用的编码有三种，分别是：</p>
<ul>
<li><em>UFT-8</em>：一种变长的编码方案，使用 <em>1~6</em> 个字节来存储；</li>
<li><em>UFT-32</em>：一种固定长度的编码方案，不管字符编号大小，始终使用 <em>4</em> 个字节来存储；</li>
<li><em>UTF-16</em>：介于 <em>UTF-8</em> 和 <em>UTF-32</em> 之间，使用 <em>2</em> 个或者 <em>4</em> 个字节来存储，长度既固定又可变。</li>
</ul>
</blockquote>
<h3 id="239-为什么函数的-arguments-参数是类数组而不是数组？如何遍历类数组"><a href="#239-为什么函数的-arguments-参数是类数组而不是数组？如何遍历类数组" class="headerlink" title="239. 为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?"></a>239. 为什么函数的 <em>arguments</em> 参数是类数组而不是数组？如何遍历类数组?</h3><blockquote>
<p>参考答案：</p>
<p>首先了解一下什么是数组对象和类数组对象。</p>
<p>数组对象：使用单独的变量名来存储一系列的值。从 <em>Array</em> 构造函数中继承了一些用于进行数组操作的方法。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mycars = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">mycars[<span class="number">0</span>] = <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">mycars[<span class="number">1</span>] = <span class="string">&quot;lisi&quot;</span>;</span><br><span class="line">mycars[<span class="number">2</span>] = <span class="string">&quot;wangwu&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>类数组对象：<strong>对于一个普通的对象来说，如果它的所有 property 名均为正整数，同时也有相应的length属性，那么虽然该对象并不是由Array构造函数所创建的，它依然呈现出数组的行为，在这种情况下，这些对象被称为“类数组对象”。</strong></p>
<p><strong>两者区别</strong></p>
<ul>
<li><p>一个是对象，一个是数组</p>
</li>
<li><p>数组的<em>length</em>属性，当新的元素添加到列表中的时候，其值会自动更新。类数组对象的不会。</p>
</li>
<li><p>设置数组的<em>length</em>属性可以扩展或截断数组。</p>
</li>
<li><p>数组也是<em>Array</em>的实例可以调用<em>Array</em>的方法，比如<em>push、pop</em>等等</p>
</li>
</ul>
<p>所以说<em>arguments</em>对象不是一个 <em>Array</em> 。它类似于<em>Array</em>，但除了<em>length</em>属性和索引元素之外没有任何<em>Array</em>属性。</p>
<p>可以使用 <em>for…in</em> 来遍历 <em>arguments</em> 这个类数组对象。</p>
</blockquote>
<h3 id="240-escape、encodeURI、encodeURIComponent-的区别"><a href="#240-escape、encodeURI、encodeURIComponent-的区别" class="headerlink" title="240. escape、encodeURI、encodeURIComponent 的区别"></a>240. <em>escape、encodeURI、encodeURIComponent</em> 的区别</h3><blockquote>
<p>参考答案：</p>
<p><em>escape</em> 除了 <em>ASCII</em> 字母、数字和特定的符号外，对传进来的字符串全部进行转义编码，因此如果想对 <em>URL</em> 编码，最好不要使用此方法。</p>
<p><em>encodeURI</em> 用于编码整个 <em>URI</em>，因为 <em>URI</em> 中的合法字符都不会被编码转换。</p>
<p><em>encodeURIComponent</em> 方法在编码单个<em>URIComponent</em>（指请求参数）应当是最常用的，它可以讲参数中的中文、特殊字符进行转义，而不会影响整个 <em>URL</em>。</p>
</blockquote>
<h3 id="241-use-strict-是什么意思-使用它区别是什么？"><a href="#241-use-strict-是什么意思-使用它区别是什么？" class="headerlink" title="241. use strict 是什么意思 ? 使用它区别是什么？"></a>241. <em>use strict</em> 是什么意思 ? 使用它区别是什么？</h3><blockquote>
<p>参考答案：</p>
<p> <em>use strict</em> 代表开启严格模式，这种模式使得 <em>Javascript</em> 在更严格的条件下运行，实行更严格解析和错误处理。</p>
<p>开启“严格模式”的优点：</p>
<ul>
<li>消除 <em>Javascript</em> 语法的一些不合理、不严谨之处，减少一些怪异行为;</li>
<li>消除代码运行的一些不安全之处，保证代码运行的安全；</li>
<li>提高编译器效率，增加运行速度；</li>
<li>为未来新版本的 <em>Javascript</em> 做好铺垫。</li>
</ul>
</blockquote>
<h3 id="242-for…in-和-for…of-的区别"><a href="#242-for…in-和-for…of-的区别" class="headerlink" title="242. for…in 和 for…of 的区别"></a>242. <em>for…in</em> 和 <em>for…of</em> 的区别</h3><blockquote>
<p>参考答案：</p>
<p><em>JavaScript</em> 原有的 <em>for…in</em> 循环，只能获得对象的键名，不能直接获取键值。<em>ES6</em> 提供 <em>for…of</em> 循环，允许遍历获得键值。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> a <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 0 1 2 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> a <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// a b c d</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="243-ajax、axios、fetch-的区别"><a href="#243-ajax、axios、fetch-的区别" class="headerlink" title="243. ajax、axios、fetch 的区别"></a>243. <em>ajax、axios、fetch</em> 的区别</h3><blockquote>
<p>参考答案：</p>
<p><em>ajax</em> 是指一种创建交互式网页应用的网页开发技术，并且可以做到无需重新加载整个网页的情况下，能够更新部分网页，也叫作局部更新。</p>
<p>使用 <em>ajax</em> 发送请求是依靠于一个对象，叫 <em>XmlHttpRequest</em> 对象，通过这个对象我们可以从服务器获取到数据，然后再渲染到我们的页面上。现在几乎所有的浏览器都有这个对象，只有 <em>IE7</em> 以下的没有，而是通过 <em>ActiveXObject</em> 这个对象来创建的。</p>
<p><em>Fetch</em> 是 <em>ajax</em> 非常好的一个替代品，基于 <em>Promise</em> 设计，使用 <em>Fetch</em> 来获取数据时，会返回给我们一个 <em>Pormise</em> 对象，但是 <em>Fetch</em> 是一个低层次的 <em>API</em>，想要很好的使用 <em>Fetch</em>，需要做一些封装处理。</p>
<p>下面是 <em>Fetch</em> 的一些缺点</p>
<ul>
<li><em>Fetch</em> 只对网络请求报错，对 <em>400，500</em> 都当做成功的请求，需要封装去处理</li>
<li><em>Fetch</em> 默认不会带 <em>cookie</em>，需要添加配置项。</li>
<li><em>Fetch</em> 不支持 <em>abort</em>，不支持超时控制，使用 <em>setTimeout</em> 及 <em>Promise.reject</em> 的实现超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费。</li>
<li><em>Fetch</em> 没有办法原生监测请求的进度，而 <em>XHR</em> 可以。</li>
</ul>
<p><em>Vue2.0</em> 之后，<em>axios</em> 开始受到更多的欢迎了。其实 <em>axios</em> 也是对原生 <em>XHR</em> 的一种封装，不过是 <em>Promise</em> 实现版本。它可以用于浏览器和 <em>nodejs</em> 的 <em>HTTP</em> 客户端，符合最新的 <em>ES</em> 规范。</p>
</blockquote>
<h3 id="244-下面代码的输出是什么？（-D-）"><a href="#244-下面代码的输出是什么？（-D-）" class="headerlink" title="244. 下面代码的输出是什么？（ D ）"></a>244. 下面代码的输出是什么？（ <em>D</em> ）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">  <span class="built_in">console</span>.log(age);</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&quot;Lydia&quot;</span>;</span><br><span class="line">  <span class="keyword">let</span> age = <span class="number">21</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayHi();</span><br></pre></td></tr></table></figure>

<ul>
<li>A: <em>Lydia</em> 和 <em>undefined</em></li>
<li>B: <em>Lydia</em> 和 <em>ReferenceError</em></li>
<li>C: <em>ReferenceError</em> 和 <em>21</em></li>
<li>D: <em>undefined</em> 和 <em>ReferenceError</em></li>
</ul>
<blockquote>
<p><strong>分析：</strong></p>
<p>在 <em>sayHi</em> 函数内部，通过 <em>var</em> 声明的变量 <em>name</em> 会发生变量提升，<em>var name</em> 会提升到函数作用域的顶部，其默认值为 <em>undefined</em>。因此输出 <em>name</em> 时得到的值为 <em>undefined</em>；</p>
<p><em>let</em> 声明的 <em>age</em> 不会发生变量提升，在输出 <em>age</em> 时该变量还未声明，因此会抛出 <em>ReferenceError</em> 的报错。</p>
</blockquote>
<h3 id="245-下面代码的输出是什么？（-C-）"><a href="#245-下面代码的输出是什么？（-C-）" class="headerlink" title="245. 下面代码的输出是什么？（ C ）"></a>245. 下面代码的输出是什么？（ <em>C</em> ）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>A: <em>0 1 2</em> 和 <em>0 1 2</em></li>
<li>B: <em>0 1 2</em> 和 <em>3 3 3</em></li>
<li>C: <em>3 3 3</em> 和 <em>0 1 2</em></li>
</ul>
<blockquote>
<p>分析：</p>
<p><em>JavaScript</em> 中的执行机制，<em>setTimeout</em> 为异步代码，因此在 <em>setTimeout</em> 执行时，<em>for</em> 循环已经执行完毕。</p>
<p>第一个 <em>for</em> 循环中的变量 <em>i</em> 通过 <em>var</em> 声明， 为全局变量，因此每一次的 <em>i++</em> 都会将全局变量 <em>i</em> 的值加 <em>1</em>，当第一个 <em>for</em> 执行完成后 <em>i</em> 的值为 <em>3</em>。所以再执行 <em>setTimeout</em> 时，输出 <em>i</em> 的值都为 <em>3</em>；</p>
<p>第二个 <em>for</em> 循环中的变量 <em>i</em> 通过 <em>let</em> 声明，为局部变量，因此每一次 <em>for</em> 循环时都会产生一个块级作用域，用来存储本次循环中新产生的 <em>i</em> 的值。当循环结束后，<em>setTimeout</em> 会沿着作用域链去对应的块级作用域中寻找对应的 <em>i</em> 值。</p>
</blockquote>
<h3 id="246-下面代码的输出是什么？（-B-）"><a href="#246-下面代码的输出是什么？（-B-）" class="headerlink" title="246. 下面代码的输出是什么？（ B ）"></a>246. 下面代码的输出是什么？（ <em>B</em> ）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> shape = &#123;</span><br><span class="line">  <span class="attr">radius</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="function"><span class="title">diameter</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.radius * <span class="number">2</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">perimeter</span>: <span class="function">() =&gt;</span> <span class="number">2</span> * <span class="built_in">Math</span>.PI * <span class="built_in">this</span>.radius</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">shape.diameter();</span><br><span class="line">shape.perimeter();</span><br></pre></td></tr></table></figure>

<ul>
<li>A: <em>20</em> 和 <em>62.83185307179586</em></li>
<li>B: <em>20</em> 和 <em>NaN</em></li>
<li>C: <em>20</em> 和 <em>63</em></li>
<li>D: <em>NaN</em> 和 <em>63</em></li>
</ul>
<blockquote>
<p><strong>分析：</strong></p>
<p><em>diameter</em> 作为对象的方法，其内部的 <em>this</em> 指向调用该方法的对象，因此 <em>this.raduus</em> 获取到的是 <em>shape.radius</em> 的值 <em>10</em>，再乘以 <em>2</em> 输出的值即为 <em>20</em>；</p>
<p><em>perimeter</em> 是一个箭头函数，其内部的 <em>this</em> 应该继承声明时所在上下文中的 <em>this</em>，在这里即继承全局的 <em>this</em>，因此 <em>this.radius</em> 值的为 <em>undefined</em>，<em>undefined</em> 与数值相乘后值为 <em>NaN</em>。</p>
</blockquote>
<h3 id="247-下面代码的输出是什么？（-A-）"><a href="#247-下面代码的输出是什么？（-A-）" class="headerlink" title="247. 下面代码的输出是什么？（ A ）"></a>247. 下面代码的输出是什么？（ <em>A</em> ）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+true;</span><br><span class="line">!&quot;Lydia&quot;;</span><br></pre></td></tr></table></figure>

<ul>
<li>A: <em>1</em> 和 <em>false</em></li>
<li>B: <em>false</em> 和 <em>NaN</em></li>
<li>C: <em>false</em> 和 <em>false</em></li>
</ul>
<blockquote>
<p><strong>分析：</strong></p>
<p>一元加号会将数据隐式转换为 <em>number</em> 类型，<em>true</em> 转换为数值为 <em>1</em>；</p>
<p>非运算符 <em>!</em> 会将数据隐式转换为 <em>boolean</em> 类型后进行取反，*”Lydia”* 转换为布尔值为 <em>true</em>，取反后为 <em>false</em>。</p>
</blockquote>
<h3 id="248-哪个选项是不正确的？（-A-）"><a href="#248-哪个选项是不正确的？（-A-）" class="headerlink" title="248. 哪个选项是不正确的？（ A ）"></a>248. 哪个选项是不正确的？（ <em>A</em> ）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bird = &#123;</span><br><span class="line">  <span class="attr">size</span>: <span class="string">&quot;small&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mouse = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Mickey&quot;</span>,</span><br><span class="line">  <span class="attr">small</span>: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>A: <em>mouse.bird.size</em></li>
<li>B: <em>mouse[bird.size]</em></li>
<li>C: <em>mouse[bird[“size”]]</em></li>
<li>D: 以上选项都对</li>
</ul>
<blockquote>
<p><strong>分析：</strong></p>
<p><em>mouse</em> 对象中没有 <em>bird</em> 属性，当访问一个对象不存在的属性时值为 <em>undefined</em>，因此 <em>mouse.bird</em> 的值为 <em>undefined</em>，而 <em>undefined</em> 作为原始数据类型没有 <em>size</em> 属性，因此再访问 <em>undefined.size</em> 时会报错。</p>
</blockquote>
<h3 id="249-下面代码的输出是什么？（-A-）"><a href="#249-下面代码的输出是什么？（-A-）" class="headerlink" title="249. 下面代码的输出是什么？（ A ）"></a>249. 下面代码的输出是什么？（ <em>A</em> ）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> c = &#123; <span class="attr">greeting</span>: <span class="string">&quot;Hey!&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> d;</span><br><span class="line"></span><br><span class="line">d = c;</span><br><span class="line">c.greeting = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(d.greeting);</span><br></pre></td></tr></table></figure>

<ul>
<li>A: <em>Hello</em></li>
<li>B: <em>undefined</em></li>
<li>C: <em>ReferenceError</em></li>
<li>D: <em>TypeError</em></li>
</ul>
<blockquote>
<p><strong>分析：</strong></p>
<p>在 <em>JavaScript</em> 中，复杂类型数据在进行赋值操作时，进行的是「引用传递」，因此变量 <em>d</em> 和 <em>c</em> 指向的是同一个引用。当 <em>c</em> 通过引用去修改了数据后，<em>d</em> 再通过引用去访问数据，获取到的实际就是 <em>c</em> 修改后的数据。</p>
</blockquote>
<h3 id="250-下面代码的输出是什么？（-C-）"><a href="#250-下面代码的输出是什么？（-C-）" class="headerlink" title="250. 下面代码的输出是什么？（ C ）"></a>250. 下面代码的输出是什么？（ <em>C</em> ）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">let</span> c = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a == b);</span><br><span class="line"><span class="built_in">console</span>.log(a === b);</span><br><span class="line"><span class="built_in">console</span>.log(b === c);</span><br></pre></td></tr></table></figure>

<ul>
<li>A: <em>true</em>  <em>false</em>  <em>true</em></li>
<li>B: <em>false</em>  <em>false</em>  <em>true</em></li>
<li>C: <em>true</em>  <em>false</em>  <em>false</em></li>
<li>D: <em>false</em>  <em>true</em>  <em>true</em></li>
</ul>
<blockquote>
<p><strong>分析：</strong></p>
<p><em>new Number()</em> 是 <em>JavaScript</em> 中一个内置的构造函数。变量 <em>b</em> 虽然看起来像一个数字，但它并不是一个真正的数字：它有一堆额外的功能，是一个对象。</p>
<p>== 会触发隐式类型转换，右侧的对象类型会自动转换为 <em>Number</em> 类型，因此最终返回 <em>true</em>。</p>
<p>=== 不会触发隐式类型转换，因此在比较时由于数据类型不相等而返回 <em>false</em>。</p>
</blockquote>
<h3 id="251-下面代码的输出是什么？（-D-）"><a href="#251-下面代码的输出是什么？（-D-）" class="headerlink" title="251. 下面代码的输出是什么？（ D ）"></a>251. 下面代码的输出是什么？（ <em>D</em> ）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chameleon</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">colorChange</span>(<span class="params">newColor</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.newColor = newColor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">&#123; newColor = <span class="string">&quot;green&quot;</span> &#125; = &#123;&#125;</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.newColor = newColor;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> freddie = <span class="keyword">new</span> Chameleon(&#123; <span class="attr">newColor</span>: <span class="string">&quot;purple&quot;</span> &#125;);</span><br><span class="line">freddie.colorChange(<span class="string">&quot;orange&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>A: <em>orange</em></li>
<li>B: <em>purple</em></li>
<li>C: <em>green</em></li>
<li>D: <em>TypeError</em> </li>
</ul>
<blockquote>
<p><strong>分析</strong>：</p>
<p><em>colorChange</em> 方法是静态的。 静态方法仅在创建它们的构造函数中存在，并且不能传递给任何子级。 由于 <em>freddie</em> 是一个子级对象，函数不会传递，所以在 <em>freddie</em> 实例上不存在 <em>colorChange</em> 方法：抛出<em>TypeError</em>。</p>
</blockquote>
<h3 id="252-下面代码的输出是什么？（-A-）"><a href="#252-下面代码的输出是什么？（-A-）" class="headerlink" title="252. 下面代码的输出是什么？（ A ）"></a>252. 下面代码的输出是什么？（ <em>A</em> ）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> greeting;</span><br><span class="line">greetign = &#123;&#125;; <span class="comment">// Typo!</span></span><br><span class="line"><span class="built_in">console</span>.log(greetign);</span><br></pre></td></tr></table></figure>

<ul>
<li>A: <em>{}</em></li>
<li>B: <em>ReferenceError: greetign is not defined</em></li>
<li>C: <em>undefined</em></li>
</ul>
<blockquote>
<p><strong>分析：</strong></p>
<p>控制台会输出空对象，因为我们刚刚在全局对象上创建了一个空对象！</p>
<p>当我们错误地将 <em>greeting</em> 输入为 <em>greetign</em> 时，<em>JS</em> 解释器实际上在浏览器中将其视为 *window.greetign = {}*。</p>
</blockquote>
<h3 id="253-当我们执行以下代码时会发生什么？（-A-）"><a href="#253-当我们执行以下代码时会发生什么？（-A-）" class="headerlink" title="253. 当我们执行以下代码时会发生什么？（ A ）"></a>253. 当我们执行以下代码时会发生什么？（ <em>A</em> ）</h3>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bark</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Woof!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bark.animal = <span class="string">&quot;dog&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>A 什么都不会发生</li>
<li>B: <em>SyntaxError. You cannot add properties to a function this way.</em></li>
<li>C: <em>undefined</em></li>
<li>D: <em>ReferenceError</em></li>
</ul>
<blockquote>
<p><strong>分析：</strong></p>
<p>因为函数也是对象！（原始类型之外的所有东西都是对象）</p>
<p>函数是一种特殊类型的对象，我们可以给函数添加属性，且此属性是可调用的。</p>
</blockquote>
<h3 id="254-下面代码的输出是什么？（-A-）"><a href="#254-下面代码的输出是什么？（-A-）" class="headerlink" title="254. 下面代码的输出是什么？（ A ）"></a>254. 下面代码的输出是什么？（ <em>A</em> ）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">firstName, lastName</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.firstName = firstName;</span><br><span class="line">  <span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> member = <span class="keyword">new</span> Person(<span class="string">&quot;Lydia&quot;</span>, <span class="string">&quot;Hallie&quot;</span>);</span><br><span class="line">Person.getFullName = <span class="function">() =&gt;</span> <span class="built_in">this</span>.firstName + <span class="built_in">this</span>.lastName;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(member.getFullName());</span><br></pre></td></tr></table></figure>

<ul>
<li>A: <em>TypeError</em></li>
<li>B: <em>SyntaxError</em></li>
<li>C: <em>Lydia Hallie</em></li>
<li>D: <em>undefined</em>  <em>undefined</em></li>
</ul>
<blockquote>
<p><strong>分析：</strong></p>
<p><em>Person.getFullName</em> 是将方法添加到了函数身上，因此当我们通过实例对象 <em>member</em> 去调用该方法时并不能找到该方法。</p>
</blockquote>
<h3 id="255-下面代码的输出是什么？（-A-）"><a href="#255-下面代码的输出是什么？（-A-）" class="headerlink" title="255. 下面代码的输出是什么？（ A ）"></a>255. 下面代码的输出是什么？（ <em>A</em> ）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">firstName, lastName</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.firstName = firstName;</span><br><span class="line">  <span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> lydia = <span class="keyword">new</span> Person(<span class="string">&quot;Lydia&quot;</span>, <span class="string">&quot;Hallie&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> sarah = Person(<span class="string">&quot;Sarah&quot;</span>, <span class="string">&quot;Smith&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(lydia);</span><br><span class="line"><span class="built_in">console</span>.log(sarah);</span><br></pre></td></tr></table></figure>

<ul>
<li>A: <em>Person { firstName: “Lydia”, lastName: “Hallie” }</em> 和 <em>undefined</em></li>
<li>B: <em>Person { firstName: “Lydia”, lastName: “Hallie” }</em> 和 <em>Person { firstName: “Sarah”, lastName: “Smith” }</em></li>
<li>C: <em>Person { firstName: “Lydia”, lastName: “Hallie” }</em> 和 <em>{}</em></li>
<li>D: <em>Person { firstName: “Lydia”, lastName: “Hallie” }</em> 和 <em>ReferenceError</em></li>
</ul>
<blockquote>
<p><strong>分析：</strong></p>
<p><em>lydia</em> 是调用构造函数后得到的实例对象，拥有 <em>firstName</em> 和 <em>lastName</em> 属性；</p>
<p><em>sarah</em> 是调用普通函数后得到的返回值，而 <em>Person</em> 作为普通函数没有返回值；</p>
</blockquote>
<h3 id="256-事件传播的三个阶段是什么？（-D-）"><a href="#256-事件传播的三个阶段是什么？（-D-）" class="headerlink" title="256. 事件传播的三个阶段是什么？（ D ）"></a>256. 事件传播的三个阶段是什么？（ <em>D</em> ）</h3><ul>
<li>A: 目标 &gt; 捕获 &gt; 冒泡</li>
<li>B: 冒泡 &gt; 目标 &gt; 捕获</li>
<li>C: 目标 &gt; 冒泡 &gt; 捕获</li>
<li>D: 捕获 &gt; 目标 &gt; 冒泡</li>
</ul>
<h3 id="257-下面代码的输出是什么？（-C-）"><a href="#257-下面代码的输出是什么？（-C-）" class="headerlink" title="257. 下面代码的输出是什么？（ C ）"></a>257. 下面代码的输出是什么？（ <em>C</em> ）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">1</span>, <span class="string">&quot;2&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>A: <em>NaN</em></li>
<li>B: <em>TypeError</em></li>
<li>C: <em>“12”</em></li>
<li>D: <em>3</em></li>
</ul>
<blockquote>
<p><strong>分析：</strong></p>
<p>任意数据类型在跟 <em>String</em> 做 + 运算时，都会隐式转换为 <em>String</em> 类型。</p>
<p>即 <em>a</em> 所对应的 <em>Number</em> 值 <em>1</em>，被隐式转换为了 <em>String</em> 值 “1”，最终字符串拼接的到 “12”。  </p>
</blockquote>
<h3 id="258-下面代码的输出是什么？（-C-）"><a href="#258-下面代码的输出是什么？（-C-）" class="headerlink" title="258. 下面代码的输出是什么？（ C ）"></a>258. 下面代码的输出是什么？（ <em>C</em> ）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> number = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(number++);</span><br><span class="line"><span class="built_in">console</span>.log(++number);</span><br><span class="line"><span class="built_in">console</span>.log(number);</span><br></pre></td></tr></table></figure>

<ul>
<li>A: <em>1  1  2</em></li>
<li>B: <em>1  2  2</em></li>
<li>C: <em>0  2  2</em></li>
<li>D: <em>0  1  2</em></li>
</ul>
<blockquote>
<p><strong>分析：</strong></p>
<p>++ 后置时，先输出，后加 <em>1</em>；++ 前置时，先加 <em>1</em>，后输出；</p>
<p>第一次输出的值为 0，输出完成后 <em>number</em> 加 <em>1</em> 变为 <em>1</em>。</p>
<p>第二次输出，<em>number</em> 先加 <em>1</em> 变为 <em>2</em>，然后输出值 <em>2</em>。</p>
<p>第三次输出，<em>number</em> 值没有变化，还是 <em>2</em>。</p>
</blockquote>
<h3 id="259-下面代码的输出是什么？（-B-）"><a href="#259-下面代码的输出是什么？（-B-）" class="headerlink" title="259. 下面代码的输出是什么？（ B ）"></a>259. 下面代码的输出是什么？（ <em>B</em> ）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPersonInfo</span>(<span class="params">one, two, three</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(one);</span><br><span class="line">  <span class="built_in">console</span>.log(two);</span><br><span class="line">  <span class="built_in">console</span>.log(three);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="string">&quot;Lydia&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line">getPersonInfo<span class="string">`<span class="subst">$&#123;person&#125;</span> is <span class="subst">$&#123;age&#125;</span> years old`</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>A: <em>Lydia</em>   <em>21</em>   <em>[“”, “is”, “years old”]</em></li>
<li>B:  <em>[“”, “is”, “years old”]</em>  <em>Lydia</em>   <em>21</em></li>
<li>C:  <em>Lydia</em>  <em>[“”, “is”, “years old”]</em>    <em>21</em></li>
</ul>
<blockquote>
<p><strong>分析：</strong></p>
<p>如果使用标记的模板字符串，则第一个参数的值始终是字符串值的数组。 其余参数获取传递到模板字符串中的表达式的值！</p>
</blockquote>
<h3 id="260-下面代码的输出是什么？（-C-）"><a href="#260-下面代码的输出是什么？（-C-）" class="headerlink" title="260. 下面代码的输出是什么？（ C ）"></a>260. 下面代码的输出是什么？（ <em>C</em> ）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkAge</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (data === &#123; <span class="attr">age</span>: <span class="number">18</span> &#125;) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;You are an adult!&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data == &#123; <span class="attr">age</span>: <span class="number">18</span> &#125;) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;You are still an adult.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hmm.. You don&#x27;t have an age I guess`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">checkAge(&#123; <span class="attr">age</span>: <span class="number">18</span> &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>A: <em>You are an adult!</em></li>
<li>B: <em>You are still an adult.</em></li>
<li>C: <em>Hmm.. You don’t have an age I guess</em></li>
</ul>
<blockquote>
<p><strong>分析：</strong></p>
<p>在比较相等性时，原始类型通过它们的值进行比较，而对象通过它们的引用进行比较。</p>
<p><em>data</em> 和条件中的 <em>{ age: 18 }</em> 两个不同引用的对象，因此永远都不相等。</p>
</blockquote>
<h3 id="261-下面代码的输出是什么？（-C-）"><a href="#261-下面代码的输出是什么？（-C-）" class="headerlink" title="261. 下面代码的输出是什么？（ C ）"></a>261. 下面代码的输出是什么？（ <em>C</em> ）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getAge(<span class="number">21</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>A: <em>“number”</em></li>
<li>B: <em>“array”</em></li>
<li>C: <em>“object”</em></li>
<li>D: <em>“NaN”</em></li>
</ul>
<blockquote>
<p><strong>分析：</strong></p>
<p><em>ES6</em> 中的不定参数（…<em>args</em>）返回的是一个数组。</p>
<p><em>typeof</em> 检查数组的类型返回的值是 <em>object</em>。</p>
</blockquote>
<h3 id="262-下面代码的输出是什么？（-C-）"><a href="#262-下面代码的输出是什么？（-C-）" class="headerlink" title="262. 下面代码的输出是什么？（ C ）"></a>262. 下面代码的输出是什么？（ <em>C</em> ）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &quot;use strict&quot;</span>;</span><br><span class="line">  age = <span class="number">21</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getAge();</span><br></pre></td></tr></table></figure>

<ul>
<li>A: <em>21</em></li>
<li>B: <em>undefined</em></li>
<li>C: <em>ReferenceError</em></li>
<li>D: <em>TypeError</em></li>
</ul>
<blockquote>
<p><strong>分析：</strong></p>
<p><em>“use strict”</em> 严格模式中，使用未声明的变量会引发报错。</p>
</blockquote>
<h3 id="263-下面代码的输出是什么？（-A-）"><a href="#263-下面代码的输出是什么？（-A-）" class="headerlink" title="263. 下面代码的输出是什么？（ A ）"></a>263. 下面代码的输出是什么？（ <em>A</em> ）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="built_in">eval</span>(<span class="string">&quot;10*10+5&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>A: <em>105</em></li>
<li>B: <em>“105”</em></li>
<li>C: <em>TypeError</em></li>
<li>D: <em>“10*10+5”</em></li>
</ul>
<blockquote>
<p><strong>分析：</strong></p>
<p><em>eval</em> 方法会将字符串当作 <em>JavaScript</em> 代码进行解析。</p>
</blockquote>
<h3 id="264-cool-secret-可以访问多长时间？（-B-）"><a href="#264-cool-secret-可以访问多长时间？（-B-）" class="headerlink" title="264. cool_secret 可以访问多长时间？（ B ）"></a>264. <em>cool_secret</em> 可以访问多长时间？（ <em>B</em> ）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sessionStorage.setItem(<span class="string">&quot;cool_secret&quot;</span>, <span class="number">123</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>A：永远，数据不会丢失。</li>
<li>B：用户关闭选项卡时。</li>
<li>C：当用户关闭整个浏览器时，不仅是选项卡。</li>
<li>D：用户关闭计算机时。</li>
</ul>
<blockquote>
<p><strong>分析：</strong></p>
<p><em>sessionStorage</em> 是会话级别的本地存储，当窗口关闭，则会话结束，数据删除。</p>
</blockquote>
<h3 id="265-下面代码的输出是什么？（-B-）"><a href="#265-下面代码的输出是什么？（-B-）" class="headerlink" title="265. 下面代码的输出是什么？（ B ）"></a>265. 下面代码的输出是什么？（ <em>B</em> ）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num);</span><br></pre></td></tr></table></figure>

<ul>
<li>A: <em>8</em></li>
<li>B: <em>10</em></li>
<li>C: <em>SyntaxError</em></li>
<li>D: <em>ReferenceError</em></li>
</ul>
<blockquote>
<p><strong>分析：</strong></p>
<p><em>var</em> 声明的变量允许重复声明，但后面的值会覆盖前面的值。</p>
</blockquote>
<h3 id="266-下面代码的输出是什么？（-C-）"><a href="#266-下面代码的输出是什么？（-C-）" class="headerlink" title="266. 下面代码的输出是什么？（ C ）"></a>266. 下面代码的输出是什么？（ <em>C</em> ）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="number">1</span>: <span class="string">&quot;a&quot;</span>, <span class="number">2</span>: <span class="string">&quot;b&quot;</span>, <span class="number">3</span>: <span class="string">&quot;c&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">obj.hasOwnProperty(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">obj.hasOwnProperty(<span class="number">1</span>);</span><br><span class="line">set.has(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">set.has(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>A: <em>false</em>  <em>true</em>  <em>false</em>  <em>true</em></li>
<li>B: <em>false</em>  <em>true</em>  <em>true</em>  <em>true</em></li>
<li>C: <em>true</em>  <em>true</em>  <em>false</em>  <em>true</em></li>
<li>D: <em>true</em>  <em>true</em>  <em>true</em>  <em>true</em></li>
</ul>
<h3 id="267-下面代码的输出是什么？（-C-）"><a href="#267-下面代码的输出是什么？（-C-）" class="headerlink" title="267. 下面代码的输出是什么？（ C ）"></a>267. 下面代码的输出是什么？（ <em>C</em> ）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="string">&quot;one&quot;</span>, <span class="attr">b</span>: <span class="string">&quot;two&quot;</span>, <span class="attr">a</span>: <span class="string">&quot;three&quot;</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br></pre></td></tr></table></figure>

<ul>
<li>A: <em>{ a: “one”, b: “two” }</em></li>
<li>B: <em>{ b: “two”, a: “three” }</em></li>
<li>C: <em>{ a: “three”, b: “two” }</em></li>
<li>D: <em>SyntaxError</em></li>
</ul>
<blockquote>
<p><strong>分析：</strong></p>
<p>如果对象有两个具有相同名称的键，则后面的将替前面的键。它仍将处于第一个位置，但具有最后指定的值。</p>
</blockquote>
<h3 id="268-下面代码的输出是什么？（-C-）"><a href="#268-下面代码的输出是什么？（-C-）" class="headerlink" title="268. 下面代码的输出是什么？（ C ）"></a>268. 下面代码的输出是什么？（ <em>C</em> ）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i === <span class="number">3</span>) <span class="keyword">continue</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>A: <em>1  2</em></li>
<li>B: <em>1  2  3</em></li>
<li>C: <em>1  2  4</em></li>
<li>D: <em>1  3  4</em></li>
</ul>
<blockquote>
<p><strong>分析：</strong></p>
<p>当 <em>i</em> 的值为 <em>3</em> 时，进入 <em>if</em> 语句执行 <em>continue</em>，结束本次循环，立即进行下一次循环。</p>
</blockquote>
<h3 id="269-下面代码的输出是什么？（-A-）"><a href="#269-下面代码的输出是什么？（-A-）" class="headerlink" title="269. 下面代码的输出是什么？（ A ）"></a>269. 下面代码的输出是什么？（ <em>A</em> ）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.giveLydiaPizza = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Just give Lydia pizza already!&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;Lydia&quot;</span>;</span><br><span class="line"></span><br><span class="line">name.giveLydiaPizza();</span><br></pre></td></tr></table></figure>

<ul>
<li>A: <em>“Just give Lydia pizza already!”</em></li>
<li>B: <em>TypeError: not a function</em></li>
<li>C: <em>SyntaxError</em></li>
<li>D: <em>undefined</em></li>
</ul>
<blockquote>
<p><strong>分析：</strong></p>
<p><em>String</em> 是一个内置的构造函数，我们可以为它添加属性。 我们给它的原型添加了一个方法。 原始类型的字符串自动转换为字符串对象，由字符串原型函数生成。 因此，所有字符串（字符串对象）都可以访问该方法！</p>
<p>当使用基本类型的字符串调用 <em>giveLydiaPizza</em> 时，实际上发生了下面的过程：</p>
<ul>
<li>创建一个 <em>String</em> 的包装类型实例</li>
<li>在实例上调用 <em>substring</em> 方法</li>
<li>销毁实例</li>
</ul>
</blockquote>
<h3 id="270-下面代码的输出是什么？（-B-）"><a href="#270-下面代码的输出是什么？（-B-）" class="headerlink" title="270. 下面代码的输出是什么？（ B ）"></a>270. 下面代码的输出是什么？（ <em>B</em> ）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> b = &#123; <span class="attr">key</span>: <span class="string">&quot;b&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> c = &#123; <span class="attr">key</span>: <span class="string">&quot;c&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">a[b] = <span class="number">123</span>;</span><br><span class="line">a[c] = <span class="number">456</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a[b]);</span><br></pre></td></tr></table></figure>

<ul>
<li>A: <em>123</em></li>
<li>B: <em>456</em></li>
<li>C: <em>undefined</em></li>
<li>D: <em>ReferenceError</em></li>
</ul>
<blockquote>
<p><strong>分析：</strong></p>
<p>当 <em>b</em> 和 <em>c</em> 作为一个对象的键时，会自动转换为字符串，而对象自动转换为字符串化时，结果都为 *[Object object]*。因此 <em>a[b]</em> 和 <em>a[c]</em> 其实都是同一个属性 *a[“Object object”]*。</p>
<p>对象同名的属性后面的值会覆盖前面的，因此最终 <em>a[“Object object”]</em> 的值为 <em>456</em>。</p>
</blockquote>
<h3 id="271-下面代码的输出是什么？（-B-）"><a href="#271-下面代码的输出是什么？（-B-）" class="headerlink" title="271. 下面代码的输出是什么？（ B ）"></a>271. 下面代码的输出是什么？（ <em>B</em> ）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;First&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> bar = <span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;Second&quot;</span>));</span><br><span class="line"><span class="keyword">const</span> baz = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;Third&quot;</span>);</span><br><span class="line"></span><br><span class="line">bar();</span><br><span class="line">foo();</span><br><span class="line">baz();</span><br></pre></td></tr></table></figure>

<ul>
<li>A: <em>First</em>  <em>Second</em>  <em>Third</em></li>
<li>B: <em>First</em>  <em>Third</em>  <em>Second</em></li>
<li>C: <em>Second</em>  <em>First</em>  <em>Third</em></li>
<li>D: <em>Second</em>  <em>Third</em>  <em>First</em></li>
</ul>
<blockquote>
<p><strong>分析：</strong></p>
<p><em>bar</em> 函数中执行的是一段异步代码，按照 <em>JavaScript</em> 中的事件循环机制，主线程中的所有同步代码执行完成后才会执行异步代码。因此 <em>“Second”</em> 最后输出。</p>
</blockquote>
<h3 id="272-单击按钮时-event-target-是什么？（-C-）"><a href="#272-单击按钮时-event-target-是什么？（-C-）" class="headerlink" title="272. 单击按钮时 event.target 是什么？（ C ）"></a>272. 单击按钮时 <em>event.target</em> 是什么？（ <em>C</em> ）</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(&#x27;first div&#x27;)&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(&#x27;second div&#x27;)&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(&#x27;button&#x27;)&quot;</span>&gt;</span></span><br><span class="line">      Click!</span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>A: <em>div</em> 外部</li>
<li>B: <em>div</em> 内部</li>
<li>C: <em>button</em></li>
<li>D: 所有嵌套元素的数组</li>
</ul>
<blockquote>
<p><strong>分析：</strong></p>
<p><em>event.target</em> 指向的是事件目标，即触发事件的元素。因此点击 <em>&lt;button&gt;</em> 触发事件的也就是  *&lt;button&gt;*。</p>
</blockquote>
<h3 id="273-单击下面的-html-片段打印的内容是什么？（-A-）"><a href="#273-单击下面的-html-片段打印的内容是什么？（-A-）" class="headerlink" title="273. 单击下面的 html 片段打印的内容是什么？（ A ）"></a>273. 单击下面的 <em>html</em> 片段打印的内容是什么？（ <em>A</em> ）</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(&#x27;div&#x27;)&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(&#x27;p&#x27;)&quot;</span>&gt;</span></span><br><span class="line">    Click here!</span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>A: <em>p</em>  <em>div</em></li>
<li>B: <em>div</em>  <em>p</em></li>
<li>C: <em>p</em></li>
<li>D: <em>div</em></li>
</ul>
<blockquote>
<p><strong>分析：</strong></p>
<p><em>onclick</em> 绑定的事件为冒泡型事件。因此当点击 <em>p</em> 标签时，事件会从事件目标开始依次往外触发。</p>
</blockquote>
<h3 id="274-下面代码的输出是什么？（-D-）"><a href="#274-下面代码的输出是什么？（-D-）" class="headerlink" title="274. 下面代码的输出是什么？（ D ）"></a>274. 下面代码的输出是什么？（ <em>D</em> ）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> is <span class="subst">$&#123;age&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayHi.call(person, <span class="number">21</span>);</span><br><span class="line">sayHi.bind(person, <span class="number">21</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>A: <em>undefined is 21</em>   <em>Lydia is 21</em></li>
<li>B: <em>function</em>   <em>function</em></li>
<li>C: <em>Lydia is 21</em>   <em>Lydia is 21</em></li>
<li>D: <em>Lydia is 21</em>   <em>function</em></li>
</ul>
<blockquote>
<p><strong>分析：</strong></p>
<p><em>call</em> 和 <em>bind</em> 都可以修改 <em>this</em> 的指向，但区别在于 <em>call</em> 方法会立即执行，而 <em>bind</em> 会返回一个修改后的新函数。</p>
</blockquote>
<h3 id="275-下面代码的输出是什么？（-B-）"><a href="#275-下面代码的输出是什么？（-B-）" class="headerlink" title="275. 下面代码的输出是什么？（ B ）"></a>275. 下面代码的输出是什么？（ <em>B</em> ）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="function">() =&gt;</span> <span class="number">0</span>)();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> sayHi();</span><br></pre></td></tr></table></figure>

<ul>
<li>A: <em>“object”</em></li>
<li>B: <em>“number”</em></li>
<li>C: <em>“function”</em></li>
<li>D: <em>“undefined”</em></li>
</ul>
<blockquote>
<p><strong>分析：</strong></p>
<p><em>return</em> 后是一个 <em>IIFE</em>，其返回值是 <em>0</em>，因此 <em>sayHi</em> 函数中返回的是一个 <em>0</em>。<em>typeof</em> 检测 <em>sayHi</em> 返回值类型即为 <em>number</em>。</p>
</blockquote>
<h3 id="276-下面这些值哪些是假值？（-A-）"><a href="#276-下面这些值哪些是假值？（-A-）" class="headerlink" title="276. 下面这些值哪些是假值？（ A ）"></a>276. 下面这些值哪些是假值？（ <em>A</em> ）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>;</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">0</span>);</span><br><span class="line">(<span class="string">&quot;&quot;</span>);</span><br><span class="line">(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>A: <em>0</em>   <em>“”</em>    <em>undefined</em></li>
<li>B: <em>0</em>   <em>new Number(0)</em>   <em>“”</em>   <em>new Boolean(false)</em>   <em>undefined</em></li>
<li>C: <em>0</em>   <em>“”</em>   <em>new Boolean(false)</em>   <em>undefined</em></li>
<li>D: 所有都是假值。</li>
</ul>
<blockquote>
<p><strong>分析：</strong></p>
<p><em>JavaScript</em> 中假值只有 <em>6</em> 个：<em>false</em>、*””<em>、</em>null<em>、</em>undefined<em>、</em>NaN<em>、</em>0*</p>
</blockquote>
<h3 id="278-下面代码的输出是什么？（-B-）"><a href="#278-下面代码的输出是什么？（-B-）" class="headerlink" title="278. 下面代码的输出是什么？（ B ）"></a>278. 下面代码的输出是什么？（ <em>B</em> ）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="keyword">typeof</span> <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>A: <em>“number”</em></li>
<li>B: <em>“string”</em></li>
<li>C: <em>“object”</em></li>
<li>D: <em>“undefined”</em></li>
</ul>
<blockquote>
<p>分析：</p>
<p><em>typeof 1</em> 返回 <em>“number”<em>，</em>typeof “number”</em> 返回 <em>“string”</em></p>
</blockquote>
<h3 id="279-下面代码的输出是什么？（-C-）"><a href="#279-下面代码的输出是什么？（-C-）" class="headerlink" title="279. 下面代码的输出是什么？（ C ）"></a>279. 下面代码的输出是什么？（ <em>C</em> ）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">numbers[<span class="number">10</span>] = <span class="number">11</span>;</span><br><span class="line"><span class="built_in">console</span>.log(numbers);</span><br></pre></td></tr></table></figure>

<ul>
<li>A: <em>[1, 2, 3, 7 x null, 11]</em></li>
<li>B: <em>[1, 2, 3, 11]</em></li>
<li>C: <em>[1, 2, 3, 7 x empty, 11]</em></li>
<li>D: <em>SyntaxError</em></li>
</ul>
<blockquote>
<p><strong>分析：</strong></p>
<p>当你为数组中的元素设置一个超过数组长度的值时，<em>JavaScript</em> 会创建一个名为“空插槽”的东西。 这些位置的值实际上是 <em>undefined</em>，但你会看到类似的东西：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1, 2, 3, 7 x empty, 11]</span><br></pre></td></tr></table></figure>

<p>这取决于你运行它的位置（每个浏览器有可能不同）。</p>
</blockquote>
<h3 id="280-下面代码的输出是什么？（-A-）"><a href="#280-下面代码的输出是什么？（-A-）" class="headerlink" title="280. 下面代码的输出是什么？（ A ）"></a>280. 下面代码的输出是什么？（ <em>A</em> ）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> x, y;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (x) &#123;</span><br><span class="line">    (x = <span class="number">1</span>), (y = <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">  <span class="built_in">console</span>.log(y);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>A: <em>1</em>   <em>undefined</em>   <em>2</em></li>
<li>B: <em>undefined</em>   <em>undefined</em>   <em>undefined</em></li>
<li>C: <em>1</em>   <em>1</em>   <em>2</em>  </li>
<li>D: <em>1</em>   <em>undefined</em>   <em>undefined</em></li>
</ul>
<blockquote>
<p><strong>分析：</strong></p>
<p><em>catch</em> 块接收参数 <em>x</em>。当我们传递参数时，这与变量的 <em>x</em> 不同。这个变量 <em>x</em> 是属于 <em>catch</em> 作用域的。</p>
<p>之后，我们将这个块级作用域的变量设置为 <em>1</em>，并设置变量 <em>y</em> 的值。 现在，我们打印块级作用域的变量 <em>x</em>，它等于 <em>1</em>。</p>
<p>在<em>catch</em> 块之外，<em>x</em> 仍然是 <em>undefined</em>，而 <em>y</em> 是 <em>2</em>。 当我们想在 <em>catch</em> 块之外的 <em>console.log(x)</em> 时，它返回<em>undefined</em>，而 <em>y</em> 返回 <em>2</em>。</p>
</blockquote>
<h3 id="281-JavaScript-中的所有内容都是…（-A-）"><a href="#281-JavaScript-中的所有内容都是…（-A-）" class="headerlink" title="281. JavaScript 中的所有内容都是…（ A ）"></a>281. <em>JavaScript</em> 中的所有内容都是…（ <em>A</em> ）</h3><ul>
<li>A：原始或对象</li>
<li>B：函数或对象</li>
<li>C：技巧问题！只有对象</li>
<li>D：数字或对象</li>
</ul>
<blockquote>
<p>分析：</p>
<p><em>JavaScript</em> 只有原始类型和对象。</p>
</blockquote>
<h3 id="282-下面代码的输出是什么"><a href="#282-下面代码的输出是什么" class="headerlink" title="282. 下面代码的输出是什么?"></a>282. 下面代码的输出是什么?</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>]].reduce(</span><br><span class="line">  <span class="function">(<span class="params">acc, cur</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> acc.concat(cur);</span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>A: <em>[0, 1, 2, 3, 1, 2]</em></li>
<li>B: <em>[6, 1, 2]</em></li>
<li>C: <em>[1, 2, 0, 1, 2, 3]</em></li>
<li>D: <em>[1, 2, 6]</em></li>
</ul>
<blockquote>
<p><strong>分析：</strong></p>
<p><em>[1,2]</em> 是我们的初始值。 这是我们开始执行 <em>reduce</em> 函数的初始值，以及第一个 <em>acc</em> 的值。 在第一轮中，<em>acc</em> 是 <em>[1,2]<em>，</em>cur</em> 是 *[0,1]*。 我们将它们连接起来，结果是 *[1,2,0,1]*。</p>
<p>然后，<em>acc</em> 的值为 <em>[1,2,0,1]<em>，</em>cur</em> 的值为 *[2,3]*。 我们将它们连接起来，得到 *[1,2,0,1,2,3]*。</p>
</blockquote>
<h3 id="283-下面代码的输出是什么？（-B-）"><a href="#283-下面代码的输出是什么？（-B-）" class="headerlink" title="283. 下面代码的输出是什么？（ B ）"></a>283. 下面代码的输出是什么？（ <em>B</em> ）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">!!<span class="literal">null</span>;</span><br><span class="line">!!<span class="string">&quot;&quot;</span>;</span><br><span class="line">!!<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>A: <em>false</em>   <em>true</em>   <em>false</em></li>
<li>B: <em>false</em>   <em>false</em>   <em>true</em></li>
<li>C: <em>false</em>   <em>true</em>   <em>true</em></li>
<li>D: <em>true</em>   <em>true</em>   <em>false</em></li>
</ul>
<blockquote>
<p><strong>分析：</strong></p>
<p><em>null</em> 是假值。 <em>!null</em> 返回 <em>true</em>。 <em>!true</em> 返回 <em>false</em>。</p>
<p><em>“”</em> 是假值。 <em>!””</em> 返回 <em>true</em>。 <em>!true</em> 返回 <em>false</em>。</p>
<p><em>1</em> 是真值。 <em>!1</em> 返回 <em>false</em>。 <em>!false</em> 返回 <em>true</em>。</p>
</blockquote>
<h3 id="284-setInterval-方法的返回值什么？（-A-）"><a href="#284-setInterval-方法的返回值什么？（-A-）" class="headerlink" title="284. setInterval 方法的返回值什么？（ A ）"></a>284. <em>setInterval</em> 方法的返回值什么？（ <em>A</em> ）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;Hi&quot;</span>), <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>A：一个唯一的 <em>id</em></li>
<li>B：指定的毫秒数</li>
<li>C：传递的函数</li>
<li>D：<em>undefined</em></li>
</ul>
<blockquote>
<p><strong>分析：</strong></p>
<p>它返回一个唯一的 <em>id</em>。 此 <em>id</em> 可用于使用 <em>clearInterval()</em> 函数清除该定时器。</p>
</blockquote>
<h3 id="285-下面代码的返回值是什么？（-A-）"><a href="#285-下面代码的返回值是什么？（-A-）" class="headerlink" title="285. 下面代码的返回值是什么？（ A ）"></a>285. 下面代码的返回值是什么？（ <em>A</em> ）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[...<span class="string">&quot;Lydia&quot;</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li>A: <em>[“L”, “y”, “d”, “i”, “a”]</em></li>
<li>B: <em>[“Lydia”]</em></li>
<li>C: <em>[[], “Lydia”]</em></li>
<li>D: <em>[[“L”, “y”, “d”, “i”, “a”]]</em></li>
</ul>
<blockquote>
<p><strong>分析：</strong></p>
<p>字符串是可迭代的。 扩展运算符将迭代的每个字符映射到一个元素。</p>
</blockquote>
<h3 id="286-document-write-和-innerHTML-有哪些区别？"><a href="#286-document-write-和-innerHTML-有哪些区别？" class="headerlink" title="286. document.write 和 innerHTML 有哪些区别？"></a>286. <em>document.write</em> 和 <em>innerHTML</em> 有哪些区别？</h3><blockquote>
<p>参考答案：</p>
<p><em>document.write</em> 和 <em>innerHTML</em> 都能将 <em>HTML</em> 字符串解析为 <em>DOM</em> 树，再将 <em>DOM</em> 树插入到某个位置，但两种在执行细节上还是有许多不同。</p>
<p>1）<em>write()</em> 方法存在于 <em>Document</em> 对象中，<em>innerHTML</em> 属性存在于 <em>Element</em> 对象中；</p>
<p>2）<em>document.write</em> 会将解析后的 <em>DOM</em> 树插入到文档中调用它的脚本元素的位置，而 <em>innerHTML</em> 会将 <em>DOM</em> 树插入到指定的元素内；</p>
<p>3）<em>document.write</em> 会将多次调用的字符串参数自动连接起来，<em>innerHTML</em> 要用赋值运算符 <em>“+=”</em> 拼接；</p>
<p>4）只有当文档还在解析时，才能使用 <em>document.write</em>，否则 <em>document.write</em> 的值会将当前文档覆盖掉，而 <em>innerHTML</em> 属性则没有这个限制；</p>
</blockquote>
<blockquote>
<p>注：也可以参阅前面第 <em>157</em> 题答案</p>
</blockquote>
<h3 id="287-假设有两个变量-a-和-b，他们的值都是数字，如何在不借用第三个变量的情况下，将两个变量的值对调？"><a href="#287-假设有两个变量-a-和-b，他们的值都是数字，如何在不借用第三个变量的情况下，将两个变量的值对调？" class="headerlink" title="287. 假设有两个变量 a 和 b，他们的值都是数字，如何在不借用第三个变量的情况下，将两个变量的值对调？"></a>287. 假设有两个变量 <em>a</em> 和 <em>b</em>，他们的值都是数字，如何在不借用第三个变量的情况下，将两个变量的值对调？</h3><blockquote>
<p>参考答案：</p>
<p>方法一：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a = a + b;</span><br><span class="line">b = a - b;</span><br><span class="line">a = a - b; </span><br></pre></td></tr></table></figure>

<p>方法二（<em>ES6</em> 中的解构）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[a, b] = [b, a]</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="288-前端为什么提倡模块化开发？"><a href="#288-前端为什么提倡模块化开发？" class="headerlink" title="288. 前端为什么提倡模块化开发？"></a>288. 前端为什么提倡模块化开发？</h3><blockquote>
<p>参考答案：</p>
<p>模块化能将一个复杂的大型系统分解成一个个高内聚、低耦合的简单模块，并且每个模块都是独立的，用于完成特定的功能。模块化后的系统变得更加可控、可维护、可扩展，程序代码也更简单直观，可读性也很高，有利于团队协作开发。<em>ES6</em> 模块化的出现，使得前端能更容易、更快速的实现模块化开发。</p>
</blockquote>
<h3 id="289-请解释-JSONP-的原理，并用代码描述其过程。"><a href="#289-请解释-JSONP-的原理，并用代码描述其过程。" class="headerlink" title="289. 请解释 JSONP 的原理，并用代码描述其过程。"></a>289. 请解释 <em>JSONP</em> 的原理，并用代码描述其过程。</h3><blockquote>
<p>参考答案：</p>
<p><em>JSONP（JSON with padding）</em>是一种借助 <em>&lt;script&gt;</em> 元素实现跨域的技术，它不会使用 <em>XHR</em> 对象。之所以能实现跨域，主要是因为 <em>&lt;script&gt;</em> 元素有以下两个特点：</p>
<p>1）它的 <em>src</em> 属性能够访问任何 <em>URL</em> 资源，不会受同源策略的限制；</p>
<p>2）如果访问的资源包含 <em>JavaScript</em> 代码，那么在下载下来后会自动执行；</p>
<p><em>JSONP</em> 就是基于这两点，再与服务器配合来实现跨域请求的，它的执行步骤可分为以下 <em>6</em> 步：</p>
<p>1）定义一个回调函数；</p>
<p>2）用 <em>DOM</em> 方法动态创建一个 <em>&lt;script&gt;</em> 元素；</p>
<p>3）通过 <em>&lt;script&gt;</em> 元素的 <em>src</em> 属性指定要请求的 <em>URL</em>，并且将回调函数的名称作为一个参数传递过去；</p>
<p>4）将 <em>&lt;script&gt;</em> 元素插入到当前文档中，开始请求；</p>
<p>5）服务器接收到传递过来的参数，然后将回调函数和数据以调用的形式输出；</p>
<p>6）当 <em>&lt;script&gt;</em> 元素接收到响应中的脚本代码后，就会自动的执行它们；</p>
</blockquote>
<h3 id="290-列举几种-JavaScript-中数据类型的强制转换和隐式转换。"><a href="#290-列举几种-JavaScript-中数据类型的强制转换和隐式转换。" class="headerlink" title="290. 列举几种 JavaScript 中数据类型的强制转换和隐式转换。"></a>290. 列举几种 <em>JavaScript</em> 中数据类型的强制转换和隐式转换。</h3><blockquote>
<p>参考答案：</p>
<p>强制转换：</p>
<ul>
<li>转换为 <em>number</em>：<em>parseInt()<em>、</em>parseFloat()<em>、</em>Number()</em></li>
<li>转换为 <em>string</em>：<em>String()<em>、</em>toString()</em></li>
<li>转换为 <em>boolean</em>：<em>Boolean()</em></li>
</ul>
<p>隐式转换：</p>
<ul>
<li>隐式转换为 <em>number</em>：算术运算/比较运算，例如加、减、乘、除、相等（==）、大于、小于等；</li>
<li>隐式转换为 <em>string</em>：与字符串拼接，例如 + “”；</li>
<li>隐式转换为 <em>boolean</em>：逻辑运算，例如或（||）、与（&amp;&amp;）、非（!）；</li>
</ul>
</blockquote>
<h3 id="291-分析以下代码的执行结果并解释为什么。"><a href="#291-分析以下代码的执行结果并解释为什么。" class="headerlink" title="291. 分析以下代码的执行结果并解释为什么。"></a>291. 分析以下代码的执行结果并解释为什么。</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">n</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">a.x = a = &#123;<span class="attr">n</span>: <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.x) 	</span><br><span class="line"><span class="built_in">console</span>.log(b.x)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考答案：</p>
<p>运行结果：</p>
<p><em>undefined</em>、*{n: 2}*</p>
<p>分析：</p>
<p>首先，<em>a</em> 和 <em>b</em> 同时引用了 <em>{n: 1}</em> 对象，接着执行到 <em>a.x = a = {n: 2}</em> 语句，虽然赋值是从右到左执行，但是点（.）的优先级比赋值符（=）要高，所以这里首先执行 <em>a.x</em>，相当于为 <em>a</em>（或者 <em>b</em>）所指向的 <em>{n:1}</em> 对象新增了一个属性 <em>x</em>，即此时对象将变为 *{n: 1; x: undefined}*。然后按正常情况，从右到左进行赋值，此时执行 <em>a = {n: 2}</em> 的时候，a的引用改变，指向了新对象 *{n: 2}*，而 <em>b</em> 依然指向的是旧对象 *{n: 1; x: undefined}*。之后再执行 <em>a.x = {n: 2}</em> 的时候，并不会重新解析一遍 <em>a</em>，而是沿用最初解析 <em>a.x</em> 时候的 <em>a</em>，即旧对象 *{n: 1; x: undefined}<em>，故此时旧对象的 <em>x</em> 的值变为</em>{n: 2}*，旧对象为 *{n: 1; x: {n: 2}}*，它依然被 <em>b</em> 引用着。 </p>
<p>最后，<em>a</em> 指向的对象为  <em>{n: 2}<em>，</em>b</em> 指向的对象为 *{n: 1; x: {n: 2}}*。因此输出 <em>a.x</em> 值为 <em>undefined</em>，输出 <em>b.x</em> 值为 *{n: 2}*。</p>
</blockquote>
<h3 id="292-分析以下代码的执行结果并解释为什么。"><a href="#292-分析以下代码的执行结果并解释为什么。" class="headerlink" title="292. 分析以下代码的执行结果并解释为什么。"></a>292. 分析以下代码的执行结果并解释为什么。</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example 1</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;, b = <span class="string">&#x27;123&#x27;</span>, c = <span class="number">123</span>;  </span><br><span class="line">a[b] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">a[c] = <span class="string">&#x27;c&#x27;</span>;  </span><br><span class="line"><span class="built_in">console</span>.log(a[b]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// example 2</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;, b = <span class="built_in">Symbol</span>(<span class="string">&#x27;123&#x27;</span>), c = <span class="built_in">Symbol</span>(<span class="string">&#x27;123&#x27;</span>);  </span><br><span class="line">a[b] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">a[c] = <span class="string">&#x27;c&#x27;</span>;  </span><br><span class="line"><span class="built_in">console</span>.log(a[b]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// example 3</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;, b = &#123;<span class="attr">key</span>:<span class="string">&#x27;123&#x27;</span>&#125;, c = &#123;<span class="attr">key</span>:<span class="string">&#x27;456&#x27;</span>&#125;;  </span><br><span class="line">a[b] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">a[c] = <span class="string">&#x27;c&#x27;</span>;  </span><br><span class="line"><span class="built_in">console</span>.log(a[b]);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考答案：</p>
<p>运行结果：</p>
<p><em>example 1</em>：<em>c</em></p>
<p><em>example 2</em>：<em>b</em></p>
<p><em>example 3</em>：<em>c</em></p>
<p>分析：</p>
<p>这题考察的是对象的键名的转换。</p>
<ul>
<li>对象的键名只能是字符串和 <em>Symbol</em> 类型。</li>
<li>其他类型的键名会被转换成字符串类型。</li>
<li>对象转字符串默认会调用 <em>String</em> 方法。</li>
</ul>
<p>因此 <em>example 1</em> 中 <em>c</em> 作为键名后也是 <em>‘123’<em>，直接覆盖 <em>a[b]</em> 的值；而 <em>example 2</em> 中，</em>Symbol</em> 作为 <em>ES6</em> 中新增的基本数据类型，它的特点就是唯一，<em>Symbol()</em> 方法生成的值都是唯一的，里面的参数不会影响结果。因此在 <em>example 2</em> 中 <em>b</em> 和 <em>c</em> 是两个不同的键名；<em>example 3</em> 中，对象不能作为键名，因此 <em>b</em> 和 <em>c</em> 都会通过 <em>String()</em> 方法转为字符串 *[object Object]*。</p>
</blockquote>
<h3 id="293-下面的代码打印什么内容？为什么？"><a href="#293-下面的代码打印什么内容？为什么？" class="headerlink" title="293. 下面的代码打印什么内容？为什么？"></a>293. 下面的代码打印什么内容？为什么？</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  b = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(b)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考答案：</p>
<p>运行结果：</p>
<p><em>function b() { b = 20; console.log(b) }</em><br>分析：</p>
<p>当 <em>JavaScript</em> 解释器遇到非匿名立即执行函数（题目中的 <em>b</em>）时，会创建一个辅助的特定对象，然后将函数名称当作这个对象的属性，因此函数内部可以访问到 <em>b</em>，但是这个值又是只读的，所以对他的赋值并不生效，所以打印的结果还是这个函数，并且外部的值也没有发生更改。</p>
</blockquote>
<h3 id="294-下面代码中，a-在什么情况下会执行输出语句打印-1-？"><a href="#294-下面代码中，a-在什么情况下会执行输出语句打印-1-？" class="headerlink" title="294. 下面代码中，a 在什么情况下会执行输出语句打印 1 ？"></a>294. 下面代码中，<em>a</em> 在什么情况下会执行输出语句打印 <em>1</em> ？</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = ?;</span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>)&#123;</span><br><span class="line"> 	<span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考答案：</p>
<p>分析：</p>
<p>这道题考查的知识点是：相等运算符（==）在作比较时会进行隐式转换，而如果操作数是引用类型，则会调用 <em>toString()</em> 或 <em>valueOf()</em> 方法对引用类型数据进行隐式转换。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一：利用 toString()</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  <span class="attr">i</span>: <span class="number">1</span>,</span><br><span class="line">  toString () &#123;</span><br><span class="line">    <span class="keyword">return</span> a.i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：利用 valueOf()</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  <span class="attr">i</span>: <span class="number">1</span>,</span><br><span class="line">  valueOf () &#123;</span><br><span class="line">    <span class="keyword">return</span> a.i++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法三：利用数组（这个是真的骚）</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">a.join = a.shift;</span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法四：利用 Symbol</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;[<span class="built_in">Symbol</span>.toPrimitive]: (<span class="function">(<span class="params">i</span>) =&gt;</span> <span class="function">() =&gt;</span> ++i) (<span class="number">0</span>)&#125;;</span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法一和方法二没啥解释的了，解释下方法三和方法四。</p>
<p>方法三：</p>
<p><em>a.join = a.shift</em> 的目的是将数组的 <em>join</em> 方法替换成 <em>shift</em> 方法。因为数组在参与相等比较时也会通过 <em>toString()</em> 将数组转为字符串，而该字符串实际上是数组中每个元素的 <em>toString()</em> 返回值经调用 <em>join()</em> 方法拼接（由逗号隔开）组成。现在我们将 <em>join()</em> 方法替换为了 <em>shift()</em> 方法，也就意味着数组在通过 <em>toString()</em> 隐式转换后，得到是 <em>shift()</em> 的返回值，每次返回数组中的第一个元素，而原数组删除第一个值，正好可以使判断成立。</p>
<p>方法四：</p>
<p><em>ES6</em> 中提供了 <em>11</em> 个内置的 <em>Symbo</em> 值，指向语言内部使用的方法。<em>Symbol.toPrimitive</em> 就是其中一个，它指向一个方法，当该对象被转为原始类型的值时，会调用这个方法，并返回该对象对应的原始类型值。这里就是改变这个属性，把它的值改为一个闭包返回的函数。</p>
</blockquote>
<h3 id="295-介绍前端模块化的发展。"><a href="#295-介绍前端模块化的发展。" class="headerlink" title="295. 介绍前端模块化的发展。"></a>295. 介绍前端模块化的发展。</h3><blockquote>
<p>参考答案：</p>
<ul>
<li><p><em>IIFE</em>：使用自执行函数来编写模块化（特点：在一个单独的函数作用域中执行代码，避免变量冲突）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">data</span>:[] &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></li>
<li><p><em>AMD</em>：使用 <em>requireJS</em> 来编写模块化（特点：依赖必须提前声明好）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">define(<span class="string">&#x27;./index.js&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">code</span>)</span>&#123;</span><br><span class="line">	<span class="comment">// code 就是index.js 返回的内容</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p><em>CMD</em>：使用 <em>seaJS</em> 来编写模块化（特点：支持动态引入依赖文件）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">var</span> indexCode = <span class="built_in">require</span>(<span class="string">&#x27;./index.js&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p><em>CommonJS</em>：<em>nodejs</em> 中自带的模块化。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p><em>UMD</em>：通用模块规范，整合了 <em>AMD</em> 和 <em>CommonJS</em> 模块化。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">global</span>, factory</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">exports</span> === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">module</span> !== <span class="literal">undefined</span>) &#123; <span class="comment">//检查CommonJS是否可用</span></span><br><span class="line">    <span class="built_in">module</span>.exports = factory(<span class="built_in">require</span>(<span class="string">&#x27;jquery&#x27;</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">&#x27;function&#x27;</span> &amp;&amp; define.amd) &#123;      <span class="comment">//检查AMD是否可用</span></span><br><span class="line">    define(<span class="string">&#x27;toggler&#x27;</span>, [<span class="string">&#x27;jquery&#x27;</span>, factory])</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;       <span class="comment">//两种都不能用，把模块添加到JavaScript的全局命名空间中。</span></span><br><span class="line">    <span class="built_in">global</span>.toggler = factory(<span class="built_in">global</span>, factory);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="built_in">this</span>, <span class="function"><span class="keyword">function</span> (<span class="params">$</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">init</span>: init</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p><em>webpack(require.ensure)<em>：</em>webpack 2.x</em> 版本中的代码分割。</p>
</li>
<li><p><em>ES Modules</em>： <em>ES6</em> 引入的模块化，支持 <em>import</em> 来引入另一个 <em>js</em> 。</p>
</li>
</ul>
</blockquote>
<h3 id="296-请指出-document-onload-和-document-ready-两个事件的区别"><a href="#296-请指出-document-onload-和-document-ready-两个事件的区别" class="headerlink" title="296. 请指出 document.onload 和 document.ready 两个事件的区别"></a>296. 请指出 <em>document.onload</em> 和 document.ready 两个事件的区别</h3><blockquote>
<p>参考答案：</p>
<p>页面加载完成有两种事件：一是 <em>ready</em>，表示文档结构已经加载完成（不包含图片等非文字媒体文件）；二是 <em>onload</em>，指示页面包含图片等文件在内的所有元素都加载完成。</p>
</blockquote>
<h3 id="297-表单元素的readonly-和-disabled-两个属性有什么区别？"><a href="#297-表单元素的readonly-和-disabled-两个属性有什么区别？" class="headerlink" title="297. 表单元素的readonly 和 disabled 两个属性有什么区别？"></a>297. 表单元素的<em>readonly</em> 和 <em>disabled</em> 两个属性有什么区别？</h3><blockquote>
<p>参考答案：</p>
<ul>
<li><em>readonly</em>：<ul>
<li>不可编辑，但可以选择和复制；</li>
<li>值可以传递到后台；</li>
</ul>
</li>
<li>disabled：<ul>
<li>不能编辑，不能复制，不能选择；</li>
<li>值不可以传递到后台；</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="298-列举几种你知道的数组排序的方法。"><a href="#298-列举几种你知道的数组排序的方法。" class="headerlink" title="298. 列举几种你知道的数组排序的方法。"></a>298. 列举几种你知道的数组排序的方法。</h3><blockquote>
<p>参考答案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一：选择排序</span></span><br><span class="line"><span class="keyword">let</span> ary = [<span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; ary.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; ary.length; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ary[i] &lt; ary[j]) &#123;</span><br><span class="line">      [ary[i], ary[j]] = [ary[j], ary[i]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法二：冒泡排序</span></span><br><span class="line"><span class="keyword">let</span> ary = [<span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; ary.length; i++) &#123; </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; ary.length - i; j++) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (ary[j] &lt; ary[j + <span class="number">1</span>]) &#123;</span><br><span class="line">      [ary[j], ary[j + <span class="number">1</span>]] = [ary[j + <span class="number">1</span>], ary[j]]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="299-区分什么是“客户区坐标”、“页面坐标”、“屏幕坐标”？"><a href="#299-区分什么是“客户区坐标”、“页面坐标”、“屏幕坐标”？" class="headerlink" title="299. 区分什么是“客户区坐标”、“页面坐标”、“屏幕坐标”？"></a>299. 区分什么是“客户区坐标”、“页面坐标”、“屏幕坐标”？</h3><blockquote>
<p>参考答案：</p>
<ul>
<li>客户区坐标：鼠标指针在可视区中的水平坐标 (<em>clientX</em>) 和垂直坐标 (<em>clientY</em>)；</li>
<li>页面坐标：鼠标指针在页面布局中的水平坐标 (<em>pageX</em>) 和垂直坐标 (<em>pageY</em>)；</li>
<li>屏幕坐标：设备物理屏幕的水平坐标 (<em>screenX</em>) 和垂直坐标 (<em>screenY</em>)；</li>
</ul>
</blockquote>
<h3 id="300-如何编写高性能的-JavaScript？"><a href="#300-如何编写高性能的-JavaScript？" class="headerlink" title="300. 如何编写高性能的 JavaScript？"></a>300. 如何编写高性能的 <em>JavaScript</em>？</h3><blockquote>
<p>参考答案：</p>
<ul>
<li>遵循严格模式：”use strict”</li>
<li>将 <em>JavaScript</em> 本放在页面底部，加快渲染页面</li>
<li>将 <em>JavaScript</em> 脚本将脚本成组打包，减少请求</li>
<li>使用非阻塞方式下载 <em>JavaScript</em> 脚本</li>
<li>尽量使用局部变量来保存全局变量</li>
<li>尽量减少使用闭包</li>
<li>使用 <em>window</em> 对象属性方法时，省略 <em>window</em></li>
<li>尽量减少对象成员嵌套</li>
<li>缓存 <em>DOM</em> 节点的访问</li>
<li>通过避免使用 <em>eval()</em> 和 <em>Function()</em> 构造器</li>
<li>给 <em>setTimeout()</em> 和 <em>setInterval()</em> 传递函数而不是字符串作为参数</li>
<li>尽量使用直接量创建对象和数组</li>
<li>最小化重绘 (<em>repaint</em>) 和回流 (<em>reflow</em>)</li>
</ul>
</blockquote>
<h3 id="301-下面的代码输出什么？"><a href="#301-下面的代码输出什么？" class="headerlink" title="301. 下面的代码输出什么？"></a>301. 下面的代码输出什么？</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">5</span> &#125;</span><br><span class="line">a.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">3</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(a + <span class="number">7</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考答案：</p>
<p>10</p>
<p>因为会自动调用 a 函数的 <em>toString</em> 方法。</p>
</blockquote>
]]></content>
      <categories>
        <category>面试题</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>面试题</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack的使用</title>
    <url>/135xyq.github.io/2021/06/09/%E5%B7%A5%E7%A8%8B%E5%8C%96-webpack/</url>
    <content><![CDATA[<blockquote>
<p><strong>工程化，为复杂应用而生</strong></p>
</blockquote>
<h1 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h1><p><strong>webpack是用来搭建前端工程的</strong></p>
<p>它运行在node环境中，它所做的事情，简单来说，就是<strong>打包</strong></p>
<p>具体来说，就是以某个模块作为入口，根据入口分析出所有模块的依赖关系，然后对各种模块进行合并、压缩，形成最终的打包结果</p>
<p><strong>在webpack的世界中，一切皆是模块</strong></p>
<h1 id="体验"><a href="#体验" class="headerlink" title="体验"></a>体验</h1><blockquote>
<p>按照习惯，所有的模块均放置在<code>src</code>目录中</p>
</blockquote>
<ol>
<li><p>安装依赖</p>
</li>
<li><p>编写多个模块</p>
<p>随意编写一些模块，可以是js、图片、音视频，以入口模块为起点，形成依赖关系</p>
</li>
<li><p>运行<code>npm run build</code>命令，进行打包</p>
</li>
<li><p>查看打包结果</p>
<p>打包结果放置在dist目录中</p>
</li>
</ol>
<p>通过上面的体验，可以发现，webpack给我们带来了至少以下好处：</p>
<ul>
<li><p>可以大胆的使用任意模块化标准</p>
<p>无须担心兼容性问题，因为webpack完成打包后，已经没有了任何模块化语句</p>
</li>
<li><p>可以将一些非JS代码也视为模块</p>
<p>这样可以对css、图片等资源进行更加细粒度的划分</p>
</li>
<li><p>在前端开发中，也可以使用npm</p>
<p>webpack不会运行你的源代码，无论是你自己写的模块，还是通过npm安装的模块，webpack一视同仁，统统视为依赖，最终合并到打包结果中</p>
</li>
<li><p>非常适合开发单页应用</p>
<p>单页应用是前端用户体验最好的web应用</p>
<p>所谓单页应用，是指只有一个html页面，页面中没有任何内容，所有的内容均靠js生成</p>
<p>要优雅的实现单页应用，最好依托于前端框架，比如vue、react</p>
</li>
</ul>
<p>webpack给我们开发带来的变化远不止于此，接下来一一体验</p>
<h1 id="页面模板"><a href="#页面模板" class="headerlink" title="页面模板"></a>页面模板</h1><p>对于单页应用而言，只有一个空白的页面，所有内容都靠JS代码创建</p>
<p>webpack会自动生成一个页面，并且在页面中会自动加入对js和css的引用</p>
<p>它生成页面时，参考的是<code>public/index.html</code>，其称之为页面模板</p>
<h1 id="public目录"><a href="#public目录" class="headerlink" title="public目录"></a>public目录</h1><p>webpack会非常暴力的将public目录中的所有文件（除页面模板外），复制到打包结果中</p>
<h1 id="开发服务器"><a href="#开发服务器" class="headerlink" title="开发服务器"></a>开发服务器</h1><p>如果每次修改完代码，都要经过<code>打包-&gt;运行</code>，未免太过麻烦</p>
<p>在开发阶段，我们可以运行<code>npm run serve</code>命令获得更好的打包体验</p>
<p>该命令会让<code>webpack</code>启动一个<strong>开发服务器</strong>。</p>
<p>在这个阶段，webpack并不会形成打包结果文件，而是把打包的内容放到内存中，当我们请求服务器时，服务器从内存中给予我们打包结果</p>
<p>与此同时，当源码发生变动时，webpack会自动重新打包，同时刷新页面以访问到最新的打包结果</p>
<h1 id="文件缓存"><a href="#文件缓存" class="headerlink" title="文件缓存"></a>文件缓存</h1><p>可以看到，除了页面外，其他的资源在打包完成后，文件名多了一些奇奇怪怪的字符</p>
<p>例如：<code>js/app-9ea93.js</code></p>
<p>其中，<code>9ea93</code>这样的字符称之为<code>hash</code>，它会随着模块内容的变化而变化</p>
<p><strong>源码内容不变，hash不变；源码内容变化，hash变化</strong></p>
<p>之所以这样做，是因为生产环境中，浏览器会对除页面外的静态资源进行缓存</p>
<p>如果不设置hash值，一旦代码更新，浏览器还会使用之前缓存的结果，无法使用最新的代码</p>
<p>有了hash值之后，即可解决此问题</p>
<p>webpack会在打包时自动处理hash值，并不会对我们写代码造成任何影响，但作为一个前端开发者，有必要了解这一点</p>
<h1 id="资源路径"><a href="#资源路径" class="headerlink" title="资源路径"></a>资源路径</h1><p><strong>除代码和样式模块外，其他模块被视为资源模块</strong></p>
<p>值得特别注意的是，<strong>资源模块在源代码中的路径和打包后的路径是不一样的</strong>，这就导致我们在编写代码的时候，根本无法知晓最终的路径</p>
<p>最常见的例子，就是在css中使用背景图片</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="comment">/* 背景图使用了源码中的路径 */</span></span><br><span class="line">  backgroud: <span class="built_in">url</span>(<span class="string">&#x27;../assets/1.png&#x27;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它能正常工作吗？</p>
<p>它能！</p>
<p>因为webpack非常智能的发现了这一点，对于css中的路径，webpack在打包时，会将其自动转换为打包结果的路径，比如，上面的代码在打包完成后，可能被转换为下面的格式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="comment">/* css中的资源路径会被自动替换，我们无须关心 */</span></span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">/img/1492ea.png</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但如果我们要通过js动态的使用路径，webpack是无法识别的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打包前</span></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">&#x27;./assets/1.png&#x27;</span>; <span class="comment">// 该路径无法被转换</span></span><br><span class="line">img.src = url;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打包后</span></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">&#x27;./assets/1.png&#x27;</span>; <span class="comment">// ❌</span></span><br><span class="line">img.src = url;</span><br></pre></td></tr></table></figure>

<p>正确的做法是，通过模块化的方式导入资源，并获取资源路径</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打包前</span></span><br><span class="line"><span class="keyword">import</span> url <span class="keyword">from</span> <span class="string">&#x27;./assets/1.png&#x27;</span>; <span class="comment">// 打包后，url得到的将是真实的路径</span></span><br><span class="line">img.src = url;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打包后</span></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">&#x27;/img/1492ea.png&#x27;</span>; <span class="comment">// ✅</span></span><br><span class="line">img.src = url;</span><br></pre></td></tr></table></figure>

<h1 id="缺省的文件和后缀名"><a href="#缺省的文件和后缀名" class="headerlink" title="缺省的文件和后缀名"></a>缺省的文件和后缀名</h1><p>导入模块时，所有js模块均可省略<code>.js</code>，若导入的模块文件名为<code>index.js</code>，可省略文件名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./home&#x27;</span>; <span class="comment">// 若存在home.js，可省略js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./movie&#x27;</span>; <span class="comment">// 若movie是一个目录，此次导入的是 ./movie/index.js</span></span><br></pre></td></tr></table></figure>

<h1 id="路径别名"><a href="#路径别名" class="headerlink" title="路径别名"></a>路径别名</h1><p>随着体量的增长，不可避免的，会形成层级极深的目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root</span><br><span class="line"> |- src</span><br><span class="line">	|- a</span><br><span class="line">	 |- a1</span><br><span class="line">		- a2</span><br><span class="line">		 |- index.js</span><br><span class="line">	|- b</span><br><span class="line">	 |- b1</span><br><span class="line">		 |- index.js</span><br></pre></td></tr></table></figure>

<p>如果需要在<code>./src/a/a1/a2/index.js</code>中导入<code>./src/b/b1/index.js</code>，则可能产生下面特别恶心的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;../../../b/b1/index.js&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>webpack提供了别名供我们快速定位到<code>./src</code>目录，通常，该别名为<code>@</code></p>
<p>上面的导入代码可简化为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;@/b/b1&#x27;</span>; <span class="comment">// @表示src目录，同时省略了index.js</span></span><br></pre></td></tr></table></figure>

<h1 id="js兼容性"><a href="#js兼容性" class="headerlink" title="js兼容性"></a>js兼容性</h1><p>当webpack读取到js代码时，会自动对其进行兼容性处理</p>
<p>具体的处理方案涉及到两个配置文件：</p>
<ul>
<li><code>babel.config.js</code>：通过配置该文件，可以设置对哪些js代码进行降级处理</li>
<li><code>.browserslistrc</code>：通过配置该文件，可以设置在降级时，要兼容哪些浏览器，兼容的范围越光，降级产生的代码就越多，自然，打包后的体积就越大</li>
</ul>
<p>你无须知晓具体的配置方式</p>
<h1 id="打包压缩"><a href="#打包压缩" class="headerlink" title="打包压缩"></a>打包压缩</h1><p>webpack在打包时，会对所有js和css代码进行压缩</p>
<p>对于js，除了压缩之外，还会对其中的各种名称进行混淆</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(self.webpackChunkmovie_list=self.webpackChunkmovie_list||[]).push([[<span class="number">587</span>],&#123;<span class="number">3587</span>:<span class="function">(<span class="params">r,t,n</span>)=&gt;</span>&#123;<span class="string">&quot;use strict&quot;</span>;n.r(t),n(<span class="number">5666</span>),n(<span class="number">1539</span>),n(<span class="number">8674</span>),n(<span class="number">9600</span>),n(<span class="number">1249</span>),n(<span class="number">2222</span>);<span class="keyword">var</span> e=n(<span class="number">9755</span>),a=n.n(e);<span class="keyword">var</span> o;<span class="function"><span class="keyword">function</span> <span class="title">i</span>(<span class="params">r</span>)</span>&#123;o.html(r.map((<span class="function"><span class="keyword">function</span>(<span class="params">r</span>)</span>&#123;<span class="keyword">return</span><span class="string">&#x27;&lt;li&gt;\n  &lt;a href=&quot;&#x27;</span>.concat(r.url,<span class="string">&#x27;&quot; target=&quot;_blank&quot;&gt;\n    &lt;img src=&quot;&#x27;</span>).concat(r.cover,<span class="string">&#x27;&quot; title=&quot;&#x27;</span>).concat(r.title,<span class="string">&#x27;&quot;&gt;\n  &lt;/a&gt;\n  &lt;a href=&quot;&#x27;</span>).concat(r.url,<span class="string">&#x27;&quot; target=&quot;_blank&quot; class=&quot;&#x27;</span>).concat(<span class="string">&quot;qmUYQv1xlJhGMQKz-kfAp&quot;</span>,<span class="string">&#x27;&quot;&gt;&#x27;</span>).concat(r.title,<span class="string">&#x27;&lt;/a&gt;\n  &lt;p class=&quot;&#x27;</span>).concat(<span class="string">&quot;_3yV5wC-URYTUP0sPvaE0ZR&quot;</span>,<span class="string">&#x27;&quot;&gt;&#x27;</span>).concat(r.rate,<span class="string">&quot;&lt;/p&gt;\n  &lt;/li&gt;&quot;</span>)&#125;)).join(<span class="string">&quot;&quot;</span>))&#125;o=a()(<span class="string">&quot;&lt;ul&gt;&quot;</span>).addClass(<span class="string">&quot;_1fsrc5VinfYHBXCF1s58qS&quot;</span>).appendTo(<span class="string">&quot;#app&quot;</span>);<span class="keyword">var</span> c=n(<span class="number">8138</span>);<span class="keyword">const</span> u=</span><br></pre></td></tr></table></figure>

<p>混淆的作用一方面是为了进一步压缩包体积，另一方面是为了让我们的代码更难被其他人理解利用</p>
<h1 id="源码地图-source-map"><a href="#源码地图-source-map" class="headerlink" title="源码地图 source map"></a>源码地图 source map</h1><p>我们运行的是webpack打包后的结果，而打包后的结果是很难阅读的</p>
<p>但这样一来会带来新的问题，如果代码报错，我们就难以知道到底是那一行代码写的有问题</p>
<p>此时源码地图就发挥了作用</p>
<p>可以发现，js代码打包后都会跟上一个同名的、后缀为<code>.map</code>的文件，该文件就保存了原始代码的内容</p>
<p>请放心，这个内容人类是看不懂的，但浏览器可以看懂</p>
<p>当代码报错时，浏览器会定位到源码地图中的对应代码，而不是把真实报错的代码展示给我们</p>
<p>你无须关心这一点，但可以自然的从其中获得巨大的便利</p>
<h1 id="css工程化"><a href="#css工程化" class="headerlink" title="css工程化"></a>css工程化</h1><p>webpack能够识别<strong>所有</strong>的样式代码，包括<code>css</code>、<code>less</code>、<code>sass</code>、<code>stylus</code></p>
<p>在打包时，会将它们转换成纯正的<code>css</code></p>
<p>除此之外，它还具备以下的神奇能力</p>
<h2 id="自动厂商前缀"><a href="#自动厂商前缀" class="headerlink" title="自动厂商前缀"></a>自动厂商前缀</h2><p>css有很多兼容性问题，解决这些兼容性问题的最常见办法，就是加上厂商前缀。</p>
<p>比如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 兼容性不好的代码 */</span></span><br><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">	<span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 兼容性好的代码 */</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-box;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-flex;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  -webkit-<span class="attribute">transition</span>: <span class="number">1s</span>;</span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>webpack会根据<code>.browserlistrc</code>中指定的浏览器范围，<strong>按需、自动</strong>加上厂商前缀</p>
<p>我们开发无须关心</p>
<h2 id="css-module"><a href="#css-module" class="headerlink" title="css module"></a>css module</h2><p>css文件多了后，你怎么保证它们里面没有冲突的类样式？</p>
<p>靠层级选择器？就不担心效率？</p>
<p>靠命名规范？就不担心脑袋爆炸？</p>
<p>要靠就靠css module</p>
<p>当样式文件以<code>xxx.mdoule.xxx</code>的方式命名时，webpack会将该文件当成一个开启了<code>css module</code>的文件</p>
<p>比如：<code>index.module.less</code>、<code>movie.module.css</code>，都是开启了<code>css module</code>的文件</p>
<p><strong>文件中的所有类名都会被hash化</strong></p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 源码</span></span><br><span class="line"><span class="selector-class">.container</span>&#123;&#125;</span><br><span class="line"><span class="selector-class">.list</span>&#123;&#125;</span><br><span class="line"><span class="selector-class">.item</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打包结果，绝无可能重名</span></span><br><span class="line"><span class="selector-class">._2GFVidHvoHtfgtrdifua24</span>&#123;&#125;</span><br><span class="line"><span class="selector-class">._1fsrc5VinfYHBXCF1s58qS</span>&#123;&#125;</span><br><span class="line"><span class="selector-class">.urPUKUukdS_UTSuWRI5-5</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>现在就一个问题，我们在使用类名时，如何知道它打包结果的类名呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./index.module.less&#x27;</span>;</span><br><span class="line">dom.classList.add(<span class="string">&#x27;container&#x27;</span>); <span class="comment">// ❌ 最终的类名可不是这个</span></span><br></pre></td></tr></table></figure>

<p>正确的方式如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// styles 是一个对象，里面映射了源码类名和打包类名的关系</span></span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&#x27;./index.module.less&#x27;</span>;</span><br><span class="line">dom.classList.add(styles.container); <span class="comment">// ✅ 属性container中记录的就是container转换后的类名</span></span><br></pre></td></tr></table></figure>



<h1 id="真正的webpack没有那么神奇"><a href="#真正的webpack没有那么神奇" class="headerlink" title="真正的webpack没有那么神奇"></a>真正的webpack没有那么神奇</h1><p>实际上，webpack没有做这么多事，我们不能把功劳（怨念）全归结于它</p>
<p>它只是站在巨人（其他流氓）肩膀上而已</p>
<p>webpack通过插件（plugin）和加载器（loader）将这些技术整合在一起</p>
<ul>
<li><code>.browserslistrc</code>，表达适配的浏览器范围，会被工程化中的其他技术所使用</li>
<li><code>babel.config.js</code>，<code>babel</code>的配置文件，做js降级处理</li>
<li><code>postcss.config.js</code>，<code>postcss</code>的配置文件，做css代码转换</li>
<li><code>webpack.config.js</code>，<code>webpack</code>的配置文件，整合其他工程化技术，以及配置打包细节、开发服务器、路径别名等等</li>
</ul>
<h1 id="对我们开发的影响"><a href="#对我们开发的影响" class="headerlink" title="对我们开发的影响"></a>对我们开发的影响</h1><ol>
<li><p>学会访问开发服务器查看效果</p>
</li>
<li><p>学会动态获取资源文件路径</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> url <span class="keyword">from</span> <span class="string">&#x27;./assets/1.png&#x27;</span>; </span><br><span class="line">img.src = url;</span><br></pre></td></tr></table></figure></li>
<li><p>学会省略文件和后缀名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./home&#x27;</span>; <span class="comment">// 若存在home.js，可省略js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./movie&#x27;</span>; <span class="comment">// 若movie是一个目录，此次导入的是 ./movie/index.js</span></span><br></pre></td></tr></table></figure></li>
<li><p>学会使用别名简化导入代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;@/b/b1&#x27;</span>; <span class="comment">// 实际导入： src/b/b1/index.js  (若b1是目录)</span></span><br></pre></td></tr></table></figure></li>
<li><p>学会使用css module</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// styles 是一个对象，里面映射了源码类名和打包类名的关系</span></span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&#x27;./index.module.less&#x27;</span>;</span><br><span class="line">dom.classList.add(styles.container); </span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>AMD和CMD</title>
    <url>/135xyq.github.io/2021/05/20/%E6%A8%A1%E5%9D%97%E5%8C%96-AMD%E5%92%8CCMD/</url>
    <content><![CDATA[<h2 id="浏览器端模块化的难题"><a href="#浏览器端模块化的难题" class="headerlink" title="浏览器端模块化的难题"></a>浏览器端模块化的难题</h2><p><strong>CommonJS的工作原理</strong></p>
<p>当使用<code>require(模块路径)</code>导入一个模块时，node会做以下两件事情（不考虑模块缓存）：</p>
<ol>
<li>通过模块路径找到本机文件，并读取文件内容</li>
<li>将文件中的代码放入到一个函数环境中执行，并将执行后module.exports的值作为require函数的返回结果</li>
</ol>
<p>正是这两个步骤，使得CommonJS在node端可以良好的被支持</p>
<p>可以认为，<strong>CommonJS是同步的</strong>，必须要等到加载完文件并执行完代码后才能继续向后执行</p>
<p><strong>当浏览器遇到CommonJS</strong></p>
<p>当想要把CommonJS放到浏览器端时，就遇到了一些挑战</p>
<ol>
<li>浏览器要加载JS文件，需要远程从服务器读取，而网络传输的效率远远低于node环境中读取本地文件的效率。由于CommonJS是同步的，这会极大的降低运行性能</li>
<li>如果需要读取JS文件内容并把它放入到一个环境中执行，需要浏览器厂商的支持，可是浏览器厂商不愿意提供支持，最大的原因是CommonJS属于社区标准，并非官方标准</li>
</ol>
<p><strong>新的规范</strong></p>
<p>基于以上两点原因，浏览器无法支持模块化</p>
<p>可这并不代表模块化不能在浏览器中实现</p>
<p>要在浏览器中实现模块化，只要能解决上面的两个问题就行了</p>
<p>解决办法其实很简单：</p>
<ol>
<li>远程加载JS浪费了时间？做成异步即可，加载完成后调用一个回调就行了</li>
<li>模块中的代码需要放置到函数中执行？编写模块时，直接放函数中就行了</li>
</ol>
<p>基于这种简单有效的思路，出现了AMD和CMD规范，有效的解决了浏览器模块化的问题。</p>
<h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><p>全称是Asynchronous Module Definition，即异步模块加载机制</p>
<p>require.js实现了AMD规范</p>
<p>在AMD中，导入和导出模块的代码，都必须放置在define函数中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">define([依赖的模块列表], <span class="function"><span class="keyword">function</span>(<span class="params">模块名称列表</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//模块内部的代码</span></span><br><span class="line">    <span class="keyword">return</span> 导出的内容</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p>全称是Common Module Definition，公共模块定义规范</p>
<p>sea.js实现了CMD规范</p>
<p>在CMD中，导入和导出模块的代码，都必须放置在define函数中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//模块内部的代码</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>模块化</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>模块化</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6模块化</title>
    <url>/135xyq.github.io/2021/05/05/%E6%A8%A1%E5%9D%97%E5%8C%96-ES6%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    <content><![CDATA[<h1 id="ES6模块化简介"><a href="#ES6模块化简介" class="headerlink" title="ES6模块化简介"></a>ES6模块化简介</h1><p>ECMA组织参考了众多社区模块化标准，终于在2015年，随着ES6发布了官方的模块化标准，后成为ES6模块化</p>
<h2 id="ES6模块化具有以下的特点"><a href="#ES6模块化具有以下的特点" class="headerlink" title="ES6模块化具有以下的特点"></a>ES6模块化具有以下的特点</h2><ol>
<li>使用依赖<strong>预声明</strong>的方式导入模块<ol>
<li>依赖延迟声明<ol>
<li>优点：某些时候可以提高效率</li>
<li>缺点：无法在一开始确定模块依赖关系（比较模糊）</li>
</ol>
</li>
<li>依赖预声明<ol>
<li>优点：在一开始可以确定模块依赖关系</li>
<li>缺点：某些时候效率较低</li>
</ol>
</li>
</ol>
</li>
<li>灵活的多种导入导出方式</li>
<li>规范的路径表示法：所有路径必须以./或../开头</li>
</ol>
<h2 id="基本导入导出"><a href="#基本导入导出" class="headerlink" title="基本导入导出"></a>基本导入导出</h2><h3 id="模块的引入"><a href="#模块的引入" class="headerlink" title="模块的引入"></a>模块的引入</h3><p><strong>注意：这一部分非模块化标准</strong></p>
<p>目前，浏览器使用以下方式引入一个ES6模块文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;入口文件&quot;</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="模块的基本导出和导入"><a href="#模块的基本导出和导入" class="headerlink" title="模块的基本导出和导入"></a>模块的基本导出和导入</h3><p>ES6中的模块导入导出分为两种：</p>
<ol>
<li>基本导入导出</li>
<li>默认导入导出</li>
</ol>
<p><img src="/images/%E6%A8%A1%E5%9D%97%E5%8C%96/ES6%E6%A8%A1%E5%9D%97%E5%8C%96-%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA.jpg"></p>
<h3 id="基本导出"><a href="#基本导出" class="headerlink" title="基本导出"></a>基本导出</h3><p>类似于 <code>exports.xxx = xxxx</code></p>
<p>基本导出可以有多个，每个必须有名称</p>
<p>基本导出的语法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> 声明表达式</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">例：</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">&quot;xie&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;message&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;具名符号&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">例：</span><br><span class="line"><span class="keyword">const</span> a = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; a &#125;;</span><br></pre></td></tr></table></figure>

<p>由于基本导出必须具有名称，所以要求导出内容必须跟上<strong>声明表达式</strong>或<strong>具名符号</strong></p>
<h3 id="基本导入"><a href="#基本导入" class="headerlink" title="基本导入"></a>基本导入</h3><p>由于使用的是<strong>依赖预加载</strong>，因此，导入任何其他模块，导入代码必须放置到所有代码之前</p>
<p>对于基本导出，如果要进行导入，使用下面的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;导入的符号列表&#125; <span class="keyword">from</span> <span class="string">&quot;模块路径&quot;</span> </span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">例：</span><br><span class="line"><span class="keyword">import</span> &#123; name, fn, fn1, a &#125; <span class="keyword">from</span> <span class="string">&quot;./until.js&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name, a);</span><br><span class="line">fn();</span><br><span class="line">fn1();</span><br></pre></td></tr></table></figure>

<p>注意以下细节：</p>
<ul>
<li>导入时，可以通过关键字<code>as</code>对导入的符号进行重命名</li>
<li>导入时使用的符号是常量，不可修改</li>
<li>可以使用*号导入所有的基本导出，形成一个对象</li>
<li>如果仅仅只是想让某个模块的代码执行一遍不使用任何导出则可以使用 <code>import &quot;模块路径&quot; </code></li>
</ul>
<h2 id="默认导入导出"><a href="#默认导入导出" class="headerlink" title="默认导入导出"></a>默认导入导出</h2><p><img src="/images/%E6%A8%A1%E5%9D%97%E5%8C%96/ES6%E6%A8%A1%E5%9D%97%E5%8C%96-%E9%BB%98%E8%AE%A4%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA.jpg"></p>
<h3 id="默认导出"><a href="#默认导出" class="headerlink" title="默认导出"></a>默认导出</h3><p>每个模块，除了允许有多个基本导出之外，还允许有一个默认导出</p>
<p>默认导出类似于CommonJS中的<code>module.exports</code>，由于只有一个，因此无需具名</p>
<p>具体的语法是</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> 默认导出的数据</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">例：</span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;xie&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> name;</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;默认导出的数据 <span class="keyword">as</span> <span class="keyword">default</span>&#125;</span><br></pre></td></tr></table></figure>

<p>由于每个模块仅允许有一个默认导出，因此，每个模块不能出现多个默认导出语句</p>
<h3 id="默认导入"><a href="#默认导入" class="headerlink" title="默认导入"></a>默认导入</h3><p>需要想要导入一个模块的默认导出，需要使用下面的语法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> 接收变量名 <span class="keyword">from</span> <span class="string">&quot;模块路径&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">例：</span><br><span class="line"><span class="keyword">import</span> name <span class="keyword">from</span> <span class="string">&quot;./until.js&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(name())</span><br></pre></td></tr></table></figure>

<p>类似于CommonJS中的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 接收变量名 = <span class="built_in">require</span>(<span class="string">&quot;模块路径&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>由于默认导入时变量名是自行定义的，因此没有别名一说</p>
<p>如果希望同时导入某个模块的默认导出和基本导出，可以使用下面的语法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> 接收默认导出的变量, &#123;接收基本导出的变量&#125; <span class="keyword">from</span> <span class="string">&quot;模块路径&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">例：</span><br><span class="line"><span class="keyword">import</span> name, &#123; fn &#125; <span class="keyword">from</span> <span class="string">&quot;./until.js&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>

<p>注：如果使用*号，会将所有基本导出和默认导出聚合到一个对象中，默认导出会作为属性default存在</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> obj <span class="keyword">from</span> <span class="string">&quot;./until.js&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.default)</span><br></pre></td></tr></table></figure>

<h2 id="ES6模块化的其他细节"><a href="#ES6模块化的其他细节" class="headerlink" title="ES6模块化的其他细节"></a>ES6模块化的其他细节</h2><h3 id="1-尽量导出不可变值"><a href="#1-尽量导出不可变值" class="headerlink" title="1. 尽量导出不可变值"></a>1. <strong>尽量导出不可变值</strong></h3><p>当导出一个内容时，尽量保证该内容是不可变的（大部分情况都是如此）</p>
<p>因为，虽然导入后，无法更改导入内容，但是在导入的模块内部却有可能发生更改，这将导致一些无法预料的事情发生</p>
<h3 id="2-可以使用无绑定的导入用于执行一些初始化代码"><a href="#2-可以使用无绑定的导入用于执行一些初始化代码" class="headerlink" title="2. 可以使用无绑定的导入用于执行一些初始化代码"></a>2. <strong>可以使用无绑定的导入用于执行一些初始化代码</strong></h3><p>如果我们只是想执行模块中的一些代码，而不需要导入它的任何内容，可以使用无绑定的导入：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;模块路径&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-可以使用绑定再导出，来重新导出来自另一个模块的内容"><a href="#3-可以使用绑定再导出，来重新导出来自另一个模块的内容" class="headerlink" title="3. 可以使用绑定再导出，来重新导出来自另一个模块的内容"></a>3. <strong>可以使用绑定再导出，来重新导出来自另一个模块的内容</strong></h3><p>有的时候，我们可能需要用一个模块封装多个模块，然后有选择的将多个模块的内容分别导出，可以使用下面的语法轻松完成</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;绑定的标识符&#125; <span class="keyword">from</span> <span class="string">&quot;模块路径&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/%E6%A8%A1%E5%9D%97%E5%8C%96/ES6%E6%A8%A1%E5%9D%97%E5%8C%96-%E6%B7%B7%E5%90%88%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA.jpg"></p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>模块化</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>模块化</tag>
      </tags>
  </entry>
  <entry>
    <title>网站部署</title>
    <url>/135xyq.github.io/2022/03/22/%E7%BD%91%E7%BB%9C-%E6%9C%8D%E7%BD%91%E7%AB%99%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h1 id="网站上线部署"><a href="#网站上线部署" class="headerlink" title="网站上线部署"></a>网站上线部署</h1><h2 id="一、网站运行机制"><a href="#一、网站运行机制" class="headerlink" title="一、网站运行机制"></a>一、网站运行机制</h2><h3 id="1-名词解释"><a href="#1-名词解释" class="headerlink" title="1. 名词解释"></a>1. 名词解释</h3><h4 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h4><blockquote>
<ul>
<li><a href="http://www.baidu.com/">www.baidu.com</a></li>
<li><a href="http://www.taobao.com/">www.taobao.com</a></li>
<li><a href="http://www.qq.com/">www.qq.com</a></li>
</ul>
</blockquote>
<blockquote>
<p>域名俗称网址，是由一串用点分隔的名字组成，用于标识互联网上的计算机。</p>
<p>原本用于标识互联网上计算机使用的是 IP 地址，但是由于 IP 地址不便于记忆，所以人们便设计出来比较容易记忆的域名，然后通过 DNS 将域名和 IP 地址关联，这样人们便可以通过记忆域名直接访问到对应的计算机。</p>
</blockquote>
<h4 id="DNS-服务器"><a href="#DNS-服务器" class="headerlink" title="DNS 服务器"></a>DNS 服务器</h4><blockquote>
<p>DNS (Domain Name System)，可以理解为互联网上的一项服务，他可以将域名转换成其对应的 IP 地址。</p>
<p>可以将其理解为字典，字典中存储的就是域名和 IP 地址一一对应的键值对。</p>
<p>本地 hosts 文件</p>
<p>windows: c:\windows\system32\drivers\etc\hosts</p>
<p>mac: /etc/hosts</p>
</blockquote>
<h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h4><blockquote>
<p>服务器其实就是一台计算机，但是这台计算机并和我们自己的的 PC 不一样，不是日常使用的，而是提供某项互联网服务的。</p>
<p>比如 web 服务器，能为我们提供网页服务，email 服务器，能为我们提供电子邮件服务，FTP 服务器能为我们提供文件存储服务等等。</p>
<p>为计算机安装不同的服务应用程序，即可提供相应的服务。</p>
<p>常见的web 服务应用程序： Apache、Nginx、IIS、Node.js</p>
</blockquote>
<img src="/images/网络/server.jpeg" style="zoom:75%;" />

<p><img src="/images/%E7%BD%91%E7%BB%9C/server-list.jpeg"></p>
<h3 id="2-网站请求流程（简化版）"><a href="#2-网站请求流程（简化版）" class="headerlink" title="2. 网站请求流程（简化版）"></a>2. 网站请求流程（简化版）</h3><h4 id="静态页面"><a href="#静态页面" class="headerlink" title="静态页面"></a>静态页面</h4><p>网页只请求和响应简单的 HTML、CSS、JavaScript 文件，未和服务端进行任何数据通信。这样的页面叫做静态页面。</p>
<h4 id="动态页面"><a href="#动态页面" class="headerlink" title="动态页面"></a>动态页面</h4><p>页面内有和服务器进行数据通信，这样的页面叫做动态页面。</p>
<h4 id="前后端分离的页面"><a href="#前后端分离的页面" class="headerlink" title="前后端分离的页面"></a>前后端分离的页面</h4><blockquote>
<p>前后端分离的项目中，页面中的数据渲染是在浏览器中完成的。</p>
</blockquote>
<p>前后端分离的页面请求分为两部分： 静态页面请求 + ajax 数据请求</p>
<img src="/images/网络/网站运行机制-静态网页请求.png" style="zoom:50%;" />

<img src="/images/网络/网站运行机制-接口请求.png" style="zoom:50%;" />



<h4 id="前后端不分离的页面"><a href="#前后端不分离的页面" class="headerlink" title="前后端不分离的页面"></a>前后端不分离的页面</h4><blockquote>
<p>前后端不分离的项目中，页面中的数据渲染操作是在服务器端完成的。</p>
</blockquote>
<p>前后端不分离的页面一次请求就能完成。</p>
<img src="/images/网络/网站运行机制-动态网页.png" style="zoom:50%;" />

<h2 id="二、网站上线部署流程"><a href="#二、网站上线部署流程" class="headerlink" title="二、网站上线部署流程"></a>二、网站上线部署流程</h2><h3 id="1-服务器购买"><a href="#1-服务器购买" class="headerlink" title="1. 服务器购买"></a>1. 服务器购买</h3><p>国内服务器： 阿里云 ECS(Elastic Compute Service)，腾讯云 CVM(Cloud Virtual Machine) 等</p>
<p>国外服务器： 日本 <a href="https://www.vultr.com/">Vultr</a>, 美国 Linode, 谷歌云，微软 Azure，亚马逊 AWS 等</p>
<p>这一步需要创建好服务器实例，分配好外网 IP 地址。</p>
<h3 id="2-域名购买"><a href="#2-域名购买" class="headerlink" title="2. 域名购买"></a>2. 域名购买</h3><p>国内： 万网（阿里）、腾讯等</p>
<p>国外： Godaddy</p>
<h3 id="3-域名解析（配置-DNS）"><a href="#3-域名解析（配置-DNS）" class="headerlink" title="3. 域名解析（配置 DNS）"></a>3. 域名解析（配置 DNS）</h3><p>注册好域名之后需要将域名映射到自己服务器对应的 IP 地址，这样别人才能通过域名访问到我们的服务器。</p>
<p>这个步骤叫做域名解析，通过域名服务商提供的后台就可以操作，一般域名解析都会有延迟，不是即时生效的。</p>
<h3 id="4-服务器环境搭建"><a href="#4-服务器环境搭建" class="headerlink" title="4. 服务器环境搭建"></a>4. 服务器环境搭建</h3><p>配置服务器，Mac 系统下直接用终端就ok</p>
<p>windows下需要用到 git bash, 或者别的工具（Putty）</p>
<p>需要用到的 Linux 系统操作命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 远程连接命令</span></span><br><span class="line">ssh root@域名</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 展示当前文件夹路径</span></span><br><span class="line">pwd</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换文件夹目录</span></span><br><span class="line">cd 目录路径</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 展示当前文件夹中内容</span></span><br><span class="line">ls</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编辑文件</span></span><br><span class="line">vim 文件路径</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 传输文件</span> </span><br><span class="line">scp 本地文件路径 root@域名:远程路径</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压文件命令</span></span><br><span class="line">unzip </span><br></pre></td></tr></table></figure>

<h4 id="4-1-安装-CentOS-开发人员相关包"><a href="#4-1-安装-CentOS-开发人员相关包" class="headerlink" title="4.1 安装 CentOS 开发人员相关包"></a>4.1 安装 CentOS 开发人员相关包</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum groupinstall &#x27;Development tools&#x27;</span><br></pre></td></tr></table></figure>

<p>####4.2 配置免密登陆</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在自己电脑上 生成本地 秘钥对</span></span><br><span class="line">ssh-keygen -t rsa </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 生成的位置</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mac 在 ~/.ssh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> windows 在 C:\users\你的用户名\.ssh</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在服务器创建了一个.ssh 文件夹</span></span><br><span class="line">mkdir .ssh</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到这个文件夹</span></span><br><span class="line">cd .ssh</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建了一个文件</span></span><br><span class="line">touch authorized_keys</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 我们把自己电脑上的 id_rsa.pub 文件中的内容 放到 authorized_keys文件中</span></span><br><span class="line">echo &quot;cqHuvyGI2EXH5EOT/wsjIlNqH6kRaGRzLOcYAoYyn+0nsPhEfFOkv1cii9Ax9naeJuw78LapaXxmGgkcBWdk2W1KXkL5tPIZUIZAfwJ4PihDQ+0rUj5Yar741NvZYNYZ+xa1RBeziR3gbwdTLPV22Et9TTiLVEY0bNXxgvI1GGvT87f+sFB5hEB0HyQpDFyjDN+UyxTKf/Zf/7Z2z/Qz2kWTFI6oaCNfScdhjEUO8qzSsjR+9X5hE6dxmz8EII0jvAumnBy0kcIv9BaQ6TCQrijh0TWWkih2HRq8prmBzCWxb3a2A/f9PM+E6kdDBZ9lJTgB4ww8IQDxVXxhg5B14pR7ULA0rpT4ITPNFzzkVt5mo2m1bF0VH3HFiJWATaLCHZoKm8Qij6LbDL20dr4StE4zJ2fEKhi7c4CU= Ryan@panmings-MBP.lan&quot; &gt;&gt; authorized_keys</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 退出服务器，下次直接就能免密登陆了</span></span><br><span class="line">exit</span><br></pre></td></tr></table></figure>

<h4 id="4-3-安装Nginx"><a href="#4-3-安装Nginx" class="headerlink" title="4.3 安装Nginx"></a>4.3 安装Nginx</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加 Nginx 源</span></span><br><span class="line">sudo yum install epel-release</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装 Nginx</span></span><br><span class="line">sudo yum install nginx</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动 Nginx</span></span><br><span class="line">sudo systemctl start nginx</span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置防火墙规则</span></span><br><span class="line">sudo firewall-cmd --permanent --zone=public --add-service=http </span><br><span class="line">sudo firewall-cmd --permanent --zone=public --add-service=https</span><br><span class="line">sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure>

<h4 id="4-4-安装Node-js"><a href="#4-4-安装Node-js" class="headerlink" title="4.4 安装Node.js"></a>4.4 安装Node.js</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yum自带源中没有Node.js,所以首先要获取Node.js资源：</span></span><br><span class="line">curl --silent --location https://rpm.nodesource.com/setup_14.x | bash -</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装 Node.js</span></span><br><span class="line">yum install -y nodejs</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装完成之后使用如下指令测试安装是否成功</span></span><br><span class="line">node -v</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装pm2 node.js程序管理工具</span></span><br><span class="line">npm i pm2 -g</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用pm2 启动node.js项目</span></span><br><span class="line">pm2 start 文件名</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止</span></span><br><span class="line">pm2 stop 文件名或者id</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从pm2的管理列表中删除</span></span><br><span class="line">pm2 delete 文件名或者id</span><br></pre></td></tr></table></figure>

<h4 id="4-5-安装MySQL"><a href="#4-5-安装MySQL" class="headerlink" title="4.5 安装MySQL"></a>4.5 安装MySQL</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载并安装 MySQL 源</span></span><br><span class="line">wget https://dev.mysql.com/get/mysql80-community-release-el7-3.noarch.rpm</span><br><span class="line">sudo yum localinstall mysql80-community-release-el7-3.noarch.rpm</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装 MySQL</span></span><br><span class="line">sudo yum install mysql-community-server -y</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果上一步报错 执行下面的语句 之后 再次执行一下上面的安装Mysql的语句</span></span><br><span class="line">sudo yum module disable mysql</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动MySQL</span></span><br><span class="line">sudo systemctl start mysqld</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 找到默认密码</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> MySQL安装完毕之后会自动设置一个默认密码，我们需要找到默认密码</span></span><br><span class="line">grep &#x27;temporary password&#x27; /var/log/mysqld.log</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 连接到MySQL数据库，修改密码</span></span><br><span class="line">mysql -uroot -p</span><br><span class="line"></span><br><span class="line">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;xyq2386152296XYQ_&#x27;;</span><br></pre></td></tr></table></figure>



<h3 id="5-上传网站资源"><a href="#5-上传网站资源" class="headerlink" title="5. 上传网站资源"></a>5. 上传网站资源</h3><p>可以使用 <code>scp</code> 命令，也可以安装 FTP （vsftpd）工具。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp 本地文件 root@域名:远程路径</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在服务器创建文件夹</span></span><br><span class="line">mkdir /home/nginx/</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 把网页文件移动到创建好的文件夹里</span></span><br><span class="line">mv ./dist.zip /home/nginx/</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压压缩文件</span></span><br><span class="line">cd /home/ningx</span><br><span class="line">unzip ./dist.zip</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改文件夹名字</span></span><br><span class="line">mv dist ilovefe</span><br><span class="line"><span class="meta">#</span><span class="bash"> 结果就是  /home/nginx/ilovefe  这个文件夹中放的就是我们的网页文件了</span></span><br></pre></td></tr></table></figure>



<h3 id="6-配置Nginx"><a href="#6-配置Nginx" class="headerlink" title="6. 配置Nginx"></a>6. 配置Nginx</h3><p>创建一个ilovefe.conf文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /etc/nginx/conf.d</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建配置文件</span></span><br><span class="line">touch ilovefe.conf</span><br><span class="line">vim ilovefe.conf</span><br><span class="line"><span class="meta">#</span><span class="bash"> 按i键 进出插入模式</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 复制下面的内容，粘贴进去</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 保存退出</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 按一下esc退出编辑模式</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 然后输入 下面的内容 敲回车</span></span><br><span class="line">:wq</span><br></pre></td></tr></table></figure>



<p>ilovefe.conf</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  ilovefe.com;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   /home/nginx/ilovefe;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-接口项目部署步骤"><a href="#7-接口项目部署步骤" class="headerlink" title="7. 接口项目部署步骤"></a>7. 接口项目部署步骤</h3><ol>
<li><p>修改配置文件中的 mysql 数据库密码</p>
</li>
<li><p>上传项目压缩文件到服务器</p>
</li>
<li><p>在服务器上解压项目文件到 /home/nginx/ilovefeadmin</p>
</li>
<li><p>为项目安装依赖项 npm i</p>
</li>
<li><p>修改mysql数据库 密码规则</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use mysql;</span><br><span class="line">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;xyq2386152296XYQ_&#x27; PASSWORD EXPIRE NEVER;</span><br><span class="line">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;xyq2386152296XYQ_&#x27;;</span><br><span class="line"></span><br><span class="line"># 查看是否已经修改成功</span><br><span class="line">select user,host,plugin from user where user=&#x27;root&#x27;; </span><br></pre></td></tr></table></figure></li>
<li><p>创建新的数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create database vuesql;</span><br></pre></td></tr></table></figure></li>
<li><p>在之前的nginx配置文件中添加反向代理的配置：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location ^~ /api/ &#123;</span><br><span class="line"> 		rewrite  ^/api/(.*)$ /$1 break;</span><br><span class="line">   	proxy_pass  http://127.0.0.1:3000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>ilovefeamdin.conf</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  admin.ilovefe.com;</span><br><span class="line">    </span><br><span class="line">    location / &#123;</span><br><span class="line">    	proxy_pass  http://127.0.0.1:3000;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客网-JS能力测评1</title>
    <url>/135xyq.github.io/2022/01/27/%E7%89%9B%E5%AE%A2%E7%BD%91-JS%E8%83%BD%E5%8A%9B%E6%B5%8B%E8%AF%841/</url>
    <content><![CDATA[<h2 id="JS1-直角三角形"><a href="#JS1-直角三角形" class="headerlink" title="JS1 直角三角形"></a>JS1 直角三角形</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">            pre&#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">font-size</span>:<span class="number">20px</span>;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">        请补全JavaScript代码，要求在页面上渲染出一个直角三角形，三角形换行要求使用&quot;br&quot;实现。三角形如下：</span><br><span class="line">        *</span><br><span class="line">        **</span><br><span class="line">        ***</span><br><span class="line">        <span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;triangle&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> triangle = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.triangle&#x27;</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>;j&lt;=i;j++)&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">const</span> span = <span class="built_in">document</span>.createElement(<span class="string">&#x27;span&#x27;</span>);</span></span><br><span class="line"><span class="javascript">                    span.innerHTML = <span class="string">&quot;*&quot;</span>;</span></span><br><span class="line"><span class="javascript">                    triangle.appendChild(span);</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">                triangle.appendChild(<span class="built_in">document</span>.createElement(<span class="string">&#x27;br&#x27;</span>))</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">            </span></span><br><span class="line"><span class="javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="JS2-文件扩展名"><a href="#JS2-文件扩展名" class="headerlink" title="JS2 文件扩展名"></a>JS2 文件扩展名</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">            pre&#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">font-size</span>:<span class="number">20px</span>;</span></span><br><span class="line"><span class="css">                <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">            请补全JavaScript代码，要求以字符串的形式返回文件名扩展名，文件名参数为&quot;filename&quot;。</span><br><span class="line">        <span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> _getExFilename = <span class="function">(<span class="params">filename</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 补全代码</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> <span class="string">&#x27;.&#x27;</span> + filename.split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">1</span>];</span></span><br><span class="line"><span class="javascript">                </span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="JS3-分隔符"><a href="#JS3-分隔符" class="headerlink" title="JS3 分隔符"></a>JS3 分隔符</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">utf-8</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">            pre&#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">font-size</span>:<span class="number">20px</span>;</span></span><br><span class="line"><span class="css">                <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">            请补全JavaScript代码，要求返回参数数字的千分位分隔符字符串。</span><br><span class="line">        <span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="keyword">function</span> <span class="title">_comma</span>(<span class="params">number</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 补全代码</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span>(number &gt; <span class="number">1000</span>)&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">const</span> arr = (number +<span class="string">&#x27;&#x27;</span>).split(<span class="string">&#x27;&#x27;</span>);</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">for</span>(<span class="keyword">let</span> i = arr.length;i&gt;<span class="number">3</span>;i-=<span class="number">3</span>)&#123;</span></span><br><span class="line"><span class="javascript">                        arr.splice(i-<span class="number">3</span>,<span class="number">0</span>,<span class="string">&#x27;,&#x27;</span>);</span></span><br><span class="line"><span class="javascript">                    &#125;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">return</span> arr.join(<span class="string">&#x27;&#x27;</span>)</span></span><br><span class="line"><span class="javascript">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(number &lt; -<span class="number">1000</span>)&#123;</span></span><br><span class="line"><span class="javascript">                    number = -number;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">const</span> arr = (number +<span class="string">&#x27;&#x27;</span>).split(<span class="string">&#x27;&#x27;</span>);</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">for</span>(<span class="keyword">let</span> i = arr.length;i&gt;<span class="number">3</span>;i-=<span class="number">3</span>)&#123;</span></span><br><span class="line"><span class="javascript">                        arr.splice(i-<span class="number">3</span>,<span class="number">0</span>,<span class="string">&#x27;,&#x27;</span>);</span></span><br><span class="line"><span class="javascript">                    &#125;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">return</span> <span class="string">&#x27;-&#x27;</span> + arr.join(<span class="string">&#x27;&#x27;</span>)</span></span><br><span class="line"><span class="javascript">                &#125; <span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">return</span> number+<span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">                </span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(_comma(-<span class="number">123</span>))  </span></span><br><span class="line"><span class="javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="JS4-单向绑定"><a href="#JS4-单向绑定" class="headerlink" title="JS4 单向绑定"></a>JS4 单向绑定</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">utf-8</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">            pre&#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">font-size</span>:<span class="number">20px</span>;</span></span><br><span class="line"><span class="css">                <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">            请补全JavaScript代码，要求每当id为&quot;input&quot;的输入框值发生改变时触发id为&quot;span&quot;的标签内容同步改变。</span><br><span class="line"></span><br><span class="line">            注意：必须使用DOM0级标准事件（onchange）</span><br><span class="line">        <span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;input&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;span&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 补全代码</span></span></span><br><span class="line"><span class="javascript">            input.onchange =<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">                span.innerHTML =input.value;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="JS5-创建数组"><a href="#JS5-创建数组" class="headerlink" title="JS5 创建数组"></a>JS5 创建数组</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">utf-8</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">            pre&#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">font-size</span>:<span class="number">20px</span>;</span></span><br><span class="line"><span class="css">                <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">            请补全JavaScript代码，要求返回一个长度为参数值并且每一项值都为参数值的数组。</span><br><span class="line">        注意：请勿直接使用for/while</span><br><span class="line">        <span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    	</span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> _createArray = <span class="function">(<span class="params">number</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 补全代码</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="built_in">Math</span>.abs(number)).fill(number)</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="comment">// console.log(_createArray(4))</span></span></span><br><span class="line"><span class="javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="JS6-判断版本"><a href="#JS6-判断版本" class="headerlink" title="JS6 判断版本"></a>JS6 判断版本</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">utf-8</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">            pre&#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">font-size</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">请补全JavaScript代码，该函数接收两个参数分别为旧版本、新版本，当新版本高于旧版本时表明需要更新，返回true，否则返回false。</span><br><span class="line">注意：</span><br><span class="line">1. 版本号格式均为&quot;X.X.X&quot;</span><br><span class="line">2. X∈[0,9]</span><br><span class="line">3. 当两个版本号相同时，不需要更新</span><br><span class="line">        <span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    	</span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> _shouldUpdate = <span class="function">(<span class="params">oldVersion, newVersion</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 补全代码</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">const</span> oldArr = oldVersion.split(<span class="string">&#x27;.&#x27;</span>);</span></span><br><span class="line"><span class="javascript">                <span class="keyword">const</span> newArr = newVersion.split(<span class="string">&#x27;.&#x27;</span>);</span></span><br><span class="line"><span class="javascript">                <span class="keyword">let</span> oldNumber = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">let</span> newNumber = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span></span><br><span class="line"><span class="javascript">                    oldNumber += <span class="number">10</span> * oldNumber + <span class="built_in">parseInt</span>(oldArr[i]);</span></span><br><span class="line"><span class="javascript">                    newNumber += <span class="number">10</span> * newNumber + <span class="built_in">parseInt</span>(newArr[i]);</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span>(newNumber &gt; oldNumber)&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">                </span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(_shouldUpdate(<span class="string">&#x27;0,0,0&#x27;</span>,<span class="string">&#x27;0,0,2&#x27;</span>))</span></span><br><span class="line"><span class="javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="JS7-无重复数组"><a href="#JS7-无重复数组" class="headerlink" title="JS7 无重复数组"></a>JS7 无重复数组</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">            pre&#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">font-size</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">请补全JavaScript代码，实现一个函数，要求如下：</span><br><span class="line">1. 根据输入的数字范围[start,end]和随机数个数&quot;n&quot;生成随机数</span><br><span class="line">2. 生成的随机数存储到数组中，返回该数组</span><br><span class="line">3. 返回的数组不能有相同元素</span><br><span class="line">注意：</span><br><span class="line">1. 不需要考虑&quot;n&quot;大于数字范围的情况</span><br><span class="line">        <span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> _getUniqueNums = <span class="function">(<span class="params">start,end,n</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 补全代码</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">const</span> arr = [];</span></span><br><span class="line"><span class="javascript">                <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span></span><br><span class="line"><span class="javascript">                   <span class="keyword">const</span> temp = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random()*(end - start)) + start;</span></span><br><span class="line"><span class="javascript">                   <span class="keyword">if</span>(!arr.includes(temp))&#123;</span></span><br><span class="line"><span class="javascript">                    arr.push(temp)</span></span><br><span class="line"><span class="javascript">                   &#125;</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> arr;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(_getUniqueNums(<span class="number">2</span>,<span class="number">10</span>,<span class="number">4</span>))</span></span><br><span class="line"><span class="javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="JS8-数组排序"><a href="#JS8-数组排序" class="headerlink" title="JS8 数组排序"></a>JS8 数组排序</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">            pre&#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">font-size</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">描述</span><br><span class="line">请补全JavaScript代码，根据预设代码中的数组，实现以下功能：</span><br><span class="line">1. 列表只展示数组中的name属性</span><br><span class="line">2. 实现点击&quot;销量升序&quot;按钮，列表内容按照销量升序重新渲染</span><br><span class="line">3. 实现点击&quot;销量降序&quot;按钮，列表内容按照销量降序重新渲染</span><br><span class="line">注意：</span><br><span class="line">1. 必须使用DOM0级标准事件（onclick）        </span><br><span class="line">        <span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&#x27;up&#x27;</span>&gt;</span>销量升序<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&#x27;down&#x27;</span>&gt;</span>销量降序<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> cups = [</span></span><br><span class="line"><span class="javascript">                &#123; <span class="attr">type</span>: <span class="number">1</span>, <span class="attr">price</span>: <span class="number">100</span>, <span class="attr">color</span>: <span class="string">&#x27;black&#x27;</span>, <span class="attr">sales</span>: <span class="number">3000</span>, <span class="attr">name</span>: <span class="string">&#x27;牛客logo马克杯&#x27;</span> &#125;,</span></span><br><span class="line"><span class="javascript">                &#123; <span class="attr">type</span>: <span class="number">2</span>, <span class="attr">price</span>: <span class="number">40</span>, <span class="attr">color</span>: <span class="string">&#x27;blue&#x27;</span>, <span class="attr">sales</span>: <span class="number">1000</span>, <span class="attr">name</span>: <span class="string">&#x27;无盖星空杯&#x27;</span> &#125;,</span></span><br><span class="line"><span class="javascript">                &#123; <span class="attr">type</span>: <span class="number">4</span>, <span class="attr">price</span>: <span class="number">60</span>, <span class="attr">color</span>: <span class="string">&#x27;green&#x27;</span>, <span class="attr">sales</span>: <span class="number">200</span>, <span class="attr">name</span>: <span class="string">&#x27;老式茶杯&#x27;</span> &#125;,</span></span><br><span class="line"><span class="javascript">                &#123; <span class="attr">type</span>: <span class="number">3</span>, <span class="attr">price</span>: <span class="number">50</span>, <span class="attr">color</span>: <span class="string">&#x27;green&#x27;</span>, <span class="attr">sales</span>: <span class="number">600</span>, <span class="attr">name</span>: <span class="string">&#x27;欧式印花杯&#x27;</span> &#125;</span></span><br><span class="line"><span class="javascript">            ]</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;ul&#x27;</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> upbtn = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.up&#x27;</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> downbtn = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.down&#x27;</span>);</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 补全代码</span></span></span><br><span class="line"><span class="javascript">            render(cups)</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">cups</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                ul.innerHTML= <span class="string">&#x27;&#x27;</span></span></span><br><span class="line"><span class="javascript">                cups.forEach(<span class="function"><span class="params">cup</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">const</span> li = <span class="built_in">document</span>.createElement(<span class="string">&#x27;li&#x27;</span>);</span></span><br><span class="line"><span class="javascript">                    li.innerHTML = i=cup.name;</span></span><br><span class="line"><span class="javascript">                    ul.appendChild(li)</span></span><br><span class="line"><span class="javascript">                &#125;)</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">            upbtn.onclick = <span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">                cups = cups.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a.sales - b.sales)</span></span><br><span class="line"><span class="javascript">                render(cups)</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">            downbtn.onclick=<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">                cups = cups.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>b.sales - a.sales)</span></span><br><span class="line"><span class="javascript">                render(cups)</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="JS9-新数组"><a href="#JS9-新数组" class="headerlink" title="JS9 新数组"></a>JS9 新数组</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">utf-8</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">            pre&#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">font-size</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">请补全JavaScript代码，该函数接受两个参数分别为数组、索引值，要求在不改变原数组的情况下返回删除了索引项的新数组。</span><br><span class="line">        <span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    	</span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> _delete = <span class="function">(<span class="params">array,index</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 补全代码</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">const</span> newArr = [...array];</span></span><br><span class="line"><span class="javascript">                newArr.splice(index,<span class="number">1</span>);</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> newArr</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(_delete([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],<span class="number">2</span>))</span></span><br><span class="line"><span class="javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="JS10-计数器"><a href="#JS10-计数器" class="headerlink" title="JS10 计数器"></a>JS10 计数器</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">utf-8</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">            pre&#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">font-size</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">请补全JavaScript代码，要求每次调用函数&quot;closure&quot;时会返回一个新计数器。每当调用某个计数器时会返回一个数字且该数字会累加1。</span><br><span class="line">注意：</span><br><span class="line">1. 初次调用返回值为1</span><br><span class="line">2. 每个计数器所统计的数字是独立的        </span><br><span class="line">        <span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    	</span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> closure = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 补全代码</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">let</span> count = <span class="number">1</span>;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> <span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">return</span> count++;</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">            闭包的应用</span><br><span class="line">        <span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="JS11-列表动态渲染"><a href="#JS11-列表动态渲染" class="headerlink" title="JS11 列表动态渲染"></a>JS11 列表动态渲染</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">            pre&#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">font-size</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">请补全JavaScript代码，将预设代码中的&quot;people&quot;数组渲染在页面中。实现下面的列表：</span><br><span class="line">牛油1号 20岁</span><br><span class="line">牛油2号 21岁</span><br><span class="line">牛油3号 19岁</span><br><span class="line">        <span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> people = [</span></span><br><span class="line"><span class="javascript">                &#123; <span class="attr">name</span>: <span class="string">&#x27;牛油1号&#x27;</span>, <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;,</span></span><br><span class="line"><span class="javascript">                &#123; <span class="attr">name</span>: <span class="string">&#x27;牛油2号&#x27;</span>, <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">age</span>: <span class="number">21</span> &#125;,</span></span><br><span class="line"><span class="javascript">                &#123; <span class="attr">name</span>: <span class="string">&#x27;牛油3号&#x27;</span>, <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">age</span>: <span class="number">19</span> &#125;,</span></span><br><span class="line"><span class="javascript">            ]</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;ul&#x27;</span>);</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 补全代码</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;people.length;i++)&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">const</span> li = <span class="built_in">document</span>.createElement(<span class="string">&#x27;li&#x27;</span>);</span></span><br><span class="line"><span class="javascript">                <span class="keyword">const</span> spanName = <span class="built_in">document</span>.createElement(<span class="string">&#x27;span&#x27;</span>);</span></span><br><span class="line"><span class="javascript">                <span class="keyword">const</span> spanAge = <span class="built_in">document</span>.createElement(<span class="string">&#x27;sapn&#x27;</span>);</span></span><br><span class="line"><span class="javascript">                spanName.innerText = people[i].name;</span></span><br><span class="line"><span class="javascript">                spanAge.innerText = <span class="string">&quot; &quot;</span>+ people[i].age + <span class="string">&quot;岁&quot;</span>;</span></span><br><span class="line"><span class="javascript">                li.appendChild(spanName)</span></span><br><span class="line"><span class="javascript">                li.appendChild(spanAge)</span></span><br><span class="line"><span class="javascript">                ul.appendChild(li)</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="JS12-模板字符串"><a href="#JS12-模板字符串" class="headerlink" title="JS12 模板字符串"></a>JS12 模板字符串</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">            pre&#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">font-size</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">请补全JavaScript代码，实现以下功能：</span><br><span class="line">1.根据已有的person对象的注册时间求出距离当前时间的天数（天数向下取整）。</span><br><span class="line">2. 将获得的天数和person数据拼接成字符串，作为h2标签的内容。</span><br><span class="line">注意：</span><br><span class="line">使用模板字符串进行字符串拼接，字符串最终内容如：尊贵的牛客网2级用户小丽您好，您已经注册牛客网3天啦~</span><br><span class="line">        <span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> person = &#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">level</span>: <span class="string">&#x27;2&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                <span class="attr">name</span>: <span class="string">&#x27;小丽&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                <span class="attr">registTime</span>: <span class="string">&#x27;2021-11-01&#x27;</span>,</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> h2 = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;h2&#x27;</span>);</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 补全代码</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> registDate = <span class="keyword">new</span> <span class="built_in">Date</span>(person.registTime);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> registMilTime = registDate.valueOf();</span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> nowMilTime = <span class="keyword">new</span> <span class="built_in">Date</span>().valueOf();</span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> days = <span class="built_in">Math</span>.floor((nowMilTime - registMilTime) / (<span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span>* <span class="number">24</span>));</span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> str = <span class="string">`尊贵的牛客网<span class="subst">$&#123;person.level&#125;</span>级用户<span class="subst">$&#123;person.name&#125;</span>您好，您已经注册牛客网<span class="subst">$&#123;days&#125;</span>天啦~`</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;h2&#x27;</span>)[<span class="number">0</span>].innerText = str;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            </span></span><br><span class="line"><span class="javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="JS13-类继承"><a href="#JS13-类继承" class="headerlink" title="JS13 类继承"></a>JS13 类继承</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">utf-8</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">            pre&#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">font-size</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">请补全JavaScript代码，完成类的继承。要求如下：</span><br><span class="line">1. &quot;Chinese&quot;类继承于&quot;Human&quot;类</span><br><span class="line">2. &quot;Human&quot;类实现一个函数&quot;getName&quot;，返回该实例的&quot;name&quot;属性</span><br><span class="line">3. &quot;Chinese&quot;类构造函数有两个参数，分别为&quot;name&quot;、&quot;age&quot;</span><br><span class="line">4. &quot;Chinese&quot;类实现一个函数&quot;getAge&quot;，返回该实例的&quot;age&quot;属性</span><br><span class="line">        <span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">this</span>.name = name</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">this</span>.kingdom = <span class="string">&#x27;animal&#x27;</span></span></span><br><span class="line"><span class="javascript">                    <span class="built_in">this</span>.color = [<span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;white&#x27;</span>, <span class="string">&#x27;brown&#x27;</span>, <span class="string">&#x27;black&#x27;</span>]</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 补全代码</span></span></span><br><span class="line"><span class="javascript">                <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 补全代码</span></span></span><br><span class="line"><span class="javascript">            <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="function"><span class="title">constructor</span>(<span class="params">name,age</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">super</span>(name)</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">this</span>.age = age;</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">                <span class="function"><span class="title">getAge</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">return</span> <span class="built_in">this</span>.age;</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="JS14-参数解析器"><a href="#JS14-参数解析器" class="headerlink" title="JS14 参数解析器"></a>JS14 参数解析器</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">            pre&#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">font-size</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">描述:</span><br><span class="line">请补全JavaScript代码，要求将字符串参数URL中的参数解析并以对象的形式返回。</span><br><span class="line"></span><br><span class="line">示例1</span><br><span class="line">输入：</span><br><span class="line">getParams(&#x27;https://nowcoder.com/online?id=1&amp;salas=1000&#x27;)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">&#123;id:1, salas: 100&#125;      </span><br><span class="line">        <span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 第一种</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// const _getParams = (url) =&gt; &#123;</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//     // 补全代码</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//     const index = url.indexOf(&#x27;?&#x27;);</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//     const str = url.slice(index+1)</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//     const arr = str.split(&#x27;&amp;&#x27;);</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//     const obj = &#123;&#125;;</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//     arr.forEach(item=&gt;&#123;</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//         const temp  =item.split(&#x27;=&#x27;);</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//         obj[temp[0]] = temp[1];</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//     &#125;)</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//     return obj;</span></span></span><br><span class="line"><span class="javascript">                </span></span><br><span class="line"><span class="javascript">            <span class="comment">// &#125;</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 第二种</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> _getParams = <span class="function">(<span class="params">url</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 补全代码</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">const</span> arr = url.split(<span class="string">&#x27;?&#x27;</span>)[<span class="number">1</span>].split(<span class="string">&#x27;&amp;&#x27;</span>);</span></span><br><span class="line"><span class="javascript">                <span class="keyword">const</span> obj = &#123;&#125;;</span></span><br><span class="line"><span class="javascript">                arr.forEach(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">const</span> temp  =item.split(<span class="string">&#x27;=&#x27;</span>);</span></span><br><span class="line"><span class="javascript">                    obj[temp[<span class="number">0</span>]] = temp[<span class="number">1</span>];</span></span><br><span class="line"><span class="javascript">                &#125;)</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> obj;</span></span><br><span class="line"><span class="javascript">                </span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(_getParams(<span class="string">&#x27;https://nowcoder.com/online?id=1&amp;salas=1000&#x27;</span>))</span></span><br><span class="line"><span class="javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="JS15-生成页码"><a href="#JS15-生成页码" class="headerlink" title="JS15 生成页码"></a>JS15 生成页码</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">utf-8</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">            pre&#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">font-size</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">描述:</span><br><span class="line">请补全JavaScript代码，要求根据参数动态生成&quot;li&quot;标签页码并插入&quot;ul&quot;标签下。要求如下：</span><br><span class="line">1. &quot;allItem&quot;为总数据项个数，&quot;pageItem&quot;为每页的数据项个数</span><br><span class="line">2. &quot;li&quot;标签内容为当前页码数，页码从1开始</span><br><span class="line"></span><br><span class="line">示例1</span><br><span class="line">输入：</span><br><span class="line">_createPage(13,2)</span><br><span class="line">输出：</span><br><span class="line">&quot;li&quot;长度为7，&quot;li&quot;内容依次为&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;ul&quot;</span>&gt;</span></span><br><span class="line">            </span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 第一种</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// const _createPage = (allItem, pageItem) =&gt; &#123;</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//     // 补全代码</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//     const pageNum = Math.ceil(allItem / pageItem);</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//     const container = document.querySelector(&#x27;#ul&#x27;);</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//     for(let i = 1;i&lt;=pageNum;i++)&#123;</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//         const li = document.createElement(&#x27;li&#x27;);</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//         li.innerText = i;</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//         container.appendChild(li)</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//     &#125;</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// &#125;</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> _createPage = <span class="function">(<span class="params">allItem, pageItem</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 补全代码</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">const</span> pageNum = <span class="built_in">Math</span>.ceil(allItem / pageItem);</span></span><br><span class="line"><span class="javascript">                <span class="keyword">let</span> html = <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>;i&lt;=pageNum;i++)&#123;</span></span><br><span class="line"><span class="javascript">                    html += <span class="string">&#x27;&lt;li&gt;&#x27;</span> + i + <span class="string">&#x27;&lt;/li&gt;&#x27;</span></span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">                ul.innerHTML = html;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            _createPage(<span class="number">13</span>,<span class="number">2</span>)</span></span><br><span class="line"><span class="javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="JS16-总成绩排名"><a href="#JS16-总成绩排名" class="headerlink" title="JS16 总成绩排名"></a>JS16 总成绩排名</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">utf-8</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">            pre&#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">font-size</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">请补全JavaScript代码，要求将数组参数中的对象以总成绩(包括属性&quot;chinese&quot;、&quot;math&quot;、&quot;english&quot;)从高到低进行排序并返回。  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> _rank = <span class="function"><span class="params">array</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 补全代码</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> array.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>(b.chinese +b.math +b.english)-(a.chinese +a.math +a.english))</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(_rank([</span></span><br><span class="line"><span class="javascript">        &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">chinese</span>:<span class="number">1</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">math</span>:<span class="number">2</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">english</span>:<span class="number">3</span></span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">chinese</span>:<span class="number">1</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">math</span>:<span class="number">3</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">english</span>:<span class="number">3</span></span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">chinese</span>:<span class="number">3</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">math</span>:<span class="number">3</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">english</span>:<span class="number">3</span></span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">        ]))</span></span><br><span class="line"><span class="javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>




<h2 id="JS17-子字符串频次"><a href="#JS17-子字符串频次" class="headerlink" title="JS17 子字符串频次"></a>JS17 子字符串频次</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">            pre&#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">font-size</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">                <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">请补全JavaScript代码，该函数接受两个参数分别为字符串、子字符串，要求返回子字符串在字符串中出现的频次。</span><br><span class="line">        <span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 第一种</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> _searchStrIndexOf = <span class="function">(<span class="params">str, target</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 补全代码</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">let</span> fromIndex  = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">let</span> count = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">while</span>(str.indexOf(target,fromIndex) !== -<span class="number">1</span>)&#123;</span></span><br><span class="line"><span class="javascript">                    count++;</span></span><br><span class="line"><span class="javascript">                    fromIndex = str.indexOf(target,fromIndex) + target.length;</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> count;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(_searchStrIndexOf(<span class="string">&quot;abcdeabfghabisdsa&quot;</span>,<span class="string">&#x27;ab&#x27;</span>))</span></span><br><span class="line"><span class="javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="JS18-继承"><a href="#JS18-继承" class="headerlink" title="JS18 继承"></a>JS18 继承</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">utf-8</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">            pre&#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">font-size</span>:<span class="number">20px</span>;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">请补全JavaScript代码，实现以下功能：</span><br><span class="line">1.给&quot;Human&quot;构造函数的原型对象添加&quot;getName&quot;方法，返回当前实例&quot;name&quot;属性</span><br><span class="line">2. 将&quot;Chinese&quot;构造函数继承于&quot;Human&quot;构造函数</span><br><span class="line">3. 给&quot;Chinese&quot;构造函数的原型对象添加&quot;getAge&quot;方法，返回当前实例&quot;age&quot;属性</span><br><span class="line">        <span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="keyword">function</span> <span class="title">Human</span>(<span class="params">name</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.name = name</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.kingdom = <span class="string">&#x27;animal&#x27;</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.color = [<span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;white&#x27;</span>, <span class="string">&#x27;brown&#x27;</span>, <span class="string">&#x27;black&#x27;</span>]</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">            </span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="keyword">function</span> <span class="title">Chinese</span>(<span class="params">name,age</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                Human.call(<span class="built_in">this</span>,name)</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.age = age</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.color = <span class="string">&#x27;yellow&#x27;</span></span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 补全代码</span></span></span><br><span class="line"><span class="javascript">            Human.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> <span class="built_in">this</span>.name;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">            Chinese.prototype = <span class="keyword">new</span> Human();</span></span><br><span class="line"><span class="javascript">            Chinese.prototype.constructor = Chinese;</span></span><br><span class="line"><span class="javascript">            Chinese.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> <span class="built_in">this</span>.age</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">            </span></span><br><span class="line"><span class="javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="JS19-判断斐波那契数组"><a href="#JS19-判断斐波那契数组" class="headerlink" title="JS19 判断斐波那契数组"></a>JS19 判断斐波那契数组</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">utf-8</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">            pre&#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">font-size</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">请补全JavaScript代码，要求以Boolean的形式返回参数数组是否为斐波那契数列。在数学上，斐波那契数列以如下方法定义：F(0)=0，F(1)=1, F(n)=F(n - 1)+F(n - 2)（n ≥ 2，n ∈ N）</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">1. [0,1,1]为最短有效斐波那契数列</span><br><span class="line">        <span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> _isFibonacci = <span class="function"><span class="params">array</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 补全代码</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span>(array.length &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span>;i&lt;array.length-<span class="number">2</span>;i++)&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">if</span>(array[i] + array[i+<span class="number">1</span>] != array[i+<span class="number">2</span>])&#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">                    &#125;</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(_isFibonacci([<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]))</span></span><br><span class="line"><span class="javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="JS20-数组扁平化"><a href="#JS20-数组扁平化" class="headerlink" title="JS20 数组扁平化"></a>JS20 数组扁平化</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">            pre&#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">font-size</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">请补全JavaScript代码，要求将数组参数中的多维数组扩展为一维数组并返回该数组。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">1. 数组参数中仅包含数组类型和数字类型</span><br><span class="line"></span><br><span class="line">示例1</span><br><span class="line">输入：</span><br><span class="line">[1,[2,[3,[4]]]]</span><br><span class="line">输出：</span><br><span class="line">[1,2,3,4]</span><br><span class="line">        <span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> _flatten = <span class="function"><span class="params">arr</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 补全代码</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">const</span> str = <span class="built_in">String</span>(arr);</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> str.split(<span class="string">&#x27;,&#x27;</span>).map(<span class="function"><span class="params">item</span>=&gt;</span>+item)</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(_flatten([<span class="number">1</span>,[<span class="number">2</span>,[<span class="number">3</span>,[<span class="number">4</span>]]]]))</span></span><br><span class="line"><span class="javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="JS21-数组过滤"><a href="#JS21-数组过滤" class="headerlink" title="JS21 数组过滤"></a>JS21 数组过滤</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">            pre&#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">font-size</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">请补全JavaScript代码，要求根据下拉框选中的条件变换重新渲染列表中展示的商品，且只展示符合条件的商品。</span><br><span class="line">注意：</span><br><span class="line">1. 必须使用DOM0级标准事件（onchange）</span><br><span class="line">2. 建议使用ES6的filter方法   </span><br><span class="line">        <span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span>&gt;</span>请选择销量范围<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span>&amp;lt100<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span>100~500<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span>&gt;</span>&amp;gt500<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>牛客logo马克杯<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>无盖星空杯<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>老式茶杯<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>欧式印花杯<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> cups = [</span></span><br><span class="line"><span class="javascript">                &#123; <span class="attr">type</span>: <span class="number">1</span>, <span class="attr">price</span>: <span class="number">100</span>, <span class="attr">color</span>: <span class="string">&#x27;black&#x27;</span>, <span class="attr">sales</span>: <span class="number">60</span>, <span class="attr">name</span>: <span class="string">&#x27;牛客logo马克杯&#x27;</span> &#125;,</span></span><br><span class="line"><span class="javascript">                &#123; <span class="attr">type</span>: <span class="number">2</span>, <span class="attr">price</span>: <span class="number">40</span>, <span class="attr">color</span>: <span class="string">&#x27;blue&#x27;</span>, <span class="attr">sales</span>: <span class="number">100</span>, <span class="attr">name</span>: <span class="string">&#x27;无盖星空杯&#x27;</span> &#125;,</span></span><br><span class="line"><span class="javascript">                &#123; <span class="attr">type</span>: <span class="number">4</span>, <span class="attr">price</span>: <span class="number">60</span>, <span class="attr">color</span>: <span class="string">&#x27;green&#x27;</span>, <span class="attr">sales</span>: <span class="number">200</span>, <span class="attr">name</span>: <span class="string">&#x27;老式茶杯&#x27;</span> &#125;,</span></span><br><span class="line"><span class="javascript">                &#123; <span class="attr">type</span>: <span class="number">3</span>, <span class="attr">price</span>: <span class="number">50</span>, <span class="attr">color</span>: <span class="string">&#x27;green&#x27;</span>, <span class="attr">sales</span>: <span class="number">600</span>, <span class="attr">name</span>: <span class="string">&#x27;欧式印花杯&#x27;</span> &#125;</span></span><br><span class="line"><span class="javascript">            ]</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> select = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;select&#x27;</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;ul&#x27;</span>);</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 补全代码</span></span></span><br><span class="line"><span class="javascript">            select.onchange = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                ul.innerHTML = <span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">const</span> value = e.target.value;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">let</span> filterCups;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">switch</span>(value)&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>: </span></span><br><span class="line"><span class="javascript">                        filterCups = cups.filter(<span class="function"><span class="params">item</span>=&gt;</span>item.sales &lt; <span class="number">100</span>)</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">case</span> <span class="string">&#x27;2&#x27;</span>:</span></span><br><span class="line"><span class="javascript">                        filterCups = cups.filter(<span class="function"><span class="params">item</span>=&gt;</span>(item.sales &lt;= <span class="number">500</span>) &amp;&amp; (item.sales &gt;= <span class="number">100</span>))</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">case</span> <span class="string">&#x27;3&#x27;</span>:</span></span><br><span class="line"><span class="javascript">                        filterCups = cups.filter(<span class="function"><span class="params">item</span>=&gt;</span>item.sales &gt; <span class="number">500</span>)</span></span><br><span class="line"><span class="javascript">                    <span class="attr">default</span>:</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">let</span> str = <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="javascript">                filterCups.forEach(<span class="function"><span class="params">cup</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">                    str += <span class="string">&#x27;&lt;li&gt;&#x27;</span> + cup.name + <span class="string">&#x27;&lt;/li&gt;&#x27;</span></span></span><br><span class="line"><span class="javascript">                &#125;)</span></span><br><span class="line"><span class="javascript">                ul.innerHTML = str;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">            </span></span><br><span class="line"><span class="javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="JS22-判断质数"><a href="#JS22-判断质数" class="headerlink" title="JS22 判断质数"></a>JS22 判断质数</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">utf-8</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">            pre&#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">font-size</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">请补全JavaScript代码，要求在Number对象的原型对象上添加&quot;_isPrime&quot;函数，该函数判断调用的对象是否为一个质数，是则返回true，否则返回false。</span><br><span class="line">        <span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 补全代码</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">Number</span>.prototype._isPrime = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">const</span> value = <span class="built_in">this</span>.valueOf();</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span>(value &lt; <span class="number">2</span>)&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">2</span>;i&lt;value;i++)&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">if</span>(value % i === <span class="number">0</span>)&#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">                    &#125;</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log((<span class="number">2</span>)._isPrime())</span></span><br><span class="line"><span class="javascript">            </span></span><br><span class="line"><span class="javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="JS23-验证是否是身份证"><a href="#JS23-验证是否是身份证" class="headerlink" title="JS23 验证是否是身份证"></a>JS23 验证是否是身份证</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">            pre&#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">font-size</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">请补全JavaScript代码，要求以Boolean的形式返回字符串参数是否符合身份证标准。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">1. 无需考虑地区信息、出生日期、顺序码与校验码的验证</span><br><span class="line"></span><br><span class="line">示例1</span><br><span class="line">输入：</span><br><span class="line">_isCard(&#x27;21062319980907888X&#x27;)</span><br><span class="line">输出：</span><br><span class="line">true</span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> _isCard = <span class="function"><span class="params">number</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 补全代码</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">const</span> length = number.length;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span>(length !== <span class="number">18</span>)&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; length-<span class="number">1</span>; i++)&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">if</span>(number[i] &gt; <span class="string">&#x27;9&#x27;</span> || number[i] &lt; <span class="string">&#x27;0&#x27;</span>)&#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">                    &#125;</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span>(number[length-<span class="number">1</span>]=== <span class="string">&#x27;X&#x27;</span> || number[length-<span class="number">1</span>]=== <span class="string">&#x27;x&#x27;</span>  || (number[length -<span class="number">1</span>] &gt; <span class="string">&#x27;0&#x27;</span> &amp;&amp; number[length-<span class="number">1</span>] &lt; <span class="string">&#x27;9&#x27;</span>))&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">                &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(_isCard(<span class="string">&#x27;21062319980907888X&#x27;</span>))</span></span><br><span class="line"><span class="javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="JS24-Symbol"><a href="#JS24-Symbol" class="headerlink" title="JS24 Symbol"></a>JS24 Symbol</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">utf-8</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">            pre&#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">font-size</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">请补全JavaScript代码，要求以键/值对的对象形式返回参数数组。要求如下：</span><br><span class="line">1. 键名的数据类型为Symbol</span><br><span class="line">2. 键值为当前数组项</span><br><span class="line">3. Symbol的描述为当前数组项</span><br><span class="line">4. 返回普通对象</span><br><span class="line">        <span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> _symbolKey = <span class="function"><span class="params">array</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 补全代码</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">const</span> obj = &#123;&#125;</span></span><br><span class="line"><span class="javascript">                array.forEach(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">                   obj[<span class="built_in">Symbol</span>(item)] = item; </span></span><br><span class="line"><span class="javascript">                &#125;)</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> obj;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(_symbolKey([<span class="number">121</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">23</span>,]))</span></span><br><span class="line"><span class="javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="JS25-相同的Set"><a href="#JS25-相同的Set" class="headerlink" title="JS25 相同的Set"></a>JS25 相同的Set</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">            pre&#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">font-size</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">                <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">            请补全JavaScript代码，要求以boolean的形式返回两个Set对象参数是否一样，是则返回true，否则返回false。</span><br><span class="line">        <span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> _isSameSet = <span class="function">(<span class="params">s1, s2</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 补全代码</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span>(s1.size !== s2.size)&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> s1)&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">if</span>(!s2.has(key))&#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">                    &#125;</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(_isSameSet(<span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">21</span>,<span class="number">32</span>,<span class="number">3</span>]),<span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">32</span>,<span class="number">21</span>,<span class="number">3</span>])))</span></span><br><span class="line"><span class="javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="JS26-Getter"><a href="#JS26-Getter" class="headerlink" title="JS26 Getter"></a>JS26 Getter</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">utf-8</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">            pre&#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">font-size</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">请补全JavaScript代码，完成名为&quot;Rectangle&quot;的矩形类。要求如下：</span><br><span class="line">1. 构造函数只包含两个参数，依次为&quot;height&quot;、&quot;width&quot;</span><br><span class="line">2. 设置Getter，当获取该对象的&quot;area&quot;属性时，返回该对象&quot;height&quot;与&quot;width&quot;属性的乘积</span><br><span class="line"></span><br><span class="line">示例1</span><br><span class="line">输入：</span><br><span class="line">new Rectangle(12,12).area</span><br><span class="line">输出：</span><br><span class="line">144    </span><br><span class="line">        <span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 补全代码</span></span></span><br><span class="line"><span class="javascript">                <span class="function"><span class="title">constructor</span>(<span class="params">height,width</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">this</span>.height = height,</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">this</span>.width = width</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">                <span class="keyword">get</span> <span class="title">area</span>()&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">return</span> <span class="built_in">this</span>.height * <span class="built_in">this</span>.width;</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="keyword">new</span> Rectangle(<span class="number">12</span>,<span class="number">12</span>).area)</span></span><br><span class="line"><span class="javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="JS27-控制动画"><a href="#JS27-控制动画" class="headerlink" title="JS27 控制动画"></a>JS27 控制动画</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">utf-8</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">            pre&#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">font-size</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">            <span class="selector-id">#rect</span> &#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">width</span>: <span class="number">120px</span>;</span></span><br><span class="line"><span class="css">                <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">                <span class="attribute">background-color</span>: black;</span></span><br><span class="line"><span class="css">                <span class="comment">/*补全代码*/</span></span></span><br><span class="line"><span class="css">                <span class="attribute">animation</span>:rect <span class="number">10s</span> infinite;</span></span><br><span class="line"><span class="css">                </span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">            <span class="keyword">@keyframes</span> rect &#123;</span></span><br><span class="line"><span class="css">                <span class="selector-tag">from</span> &#123;</span></span><br><span class="line"><span class="css">                    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>);</span></span><br><span class="line"><span class="css">                &#125;</span></span><br><span class="line"><span class="css">                <span class="selector-tag">to</span> &#123;</span></span><br><span class="line"><span class="css">                    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">360deg</span>);</span></span><br><span class="line"><span class="css">                &#125;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">请补全代码，要求当滑动id为&quot;range&quot;的滑块控件时可以改变id为&quot;rect&quot;的矩形旋转速度。要求如下：</span><br><span class="line">1. id为&quot;rect&quot;的矩形初始动画周期为10秒</span><br><span class="line">2. id为&quot;range&quot;的滑块控件默认值为1、最小值为、最大值为10、滑动间隔为1</span><br><span class="line">3. 当滑动滑块值为1时，矩形动画周期为10秒、当...，为...、当滑动滑块值为10时，矩形动画周期为1秒</span><br><span class="line">注意：</span><br><span class="line">1. 必须使用DOM0级标准事件（onchange）</span><br><span class="line">        <span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 补全代码 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;rect&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;range&quot;</span> /&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 补全代码</span></span></span><br><span class="line"><span class="javascript">            range.onchange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="built_in">this</span>.value)</span></span><br><span class="line"><span class="javascript">                <span class="keyword">let</span> value = <span class="built_in">Number</span>(<span class="built_in">this</span>.value);</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span>(value &gt;=<span class="number">1</span> &amp;&amp; value &lt;=<span class="number">10</span>)&#123;</span></span><br><span class="line"><span class="javascript">                    rect.style.animation = <span class="string">`rect <span class="subst">$&#123;<span class="number">10</span> - value + <span class="number">1</span>&#125;</span>s infinite`</span></span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">                </span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">            </span></span><br><span class="line"><span class="javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="JS28-Map保存节点"><a href="#JS28-Map保存节点" class="headerlink" title="JS28 Map保存节点"></a>JS28 Map保存节点</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">utf-8</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">            pre&#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">font-size</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">                <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">            请补全JavaScript代码，要求将页面中的&quot;p&quot;标签以键名的形式保存在Map对象中，键名所对应的键值为该&quot;p&quot;标签的文字内容。</span><br><span class="line">        <span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> _elementKey = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 补全代码</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span></span><br><span class="line"><span class="javascript">                <span class="keyword">const</span> p = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;p&#x27;</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript">                map.set(p,p.innerText);</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> map;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(_elementKey())</span></span><br><span class="line"><span class="javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="JS29-全选"><a href="#JS29-全选" class="headerlink" title="JS29 全选"></a>JS29 全选</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">            pre&#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">font-size</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">ul</span> &#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">list-style</span>: none;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">请补全JavaScript代码，实现以下效果：</span><br><span class="line">1. 选中&quot;全选&quot;框，以下所有选项全部勾选。</span><br><span class="line">2. 把&quot;全选&quot;框从选中状态勾选成未选中状态，其他复选框全部取消选中效果。</span><br><span class="line">3. 当其他复选框全部选中，&quot;全选框&quot;为选中状态。</span><br><span class="line">4. 当其他复选框有一个未选中，&quot;全选框&quot;取消选中状态。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">1. 必须使用DOM0级标准事件（onchange）</span><br><span class="line">        <span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>全选<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;checkbox&#x27;</span> <span class="attr">id</span>=<span class="string">&#x27;all&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>Java<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;checkbox&#x27;</span> <span class="attr">class</span>=<span class="string">&#x27;item&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>javaScript<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;checkbox&#x27;</span> <span class="attr">class</span>=<span class="string">&#x27;item&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>C++<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;checkbox&#x27;</span> <span class="attr">class</span>=<span class="string">&#x27;item&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>python<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;checkbox&#x27;</span> <span class="attr">class</span>=<span class="string">&#x27;item&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>.net<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;checkbox&#x27;</span> <span class="attr">class</span>=<span class="string">&#x27;item&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 第一种方法，不知道为啥，本地调试没问题，就是过不了</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 补全代码</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> items = [...document.getElementsByClassName(<span class="string">&#x27;item&#x27;</span>)];</span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> all = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;all&#x27;</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(items.length).fill(<span class="literal">false</span>);</span></span><br><span class="line"><span class="javascript">            items.forEach(<span class="function">(<span class="params">item,index</span>)=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">                item.onchange=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">if</span>(<span class="built_in">this</span>.checked)&#123;</span></span><br><span class="line"><span class="javascript">                        arr[index] = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">                    &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">                        arr[index] = <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">                    &#125;</span></span><br><span class="line"><span class="javascript">                    render()  </span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">                                  </span></span><br><span class="line"><span class="javascript">            &#125;)</span></span><br><span class="line"><span class="javascript">            all.onchange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span>(<span class="built_in">this</span>.checked)&#123;</span></span><br><span class="line"><span class="javascript">                    arr = arr.map(<span class="function"><span class="params">item</span>=&gt;</span>item=<span class="literal">true</span>)</span></span><br><span class="line"><span class="javascript">                &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">                    arr = arr.map(<span class="function"><span class="params">item</span>=&gt;</span>item=<span class="literal">false</span>)</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">                render();</span></span><br><span class="line"><span class="javascript">                items.forEach(<span class="function"><span class="params">i</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(i.checked)</span></span><br><span class="line"><span class="javascript">                &#125;)</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">let</span> flag = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span>;i&lt;items.length;i++)&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">if</span>(arr[i])&#123;</span></span><br><span class="line"><span class="javascript">                        items[i].checked = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">                    &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">                        flag = <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">                        items[i].checked = <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">                    &#125;</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span>(flag)&#123;</span></span><br><span class="line"><span class="javascript">                    all.checked = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">                &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">                    all.checked = <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 第二种方法</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> all = <span class="built_in">document</span>.getElementById(<span class="string">&quot;all&quot;</span>)</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> options = <span class="built_in">Array</span>.from(<span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;.item&quot;</span>))</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 补全代码</span></span></span><br><span class="line"><span class="javascript">            all.onchange = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                options.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                    item.checked = all.checked</span></span><br><span class="line"><span class="javascript">                &#125;)</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">            options.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                item.onchange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">let</span> isCheckAll = <span class="literal">true</span></span></span><br><span class="line"><span class="javascript">                    options.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">if</span> (!item.checked) &#123;</span></span><br><span class="line"><span class="javascript">                            isCheckAll = <span class="literal">false</span></span></span><br><span class="line"><span class="javascript">                        &#125;</span></span><br><span class="line"><span class="javascript">                    &#125;)</span></span><br><span class="line"><span class="javascript">                    all.checked = isCheckAll</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">            &#125;)</span></span><br><span class="line"><span class="javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="JS30-回文字符串"><a href="#JS30-回文字符串" class="headerlink" title="JS30 回文字符串"></a>JS30 回文字符串</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">utf-8</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">            pre&#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">font-size</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">                <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">            请补全JavaScript代码，要求以boolean的形式返回参数字符串是否为回文字符串。</span><br><span class="line">        <span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> _isPalindrome = <span class="function"><span class="params">string</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 补全代码</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">const</span> length = string.length;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;<span class="built_in">Math</span>.floor(length / <span class="number">2</span>);i++)&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">if</span>(string[i]!==string[length-<span class="number">1</span>-i])&#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">                    &#125;</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(_isPalindrome(<span class="string">&quot;asdffdsa&quot;</span>))</span></span><br><span class="line"><span class="javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>牛客</category>
        <category>JS能力测评</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>牛客</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式的原则</title>
    <url>/135xyq.github.io/2022/02/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="设计模式的定义"><a href="#设计模式的定义" class="headerlink" title="设计模式的定义"></a>设计模式的定义</h2><p>设计模式是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。</p>
<h2 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h2><p> 减少耦合，增强复用性，降低代码的开发维护扩展成本(优先降低复杂度，尽量降低耦合度)。</p>
<ol>
<li>单一职责原则（一个方法只做一件事）</li>
<li>开闭原则OCP</li>
<li>里氏代换原则(子类可以扩展父类的的功能，但不能更改父类原有的功能)</li>
<li>依赖倒置原则DIP</li>
<li>迪米特法则（最小知道原则)(传入参数越少越好)(依赖越少越好)</li>
<li>接口分离原则ISP(把大接口拆分成小接口)</li>
</ol>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构和算法</title>
    <url>/135xyq.github.io/2022/04/29/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>便于存取</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>删除消耗性能</li>
<li>占用一段连续的存储空间</li>
</ol>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ol>
<li>删除效率高</li>
<li>不占用连续的存储空间</li>
</ol>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>查询效率低</p>
<h3 id="创建一个链表"><a href="#创建一个链表" class="headerlink" title="创建一个链表"></a>创建一个链表</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">    <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> list = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> temp = list;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">    temp.next = <span class="keyword">new</span> Node(i + <span class="number">1</span>);</span><br><span class="line">    temp = temp.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="遍历链表"><a href="#遍历链表" class="headerlink" title="遍历链表"></a>遍历链表</h3><h4 id="普通while循环遍历"><a href="#普通while循环遍历" class="headerlink" title="普通while循环遍历"></a>普通while循环遍历</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">traversal</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(root.value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root = root.next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="递归遍历链表"><a href="#递归遍历链表" class="headerlink" title="递归遍历链表"></a>递归遍历链表</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">traversalRecursion</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(root.value);</span><br><span class="line">    traversalRecursion(root.next)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链表逆置"><a href="#链表逆置" class="headerlink" title="链表逆置"></a>链表逆置</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseLink</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root.next.next) &#123;</span><br><span class="line">        root.next.next = root;</span><br><span class="line">        <span class="keyword">return</span> root.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> result = reverseLink(root.next);</span><br><span class="line">        root.next.next = root;</span><br><span class="line">        root.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入两个参数，比较是否需要交换，flag为1表示升序，flag = 0表示降序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> </span>a </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> </span>b </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> </span>flag 1 &#125;| 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">a, b, flag = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="keyword">return</span> a - b &gt; <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a - b &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 交换数组链各个位置的数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;array&#125;</span> </span>arr </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> </span>a </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> </span>b </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">exchange</span>(<span class="params">arr, a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> temp = arr[a];</span><br><span class="line">    arr[a] = arr[b];</span><br><span class="line">    arr[b] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>每次将最大或最小的数，通过数组前后两两交换，冒泡到数组的最后一位。<br>数组顺序越混乱，效率越低。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;array&#125;</span> </span>arr </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compare(arr[j], arr[j + <span class="number">1</span>])) &#123;</span><br><span class="line">                exchange(arr, j, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>通过找出数组中除去已排好位置中的最大值或最小值，把它放到数组中未排序部分的最前面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选择排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;array&#125;</span> </span>arr </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compare(arr[i], arr[j], <span class="number">0</span>)) &#123;</span><br><span class="line">                exchange(arr, i, j);</span><br><span class="line">                <span class="built_in">console</span>.log(arr)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>数组顺序越乱，效率越高。</p>
<h4 id="一种简单的实现，消耗性能-创建多个数组"><a href="#一种简单的实现，消耗性能-创建多个数组" class="headerlink" title="一种简单的实现，消耗性能(创建多个数组)"></a>一种简单的实现，消耗性能(创建多个数组)</h4><p>每次都找一个领导者，大于这个数的都放在left数组中，大于这个数的都放在right数组中，再对left和right重复操作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr === <span class="literal">null</span> || arr.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> leader = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> left = [];</span><br><span class="line">    <span class="keyword">let</span> right = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; leader) &#123;</span><br><span class="line">            left.push(arr[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    left = quickSort(left);</span><br><span class="line">    right = quickSort(right);</span><br><span class="line">    left.push(leader);</span><br><span class="line">    <span class="keyword">return</span> left.concat(right)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="效率高"><a href="#效率高" class="headerlink" title="效率高"></a>效率高</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>arr 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>begin 数组开始处理的位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>end 数组结束处理的位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr, begin, end</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (begin &gt;= end - <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">let</span> left = begin;</span><br><span class="line">    <span class="keyword">let</span> right = end;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 找出连续的两段数组，左边一段比领导者，右边一段比领导者大，领导者为arr[begin]</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt; arr[begin]);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125; <span class="keyword">while</span> (right &gt; left &amp;&amp; arr[right] &gt; arr[begin]);</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            exchange(arr, left, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (left &lt; right);</span><br><span class="line">    <span class="keyword">const</span> swapPointer = left == right ? right - <span class="number">1</span> : right;</span><br><span class="line">    exchange(arr, begin, swapPointer);</span><br><span class="line">    quickSort(arr, begin, swapPointer);</span><br><span class="line">    quickSort(arr, swapPointer + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>先进后出</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stack</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.arr = [];</span><br><span class="line">    <span class="built_in">this</span>.pop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.arr.pop();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">this</span>.push = <span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.arr.push(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>先进先出</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Queue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.arr = [];</span><br><span class="line">    <span class="built_in">this</span>.pop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.arr.shift();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.push = <span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.arr.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><p>无论给出哪一个节点，都能对整个链表进行遍历</p>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><p>多耗费一个引用空间，且构建较为麻烦</p>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>创建一个二叉树</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Root</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">    <span class="built_in">this</span>.leftChild = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>.rightChild = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> Root(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> Root(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Root(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> d = <span class="keyword">new</span> Root(<span class="string">&#x27;d&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> e = <span class="keyword">new</span> Root(<span class="string">&#x27;e&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> f = <span class="keyword">new</span> Root(<span class="string">&#x27;f&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> g = <span class="keyword">new</span> Root(<span class="string">&#x27;g&#x27;</span>);</span><br><span class="line"></span><br><span class="line">a.leftChild = b;</span><br><span class="line">a.rightChild = c;</span><br><span class="line">b.leftChild = d;</span><br><span class="line">b.rightChild = e;</span><br><span class="line">c.leftChild = f;</span><br><span class="line">c.rightChild = g;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h3><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><p>先根，再左子树点再遍历右子树</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">frontTraversal</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(root.value);</span><br><span class="line">    frontTraversal(root.leftChild);</span><br><span class="line">    frontTraversal(root.rightChild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>先左子树，再根节点，最后遍历右子树</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">middleTraversal</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    middleTraversal(root.leftChild);</span><br><span class="line">    <span class="built_in">console</span>.log(root.value);</span><br><span class="line">    middleTraversal(root.rightChild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>先左子树，再右子树，最后是根节点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lastTraversal</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    lastTraversal(root.leftChild);</span><br><span class="line">    lastTraversal(root.rightChild);</span><br><span class="line">    <span class="built_in">console</span>.log(root.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="还原二叉树"><a href="#还原二叉树" class="headerlink" title="还原二叉树"></a>还原二叉树</h3><h4 id="根据前序和中序遍历结果还原二叉树"><a href="#根据前序和中序遍历结果还原二叉树" class="headerlink" title="根据前序和中序遍历结果还原二叉树"></a>根据前序和中序遍历结果还原二叉树</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">    <span class="built_in">this</span>.leftChild = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>.rightChild = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据树的中序和前序遍历结果还原二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">frontMiddleToTree</span>(<span class="params">front, middle</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (front === <span class="literal">null</span> || middle === <span class="literal">null</span> || front.length === <span class="number">0</span> || middle.length === <span class="number">0</span> || front.length !== middle.length) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">const</span> root = <span class="keyword">new</span> Node(front[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">const</span> rootIndex = middle.indexOf(root.value); <span class="comment">//在中序遍历中找到根节点的位置</span></span><br><span class="line">    <span class="keyword">const</span> frontLeft = front.slice(<span class="number">1</span>, rootIndex + <span class="number">1</span>); <span class="comment">//在前序遍历中的左子树</span></span><br><span class="line">    <span class="keyword">const</span> frontRight = front.slice(rootIndex + <span class="number">1</span>); <span class="comment">//在前序遍历中的右子树</span></span><br><span class="line">    <span class="keyword">const</span> middleLeft = middle.slice(<span class="number">0</span>, rootIndex); <span class="comment">//在中序遍历中的左子树</span></span><br><span class="line">    <span class="keyword">const</span> middleRight = middle.slice(rootIndex + <span class="number">1</span>); <span class="comment">// 在中序遍历中的右子树</span></span><br><span class="line">    root.leftChild = frontMiddleToTree(frontLeft, middleLeft);</span><br><span class="line">    root.rightChild = frontMiddleToTree(frontRight, middleRight);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="根据后序和中序遍历结果还原二叉树"><a href="#根据后序和中序遍历结果还原二叉树" class="headerlink" title="根据后序和中序遍历结果还原二叉树"></a>根据后序和中序遍历结果还原二叉树</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> middle = [<span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;E&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> last = [<span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;A&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">    <span class="built_in">this</span>.leftChild = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>.rightChild = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据树的中序和后序遍历结果还原二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">middleLastToTree</span>(<span class="params">middle, last</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (middle === <span class="literal">null</span> || last === <span class="literal">null</span> || middle.length === <span class="number">0</span> || last.length === <span class="number">0</span> || middle.length !== last.length) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">const</span> root = <span class="keyword">new</span> Node(last[last.length - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">const</span> rootIndex = middle.indexOf(root.value); <span class="comment">//找到根节点在中序遍历中的位置</span></span><br><span class="line">    <span class="keyword">const</span> lastLeft = last.slice(<span class="number">0</span>, rootIndex);</span><br><span class="line">    <span class="keyword">const</span> lastRight = last.slice(rootIndex, last.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">const</span> middleLeft = middle.slice(<span class="number">0</span>, rootIndex);</span><br><span class="line">    <span class="keyword">const</span> middleRight = middle.slice(rootIndex + <span class="number">1</span>);</span><br><span class="line">    root.leftChild = middleLastToTree(middleLeft, lastLeft);</span><br><span class="line">    root.rightChild = middleLastToTree(middleRight, lastRight);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="二叉树的搜索"><a href="#二叉树的搜索" class="headerlink" title="二叉树的搜索"></a>二叉树的搜索</h3><h4 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h4><p>搜索未知，和前序遍历顺序一致</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 深度优先搜索</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>root 二叉树的根节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>target 要查找的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns </span>true | false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">root, target</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(root)</span><br><span class="line">    <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.value === target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">const</span> left = dfs(root.leftChild, target);</span><br><span class="line">    <span class="keyword">const</span> right = dfs(root.rightChild, target);</span><br><span class="line">    <span class="keyword">return</span> left || right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h4><p>搜索局域；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 广度优先搜索</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;array&#125;</span> </span>rootList 根节点数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>target 要查询的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return </span>true | false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bfs</span>(<span class="params">rootList, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rootList == <span class="literal">null</span> || rootList.length === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> childrenList = []; <span class="comment">//存放子节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; rootList.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rootList[i] !== <span class="literal">null</span> &amp;&amp; rootList[i].value === target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (rootList[i].leftChild) &#123;</span><br><span class="line">                childrenList.push(rootList[i].leftChild);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rootList[i].rightChild) &#123;</span><br><span class="line">                childrenList.push(rootList[i].rightChild);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bfs(childrenList, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="二叉树的比较"><a href="#二叉树的比较" class="headerlink" title="二叉树的比较"></a>二叉树的比较</h3><h4 id="不区分左右子树的比较"><a href="#不区分左右子树的比较" class="headerlink" title="不区分左右子树的比较"></a>不区分左右子树的比较</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在区分左右子树的情况下，比较两个树是否相等</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>root1 根节点1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>root2 根节点2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">root1, root2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root1 === root2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (root1 === <span class="literal">null</span> &amp;&amp; root2 !== <span class="literal">null</span> || root1 !== <span class="literal">null</span> &amp;&amp; root2 === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (root1.value !== root2.value) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> compare(root1.leftChild, root2.leftChild) &amp;&amp; compare(root1.rightChild, root2.rightChild)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="不区分左右子树的比较-1"><a href="#不区分左右子树的比较-1" class="headerlink" title="不区分左右子树的比较"></a>不区分左右子树的比较</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在不区分左右子树的情况下，比较两个树是否相等</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>root1 根节点1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>root2 根节点2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">root1, root2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root1 === root2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (root1 === <span class="literal">null</span> &amp;&amp; root2 !== <span class="literal">null</span> || root1 !== <span class="literal">null</span> &amp;&amp; root2 === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (root1.value !== root2.value) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> (compare(root1.leftChild, root2.leftChild) &amp;&amp; compare(root1.rightChild, root2.rightChild)) ||</span><br><span class="line">        (compare(root1.leftChild, root2.rightChild) &amp;&amp; compare(root1.rightChild, root2.leftChild))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 找出两棵树不同的地方</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>root1 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>root2 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;array&#125;</span> </span>diffList 存放不同的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diff</span>(<span class="params">root1, root2, diffList</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root1 === root2) <span class="keyword">return</span> diffList</span><br><span class="line">    <span class="keyword">if</span> (root1 === <span class="literal">null</span> &amp;&amp; root2 !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> diffList.push(&#123; <span class="attr">type</span>: <span class="string">&#x27;新增&#x27;</span>, <span class="attr">origin</span>: <span class="literal">null</span>, <span class="attr">now</span>: root2 &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root1 !== <span class="literal">null</span> &amp;&amp; root2 === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> diffList.push(&#123; <span class="attr">type</span>: <span class="string">&#x27;删除&#x27;</span>, <span class="attr">origin</span>: root1, <span class="attr">now</span>: <span class="literal">null</span> &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root1.value !== root2.value) &#123;</span><br><span class="line">        <span class="keyword">return</span> diffList.push(&#123; <span class="attr">type</span>: <span class="string">&#x27;修改&#x27;</span>, <span class="attr">origin</span>: root1, <span class="attr">now</span>: root2 &#125;);</span><br><span class="line">        diff(root1.leftChild, root2.leftChild, diffList);</span><br><span class="line">        diff(root1.rightChild, root2.rightChild, diffList);</span><br><span class="line">    &#125;</span><br><span class="line">    diff(root1.leftChild, root2.leftChild, diffList);</span><br><span class="line">    diff(root1.rightChild, root2.rightChild, diffList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="最小生成树问题"><a href="#最小生成树问题" class="headerlink" title="最小生成树问题"></a>最小生成树问题</h3><h4 id="普利姆算法"><a href="#普利姆算法" class="headerlink" title="普利姆算法"></a>普利姆算法</h4><p>加点法</p>
<ol>
<li>任意找一个点做为起点</li>
<li>找到以当前选中点为起点路径最短的边</li>
<li>如果这个边的另一端没有被连通，那么久连接</li>
<li>如果已经被连通，则继续寻找第二短路径的边</li>
<li>重复寻找</li>
</ol>
<h4 id="克鲁斯卡尔算法"><a href="#克鲁斯卡尔算法" class="headerlink" title="克鲁斯卡尔算法"></a>克鲁斯卡尔算法</h4><p>加边法</p>
<ol>
<li>选择最小的边进行连接</li>
<li>要保证连接的两端至少有一个点是新的点，或者这个边将两个部落相连</li>
<li>重复，直到所有点都加入</li>
</ol>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>网络的基本知识</title>
    <url>/135xyq.github.io/2021/07/01/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><hr>
<p>WWW(World Wide Web)</p>
<p>冯诺依曼计算机：<br>运算器，存储器，控制器，输入设备，输出设备</p>
<p>IP地址：网络ID + 主机ID</p>
<p>域名经过DNS解析 为IP地址</p>
<p>127.0.0.1 访问本机<br>0.0.0.0  不知道IP地址，访问本机</p>
<p>五层网络模型：<br>应用层，运输层，网络层，数据链路层，物理层</p>
<p>发送文件，大量数据要用POST<br>GET请求： GET /path?.. = ..&amp;..=.. HTTP1.1 ,        请求的参数都在URL里 ，</p>
<h2 id="POST请求："><a href="#POST请求：" class="headerlink" title="POST请求："></a>POST请求：</h2><h3 id="请求：Request："><a href="#请求：Request：" class="headerlink" title="请求：Request："></a>请求：Request：</h3><ul>
<li>请求头</li>
<li>数据体</li>
<li>请求方式url版本协议</li>
</ul>
<h3 id="响应：Response："><a href="#响应：Response：" class="headerlink" title="响应：Response："></a>响应：Response：</h3><ul>
<li>响应头</li>
<li>数据体</li>
<li>协议版本   状态码 message</li>
</ul>
<h2 id="Get和Post请求方式的区别："><a href="#Get和Post请求方式的区别：" class="headerlink" title="Get和Post请求方式的区别："></a>Get和Post请求方式的区别：</h2><ol>
<li>是基于什么前提的？如果什么前提都没有，不使用任何规范，只考虑语法和理论上的HTTP协议：<br>GET和POST几乎没有什么区别，只有名字不一样。</li>
<li>如果是基于RFC规范的：<ul>
<li>理论上：get和post具有相同语法，但是有不同的语义。get是用来获取数据的，post是用来发送数据的，其它方面没有区别。</li>
<li>实现上：<ul>
<li>各种浏览器，就是这个规范的实现者。常见的那些不同：get的数据在URL是可见的，post请求是不显示在URL中的。</li>
<li>get请求是有长度限制的，post长度的无限的。</li>
<li>get请求的数据可以收藏为书签，post请求到的不可以收藏为书签。</li>
<li>get请求后，按后退按钮、刷新按钮无影响，post数据会被重新提交。</li>
<li>get编码类型：application/x-www-form-url,post的编码类型有很多：encodeapplication/x-www-form-urlencoded    multipart/form-data。</li>
<li>get的历史参数会被保留在浏览器里，post的不会保存在浏览器中。</li>
<li>get值允许ASCII，post没有编码限制，允许发二进制。</li>
<li>get与post相比get的安全性较差，因为所发的数据是URL的一部分。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="Cookie与Session"><a href="#Cookie与Session" class="headerlink" title="Cookie与Session"></a>Cookie与Session</h2><ol>
<li><p>如果我们⽤JS的变量来存数据，那么在⻚⾯关闭的时候，数据就消失了。</p>
</li>
<li><p>保持登录状态是怎么做到的呢？</p>
<p> 按照正常的HTTP协议来说，是做不到的。<br>因为HTTP协议，上下⽂⽆关协议。</p>
</li>
<li><p>所以说前端⻚⾯上，有可以持久化存储数据的东⻄。⼀旦登录成功，我就记载在这个⾥⾯。</p>
</li>
</ol>
<p>Cookie是有限制的。</p>
<p>Cookie是存在浏览器⾥的，不是存在某个⻚⾯上的。是可以⻓期存储的。Cookie即使是保存在浏览器⾥，也是存放在不同的域名下的。</p>
<p><strong>缺点</strong>：如果某个坏⼈，复制了我浏览器⾥的cookie，他就可以在他的电脑上登录我的账号了。</p>
<p>XSS注⼊攻击。</p>
<h3 id="数据存在Session上也有缺点："><a href="#数据存在Session上也有缺点：" class="headerlink" title="数据存在Session上也有缺点："></a>数据存在Session上也有缺点：</h3><p>如果⽤户量⾮常⼤，上亿的⽤户。</p>
<p>在⽤户量很⼤的时候，服务器端很耗资源的。</p>
<p>因为后端可能不⽌⼀台服务器，⽤户的登录信息，⼀般只存在⼀台服务器上。</p>
<p>因为⽤户的登录操作，在哪台机器上执⾏的，就⼀般存在哪台机器上。</p>
<p>需要通过反向代理。（轮询，IP哈希。）</p>
<h2 id="B-S结构-C-S结构"><a href="#B-S结构-C-S结构" class="headerlink" title="B/S结构    C/S结构"></a>B/S结构    C/S结构</h2><p>Client/Server——Client只负责内容的展示，Server负责提供内容。</p>
<p>Browser/Server——Browser只负责内容的展示，Server负责提供内容。</p>
<p>⻚⾯的本质是什么？<br>⻚⾯的本质就是⼀个字符串。带有HTML格式的字符串。</p>
<p>浏览器 向服务器 请求⼀个⻚⾯的本质是什么？</p>
<ol>
<li><p><a href="http://www.baidu.com/">www.baidu.com</a></p>
</li>
<li><p>服务器接收到这个请求后，服务器想要把这个⻚⾯的内容（HTML格式的字串. 返回给浏览器。</p>
</li>
<li><p>⻚⾯的字符串存在哪⾥呢？存在HTML⽂件⾥。例如：index.html </p>
</li>
<li><p>服务器端要读取⽂件。</p>
</li>
<li><p>将读取出来的内容返回给浏览器。</p>
</li>
</ol>
<p>最后返回的是⼀个字符串，这个字符串的来源可能是⽂件，可能是缓存，可能来⾃于数据库。</p>
<p>服务器：严格的说，服务器是⼀台计算机，这台计算机，只提供服务。（不是⽤户⽤的）</p>
<p>但是，我们常说的这个服务器，指的是服务容器，不是服务器。</p>
<p>服务容器：是⼀个程序。程序可以监听⼀个端⼝。读取⽂件，并且返回。</p>
<p>如果我们想通过访问服务器（服务容器）的⽅式，来访问我们⾃⼰写的⻚⾯。</p>
<p>我们就得装⼀个服务容器的程序。</p>
<h3 id="向后端发出请求："><a href="#向后端发出请求：" class="headerlink" title="向后端发出请求："></a>向后端发出请求：</h3><ol>
<li>在浏览器中直接输入网址（无法用代码控制）</li>
<li>location.href = url; 可以发出网络请求，但是页面会发生跳转。（页面跳转）</li>
<li>带有src属性的标签，请求是可以发出的，服务端是可以处理也是可以返回的，但是返回之后能否被应用，还要看浏览器。（页面无法处理返回结果）</li>
<li>带有href属性的标签，请求是可以发出的，服务端是可以处理也是可以返回的，但是返回之后能否被应用，还要看浏览器。（页面无法处理返回结果）</li>
<li>带有action属性的标签，例如form表单，也可以向后端发出请求。但是form表单发出请求之后，也会页面跳转。（页面会跳转）</li>
<li>ajax请求</li>
</ol>
<p><strong>要素；请求方式，url</strong></p>
<h2 id="跨域访问资源"><a href="#跨域访问资源" class="headerlink" title="跨域访问资源"></a>跨域访问资源</h2><p>哪些东⻄属于资源？</p>
<p>js⽂件算吗？js⽂件肯定是算资源的，但是js⽂件是允许被跨域请求的。</p>
<p>css⽂件，jpg,png等。src属性的资源都是可以被跨域请求的。href资源⼤部分都是可以被跨域请求的。</p>
<h3 id="哪些资源算跨域请求的资源？"><a href="#哪些资源算跨域请求的资源？" class="headerlink" title="哪些资源算跨域请求的资源？"></a>哪些资源算跨域请求的资源？</h3><ol>
<li><p>后端接⼝的数据。</p>
</li>
<li><p>其它域的cookie </p>
</li>
<li><p>其它域的缓存</p>
</li>
</ol>
<h3 id="什么是其它的域？怎么样算跨域？"><a href="#什么是其它的域？怎么样算跨域？" class="headerlink" title="什么是其它的域？怎么样算跨域？"></a>什么是其它的域？怎么样算跨域？</h3><p>⻚⾯本身：有协议（http/https）,域名，端⼝</p>
<p>要请求的数据：<a href="http://www.baidu.com/">http://www.baidu.com:80</a></p>
<p>协议，域名，端⼝这三个，有任意⼀个不⼀样就算跨域。</p>
<p>跨域这个⾏为，发⽣在哪⾥？</p>
<p>答案：</p>
<ol>
<li><p>即使跨域了（协议，域名，端⼝号有不⼀样的），请求也可以发出。</p>
</li>
<li><p>服务器端也是可以接收的。</p>
</li>
<li><p>服务器端也是可以正常处理的。</p>
</li>
<li><p>服务器端也是可以正常返回数据。</p>
</li>
<li><p>浏览器也能接收到这些数据。</p>
</li>
<li><p>接收到之后，发现当前⻚⾯的域和请求的域不同，所以判定为跨域。</p>
</li>
<li><p>我们的代码在这等着结果呢，但是因为浏览器判定跨域了，不会把结果传递给我们的代码。</p>
</li>
</ol>
<p>虽然跨域了，但是我们依然需要这个数据，怎么办？</p>
<h3 id="解决跨域问题："><a href="#解决跨域问题：" class="headerlink" title="解决跨域问题："></a>解决跨域问题：</h3><ol>
<li><p>后端（别⼈家的）配合我们进⾏跨域。</p>
<ol>
<li>JSONP（正常的情况，返回的数据都是JSON格式。JSONP是⼀种特殊的格式。）</li>
<li>后端设置Access-Control-Allow-Origin属性以⽀持跨域。</li>
</ol>
</li>
<li><p>后端不配合我们进⾏跨域。</p>
<ol>
<li><p>iframe（只能显示，不能控制）</p>
</li>
<li><p>通过后端代理（⾃⼰的后端）（后⾯聊天机器⼈讲，因为需要nodejs）</p>
</li>
</ol>
</li>
</ol>
<p>readyState ：</p>
<p>状态4代表请求完成，已经接收到数据</p>
<p>jsonp跨域，只能使用get方法，如果我们设置的是post方法，jQuery会自动转为get方法</p>
<p>jQuery会先判断是否同源，如果同源，那么设置的是get就是get，设置的是post就是post<br>不是同源的话，就都改为get(跨域)</p>
<p>script标签，虽然可以引用其他域的资源，浏览器不限制，但是，浏览器会将返回的内容当做js代码执行。</p>
<h3 id="jsonp原理："><a href="#jsonp原理：" class="headerlink" title="jsonp原理："></a>jsonp原理：</h3><h4 id="前端："><a href="#前端：" class="headerlink" title="前端："></a>前端：</h4><ol>
<li>判断请求与当前页面的域是是否同源，如果同源则发送Ajax，没有跨域</li>
<li>如果不同源，生成一个script标签</li>
<li>生成一个随机的callback名字</li>
<li>设置script标签的src设置为要请求的接口</li>
<li>将callback作为参数拼接在后面</li>
</ol>
<h4 id="后端："><a href="#后端：" class="headerlink" title="后端："></a>后端：</h4><ol>
<li>后端接收到请求后，开始准备要返回的数据</li>
<li>后端拼接数据，将要返回的数据用callback的值和括号包裹起来。</li>
<li>将内容返回</li>
<li>浏览器接收到内容，会当做js代码来执行</li>
<li>从而执行方法，这样我们就接收到了后端返回给我们的对象。</li>
</ol>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux期末知识点总结</title>
    <url>/135xyq.github.io/2021/12/30/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0-Linux%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="Linux知识点总结"><a href="#Linux知识点总结" class="headerlink" title="Linux知识点总结"></a>Linux知识点总结</h1><h2 id="Linux概述"><a href="#Linux概述" class="headerlink" title="Linux概述"></a>Linux概述</h2><h3 id="Linux系统的优缺点"><a href="#Linux系统的优缺点" class="headerlink" title="Linux系统的优缺点"></a>Linux系统的优缺点</h3><ol>
<li>优点：Linux系统主打网络服务，专业性强，免费开源，主要用于搭建服务器，性能稳定，长时间开机不出现卡顿，漏洞少，更安全；</li>
<li>缺点：Linux式子专业系统，对业余人员不友好，操作难度较高。</li>
</ol>
<h3 id="Linux系统的特点"><a href="#Linux系统的特点" class="headerlink" title="Linux系统的特点"></a>Linux系统的特点</h3><ol>
<li>一切皆文件</li>
<li>完全兼容可移植操作系统接口POSIX1.0标准</li>
<li>多用户、多任务</li>
<li>完全免费</li>
</ol>
<h3 id="Linux的含义"><a href="#Linux的含义" class="headerlink" title="Linux的含义"></a>Linux的含义</h3><p>Linux是指在GPL协议下发行的遵循可移植性操作系统POSIX标准的操作系统内核。<br>通常说的Linux是指基于Linux内核，并且使用GNU工程各种工具和数据库的操作系统。<br>Linux是类UNIX操作系统。</p>
<h3 id="Linux的诞生、发展和成长过程依赖五个重要支柱"><a href="#Linux的诞生、发展和成长过程依赖五个重要支柱" class="headerlink" title="Linux的诞生、发展和成长过程依赖五个重要支柱"></a>Linux的诞生、发展和成长过程依赖五个重要支柱</h3><ol>
<li>UXIX操作系统</li>
<li>MINIX操作系统</li>
<li>GNU计划</li>
<li>POSIX标准</li>
<li>Internet</li>
</ol>
<h3 id="Linux内核的组成"><a href="#Linux内核的组成" class="headerlink" title="Linux内核的组成"></a>Linux内核的组成</h3><ol>
<li>内存管理器：对内存资源的访问控制。</li>
<li>进程管理器：对CPU的访问控制。</li>
<li>设备驱动程序：实际控制操作系统和硬件设备之间的交互，并且提供一组操作系统可理解的抽象接口，完成和操作系统之间的交互，与硬件相关的具体操作细节也由设备驱动程序完成。</li>
<li>虚拟文件系统：VFS隐藏各种文件系统的具体细节，为文件系统提供统一的接口。</li>
<li>网络管理：管理各种网络设备，并实现各种网络协议栈，最终通过网络连接其他系统。</li>
</ol>
<h3 id="shell-分为"><a href="#shell-分为" class="headerlink" title="shell 分为"></a>shell 分为</h3><ol>
<li>GLI命令行界面</li>
<li>GUI图用户界面</li>
</ol>
<h3 id="Linux文件系统"><a href="#Linux文件系统" class="headerlink" title="Linux文件系统"></a>Linux文件系统</h3><p>Linux一切皆文件；<br>文件系统是指文件存放在磁盘等存储设备上的组织方法。</p>
<h2 id="Linux基本操作"><a href="#Linux基本操作" class="headerlink" title="Linux基本操作"></a>Linux基本操作</h2><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><p><strong>命令格式</strong>： command [options] [arguments]  ，命令名：[选项]：[参数]</p>
<h3 id="获取帮助"><a href="#获取帮助" class="headerlink" title="获取帮助"></a>获取帮助</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">man [option] filename</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--help |more</span><br></pre></td></tr></table></figure>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>Linux 日志文件存放在 /var/log目录下</p>
<p>日志记录了程序的运行状态，包括各种错误信息、警告信息和其他的提示信息。</p>
<h2 id="文件系统和文件管理"><a href="#文件系统和文件管理" class="headerlink" title="文件系统和文件管理"></a>文件系统和文件管理</h2><h3 id="Linux文件类型"><a href="#Linux文件类型" class="headerlink" title="Linux文件类型"></a>Linux文件类型</h3><ol>
<li>普通文件</li>
<li>目录文件</li>
<li>链接文件</li>
<li>设备文件</li>
<li>管道文件</li>
</ol>
<h4 id="普通文件"><a href="#普通文件" class="headerlink" title="普通文件"></a>普通文件</h4><ul>
<li>普通文件是指以<strong>字节</strong>为单位的<strong>数据流</strong>类型文件，其特点是不包含文件系统的结构信息。</li>
<li>通常用户接触到的文件，如图形文件、数据文件、文档文件、声音文件等都属于普通文件。</li>
<li>按其内部结构分为文本文件和二进制文件。</li>
</ul>
<h4 id="目录文件"><a href="#目录文件" class="headerlink" title="目录文件"></a>目录文件</h4><ul>
<li>目录文件不存放常规数据，它是用来<strong>组织</strong>、<strong>访问</strong>其他文件的，是内核组织文件系统的基本节点。</li>
<li>目录文件可以包含下一级目录文件或普通文件。</li>
<li>目录文件是一种文件，是Linux文件中的一种</li>
</ul>
<h4 id="链接文件"><a href="#链接文件" class="headerlink" title="链接文件"></a>链接文件</h4><ul>
<li>链接文件是一种特殊的文件，是指向一个真实存在的文件链接(类似于Windows的快捷方式)。</li>
<li>根据链接文件的不同，分为<strong>硬链接</strong>（Hard Link）文件和<strong>符号链接</strong>（Symbolic Link，又称为软链接）文件</li>
</ul>
<h4 id="设备文件"><a href="#设备文件" class="headerlink" title="设备文件"></a>设备文件</h4><ul>
<li>设备文件是Linux中最特殊的文件，可以方便地访问外部设备。</li>
<li>Linux为外部设备提供一种标准接口，将外部设备视为一种特殊的文件。用户可以像访问普通文件一样访问任何外部设备，使Linux系统可以很方便地适应不断变化的外部设备。</li>
<li>设备文件放在/dev目录下，设备文件使用设备的主设备号和次设备号来指定某外部设备。</li>
<li>根据访问数据方式的不同，设备文件分为：块设备和字符设备文件。</li>
</ul>
<h4 id="管道文件"><a href="#管道文件" class="headerlink" title="管道文件"></a>管道文件</h4><ul>
<li>管道文件是一种很特殊的文件，主要用于不同进程的信息传递。</li>
<li>当两个进程间需要传递数据或信息时，可以使用管道文件。一个进程将需传递的数据或信息写入管道的一端，另一进程则从管道另一端取得所需的数据或信息。</li>
</ul>
<h3 id="文件类型判断"><a href="#文件类型判断" class="headerlink" title="文件类型判断"></a>文件类型判断</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">file [option] filename</span><br></pre></td></tr></table></figure>

<h3 id="查看文件的详细属性"><a href="#查看文件的详细属性" class="headerlink" title="查看文件的详细属性"></a>查看文件的详细属性</h3><p>使用stat命令，例如，文件的名称、大小、权限、atime、ctime、mtime等</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">state [option] filename</span><br></pre></td></tr></table></figure>


<h3 id="显示当前工作目录"><a href="#显示当前工作目录" class="headerlink" title="显示当前工作目录"></a>显示当前工作目录</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure>

<h3 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h3><ul>
<li>绝对路径是以根目录“/”开始，递归每级目录直到目标路径。</li>
<li>相对路径是以当前目录为起点，到达目标的路径。</li>
</ul>
<h3 id="显示目录下的文件结构"><a href="#显示目录下的文件结构" class="headerlink" title="显示目录下的文件结构"></a>显示目录下的文件结构</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tree filename</span><br></pre></td></tr></table></figure>
<h3 id="切换目录"><a href="#切换目录" class="headerlink" title="切换目录"></a>切换目录</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd [directory]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><figcaption><span>- ```表示返回到上次目录。</span></figcaption><table><tr><td class="code"><pre><span class="line">```cd ..```表示返回到上一级目录</span><br><span class="line"></span><br><span class="line">### ls命令</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line">ls [option] [names]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>显示所有隐藏文件<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -a</span><br></pre></td></tr></table></figure></li>
<li>显示所有以a开头的文件<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls a*</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="目录的创建和删除"><a href="#目录的创建和删除" class="headerlink" title="目录的创建和删除"></a>目录的创建和删除</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir [option] [dirname]</span><br></pre></td></tr></table></figure>
<p>dirname : 目录名称<br>参数：-p :创建多层目录，-v：显示创建过程信息</p>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p><strong>rmdir命令只能用来删除空目录</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rmdir [option] [dirname]</span><br></pre></td></tr></table></figure>
<p>dirname : 目录名称</p>
<h3 id="文件的创建、查看、复制、移动、删除、排序"><a href="#文件的创建、查看、复制、移动、删除、排序" class="headerlink" title="文件的创建、查看、复制、移动、删除、排序"></a>文件的创建、查看、复制、移动、删除、排序</h3><h4 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch [option] filename</span><br></pre></td></tr></table></figure>

<h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat [option] filename</span><br></pre></td></tr></table></figure>
<ul>
<li>用来显示文件内容， 依次读取其后所指文件的内容并将其输出到标准输出设备上。</li>
<li>能够用来连接两个或者多个文件，形成新文件。</li>
</ul>
<p>more命令以逐页的方式显示文件的内容.<br>less命令也是对文件或其他输出进行分页显示。<br>head命令可以查看文件的前几行的内容。<br>tail命令查看文件的后几行的内容</p>
<h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp [option] source  dest</span><br></pre></td></tr></table></figure>
<p>source表示需要复制的文件，dest 表示需要复制到的目录。</p>
<h4 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv [option] source dest</span><br></pre></td></tr></table></figure>
<p>为文件或目录改名或者将文件由一个目录移动到另一个目录中</p>
<h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm [option] filename</span><br></pre></td></tr></table></figure>
<ul>
<li>删除一个目录中的一个或者多个文件。</li>
<li>将某个目录及其下的所有文件及子目录均删除。</li>
<li>对于链接文件，只是删除了链接，原有文件均保持不变</li>
</ul>
<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>对文件中的各行进行排序。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sort [option] filename</span><br></pre></td></tr></table></figure>

<h3 id="文件查找"><a href="#文件查找" class="headerlink" title="文件查找"></a>文件查找</h3><p>以指定的查找模式搜索文件，通知用户在什么文件中搜索到与指定模式匹配的字符串，并且打印出所有包含该字符的文本行，该文本行的最前面是该行所在的文件名。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep [-abcEFGhHilLnqrsvVwxy][-A&lt;显示列数&gt;][-B&lt;显示列数&gt;][-C&lt;显示列数&gt;][-d&lt;进行动作&gt;][-e&lt;范本样式&gt;][-f&lt;范本文件&gt;][–help][范本样式][文件或目录…]</span><br></pre></td></tr></table></figure>


<p>find:从指定的目录开始，递归地搜索其各个子目录，查找满足寻找条件的文件并对其采取相关的操作。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find [pathname] [option] filename</span><br></pre></td></tr></table></figure>


<h3 id="linux-文件链接"><a href="#linux-文件链接" class="headerlink" title="linux 文件链接"></a>linux 文件链接</h3><h4 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h4><ul>
<li>默认情况下，每个文件有一个硬链接，该硬链接会给文件起名字。</li>
<li>创建一个硬链接时，也为这个文件创建了一个额外的目录条目。</li>
</ul>
<h5 id="硬链接的局限性"><a href="#硬链接的局限性" class="headerlink" title="硬链接的局限性"></a>硬链接的局限性</h5><p>（1）硬链接不能引用自身文件系统之外的文件，即不能引用不在同一磁盘分区的文件。<br>（2）硬链接无法引用目录。</p>
<p>当硬链接被删除时，只是删除了这个链接，但是文件本身的内容依然存在，除非该文件的所有链接都被删除了</p>
<h4 id="符号链接（软链接）"><a href="#符号链接（软链接）" class="headerlink" title="符号链接（软链接）"></a>符号链接（软链接）</h4><p>符号链接指向的文件与符号链接自身几乎没有区别。</p>
<h3 id="文件时间"><a href="#文件时间" class="headerlink" title="文件时间"></a>文件时间</h3><p>在Linux系统中，文件是没有创建时间的，如果新创建一个文件，它的三个时间都是与创建的时间相同。</p>
<h4 id="1-访问时间（Access-time）"><a href="#1-访问时间（Access-time）" class="headerlink" title="1.访问时间（Access time）"></a>1.访问时间（Access time）</h4><p>对文件内容进行一次读操作时间。</p>
<h4 id="2-修改时间（Change-time）"><a href="#2-修改时间（Change-time）" class="headerlink" title="2.修改时间（Change time）"></a>2.修改时间（Change time）</h4><p>文件内容被最后一次修改的时间。</p>
<p>ls -l 命令显示出来的文件时间就是这个时间</p>
<h4 id="3-状态时间（Modify-time）"><a href="#3-状态时间（Modify-time）" class="headerlink" title="3.状态时间（Modify time）"></a>3.状态时间（Modify time）</h4><p>当文件的状态被改变时，状态时间就会改变</p>
<h2 id="Linux用户管理"><a href="#Linux用户管理" class="headerlink" title="Linux用户管理"></a>Linux用户管理</h2><p>超级用户可以对普通用户进行跟踪，并限制它们的访问权限，以保证系统安全。</p>
<p>Linux系统并不能识别用户账号名称信息，所以每个用户都有一个唯一的系统可识别的UID</p>
<p>id命令可以查看当前用户登录信息。</p>
<ul>
<li>UID(User Identification)为用户的ID。</li>
<li>GID(Group Identification)为用户所属组的ID。</li>
<li>groups为用户属于的所有组的ID。</li>
</ul>
<p>ps aux | less命令查看进程</p>
<h3 id="用户分类"><a href="#用户分类" class="headerlink" title="用户分类"></a>用户分类</h3><ol>
<li>root用户：拥有最高权限，ID为0。</li>
<li>普通用户：可以登录，由管理员创建，使用权限有限。</li>
<li>系统用户：不具有登录的能力，但是系统运行不可或缺的。</li>
</ol>
<h3 id="管理用户组"><a href="#管理用户组" class="headerlink" title="管理用户组"></a>管理用户组</h3><ul>
<li>useradd用来添加用户。</li>
<li>passwd修改用户口令。</li>
<li>usermod修改用户信息。</li>
<li>userdel删除用户。</li>
</ul>
<h4 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h4><p>添加用户就是在系统中创建一个新账号，并为新账号分配用户ID、用户组、主目录和登录Shell等资源。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">useradd [option] username</span><br></pre></td></tr></table></figure>
<p>username表示新账号的登录名</p>
<h4 id="修改用户口令"><a href="#修改用户口令" class="headerlink" title="修改用户口令"></a>修改用户口令</h4><p>用户账号刚创建时没有口令，无法使用，必须为其指定口令后才可以使用，即使是空口令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">passwd [option] [username]</span><br></pre></td></tr></table></figure>

<ul>
<li>username参数没有指定时，表示修改当前用户的口令。</li>
<li>如果指定了该参数，则表示修改指定用户的口令，只有root用户才有修改指定用户口令的权限</li>
</ul>
<h4 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h4><p>删除用户就是删除与用户有关的系统配置文件中的记录（如/etc/passwd）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">userdel [option] username</span><br></pre></td></tr></table></figure>

<h4 id="修改用户信息"><a href="#修改用户信息" class="headerlink" title="修改用户信息"></a>修改用户信息</h4><p>修改用户信息就是更改用户的属性，如用户 ID、主目录、用户所在组、登录Shell等。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">usermod [option] username</span><br></pre></td></tr></table></figure>

<p>gpasswd命令–从用户组中移出一个用户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gpasswd [-a user][-d user][-A user,...][-M user,...][-r][-R]groupname</span><br></pre></td></tr></table></figure>



<h3 id="管理用户组-1"><a href="#管理用户组-1" class="headerlink" title="管理用户组"></a>管理用户组</h3><p>用户组是具有相同特征用户的集合，每个用户都有一个用户组，方便系统集中管理一个用户组中的所有用户</p>
<h4 id="添加用户组"><a href="#添加用户组" class="headerlink" title="添加用户组"></a>添加用户组</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">groupadd [option] group_name</span><br></pre></td></tr></table></figure>


<h4 id="删除用户组"><a href="#删除用户组" class="headerlink" title="删除用户组"></a>删除用户组</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">groupdel group_name</span><br></pre></td></tr></table></figure>

<h4 id="修改用户组"><a href="#修改用户组" class="headerlink" title="修改用户组"></a>修改用户组</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">groupmod [option] group_name</span><br></pre></td></tr></table></figure>

<h4 id="查看用户的分组"><a href="#查看用户的分组" class="headerlink" title="查看用户的分组"></a>查看用户的分组</h4><ol>
<li>groups命令查看。命令：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">groups</span><br><span class="line">groups user1 user2</span><br></pre></td></tr></table></figure></li>
<li>查看文件/etc/group法，通过grep命令查询某个用户所在的用户组。</li>
<li>id命令法，只执行id命令就可以查看。命令：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">id</span><br><span class="line">id user2</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="和用户相关的一些系统文件"><a href="#和用户相关的一些系统文件" class="headerlink" title="和用户相关的一些系统文件"></a>和用户相关的一些系统文件</h3><ol>
<li>/etc/passwd文件保存用户信息。</li>
<li>/etc/shadow文件保存加密的用户密码。</li>
<li>/etc/group文件保存用户组信息。</li>
<li>/etc/login.defs配置文件。</li>
</ol>
<p><strong>su root</strong>可以返回root </p>
<h2 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h2><p>权限的意义在于允许某一个用户或某个用户组以规定的方式去访问某个文件。</p>
<h3 id="U-G-O"><a href="#U-G-O" class="headerlink" title="U G O"></a>U G O</h3><p>U: owner为属主，文件所有者。<br>G：group为属组，同组用户。<br>O：other为其他用户。</p>
<h3 id="UGO方式每组的3个字符具体意义如下："><a href="#UGO方式每组的3个字符具体意义如下：" class="headerlink" title="UGO方式每组的3个字符具体意义如下："></a>UGO方式每组的3个字符具体意义如下：</h3><p>r:read，数字设定值为4<br>w:write,数字设定值为2<br>x:execute,数字设定值为1</p>
<h3 id="设置文件属性和权限"><a href="#设置文件属性和权限" class="headerlink" title="设置文件属性和权限"></a>设置文件属性和权限</h3><h4 id="改变文件所属用户命令chown"><a href="#改变文件所属用户命令chown" class="headerlink" title="改变文件所属用户命令chown"></a>改变文件所属用户命令chown</h4><p>文件所有者修改为指定的用户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chown [-cfhvR] [--help] [--version] user[:group] file...</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">option</th>
<th align="center">explanation</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-c</td>
<td align="center">显示更改的部分的信息</td>
</tr>
<tr>
<td align="center">-f</td>
<td align="center">忽略错误信息</td>
</tr>
<tr>
<td align="center">-h</td>
<td align="center">修复符号链接</td>
</tr>
<tr>
<td align="center">-v</td>
<td align="center">显示详细的处理信息</td>
</tr>
<tr>
<td align="center">-R</td>
<td align="center">处理指定目录以及其子目录下的所有文件</td>
</tr>
<tr>
<td align="center">–help</td>
<td align="center">显示辅助说明</td>
</tr>
<tr>
<td align="center">–version</td>
<td align="center">显示版本</td>
</tr>
</tbody></table>
<h4 id="改变文件所在组命令chgrp"><a href="#改变文件所在组命令chgrp" class="headerlink" title="改变文件所在组命令chgrp"></a>改变文件所在组命令chgrp</h4><p>变更目录和文件的所属组，只有超级用户才拥有此权限。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chgrp [option] group file</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">option</th>
<th align="center">explanation</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-c或–changes</td>
<td align="center">效果类似”-v”参数，但仅回报更改部分。</td>
</tr>
<tr>
<td align="center">-f或–quiet或–silent</td>
<td align="center">不显示错误信息。</td>
</tr>
<tr>
<td align="center">-h或–no-dereference</td>
<td align="center">只对符号连接的文件作修改，而不更动其他任何相关文件。</td>
</tr>
<tr>
<td align="center">-R或–recursive</td>
<td align="center">递归处理，将指定目录下的所有文件及子目录一并处理。</td>
</tr>
<tr>
<td align="center">-v或–verbose</td>
<td align="center">显示指令执行过程。</td>
</tr>
<tr>
<td align="center">–reference=&amp;lt</td>
<td align="center">参考文件或目录&gt; 　把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同。</td>
</tr>
</tbody></table>
<h4 id="修改文件或目录的权限chmod"><a href="#修改文件或目录的权限chmod" class="headerlink" title="修改文件或目录的权限chmod"></a>修改文件或目录的权限chmod</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod [ugoa...][[+-=][rwxX]...][,...]</span><br></pre></td></tr></table></figure>
<p>u表示该文件的拥有者，g表示与该文件的拥有者属于同一个群体(group)者，o表示其他以外的人，a表示这三者皆是。<br>+表示增加权限、-表示取消权限、=表示唯一设定权限。<br>r表示可读取，w表示可写入，x表示可执行，X表示只有当该文件是个子目录或者该文件已经被设定过为可执行。</p>
<h5 id="修改文件权限的方法有2种"><a href="#修改文件权限的方法有2种" class="headerlink" title="修改文件权限的方法有2种"></a>修改文件权限的方法有2种</h5><ol>
<li>符号法（表达式法）<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod [who] [operator] [mode] file</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>who指定用户身份，若此参数省略，则表示对所有用户进行操作。</li>
<li>operator表示添加或取消某个权限，取值为“+”或“-”。</li>
<li>mode指定读、写、执行权限，取值为 r、 w、 x 的任意组合。</li>
</ul>
<ol start="2">
<li>数字法<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod 数字 file</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="存储在磁盘上的文件就像是一个链表，表头是文件的起始地址，整个文件不连续存放。"><a href="#存储在磁盘上的文件就像是一个链表，表头是文件的起始地址，整个文件不连续存放。" class="headerlink" title="存储在磁盘上的文件就像是一个链表，表头是文件的起始地址，整个文件不连续存放。"></a>存储在磁盘上的文件就像是一个链表，表头是文件的起始地址，整个文件不连续存放。</h3><h3 id="基础权限ACL"><a href="#基础权限ACL" class="headerlink" title="基础权限ACL"></a>基础权限ACL</h3><p>主要提供传统的UGO的r、w、x权限之外的具体权限设置，对单一用户，单一文件或目录进行权限设置。</p>
<h4 id="getfacl命令"><a href="#getfacl命令" class="headerlink" title="getfacl命令"></a>getfacl命令</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">getfacl [-aceEsRLPtpndvh] file ...</span><br></pre></td></tr></table></figure>

<h4 id="setfacl命令可以设置ACL权限"><a href="#setfacl命令可以设置ACL权限" class="headerlink" title="setfacl命令可以设置ACL权限"></a>setfacl命令可以设置ACL权限</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">setfacl [-bkndRLP] &#123; -m|-M|-x|-X ... &#125; file ...</span><br></pre></td></tr></table></figure>

<h2 id="linux编程基础"><a href="#linux编程基础" class="headerlink" title="linux编程基础"></a>linux编程基础</h2><p>make可以获知所管理项目中源文件的修改情况，根据程序员设定的规则，自动编译被修改过的部分，</p>
<p>make通过makefile文件描述的内容自动维护编译工作。</p>
<h2 id="shell编程"><a href="#shell编程" class="headerlink" title="shell编程"></a>shell编程</h2><p>Shell脚本是一个包含一系列命令的文件。<br>Shell自动读取这个文件，并执行这些命令，与直接输入命令行得到结果一样。</p>
<h3 id="用Shell脚本的原因："><a href="#用Shell脚本的原因：" class="headerlink" title="用Shell脚本的原因："></a>用Shell脚本的原因：</h3><ol>
<li>效率高：如果让Shell记住这些命令并自动完成输入将会大大提升效率。 </li>
<li>简单性： 通过Shell高级语言，可以简洁地表达复杂的操作。</li>
<li>可移植性：使用POSIX定义的功能，可以做到脚本无须修改就可在不同系统上执行。</li>
<li>开发容易：可以在短时间内完成一个功能强大又好用的脚本。</li>
</ol>
<h3 id="Shell分类："><a href="#Shell分类：" class="headerlink" title="Shell分类："></a>Shell分类：</h3><ol>
<li>用于用户交互接口的Shell称为交互式Shell。</li>
<li>作为命令解析器的Shell称为非交互式Shell。</li>
</ol>
<h3 id="bin-bash"><a href="#bin-bash" class="headerlink" title="#!/bin/bash"></a><code>#!/bin/bash</code></h3><p>脚本第一行开头的“#!”是一个约定的标记，称为shebang，用来告知操作系统需要用什么解析器来执行此脚本，</p>
<p>Shell的注释以“#”开头，注释的内容不会执行。</p>
<p>给文件helloxiangtian.sh增加可执行权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chomd +x helloxiangtan.sh</span><br></pre></td></tr></table></figure>

<h3 id="Shell变量命名规则："><a href="#Shell变量命名规则：" class="headerlink" title="Shell变量命名规则："></a>Shell变量命名规则：</h3><p>变量名必须由大写字母（A～Z）、小写字母（a～z）、数字（0～9）或下画线构成；变量名的第一个字符不能是数字。 </p>
<h3 id="shell变量分类"><a href="#shell变量分类" class="headerlink" title="shell变量分类"></a>shell变量分类</h3><p>Shell变量分为自定义变量、环境变量、位置变量和预定义变量。</p>
<p>根据工作要求临时定义的变量称为自定义变量。<br>环境变量一般是指用export内置命令导出的变量，用于定义Shell的运行环境，保证Shell命令的正确执行，如$0、$1、$#。<br>从命令行、函数或脚本执行等处传递参数时，$0、$1称为特殊位置变量。<br>预定义变量是在bash（默认Shell）中已有的变量，可以直接使用，如$@、$*等。</p>
<p>Shell变量只有字符串一种类型，即无论给 Shell变量赋予什么值，在存储时都会转换为字符串。</p>
<h4 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h4><table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">定义自定义变量</td>
<td align="center">变量名=变量值，变量名必须以字母和下划线开头，如ipl=192.197.1.1。</td>
</tr>
<tr>
<td align="center">使用自定义变量</td>
<td align="center">$变量名</td>
</tr>
<tr>
<td align="center">查看自定义变量</td>
<td align="center">echo $变量名 set（所有变量：自定义变量和环境变量）</td>
</tr>
<tr>
<td align="center">取消自定义变量</td>
<td align="center">unset 变量名</td>
</tr>
<tr>
<td align="center">自定义变量作用范围</td>
<td align="center">仅在当前shell中有效</td>
</tr>
</tbody></table>
<h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>在各种编程语言中会提及全局变量概念。<br>全局变量可以在程序的任何地方使用。<br>在Shell编程中该功能由环境变量实现。<br>系统中的所有进程都可以使用环境变量。<br>环境变量与全局变量区别：<br>子进程对环境变量的修改不会传递到父进程中。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">定义环境变量</td>
<td align="center">使用export命令声明。例如，export back_dir=/home/user例如，export ipl 将自定义变量转换为环境变量。</td>
</tr>
<tr>
<td align="center">使用环境变量</td>
<td align="center">$变量名或$｛变量名｝</td>
</tr>
<tr>
<td align="center">查看环境变量</td>
<td align="center">echo $变量名 或env，如env</td>
</tr>
<tr>
<td align="center">取消环境变量</td>
<td align="center">unset 变量名</td>
</tr>
<tr>
<td align="center">环境变量作用范围</td>
<td align="center">仅在当前shell和子shell中有效</td>
</tr>
</tbody></table>
<h4 id="位置变量"><a href="#位置变量" class="headerlink" title="位置变量"></a>位置变量</h4><p>位置变量用于在命令行、函数或脚本中传递参数，其变量名不用自己定义，其作用也是固定的。<br>执行脚本时，通过在脚本后面给出具体的参数（多个参数用空格隔开）对相应的位置变量进行赋值。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">0代表命令本身，<span class="variable">$1</span>-<span class="variable">$9</span>代表接收的第1~9个参数，<span class="variable">$10</span>以上需要用&#123;&#125;括起来，如<span class="variable">$&#123;20&#125;</span>代表接收的第20个参数。</span></span><br></pre></td></tr></table></figure>

<h4 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h4><p>预定义变量在Shell中可以直接使用，位置变量也是预定义变量的一种。</p>
<table>
<thead>
<tr>
<th align="center">预定义变量</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$0</td>
<td align="left">脚本名</td>
</tr>
<tr>
<td align="center">$*</td>
<td align="left">所有的参数</td>
</tr>
<tr>
<td align="center">$@</td>
<td align="left">所有的参数</td>
</tr>
<tr>
<td align="center">$#</td>
<td align="left">参数的个数</td>
</tr>
<tr>
<td align="center">$$</td>
<td align="left">当前进程的PID</td>
</tr>
<tr>
<td align="center">$!</td>
<td align="left">上一个后台进程的PID</td>
</tr>
<tr>
<td align="center">$?</td>
<td align="left">上一个命令的返回值，0表示成功。</td>
</tr>
</tbody></table>
<h3 id="变量的操作"><a href="#变量的操作" class="headerlink" title="变量的操作"></a>变量的操作</h3><p>变量创建只需要指定变量名称和变量值，它们之间用等号（=）连接，等号两边不能有空格。</p>
<p>变量创建好后，可以用$变量名的方式获取变量的值。</p>
<p>可以使用$符号获取变量的值。</p>
<p>用户可以通过export命令将Shell变量导出为环境变量，但没有办法将环境变量再恢复成Shell变量。</p>
<h4 id="变量的删除"><a href="#变量的删除" class="headerlink" title="变量的删除"></a>变量的删除</h4><table>
<thead>
<tr>
<th align="center">格式</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">${变量名#关键字符}</td>
<td align="center">变量内容从头开始的数据符合“关键字符”，则将符合的最短数据删除。</td>
</tr>
<tr>
<td align="center">${变量名##关键字符}</td>
<td align="center">变量内容从头开始的数据符合“关键字符”，则将符合的最长数据删除。</td>
</tr>
<tr>
<td align="center">${变量名%关键字符}</td>
<td align="center">变量内容从尾开始的数据符合“关键字符”，则将符合的最短数据删除。</td>
</tr>
<tr>
<td align="center">${变量名%%关键字符}</td>
<td align="center">变量内容从尾开始的数据符合“关键字符”，则将符合的最长数据删除。</td>
</tr>
</tbody></table>
<h4 id="变量的替换"><a href="#变量的替换" class="headerlink" title="变量的替换"></a>变量的替换</h4><p>|格式  |说明|<br>|:—:|：—：|<br>|${变量名/旧字符串/新字符串}|  若变量内容符合“旧字符串”，则第1个“旧字符串”会被“新字符串”替换。|<br>|${变量名//旧字符串/新字符串} |  若变量内容符合“旧字符串”，则全部“旧字符串”会被“新字符串”替换。|</p>
<h4 id="变量的替代"><a href="#变量的替代" class="headerlink" title="变量的替代"></a>变量的替代</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;变量名-新的变量名&#125;</span></span><br></pre></td></tr></table></figure>


<p>在Shell中，变量值的类型默认是字符串，不直接进行运算。</p>
<p>用于整数运算的方法有expr、(())和$[]。</p>
<h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">expr expression</span><br><span class="line">例：</span><br><span class="line">n1 + n2</span><br><span class="line">expr $n1 + $n2</span><br></pre></td></tr></table></figure>
<p>运算符及用于计算的数字两边必须有空格，否则会执行失败。<br>用expr进行乘法运算时，必须在<em>前用反斜线转义（Shell可能误解为</em>号）。</p>
<p>“（（））”或“[ ]”数值运算命令<br>双小括号 “(())” 的作用是进行整数运算和数值比较，其效率很高，用法也非常灵活，是企业中常见的运算操作符<br>格式：<br>“ ((expression))”，或“ [expression]”<br>括号内部两侧可以有空格，也可省空格。<br>需要直接输出运算表达式的运算结果时，可以在“ ((表达式))”前加$符</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">n1+n2</span><br><span class="line"><span class="meta">$</span><span class="bash">((<span class="variable">$n1</span>+<span class="variable">$n2</span>))</span></span><br><span class="line"><span class="meta">$</span><span class="bash">[<span class="variable">$n1</span>+<span class="variable">$n2</span>]</span></span><br></pre></td></tr></table></figure>

<p>let数值运算命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">let expression</span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line">let sum = n1+n2;</span><br></pre></td></tr></table></figure>

<p>let数值符号可以直接进行计算，且不带回显功能，也就是说当使用let的时候，不再使用$引用变量</p>
<h3 id="shell中的特殊符号"><a href="#shell中的特殊符号" class="headerlink" title="shell中的特殊符号"></a>shell中的特殊符号</h3><h4 id="1-“-”表示注释。"><a href="#1-“-”表示注释。" class="headerlink" title="1. “#”表示注释。"></a>1. “#”表示注释。</h4><ul>
<li>行首为#（#!是个例外）表示此行是注释。</li>
<li>注释也可以放在本行命令的后面，需要注意的是#两边有空格。</li>
<li>释也可以放在本行行首空白的后面。</li>
</ul>
<h4 id="2-“-“"><a href="#2-“-“" class="headerlink" title="2. “ ; “"></a>2. “ ; “</h4><ul>
<li>“;”在同一行中分隔两个或者两个以上的命令。</li>
<li>“;”也适用于循环语句</li>
</ul>
<h4 id="3-“-”"><a href="#3-“-”" class="headerlink" title="3. “;;”"></a>3. “;;”</h4><ul>
<li>用于终止case语句</li>
</ul>
<h4 id="4-“-”"><a href="#4-“-”" class="headerlink" title="4. “:”"></a>4. “:”</h4><ul>
<li>空命令“:”和true命令作用相同。</li>
<li>在while死循环和if/then中也可使用这个命令。</li>
</ul>
<h4 id="5-“-”"><a href="#5-“-”" class="headerlink" title="5. “.”"></a>5. “.”</h4><ul>
<li>“.”等价于source命令，是bash中的一个内建命令。</li>
<li>“.”也可以作为文件名的一部分，如果“.”放在文件名的开头，那么这个文件将会成为“隐藏文件”。ls命令将不会正常显示出这个文件。</li>
<li>当点作为目录名时，一个单独的点代表当前工作目录，而两个点表示上一级目录。</li>
</ul>
<h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><h5 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h5><p>echo命令是最常用的，其功能是将字符串输出到屏幕</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo [-ne] [string]</span><br></pre></td></tr></table></figure>
<p>其中，string表示要输出的字符串。选项n表示输出不换行。选项e表示处理特殊字符</p>
<h5 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h5><p>输出命令printf的功能是格式化输出数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">printf format [arguments...]</span><br></pre></td></tr></table></figure>

<p>format为输出格式，用单引号或双引号包围都可以。“%s”为格式符，表示输出的格式为字符串，还有“%d”、“%c”、“%f”等，代表的格式与 C 语言中的相同。<br>arguments为要输出的数据。</p>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><h5 id="1-直接给变量赋值"><a href="#1-直接给变量赋值" class="headerlink" title="1. 直接给变量赋值"></a>1. 直接给变量赋值</h5><p>例如，name=liming</p>
<h5 id="2-从键盘读入赋值"><a href="#2-从键盘读入赋值" class="headerlink" title="2. 从键盘读入赋值"></a>2. 从键盘读入赋值</h5><ul>
<li>read命令可以通过从标准输入设备（键盘）读取一行数据赋值给变量。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">read  [options] [variable…]</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="3-使用命令行参数赋值"><a href="#3-使用命令行参数赋值" class="headerlink" title="3. 使用命令行参数赋值"></a>3. 使用命令行参数赋值</h5><p>使用命令行参数赋值是直接在命令后面跟参数，系统用$1来调用第一个参数，用$2调用第二个参数……，这种赋值方法适用于参数经常变化且不需要交互的情况。</p>
<h5 id="4-利用命令的输出结果赋值"><a href="#4-利用命令的输出结果赋值" class="headerlink" title="4. 利用命令的输出结果赋值"></a>4. 利用命令的输出结果赋值</h5><ul>
<li>在Shell程序中，可以将一个命令的输出结果当作变量的值（需要在赋值语句中使用反向单引号）。</li>
<li>把命令的结果作为变量的内容进行赋值的方法，在脚本开发时很常见，如按天打包网站的站点目录程序，生成不同文件名</li>
</ul>
<h5 id="5-从文件中读入数据赋值"><a href="#5-从文件中读入数据赋值" class="headerlink" title="5. 从文件中读入数据赋值"></a>5. 从文件中读入数据赋值</h5><p>这种方式就适合处理大批量的数据，直接把相应的数据写入文件中，通过脚本中的命令把文件中的数据读取到脚本程序中以便使用。</p>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 转义字符：用于引用任意的单个字符。</span><br><span class="line">2. 单引号引用（强引用），不管引号里面是否有变量或者其他的表达式，都是原样输出。</span><br><span class="line">3. 双引号引用（弱引用），用于引用包含的字符串，但保留$、 \和`的特殊含义，即引号里面的变量或者函数会先解析再输出内容。</span><br></pre></td></tr></table></figure>

<h3 id="条件测试"><a href="#条件测试" class="headerlink" title="条件测试"></a>条件测试</h3><h4 id="文件测试"><a href="#文件测试" class="headerlink" title="文件测试"></a>文件测试</h4><ol>
<li>test<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">“test  &lt;expression&gt;”</span><br></pre></td></tr></table></figure></li>
<li>“&lt;测试表达式&gt;”</li>
</ol>
<p>也可以使用“&lt;测试表达式&gt;”，就是使用中括号。<br>语法格式：<br>“ [  <expression> ]”<br>注意：[]与expression之间必须有空格。<br>通过[]进行条件测试的方法，与test命令用法相同，推荐使用此方法。</p>
<h4 id="整数测试"><a href="#整数测试" class="headerlink" title="整数测试"></a>整数测试</h4><p>整数测试通常用于数值之间的运算。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">语法格式：</span><br><span class="line">       [ 整数1 操作符 整数2 ]</span><br><span class="line">或   test 整数1 操作符 整数2。</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">操作符1</th>
<th align="center">操作符2(部分能用)  意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-eq ==</td>
<td align="center">等于（Equal）</td>
</tr>
<tr>
<td align="center">-ge &gt;=</td>
<td align="center">大于等于（Greater or Equal）</td>
</tr>
<tr>
<td align="center">-gt &gt;</td>
<td align="center">大于（Greater Than-le）</td>
</tr>
<tr>
<td align="center">-le &lt;=</td>
<td align="center">小于等于（Lesser or Equal）</td>
</tr>
<tr>
<td align="center">-lt</td>
<td align="center">&lt;   小于（Lesser Than）</td>
</tr>
<tr>
<td align="center">-ne !=</td>
<td align="center">不等于（Not Equal）</td>
</tr>
</tbody></table>
<h4 id="字符串测试"><a href="#字符串测试" class="headerlink" title="字符串测试"></a>字符串测试</h4><p>字符串测试操作包括比较字符串是否相同、测试字符串的长度是否为0。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ 字符串1 = 字符串2 ]</span><br><span class="line">[ 字符串1 ！= 字符串2 ]或[ -z 字符串 ]</span><br></pre></td></tr></table></figure>

<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ expression1 op expression2 ]</span><br><span class="line">or       command1 op commnad2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">Operator</th>
<th align="center">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">! expr</td>
<td align="center">如果表达式评估为假，则为真</td>
</tr>
<tr>
<td align="center">expr1 -a expr2</td>
<td align="center">如果 expr1 和 expr2 都为真，则结果为真，&amp;&amp;</td>
</tr>
<tr>
<td align="center">expr1 -o expr2</td>
<td align="center">如果 expr1 或 expr2 为真，则结果为真，</td>
</tr>
</tbody></table>
<h3 id="if语句格式"><a href="#if语句格式" class="headerlink" title="if语句格式"></a>if语句格式</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">语句格式：</span><br><span class="line">if [ expression ];then  code</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if [ expression ]  </span><br><span class="line">then code</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ expression ];then  code1</span><br><span class="line">else code2</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if [ expression ]  </span><br><span class="line">then   code1</span><br><span class="line">else  code2</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if expression; then</span><br><span class="line"> command…</span><br><span class="line">[elif expression; then</span><br><span class="line"> command…]</span><br><span class="line">[else</span><br><span class="line"> command…]</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">case value in</span><br><span class="line">    [ expression1) code1</span><br><span class="line">    ;;</span><br><span class="line">    expression2) code2</span><br><span class="line">    ;;</span><br><span class="line">    …</span><br><span class="line">    *）code</span><br><span class="line">    ]</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>


<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="while-命令"><a href="#while-命令" class="headerlink" title="while 命令"></a>while 命令</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">while expression; do</span><br><span class="line">       command…</span><br><span class="line">done   </span><br></pre></td></tr></table></figure>
<h4 id="until命令"><a href="#until命令" class="headerlink" title="until命令"></a>until命令</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">until expression; do</span><br><span class="line">     command…</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for  variable in [in sequence]</span><br><span class="line">do</span><br><span class="line">    code</span><br><span class="line">done </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for  变量名 in 取值列表；do     循环体 done</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for variable [in sequence]; do</span><br><span class="line">          command…</span><br><span class="line">     done</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for ((expression1; expression2; expression3;));do</span><br><span class="line">           command…</span><br><span class="line">     done</span><br></pre></td></tr></table></figure>


<p>在循环后面加个 &amp; 符号表示在后台执行</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="数组分为普通数组和关联数组。"><a href="#数组分为普通数组和关联数组。" class="headerlink" title="数组分为普通数组和关联数组。"></a>数组分为普通数组和关联数组。</h4><p>普通数组中的索引（下标）都是整数。<br>关联数组的数组索引可以用任意的文本。</p>
<p>两者最大区别：</p>
<ul>
<li>关联数组使用之前需要声明。</li>
<li>关联数组是由特定格式的键值对组成</li>
</ul>
<h4 id="普通数组"><a href="#普通数组" class="headerlink" title="普通数组"></a>普通数组</h4><p>定义：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">arrayname=（value_table）</span><br></pre></td></tr></table></figure>

<p>value_table中值之间用空格隔开。</p>
<h4 id="关联数组"><a href="#关联数组" class="headerlink" title="关联数组"></a>关联数组</h4><p>定义：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">arrayname=（[indexe1]=value1 [indexe2]=value2 ...... [indexen]=valuen)</span><br></pre></td></tr></table></figure>
<p>其中：<br>indexei可以用标识符表示。</p>
<p>声明普通数组方法：<br>#declare -a arrayname<br>声明关联数组方法：<br>#declare -A arrayname</p>
<h4 id="数组定义方法"><a href="#数组定义方法" class="headerlink" title="数组定义方法"></a>数组定义方法</h4><ul>
<li><p>直接定义数组</p>
</li>
<li><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">arrayname=(value1 value2 value3 ... valuen)</span><br></pre></td></tr></table></figure></li>
<li><p>下标定义数组</p>
</li>
<li><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">array_name=([index1]=value1 [index2]=value2 ...)</span><br></pre></td></tr></table></figure></li>
<li><p>间接定义数组</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">array[0]=value1;array[1]=value2;....</span><br></pre></td></tr></table></figure>

<ul>
<li>从文件中读入定义数组。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">array_name=($(command))</span><br><span class="line">array_name=($(`variable`))</span><br><span class="line"></span><br><span class="line">or </span><br><span class="line"></span><br><span class="line">array_name=(`command`)</span><br><span class="line">array_name=(`variable`)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="访问数组表达式"><a href="#访问数组表达式" class="headerlink" title="访问数组表达式"></a>访问数组表达式</h4><table>
<thead>
<tr>
<th>语法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>echo ${!array[*]}</td>
<td>访问数组所有索引</td>
</tr>
<tr>
<td>echo ${!array[@]}</td>
<td>访问数组所有索引</td>
</tr>
<tr>
<td>echo ${array[*]}</td>
<td>访问数组所有值</td>
</tr>
<tr>
<td>echo ${array[@]}</td>
<td>访问数组所有值</td>
</tr>
<tr>
<td>echo $</td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>课程学习</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>课程学习</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle期末知识点总结</title>
    <url>/135xyq.github.io/2021/12/30/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0-Oracle%E6%9C%9F%E6%9C%AB%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="Oracle知识点总结"><a href="#Oracle知识点总结" class="headerlink" title="Oracle知识点总结"></a>Oracle知识点总结</h1><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a><a href="https://www.cnblogs.com/wishyouhappy/p/3681771.html">索引</a></h2><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE [UNIQUE] | [BITMAP] INDEX index_name  --unique表示唯一索引</span><br><span class="line">ON table_name([column1 [ASC|DESC],column2    --bitmap，创建位图索引</span><br><span class="line">[ASC|DESC],…] | [express])</span><br><span class="line">[TABLESPACE tablespace_name]</span><br><span class="line">[PCTFREE n1]                                 --指定索引在数据块中空闲空间</span><br><span class="line">[STORAGE (INITIAL n2)]</span><br><span class="line">[NOLOGGING]                                  --表示创建和重建索引时允许对表做DML操作，默认情况下不应该使用</span><br><span class="line">[NOLINE]</span><br><span class="line">[NOSORT];                                    --表示创建索引时不进行排序，默认不适用，如果数据已经是按照该索引顺序排列的可以使用</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">为student1表的“注册日期”创建索引，并以降序排列，索引名为“DX1_02”。</span><br><span class="line">create index DX1_02 on student1(注册日期 desc);</span><br></pre></td></tr></table></figure>

<h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop index index_sno;</span><br></pre></td></tr></table></figure>
<h3 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select index_name,index-type, tablespace_name, uniqueness from all_indexes where table_name =&#x27;tablename&#x27;;</span><br><span class="line"></span><br><span class="line"> -- eg:    </span><br><span class="line">create index index_sno on student(&#x27;name&#x27;);</span><br><span class="line">select * from all_indexes where table_name=&#x27;student&#x27;;</span><br></pre></td></tr></table></figure>


<h2 id="同义词"><a href="#同义词" class="headerlink" title="同义词"></a><a href="https://www.cnblogs.com/moonsoft/p/12364941.html">同义词</a></h2><p>Oracle的同义词（synonyms）从字面上理解就是别名的意思，和视图的功能类似</p>
<h3 id="创建公共同义词"><a href="#创建公共同义词" class="headerlink" title="创建公共同义词"></a>创建公共同义词</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create public synonym synonym_name for table_name;</span><br></pre></td></tr></table></figure>

<h3 id="创建普通的同义词"><a href="#创建普通的同义词" class="headerlink" title="创建普通的同义词"></a>创建普通的同义词</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create  synonym synonym_name for table_name;</span><br></pre></td></tr></table></figure>

<h3 id="删除同义词"><a href="#删除同义词" class="headerlink" title="删除同义词"></a>删除同义词</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop synonym synonym_name;</span><br></pre></td></tr></table></figure>
<h2 id="序列"><a href="#序列" class="headerlink" title="序列"></a><a href="https://www.cnblogs.com/CandiceW/p/10062413.html">序列</a></h2><p>序列(SEQUENCE)是序列号生成器，可以为表中的行自动生成序列号，产生一组等间隔的数值(类型为数字)。不占用磁盘空间，占用内存。其主要用途是生成表的主键值，可以在插入语句中引用，也可以通过查询检查当前值，或使序列增至下一个值。</p>
<h3 id="创建序列"><a href="#创建序列" class="headerlink" title="创建序列"></a>创建序列</h3><p>创建序列需要CREATE SEQUENCE系统权限。序列的创建语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">　　CREATE SEQUENCE 序列名</span><br><span class="line">　　[INCREMENT BY n]</span><br><span class="line">　　[START WITH n]</span><br><span class="line">　　[&#123;MAXVALUE/ MINVALUE n| NOMAXVALUE&#125;]</span><br><span class="line">　　[&#123;CYCLE|NOCYCLE&#125;]</span><br><span class="line">　　[&#123;CACHE n| NOCACHE&#125;];</span><br></pre></td></tr></table></figure>
<h4 id="其中："><a href="#其中：" class="headerlink" title="其中："></a>其中：</h4><ol>
<li><blockquote>
<p>INCREMENT BY用于定义序列的步长，如果省略，则默认为1，如果出现负值，则代表Oracle序列的值是按照此步长递减的。</p>
</blockquote>
</li>
<li><blockquote>
<p>START WITH 定义序列的初始值(即产生的第一个值)，默认为1。</p>
</blockquote>
</li>
<li><blockquote>
<p>MAXVALUE 定义序列生成器能产生的最大值。选项NOMAXVALUE是默认选项，代表没有最大值定义，这时对于递增Oracle序列，系统能够产生的最大值是10的27次方;对于递减序列，最大值是-1。</p>
</blockquote>
</li>
<li><blockquote>
<p>MINVALUE定义序列生成器能产生的最小值。选项NOMAXVALUE是默认选项，代表没有最小值定义，这时对于递减序列，系统能够产生的最小值是?10的26次方;对于递增序列，最小值是1。</p>
</blockquote>
</li>
<li><blockquote>
<p>CYCLE和NOCYCLE 表示当序列生成器的值达到限制值后是否循环。CYCLE代表循环，NOCYCLE代表不循环。如果循环，则当递增序列达到最大值时，循环到最小值;对于递减序列达到最小值时，循环到最大值。如果不循环，达到限制值后，继续产生新值就会发生错误。</p>
</blockquote>
</li>
<li><blockquote>
<p>CACHE(缓冲)定义存放序列的内存块的大小，默认为20。NOCACHE表示不对序列进行内存缓冲。对序列进行内存缓冲，可以改善序列的性能。</p>
</blockquote>
</li>
<li><blockquote>
<p>NEXTVAL 返回序列中下一个有效的值，任何用户都可以引用。</p>
</blockquote>
</li>
<li><blockquote>
<p>CURRVAL 中存放序列的当前值,NEXTVAL 应在 CURRVAL 之前指定 ，二者应同时有效。</p>
</blockquote>
</li>
</ol>
<p> 创建序列，该序列起始值50，步长为10，不缓冲，序列名为“DX1_06”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create sequence DX1_06 increment by 10 start with 50 nocache;</span><br></pre></td></tr></table></figure>

<p>创建序列，该序列起始值为1000，步长为2，最大值为10000，不可循环，序列名为“seq_1”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create sequence seq_1 increment by 2 start with 1000  maxvalue 10000 nocycle;</span><br></pre></td></tr></table></figure>

<h3 id="修改序列"><a href="#修改序列" class="headerlink" title="修改序列"></a>修改序列</h3><p> <strong>alter</strong></p>
<p>修改序列“DX1_06”，将该序列最大值设为“82000”，最小值设为“10”，步长设为“5”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter sequence DX1_06 maxvalue 82000 minvalue 10 increment by 5;</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">### 删除序列</span><br><span class="line">**drop**</span><br><span class="line"></span><br><span class="line">删除序列seq_1。</span><br><span class="line">```plsql</span><br><span class="line">drop sequence seq_1;</span><br></pre></td></tr></table></figure>

<h3 id="一些常用函数"><a href="#一些常用函数" class="headerlink" title="一些常用函数"></a>一些常用函数</h3><h4 id="查询一张表，而且要按照业务排序"><a href="#查询一张表，而且要按照业务排序" class="headerlink" title="查询一张表，而且要按照业务排序"></a><a href="https://www.cnblogs.com/mycoding/archive/2010/05/29/1747065.html">查询一张表，而且要按照业务排序</a></h4><p>  <code>rank() over(partition)</code></p>
<h3 id="从右边对字符串使用指定的字符进行填充"><a href="#从右边对字符串使用指定的字符进行填充" class="headerlink" title="从右边对字符串使用指定的字符进行填充 "></a><a href="https://www.cnblogs.com/BetterWF/archive/2012/07/18/2597472.html">从右边对字符串使用指定的字符进行填充 </a></h3><p><code>rpad(string,padded_length,[pad_string]) 　</code></p>
<ul>
<li> string 表示：被填充的字符串 　　</li>
<li> padded_length 表示：字符的长度，是返回的字符串的数量，如果这个数量比原字符串的长度要短，rpad函数将会把字符串截取成从左到右的n个字符; 　　</li>
<li>pad_string 是个可选参数，这个字符串是要粘贴到string的右边，如果这个参数未写，lpad函数将会在string的右边粘贴空格。 　</li>
</ul>
<h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a><a href="https://blog.csdn.net/qq_39443053/article/details/104044530">存储过程</a></h2><h3 id="存储过程的定义"><a href="#存储过程的定义" class="headerlink" title="存储过程的定义"></a>存储过程的定义</h3><h4 id="无参数"><a href="#无参数" class="headerlink" title="无参数"></a>无参数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create or replace procedure 存储过程名</span><br><span class="line">as</span><br><span class="line">begin</span><br><span class="line">  ----------------------------</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>

<h4 id="有参数"><a href="#有参数" class="headerlink" title="有参数"></a>有参数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create or replace procedure myDemo02(name in varchar,age in int)</span><br><span class="line">as</span><br><span class="line">begin</span><br><span class="line">  dbms_output.put_line(&#x27;name=&#x27;||name||&#x27;, age=&#x27;||age);</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>

<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ol>
<li>主键的创建有三种方法</li>
<li>视图上不能完成的操作：在视图上定义新的基本表</li>
<li>在sql中子查询是嵌入到另一个查询语句之中的查询语句</li>
<li>减少外键能实现实体的完整性</li>
<li>在全文的搜索的函数中，用于指定被搜索的列是match()</li>
<li>中间连接不属于连接种类</li>
<li>连接种类有：外连接、内连接、交叉连接</li>
<li>union可以组合多条SQL查询语句，形成组合查询</li>
<li>分组：grouped by     ？？？</li>
<li>delete语句的使用DELETE FROM Person WHERE LastName = ‘Wilson’ </li>
<li>返回当前日期的函数：curdate()</li>
<li>数据模型：网状模型、层次模型、网络模型</li>
<li>交叉连接又可以看成笛卡尔连接</li>
<li>为数据表创建索引的目的是提高查询的检索性能</li>
<li>SQL语言中的视图view是数据库的外模式</li>
<li>查看数据库中的所有表：show tables</li>
<li>start transaction 表示一个新的事物处理快的开始</li>
<li>格式化日期的函数：DATE_FORMAT()</li>
<li>SQL语言是非过程化语言</li>
<li>在正则表达式中匹配任意一个字符的符号是’ . ‘</li>
<li>DML语句就是数据库操作语句。包括update、 delete、select</li>
<li>DDL数据库定义语言。包括create、alter、drop、truncate</li>
<li>declimal是可变精度浮点值</li>
<li>逻辑运算符优先级：not / and / or</li>
<li><a href="https://www.yiibai.com/sql/sql-limit.html">limit</a></li>
</ol>
<h2 id="索引-1"><a href="#索引-1" class="headerlink" title="索引"></a>索引</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><h4 id="单索引"><a href="#单索引" class="headerlink" title="单索引"></a>单索引</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span>  bitmap  index   索引名  <span class="keyword">on</span> 表名( 变量名 <span class="keyword">desc</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">desc</span> 表示降序排序。  bitmap 为 位图索引 正常可不加</span><br></pre></td></tr></table></figure>

<h4 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h4><pre><code>           <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> index 索引名 <span class="keyword">on</span> 表名(列名<span class="number">1</span>,列名<span class="number">2</span>);              </span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
<h3 id="查看索引-1"><a href="#查看索引-1" class="headerlink" title="查看索引"></a>查看索引</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user_indexes<span class="operator">/</span>user_ind_columns ;</span><br></pre></td></tr></table></figure>



<h3 id="删除索引-1"><a href="#删除索引-1" class="headerlink" title="删除索引"></a>删除索引</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> index 索引名;</span><br></pre></td></tr></table></figure>

<h2 id="同义词-1"><a href="#同义词-1" class="headerlink" title="同义词"></a>同义词</h2><h3 id="创建同义词"><a href="#创建同义词" class="headerlink" title="创建同义词"></a>创建同义词</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> synonym 同义词 <span class="keyword">for</span> 目标</span><br></pre></td></tr></table></figure>

<h3 id="查看同义词"><a href="#查看同义词" class="headerlink" title="查看同义词"></a>查看同义词</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user_synonyms;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> all_synonyms;</span><br></pre></td></tr></table></figure>

<h3 id="删除同义词-1"><a href="#删除同义词-1" class="headerlink" title="删除同义词"></a>删除同义词</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> synonym 同义词;</span><br></pre></td></tr></table></figure>

<h2 id="序列-1"><a href="#序列-1" class="headerlink" title="序列"></a>序列</h2><h3 id="创建序列-1"><a href="#创建序列-1" class="headerlink" title="创建序列"></a>创建序列</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> sequence 序列名称</span><br><span class="line"></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">with</span> 开始数字</span><br><span class="line"></span><br><span class="line">increment <span class="keyword">by</span> 增长数字</span><br><span class="line"></span><br><span class="line">minvalue 最小值</span><br><span class="line"></span><br><span class="line">maxvalue 最大值</span><br><span class="line"></span><br><span class="line"><span class="keyword">cycle</span></span><br><span class="line"></span><br><span class="line">nocache</span><br></pre></td></tr></table></figure>

<p><strong>详细说明：</strong></p>
<p>start with 开始数字à从几开始</p>
<p>increment by 增长à步长，每次增长几个数</p>
<p>minvalue 最小值</p>
<p>maxvalue 最大值à可以不设置，不设置应写为nomaxvalue，也就是无穷大</p>
<p>cycle 循环，也就是说当长增长到最大值后，再从最小值开始重新增长</p>
<p>nocache 不设缓存</p>
<h3 id="查看序列"><a href="#查看序列" class="headerlink" title="查看序列"></a>查看序列</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span>  <span class="keyword">from</span> user_SEQUENCES、all_SEQUENCES;</span><br></pre></td></tr></table></figure>



<h3 id="引用序列"><a href="#引用序列" class="headerlink" title="引用序列"></a>引用序列</h3><p>   xx.nextval      /  xx.curval </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> xx表 <span class="keyword">values</span> (  )  ,</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept <span class="keyword">values</span>( DX1_06.nextval,<span class="string">&#x27;ss&#x27;</span>,<span class="string">&#x27;CN&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="keyword">NULL</span>,<span class="keyword">NULL</span> );</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="修改序列-1"><a href="#修改序列-1" class="headerlink" title="修改序列"></a>修改序列</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> sequence student_id <span class="comment">-- 序列名 也可以更改</span></span><br><span class="line">minvalue <span class="number">1</span>   </span><br><span class="line">maxvalue <span class="number">99999</span>  </span><br><span class="line"><span class="keyword">start</span> <span class="keyword">with</span> <span class="number">1</span>   </span><br><span class="line">increment <span class="keyword">by</span> <span class="number">1</span>  </span><br><span class="line"><span class="keyword">cycle</span>    <span class="comment">-- 到99999后，从头开始</span></span><br><span class="line">nocache；  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h2><h3 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> 用户名 identified <span class="keyword">by</span> 密码;</span><br></pre></td></tr></table></figure>

<h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span>  (c##)<span class="keyword">user</span> username identified <span class="keyword">by</span> password;    <span class="operator">/</span><span class="operator">/</span> 创建普通用户 需要添加 c##</span><br></pre></td></tr></table></figure>





<h3 id="锁定用户"><a href="#锁定用户" class="headerlink" title="锁定用户"></a>锁定用户</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> username ACCOUNT LOCK; 锁定</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> username ACCOUNT UNLOCK; 解锁</span><br></pre></td></tr></table></figure>



<h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> username ;</span><br></pre></td></tr></table></figure>



<h2 id="新技能学习-如排序等"><a href="#新技能学习-如排序等" class="headerlink" title="新技能学习 如排序等"></a>新技能学习 如排序等</h2><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">(DENSE_)<span class="built_in">RANK</span>( ) <span class="keyword">OVER</span> ([ query_partition_clause ] order_by_clause)</span><br><span class="line"><span class="built_in">rank</span>():跳跃式，两个第<span class="number">1</span>，下一个就是第<span class="number">3</span></span><br><span class="line"><span class="built_in">dense_rank</span>():非跳跃式,两个第<span class="number">1</span>,下一个是第<span class="number">2</span></span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">分为：（1）连续或不连续：dense_rank,rank</span><br><span class="line"></span><br><span class="line">     （2）分区或不分区：使用partition，不使用partition</span><br></pre></td></tr></table></figure>



<h1 id="PL-SQL"><a href="#PL-SQL" class="headerlink" title="PL/SQL"></a>PL/SQL</h1><h2 id="和-的差别"><a href="#和-的差别" class="headerlink" title=".和/ 的差别"></a>.和/ 的差别</h2><p><strong>在SQL*Plus中键入如下PL/SQL块，以点号（.）结束。如果想运行缓冲区的内容，那么可以使用“RUN”命令或者“ / ”命令。</strong><br>1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">在SQL*Plus中键入如下PL/SQL块，以点号（.）结束。如果想运行缓冲区的内容，那么可以使用“RUN”命令或者“ / ”命令。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">set serveroutput on 命令是打开COMMAND命令窗口中的输出流。</span><br><span class="line"></span><br><span class="line">不搞的话没输出 非常恐怖！！！！！！！！！！！！！！！！！！！</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>分隔符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>+</code>,<code>-</code>, <code>*</code>, <code>/</code></td>
<td>加法，减法/负，乘法，除法</td>
</tr>
<tr>
<td><code>%</code></td>
<td>属性绑定</td>
</tr>
<tr>
<td><code>&#39;</code></td>
<td>字符串分隔符</td>
</tr>
<tr>
<td><code>.</code></td>
<td>组件选择符</td>
</tr>
<tr>
<td><code>(,)</code></td>
<td>表达式或列表分隔符</td>
</tr>
<tr>
<td><code>:</code></td>
<td>主机变量指示符</td>
</tr>
<tr>
<td><code>,</code></td>
<td>项目分隔符</td>
</tr>
<tr>
<td><code>&quot;</code></td>
<td>引用标识符分隔符</td>
</tr>
<tr>
<td><code>=</code></td>
<td>关系运算符</td>
</tr>
<tr>
<td><code>@</code></td>
<td>远程访问指示符</td>
</tr>
<tr>
<td><code>;</code></td>
<td>声明或语句终止符</td>
</tr>
<tr>
<td><code>:=</code></td>
<td>赋值运算符</td>
</tr>
<tr>
<td><code>=&gt;</code></td>
<td>关联运算符</td>
</tr>
<tr>
<td>ΙΙ</td>
<td>连接运算符</td>
</tr>
<tr>
<td><code>**</code></td>
<td>指数运算符</td>
</tr>
<tr>
<td><code>&lt;&lt;</code>, <code>&gt;&gt;</code></td>
<td>标签分隔符(开始和结束)</td>
</tr>
<tr>
<td><code>/*</code>, <code>*/</code></td>
<td>多行注释分隔符(开始和结束)</td>
</tr>
<tr>
<td><code>--</code></td>
<td>单行注释指示符</td>
</tr>
<tr>
<td><code>..</code></td>
<td>范围运算符</td>
</tr>
<tr>
<td><code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></td>
<td>关系运算符</td>
</tr>
<tr>
<td><code>&lt;&gt;</code>, <code>&#39;=</code>, <code>~=</code>, <code>^=</code></td>
<td>不同版本的”不等于”运算符</td>
</tr>
</tbody></table>
<h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><p>3、put：将内容写到内存，<strong>等到put_line时一起输出</strong><br>4、put_line：不用多说了，输出字符</p>
<h3 id="输出-语句"><a href="#输出-语句" class="headerlink" title="输出 语句"></a>输出 语句</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dbms_output.put_line(  );   //  line 为换行</span><br><span class="line"></span><br><span class="line">dbms_output.put()  正常输出</span><br></pre></td></tr></table></figure>



<h3 id="创建过程"><a href="#创建过程" class="headerlink" title="创建过程"></a>创建过程</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> REPLACE] <span class="keyword">PROCEDURE</span> procedure_name </span><br><span class="line">[(parameter_name [<span class="keyword">IN</span> <span class="operator">|</span> <span class="keyword">OUT</span> <span class="operator">|</span> <span class="keyword">IN</span> <span class="keyword">OUT</span>] type [, ...])] </span><br><span class="line">&#123;<span class="keyword">IS</span> <span class="operator">|</span> <span class="keyword">AS</span>&#125; </span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line">  <span class="operator">&lt;</span> procedure_body <span class="operator">&gt;</span> </span><br><span class="line"><span class="keyword">END</span> procedure_name;</span><br><span class="line"><span class="keyword">SQL</span></span><br></pre></td></tr></table></figure>



<h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><ul>
<li>使用EXECUTE关键字</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXECUTE</span> 过程名;</span><br></pre></td></tr></table></figure>



<ul>
<li>从PL/SQL块调用过程的名称</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span> </span><br><span class="line"> 过程名;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> REPLACE] <span class="keyword">FUNCTION</span> function_name </span><br><span class="line">[(parameter_name [<span class="keyword">IN</span> <span class="operator">|</span> <span class="keyword">OUT</span> <span class="operator">|</span> <span class="keyword">IN</span> <span class="keyword">OUT</span>] type [, ...])] </span><br><span class="line"><span class="keyword">RETURN</span> return_datatype </span><br><span class="line">&#123;<span class="keyword">IS</span> <span class="operator">|</span> <span class="keyword">AS</span>&#125; </span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line">   <span class="operator">&lt;</span> function_body <span class="operator">&gt;</span> </span><br><span class="line"><span class="keyword">END</span> [function_name];</span><br><span class="line"><span class="keyword">SQL</span></span><br></pre></td></tr></table></figure>

<p><strong>其中，</strong></p>
<ul>
<li><strong>function-name是指定要创建的函数的名称。</strong></li>
<li><strong>[OR REPLACE]选项指示是否允许修改现有的函数。</strong></li>
<li><strong>可选参数列表包含参数的名称，模式和类型。 IN表示将从外部传递的值，OUT表示将用于返回过程外的值的参数。</strong></li>
<li><strong>函数必须包含一个返回(RETURN)语句。</strong></li>
<li><strong>RETURN子句指定要从函数返回的数据类型。</strong></li>
<li><strong>function-body包含可执行部分。</strong></li>
<li><strong>使用AS关键字代替IS关键字，用来创建独立的函数。</strong></li>
</ul>
<h3 id="查询函数"><a href="#查询函数" class="headerlink" title="查询函数"></a>查询函数</h3><h2 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h2><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 游标是什么？</span><br><span class="line">   用来存储多条查询数据的一种数据结构（<span class="string">&#x27;结果集&#x27;</span>），</span><br><span class="line">   它有一个 <span class="string">&#x27;指针&#x27;</span>，从上往下移动（<span class="string">&#x27;fetch&#x27;</span>），从而能够 <span class="string">&#x27;遍历每条记录&#x27;</span></span><br><span class="line">   </span><br><span class="line"><span class="number">2.</span> 优缺点</span><br><span class="line">   (<span class="number">1</span>) 提高 <span class="keyword">sql</span> <span class="string">&#x27;执行效率&#x27;</span></span><br><span class="line">   (<span class="number">2</span>) 牺牲 <span class="string">&#x27;内存&#x27;</span></span><br></pre></td></tr></table></figure>







<h3 id="隐式游标"><a href="#隐式游标" class="headerlink" title="隐式游标"></a>隐式游标</h3><h3 id="显示游标"><a href="#显示游标" class="headerlink" title="显示游标"></a>显示游标</h3><p>使用显式游标包括以下步骤 -</p>
<ul>
<li>声明游标初始化内存</li>
<li>打开游标分配内存</li>
<li>从游标获取数据</li>
<li>关闭游标以释放分配的内存</li>
</ul>
<p>声明游标</p>
<p>声明游标使用名称和相关的SELECT语句来定义游标。 例如 -</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CURSOR</span> c_customers <span class="keyword">IS</span> </span><br><span class="line">   <span class="keyword">SELECT</span> id, name, address <span class="keyword">FROM</span> customers;</span><br><span class="line"><span class="keyword">SQL</span></span><br></pre></td></tr></table></figure>

<p>打开游标</p>
<p>打开游标将为游标分配内存，并使其准备好将SQL语句返回的行记录数据提取到其中。例如，打开上面定义的游标，如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">OPEN</span> c_customers;</span><br><span class="line"><span class="keyword">SQL</span></span><br></pre></td></tr></table></figure>

<p>获取游标获取游标一次仅访问一行。 例如，从上面打开的游标中获取行，如下所示代码：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FETCH</span> c_customers <span class="keyword">INTO</span> c_id, c_name, c_addr;</span><br><span class="line"><span class="keyword">SQL</span></span><br></pre></td></tr></table></figure>

<p>关闭游标</p>
<p>关闭游标意味着释放分配的内存。例如，关闭上面打开的游标，如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CLOSE</span> c_customers;</span><br><span class="line"><span class="keyword">SQL</span></span><br></pre></td></tr></table></figure>





<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><table>
<thead>
<tr>
<th>异常</th>
<th>Oracle错误代码</th>
<th>SQLCODE</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>ACCESS_INTO_NULL</code></td>
<td>06530</td>
<td><code>-6530</code></td>
<td>当一个空对象被自动分配一个值时会引发它。</td>
</tr>
<tr>
<td><code>CASE_NOT_FOUND</code></td>
<td>06592</td>
<td><code>-6592</code></td>
<td>当没有选择<code>CASE</code>语句的<code>WHEN</code>子句中的任何选项时，会引发这个错误，并且没有<code>ELSE</code>子句。</td>
</tr>
<tr>
<td><code>COLLECTION_IS_NULL</code></td>
<td>06531</td>
<td><code>-6531</code></td>
<td>当程序尝试将<code>EXISTS</code>以外的集合方法应用于未初始化的嵌套表或<code>varray</code>时，或程序尝试将值分配给未初始化的嵌套表或<code>varray</code>的元素时，会引发此问题。</td>
</tr>
<tr>
<td><code>DUP_VAL_ON_INDEX</code></td>
<td>00001</td>
<td><code>-1</code></td>
<td>当尝试将重复值存储在具有唯一索引的列中时引发此错误。</td>
</tr>
<tr>
<td><code>INVALID_CURSOR</code></td>
<td>01001</td>
<td><code>-1001</code></td>
<td>当尝试进行不允许的游标操作(例如关闭未打开的游标)时会引发此错误。</td>
</tr>
<tr>
<td><code>INVALID_NUMBER</code></td>
<td>01722</td>
<td><code>-1722</code></td>
<td>当字符串转换为数字时失败，因为字符串不代表有效的数字。</td>
</tr>
<tr>
<td><code>LOGIN_DENIED</code></td>
<td>01017</td>
<td><code>-1017</code></td>
<td>当程序尝试使用无效的用户名或密码登录到数据库时引发。</td>
</tr>
<tr>
<td><code>NO_DATA_FOUND</code></td>
<td>01403</td>
<td><code>+100</code></td>
<td>当<code>SELECT INTO</code>语句不返回任何行时会引发它。</td>
</tr>
<tr>
<td><code>NOT_LOGGED_ON</code></td>
<td>01012</td>
<td><code>-1012</code></td>
<td>当数据库调用没有连接到数据库时引发。</td>
</tr>
<tr>
<td><code>PROGRAM_ERROR</code></td>
<td>06501</td>
<td><code>-6501</code></td>
<td>当PL/SQL遇到内部问题时会引发。</td>
</tr>
<tr>
<td><code>ROWTYPE_MISMATCH</code></td>
<td>06504</td>
<td><code>-6504</code></td>
<td>当游标在具有不兼容数据类型的变量中获取值时引发。</td>
</tr>
<tr>
<td><code>SELF_IS_NULL</code></td>
<td>30625</td>
<td><code>-30625</code></td>
<td>当调用成员方法时引发，但对象类型的实例未初始化。</td>
</tr>
<tr>
<td><code>STORAGE_ERROR</code></td>
<td>06500</td>
<td><code>-6500</code></td>
<td>当PL/SQL用尽内存或内存已损坏时引发。</td>
</tr>
<tr>
<td><code>TOO_MANY_ROWS</code></td>
<td>01422</td>
<td><code>-1422</code></td>
<td>当<code>SELECT INTO</code>语句返回多行时引发。</td>
</tr>
<tr>
<td><code>VALUE_ERROR</code></td>
<td>06502</td>
<td><code>-6502</code></td>
<td>当发生算术，转换，截断或者<code>sizeconstraint</code>错误时引发。</td>
</tr>
<tr>
<td><code>ZERO_DIVIDE</code></td>
<td>01476</td>
<td><code>1476</code></td>
<td>当尝试将数字除以零时引发。</td>
</tr>
</tbody></table>
<h2 id="异常处理的语法"><a href="#异常处理的语法" class="headerlink" title="异常处理的语法"></a>异常处理的语法</h2><p>异常处理的一般语法如下。在这里，可以列举尽可能多的异常并且指定处理方式。默认的异常将使用WHEN…THEN处理，如下语法所示 -</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> </span><br><span class="line">   <span class="operator">&lt;</span>declarations section<span class="operator">&gt;</span> </span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line">   <span class="operator">&lt;</span>executable command(s)<span class="operator">&gt;</span> </span><br><span class="line">EXCEPTION </span><br><span class="line">   <span class="operator">&lt;</span>exception handling goes here <span class="operator">&gt;</span> </span><br><span class="line">   <span class="keyword">WHEN</span> exception1 <span class="keyword">THEN</span>  </span><br><span class="line">      exception1<span class="operator">-</span>handling<span class="operator">-</span>statements  </span><br><span class="line">   <span class="keyword">WHEN</span> exception2  <span class="keyword">THEN</span>  </span><br><span class="line">      exception2<span class="operator">-</span>handling<span class="operator">-</span>statements  </span><br><span class="line">   <span class="keyword">WHEN</span> exception3 <span class="keyword">THEN</span>  </span><br><span class="line">      exception3<span class="operator">-</span>handling<span class="operator">-</span>statements </span><br><span class="line">   ........ </span><br><span class="line">   <span class="keyword">WHEN</span> others <span class="keyword">THEN</span> </span><br><span class="line">      exception3<span class="operator">-</span>handling<span class="operator">-</span>statements </span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> SERVEROUTPUT <span class="keyword">ON</span> SIZE <span class="number">99999</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> </span><br><span class="line">   c_id customers.id<span class="operator">%</span>type :<span class="operator">=</span> <span class="number">100</span>; </span><br><span class="line">   c_name  customerS.name<span class="operator">%</span>type; </span><br><span class="line">   c_addr customers.address<span class="operator">%</span>type; </span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line">   <span class="keyword">SELECT</span>  name, address <span class="keyword">INTO</span>  c_name, c_addr </span><br><span class="line">   <span class="keyword">FROM</span> customers </span><br><span class="line">   <span class="keyword">WHERE</span> id <span class="operator">=</span> c_id;  </span><br><span class="line">   DBMS_OUTPUT.PUT_LINE (<span class="string">&#x27;姓名: &#x27;</span><span class="operator">||</span>  c_name); </span><br><span class="line">   DBMS_OUTPUT.PUT_LINE (<span class="string">&#x27;地址: &#x27;</span> <span class="operator">||</span> c_addr); </span><br><span class="line"></span><br><span class="line">EXCEPTION </span><br><span class="line">   <span class="keyword">WHEN</span> no_data_found <span class="keyword">THEN</span> </span><br><span class="line">      dbms_output.put_line(<span class="string">&#x27;没有找到符合条件的客户信息!&#x27;</span>); </span><br><span class="line">   <span class="keyword">WHEN</span> others <span class="keyword">THEN</span> </span><br><span class="line">      dbms_output.put_line(<span class="string">&#x27;Error!&#x27;</span>); </span><br><span class="line"><span class="keyword">END</span>; </span><br><span class="line"><span class="operator">/</span></span><br></pre></td></tr></table></figure>







<h2 id="填充默认值。"><a href="#填充默认值。" class="headerlink" title="填充默认值。"></a>填充默认值。</h2><p>NVL( xx  ,  0 )  默认为0      zero</p>
<p><strong>语法</strong></p>
<p><strong>NVL(eExpression1, eExpression2)</strong></p>
<p><strong>参数</strong><br><strong>eExpression1, eExpression2</strong></p>
<p><strong>如果 eExpression1 的计算结果为 null 值，则 NVL( ) 返回 eExpression2。如果 eExpression1 的计算结果不是 null 值，则返回 eExpression1。eExpression1 和 eExpression2 可以是任意一种数据类型。如果 eExpression1 与 eExpression2 的结果皆为 null 值，则 NVL( ) 返回 .NULL.。</strong></p>
<h2 id="删除-delete"><a href="#删除-delete" class="headerlink" title="删除 delete"></a>删除 delete</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> xx  <span class="keyword">where</span> </span><br></pre></td></tr></table></figure>

<h2 id="插入-insert"><a href="#插入-insert" class="headerlink" title="插入 insert"></a>插入 insert</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名 <span class="keyword">values</span>(值<span class="number">1</span>，值<span class="number">2</span>，......);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名(列<span class="number">1</span>，列<span class="number">2</span>，......)<span class="keyword">values</span>(值<span class="number">1</span>，值<span class="number">2</span>，......);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名<span class="number">2</span>(列<span class="number">1</span>，列<span class="number">2</span>，......)<span class="keyword">select</span> 值<span class="number">1</span>，值<span class="number">2</span>，...... <span class="keyword">from</span> 表名<span class="number">1</span>;  （表<span class="number">2</span>必须存在，列<span class="number">1</span>，列<span class="number">2</span>，......必须存在）</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表<span class="number">2</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> 值<span class="number">1</span>，值<span class="number">2</span>，...... <span class="keyword">into</span> 表名<span class="number">2</span> <span class="keyword">from</span> 表名<span class="number">1</span>; （表<span class="number">2</span>不存在，插入时会自动创建表名<span class="number">2</span>）</span><br></pre></td></tr></table></figure>



<h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><h2 id="old-new"><a href="#old-new" class="headerlink" title="old / new"></a>old / new</h2><p>1.当使用insert语句的时候，如果原表中没有数据的话，那么对于插入数据后表来说新插入的那条数据就是new，如图所示：</p>
<p><img src="https://images2015.cnblogs.com/blog/495456/201608/495456-20160804111235809-1841558199.png" alt="img"></p>
<p>2.当使用delete语句的时候，删除的那一条数据相对于删除数据后表的数据来说就是od，如图所示：</p>
<p><img src="https://images2015.cnblogs.com/blog/495456/201608/495456-20160804111249215-346800140.png" alt="img"></p>
<p>3.当使用update语句的时候，当修改原表数据的时候相对于修改数据后表的数据来说原表中修改的那条数据就是old，而修改数据后表被修改的那条数据就是new，如图所示：</p>
<p><img src="https://images2015.cnblogs.com/blog/495456/201608/495456-20160804111301528-856490776.png" alt="img"></p>
<h2 id="RAISE-APPLICATION-ERROR"><a href="#RAISE-APPLICATION-ERROR" class="headerlink" title="RAISE_APPLICATION_ERROR"></a>RAISE_APPLICATION_ERROR</h2><p>可能不是很多人知道 RAISE_APPLICATION_ERROR 的用途是什么，虽然从字面上已经猜到这个函数是干什么用的。平时用来测试的异常处理<br>我们都是通过dbms_output.put_line来输出异常信息，但是在实际的应用中，需要把异常信息返回给调用的客户端。<br>其实 RAISE_APPLICATION_ERROR 是将应用程序专有的错误从服务器端转达到客户端应用程序(其他机器上的SQLPLUS或者其他前台开发语言)</p>
]]></content>
      <categories>
        <category>课程学习</category>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>课程学习</tag>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>人工智能期末复习</title>
    <url>/135xyq.github.io/2022/05/28/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%9C%9F%E6%9C%AB%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="人工智能知识点总结"><a href="#人工智能知识点总结" class="headerlink" title="人工智能知识点总结"></a>人工智能知识点总结</h1><h2 id="第-1-章-人工智能概述"><a href="#第-1-章-人工智能概述" class="headerlink" title="第 1 章 人工智能概述"></a>第 1 章 人工智能概述</h2><h3 id="智能"><a href="#智能" class="headerlink" title="智能"></a>智能</h3><p>智能指人类在认识客观世界中，由思维过程和脑力活动所表现出的综合能力。</p>
<h4 id="智能包含的能力"><a href="#智能包含的能力" class="headerlink" title="智能包含的能力"></a>智能包含的能力</h4><ol>
<li>感知能力</li>
<li>记忆和思维能力</li>
<li>学习和自适应能力</li>
<li>行为能力</li>
</ol>
<h3 id="人工智能的概念"><a href="#人工智能的概念" class="headerlink" title="人工智能的概念"></a>人工智能的概念</h3><p><strong>能力角度</strong>：用人工的方法在机器上实现的智能（也称机器智能）。<br><strong>学科角度</strong>：研究如何构造智能机器或智能系统，以模拟、延伸和扩展人类智能。</p>
<h4 id="人工智能的能力"><a href="#人工智能的能力" class="headerlink" title="人工智能的能力"></a>人工智能的能力</h4><ol>
<li>机器感知（输入：机器视觉、机器听觉等）</li>
<li>机器学习（获取知识：符号学习、统计学习、神经学习、深度学习）</li>
<li>机器思维（认识事物：推理（确定性、不确定性）、搜索（启发式））</li>
<li>机器决策（解决方案：明确目标，形成方案（智能决策支持系统））</li>
<li>机器情感（态度体验：喜、怒、哀、乐、爱、恨）</li>
<li>机器行为（输出：走、跑、跳、说、唱等）</li>
</ol>
<h4 id="人工智能的载体"><a href="#人工智能的载体" class="headerlink" title="人工智能的载体"></a>人工智能的载体</h4><ul>
<li>  智能系统</li>
<li>  智能机器人</li>
</ul>
<h3 id="人工智能的不同学派"><a href="#人工智能的不同学派" class="headerlink" title="人工智能的不同学派"></a>人工智能的不同学派</h3><h4 id="符号主义学派（逻辑主义、心理学派）"><a href="#符号主义学派（逻辑主义、心理学派）" class="headerlink" title="符号主义学派（逻辑主义、心理学派）"></a>符号主义学派（逻辑主义、心理学派）</h4><p>功能模拟</p>
<p>智能的基础是知识，其核心是知识表示和知识推理；知识可用<strong>符号</strong>表示，也可用符号进行推理，因而可以建立基于知识的人类智能和机器智能的统一的理论体系。</p>
<h6 id="主要观点："><a href="#主要观点：" class="headerlink" title="主要观点："></a>主要观点：</h6><p>AI 起源于数理逻辑，人类认知的基元是符号，认知过程是符号表示上的一种运算</p>
<h6 id="代表性成果："><a href="#代表性成果：" class="headerlink" title="代表性成果："></a>代表性成果：</h6><p>纽厄尔和西蒙等人研制的称为逻辑理论机的数学定理证明程序 LT</p>
<h6 id="代表人物："><a href="#代表人物：" class="headerlink" title="代表人物："></a>代表人物：</h6><p>纽厄尔、肖、西蒙和尼尔逊(Nilsson)等</p>
<h4 id="联结主义学派（仿生学派或生理学派）"><a href="#联结主义学派（仿生学派或生理学派）" class="headerlink" title="联结主义学派（仿生学派或生理学派）"></a>联结主义学派（仿生学派或生理学派）</h4><p>结构模拟</p>
<p>思维的基元是<strong>神经元</strong>，而不是符号；思维过程是神经元的联结活动过程，而不是符号运算过程；反对符号主义关于物理符号系统的假设。</p>
<h6 id="主要观点：-1"><a href="#主要观点：-1" class="headerlink" title="主要观点："></a>主要观点：</h6><p>AI 起源于仿生学，特别是人脑模型，人类认知的基元是神经元，认知过程是神经元的联结活动过程</p>
<h6 id="代表性成果：-1"><a href="#代表性成果：-1" class="headerlink" title="代表性成果："></a>代表性成果：</h6><p>由麦克洛奇和皮兹创立的脑模型，即 MP 模型</p>
<h6 id="代表人物：-1"><a href="#代表人物：-1" class="headerlink" title="代表人物："></a>代表人物：</h6><p>麦克洛奇和皮兹</p>
<h4 id="行为主义学派（进化主义、控制论学派）"><a href="#行为主义学派（进化主义、控制论学派）" class="headerlink" title="行为主义学派（进化主义、控制论学派）"></a>行为主义学派（进化主义、控制论学派）</h4><p>行为模拟</p>
<p>智能取决于<strong>感知和行动</strong>，提出了智能行为的“感知—动作”模型；智能不需要知识、不需要表示、不需要推理；人工智能可以像人类智能那样逐步进化。</p>
<h6 id="主要观点：-2"><a href="#主要观点：-2" class="headerlink" title="主要观点："></a>主要观点：</h6><p>AI 起源于控制论，智能取决于感知和行为，取决于对外界复杂环境的适应，而不是推理。</p>
<h6 id="代表性成果：-2"><a href="#代表性成果：-2" class="headerlink" title="代表性成果："></a>代表性成果：</h6><p>Brooks 教授研制的机器虫</p>
<h6 id="代表人物：-2"><a href="#代表人物：-2" class="headerlink" title="代表人物："></a>代表人物：</h6><p>Brooks 教授</p>
<h3 id="人工智能的研究和应用领域"><a href="#人工智能的研究和应用领域" class="headerlink" title="人工智能的研究和应用领域"></a>人工智能的研究和应用领域</h3><h4 id="机器思维"><a href="#机器思维" class="headerlink" title="机器思维"></a>机器思维</h4><p>模拟人类的思维功能。</p>
<h5 id="推理"><a href="#推理" class="headerlink" title="推理"></a>推理</h5><p>推理:是指按照某种策略从已知事实出发利用知识推出所需结论的过程。<br>推理方法：是指实现推理的具体办法。</p>
<h6 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h6><p>根据所用知识的的确定性：</p>
<ol>
<li>确定性推理</li>
<li>不确定性推理</li>
</ol>
<p>$$<br>推理分类 =<br>\begin{cases}<br>按推理的逻辑基础<br>\begin{cases}<br>归纳推理 \<br>演绎推理<br>\end{cases}<br>\ 按知识的确定性<br>\begin{cases}<br>确定性推理 \<br>不确定性推理<br>\end{cases}<br>\ 按推理的控制策略<br>\begin{cases}<br>推理策略 \<br>搜索策略<br>\end{cases}<br>\end{cases}<br>$$</p>
<h5 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h5><p>搜索：依靠经验，利用已有知识，根据问题的实际情况，不断寻找可利用知识，从而构造一条代价最小的推理路线，使问题得以解决的过程称为搜索<br>智能搜索：是指可以利用搜索过程得到的中间信息来引导搜索向最优方向发展的算法。</p>
<h6 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h6><p>根据搜索机理：</p>
<ol>
<li>基于搜索空间的方法</li>
<li>基于随机算法的方法</li>
</ol>
<h5 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h5><p>规划： 是指从某个特定问题状态出发，寻找并建立一个操作序列，直到求得目标状态为止的一个行动过程的描述。</p>
<p>规划的特点：与一般问题求解技术相比，规划更侧重于问题求解过程，并且要解决的问题一般是真实世界的实际问题，而不是抽象的数学模型。</p>
<h4 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h4><p>是机器获取知识的根本途径，也是机器具有智能的重要标志。</p>
<p>按照对人类学习的模拟方式，机器学习可分为<strong>符号主义机器学习</strong>和<strong>连接主义机器学习</strong>两种类型。</p>
<h5 id="符号主义学习"><a href="#符号主义学习" class="headerlink" title="符号主义学习"></a>符号主义学习</h5><p>符号主义机器学习泛指各种从功能上模拟人类学习能力的机器学习方法，是符号主义学派的机器学习观点。</p>
<p>$$<br>符号主义机器学习<br>\begin{cases}<br>记忆学习（死记硬背学习） \<br>符号学习（以归纳推理为基础的学习） \<br>统计学习  \<br>发现学习 \<br>强化学习  \<br>集成学习 \<br>大规模机器学习<br>\end{cases}<br>$$</p>
<h5 id="连接主义学习"><a href="#连接主义学习" class="headerlink" title="连接主义学习"></a>连接主义学习</h5><p>连接主义机器学习简称连接学习或神经学习，是一种基于人工神经网络、从结构上模拟人类学习能力的方法。其生理基础是中枢神经系统，基本单位是单个神经元。</p>
<p>$$<br>连接学习方法<br>\begin{cases}<br>浅层学习<br>\begin{cases}<br>感知器学习 \<br>BP网络学习 \<br>Hopfield网络学习<br>\end{cases}<br>\ 深层学习<br>\begin{cases}<br>卷积神经网络（CNN）学习 \<br>深度信念网络（DBN）学习 \<br>深度波尔茨曼机（DBM）学习<br>\end{cases}<br>\end{cases}<br>$$</p>
<h5 id="知识发现和数据挖掘"><a href="#知识发现和数据挖掘" class="headerlink" title="知识发现和数据挖掘"></a>知识发现和数据挖掘</h5><p>在庞大的数据库中寻找和提取出人们感兴趣的知识的方法。</p>
<p>特性：</p>
<p>规模性（Volume），多样性（Variety），实时性（Velocity），价值性（Value）</p>
<h4 id="机器感知"><a href="#机器感知" class="headerlink" title="机器感知"></a>机器感知</h4><p>机器获取外界信息的主要途径。</p>
<h5 id="机器视觉"><a href="#机器视觉" class="headerlink" title="机器视觉"></a>机器视觉</h5><p>用机器模拟人和生物的视觉系统功能。</p>
<p>研究目标：使计算机具有通过二维图像认知三维环境信息的能力。</p>
<h5 id="模式识别"><a href="#模式识别" class="headerlink" title="模式识别"></a>模式识别</h5><p>让计算机能够对给定的事务进行鉴别，并把它归入与其相同或相似的模式中。</p>
<h6 id="识别模式的过程"><a href="#识别模式的过程" class="headerlink" title="识别模式的过程"></a>识别模式的过程</h6><ol>
<li>采集待识别事物的模式信息；</li>
<li>对其进行各种变换和预处理，从中抽出有意义的特征或基元，得到待识别事物的模式；</li>
<li>与机器中原有的各种标准模式进行比较，完成对待识别事物的分类识别；</li>
<li>输出识别结果。</li>
</ol>
<h5 id="自然语言处理"><a href="#自然语言处理" class="headerlink" title="自然语言处理"></a>自然语言处理</h5><p>自然语言处理就是要研究人类与计算机之间进行有效交流的各种理论和方法。</p>
<p>包括：自然语言理解、机器翻译、自然语言生成等</p>
<h4 id="机器行为"><a href="#机器行为" class="headerlink" title="机器行为"></a>机器行为</h4><p>计算机作用于外界环境的主要途径。</p>
<h5 id="智能控制"><a href="#智能控制" class="headerlink" title="智能控制"></a>智能控制</h5><p>是指那种无需或需要尽可能少的人工干预就能独立的驱动智能机器实现其目标的控制过程。它是人工智能技术与传统自动控制技术相结合的产物。</p>
<h5 id="智能制造"><a href="#智能制造" class="headerlink" title="智能制造"></a>智能制造</h5><p>计算机为核心而集成有关技术，以取代、延伸与强化有关专门人才在制造中的有关部分脑力活动所形成、发展、乃至创新了的制造。</p>
<h2 id="第-2-章-确定性知识系统"><a href="#第-2-章-确定性知识系统" class="headerlink" title="第 2 章 确定性知识系统"></a>第 2 章 确定性知识系统</h2><h3 id="确定性知识系统概述"><a href="#确定性知识系统概述" class="headerlink" title="确定性知识系统概述"></a>确定性知识系统概述</h3><h4 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h4><p>知识的一般性解释：知识是人们在改造客观世界的实践中积累起来的认识和经验。</p>
<p>$$<br>知识类型<br>\begin{cases}<br>按适应范围<br>\begin{cases}<br>常识性知识(通用通识、普遍知道的知识) \<br>领域知识（某个具体领域的知识，如专家经验等）<br>\end{cases}<br>\ 按作用效果<br>\begin{cases}<br>陈述性知识 \<br>过程性知识 \<br>控制性知识<br>\end{cases}<br>\ 按知识级别<br>\begin{cases}<br>零级知识 \<br>一级知识 \<br>二级知识<br>\end{cases}<br>\ 按知识确定性<br>\begin{cases}<br>确定性知识(可以给出真假的知识) \<br>不确定性知识(具有不确定性的知识)<br>\end{cases}<br>\end{cases}<br>$$</p>
<h5 id="知识表示的解释"><a href="#知识表示的解释" class="headerlink" title="知识表示的解释"></a>知识表示的解释</h5><p>知识表示是对知识的描述，即用一组符号把知识编码成计算机可以接受的某种结构。其表示方法不唯一。</p>
<h5 id="知识表示的要求"><a href="#知识表示的要求" class="headerlink" title="知识表示的要求"></a>知识表示的要求</h5><ul>
<li>表示能力：<br>  是指能否正确、有效地将问题求解所需要的知识表示出来。</li>
<li>可利用性：<br>  是指表示方法应有利于进行有效的知识推理。包括：对推理的适应性，对高效算法的支持程度</li>
<li>可组织性与可维护性：<br>  可组织性是指可以按某种方式把知识组织成某种知识结构。<br>  可维护性是指要便于对知识的增、删、改等操作</li>
<li>可理解性与可实现性：<br>  可理解性是指知识应易读、易懂、易获取等<br>  可实现性是指知识的表示要便于计算机上实现</li>
</ul>
<h4 id="推理-1"><a href="#推理-1" class="headerlink" title="推理"></a>推理</h4><h5 id="推理的心理学观点"><a href="#推理的心理学观点" class="headerlink" title="推理的心理学观点"></a>推理的心理学观点</h5><p>按照心理学的观点，推理是由具体事例归纳出一般规律，或者根据已有知识推出新的结论的思维过程。</p>
<h5 id="推理的形式"><a href="#推理的形式" class="headerlink" title="推理的形式"></a>推理的形式</h5><ol>
<li>三段论推理（是由两个假定真实的前提和一个可能符合也可能不符合这两前提的结论组成）</li>
<li>线性推理（三个判断之间具有线性关系）</li>
<li>条件推理（前一命题是后一命题的条件）</li>
<li>概率推理（用概率来表示知识的不确定性，并根据所给出的概率来估计新的概率）</li>
</ol>
<p>推理机：系统中用来实现推理的那段程序。</p>
<h5 id="推理方法及其分类"><a href="#推理方法及其分类" class="headerlink" title="推理方法及其分类"></a>推理方法及其分类</h5><p>$$<br>推理分类<br>\begin{cases}<br>按推理逻辑基础<br>\begin{cases}<br>归纳推理 \<br>演绎推理<br>\end{cases}<br>\ 按知识的确定性<br>\begin{cases}<br>确定性推理 \<br>不确定性推理<br>\end{cases}<br>\ 按推理的控制策略<br>\begin{cases}<br>推理策略 \<br>搜索策略<br>\end{cases}<br>\end{cases}<br>$$</p>
<h6 id="演绎推理"><a href="#演绎推理" class="headerlink" title="演绎推理"></a>演绎推理</h6><p>是一种由一般到个别的推理方法，即从已知的一般性知识出发，去推出蕴含在这些已知知识中的适合于某种个别情况的结论。</p>
<p><strong>核心</strong>:三段论(大前提、小前提、结论)</p>
<p>大前提：是已知的一般性知识或推理过程得到的判断；<br>小前提：是关于某种具体情况或某个具体实例的判断；<br>结论：是由大前提推出的，并且适合于小前提的判断。</p>
<h6 id="归纳推理"><a href="#归纳推理" class="headerlink" title="归纳推理"></a>归纳推理</h6><p>由个别到一般的推理方法。</p>
<h6 id="演绎推理与归纳推理的区别"><a href="#演绎推理与归纳推理的区别" class="headerlink" title="演绎推理与归纳推理的区别"></a>演绎推理与归纳推理的区别</h6><p>演绎推理是在已知领域内的一般性知识的前提下，通过演绎求解一个具体问题或者证明一个结论的正确性。它所得出的结论实际上早已蕴含在一般性知识的前提中，演绎推理只不过是将已有事实揭露出来，因此它<strong>不能增殖新知识</strong>。<br>归纳推理所推出的结论是没有包含在前提内容中的。这种由个别事物或现象推出一般性知识的过程，是<strong>增殖新知识的过程</strong>。</p>
<h3 id="确定性知识表示方法"><a href="#确定性知识表示方法" class="headerlink" title="确定性知识表示方法"></a>确定性知识表示方法</h3><h4 id="谓词逻辑表示法"><a href="#谓词逻辑表示法" class="headerlink" title="谓词逻辑表示法"></a>谓词逻辑表示法</h4><p>一种基于数理逻辑的知识表示方法。</p>
<h5 id="逻辑学基础"><a href="#逻辑学基础" class="headerlink" title="逻辑学基础"></a>逻辑学基础</h5><h6 id="命题和真值"><a href="#命题和真值" class="headerlink" title="命题和真值"></a>命题和真值</h6><p>断言：一个陈述句称为一个断言.<br>命题：具有真假意义的断言称为命题.</p>
<p>一个命题不能同时既为真又为假，一个命题可在一定条件下为真，而在另一条件下为假</p>
<h6 id="论域和谓词"><a href="#论域和谓词" class="headerlink" title="论域和谓词"></a>论域和谓词</h6><p>论域： 由所讨论对象的全体构成的集合。也称为个体域。</p>
<p>论域中的元素称为个体。</p>
<p>谓词：用来表示谓词逻辑中的命题，形如 P(x1,x2,…,xn) 。其中 P 是<strong>谓词名</strong>，即命题的谓语，表示个体的性质、状态或个体之间的关系；<br>x1,x2,…,xn 是<strong>个体</strong>，即命题的主语，表示独立存在的事物或概念。</p>
<p>设 D 是个体域，P：Dn→{T，F｝是一个映射，其中</p>
<p>$$<br>D^n = {(x_1,x_2,…,x_n) | x_1,x_2,…,x_n,x \in D}<br>$$</p>
<p>则称 P 是一个 n 元谓词，记为 P(x1,x2,…,xn)，其中，x1,x2,…,xn 为个体，可以是个体常量、变元和函数。</p>
<p>例：</p>
<blockquote>
<p>GREATER(x,6)，表示 x 大于 6，</p>
</blockquote>
<h6 id="连接词和量词"><a href="#连接词和量词" class="headerlink" title="连接词和量词"></a>连接词和量词</h6><p><strong>连接词</strong></p>
<p>¬ ： “非”或者“否定”。表示对其后面的命题的否定<br>∨ ：“析取”。表示所连结的两个命题之间具有“或”的关系<br>∧：“合取”。 表示所连结的两个命题之间具有“与”的关系。<br>→ ： “条件”或“蕴含”。表示“若…则…”的语义。读作“如果 P，则 Q”其中，P 称为条件的前件，Q 称为条件的后件。<br>↔ ：称为“双条件”。它表示“当且仅当”的语义。即读作“P 当且仅当 Q”。</p>
<p><strong>量词</strong></p>
<p>∀ ：全称量词。意思是“所有的”、“任一个”<br>∃ ：存在量词，意思是“至少有一个”、“存在有”</p>
<h6 id="自由变元和约束变元"><a href="#自由变元和约束变元" class="headerlink" title="自由变元和约束变元"></a>自由变元和约束变元</h6><p>辖域：指位于量词后面的单个谓词或者用括弧括起来的合式公式<br>约束变元：辖域内与量词中同名的变元称为约束变元<br>自由变元：不受约束的变元称为自由变元</p>
<p>例：</p>
<blockquote>
<p>(∀x)(P(x，y)→Q(x，y))∨R(x，y)<br>其中，(P(x，y)→Q(x，y))是(∀x)的辖域<br>辖域内的变元 x 是受(∀x)约束的变元<br>R(x，y)中的 x 和所有的 y 都是自由变元</p>
</blockquote>
<h5 id="谓词逻辑表示方式"><a href="#谓词逻辑表示方式" class="headerlink" title="谓词逻辑表示方式"></a>谓词逻辑表示方式</h5><h5 id="谓词逻辑表示步骤"><a href="#谓词逻辑表示步骤" class="headerlink" title="谓词逻辑表示步骤"></a>谓词逻辑表示步骤</h5><ol>
<li>先根据要表示的知识定义谓词</li>
<li>再用连词、量词把这些谓词连接起来</li>
</ol>
<p>例：</p>
<blockquote>
<p>表示知识“所有教师都有自己的学生”。<br>先定义谓词：<br>&nbsp;&nbsp;&nbsp;&nbsp;T (x)：表示 x 是教师。<br>&nbsp;&nbsp;&nbsp;&nbsp;S (y)：表示 y 是学生。<br>&nbsp;&nbsp;&nbsp;&nbsp;TS(x, y)：表示 x 是 y 的老师。<br>然后将知识表示如下：<br>&nbsp;&nbsp;&nbsp;&nbsp;(∀x)(∃y)(T (x)→ TS(x, y) ∧S (y))<br>可读作：对所有 x，如果 x 是一个教师，那么一定存在一个个体 y， y 是学生，且 x 是 y 的老师。</p>
</blockquote>
<p>例：</p>
<blockquote>
<p>机器人移盒子<br>分别定义描述状态和动作的谓词<br>描述状态的谓词：<br>&nbsp;&nbsp;&nbsp;&nbsp;TABLE( x)：x 是桌子<br>&nbsp;&nbsp;&nbsp;&nbsp;EMPTY( y )：y 手中是空的<br>&nbsp;&nbsp;&nbsp;&nbsp;AT( y, z )：y 在 z 处<br>&nbsp;&nbsp;&nbsp;&nbsp;HOLDS( y, w )：y 拿着 w<br>&nbsp;&nbsp;&nbsp;&nbsp;ON(w, x)：w 在 x 桌面上<br>变元的个体域：<br>&nbsp;&nbsp;&nbsp;&nbsp;x 的个体域是{a, b}<br>&nbsp;&nbsp;&nbsp;&nbsp;y 的个体域是{robot}<br>&nbsp;&nbsp;&nbsp;&nbsp;z 的个体域是{a, b, c}<br>&nbsp;&nbsp;&nbsp;&nbsp;w 的个体域是{box}</p>
</blockquote>
<p>例：</p>
<blockquote>
<p>表示知识“所有的整数不是偶数就是奇数”。</p>
</blockquote>
<pre><code>解：先定义谓词：
</code></pre>
<p>I(x)：x 是整数，E(x)：x 是偶数， O(x)：x 是奇数<br>然后再将知识表示为：<br>(∀x)(I(x) → E(x)∨O(x))</p>
<p>例：</p>
<blockquote>
<p>表示如下知识：<br>王宏是计算机系的一名学生。<br>王宏和李明是同班同学。<br>凡是计算机系的学生都喜欢编程序。<br>解：先定义谓词：<br>&nbsp;&nbsp;&nbsp;&nbsp;CS(x)：表示 x 是计算机系的学生。<br>&nbsp;&nbsp;&nbsp;&nbsp;CM(x,y)：表示 x 和 y 是同班同学。<br>&nbsp;&nbsp;&nbsp;&nbsp;L (x,y)：表示 x 喜欢 y。<br>然后再将知识表示为：<br>&nbsp;&nbsp;&nbsp;&nbsp;CS(Wang hong)<br>&nbsp;&nbsp;&nbsp;&nbsp;CM(Wanghong, Li ming)<br>&nbsp;&nbsp;&nbsp;&nbsp;(∀x)(CS(x) →L (x, programming))</p>
</blockquote>
<h5 id="谓词逻辑表示的特性"><a href="#谓词逻辑表示的特性" class="headerlink" title="谓词逻辑表示的特性"></a>谓词逻辑表示的特性</h5><h6 id="主要优点"><a href="#主要优点" class="headerlink" title="主要优点"></a>主要优点</h6><ul>
<li>  自然：一阶谓词逻辑是一种接近于自然语言的形式语言系统，谓词逻辑表示法接近于人们对问题的直观理解</li>
<li>  明确：有一种标准的知识解释方法，因此用这种方法表示的知识明确、易于理解</li>
<li>  精确：谓词逻辑的真值只有“真”与“假”，其表示、推理都是精确的</li>
<li>  灵活：知识和处理知识的程序是分开的，无须考虑处理知识的细节</li>
<li>  模块化：知识之间相对独立，这种模块性使得添加、删除、修改知识比较容易进行</li>
</ul>
<h6 id="主要缺点"><a href="#主要缺点" class="headerlink" title="主要缺点"></a>主要缺点</h6><ul>
<li>  知识表示能力差：只能表示确定性知识，而不能表示非确定性知识、过程性知识和启发式知识</li>
<li>  知识库管理困难：缺乏知识的组织原则，知识库管理比较困难</li>
<li>  存在组合爆炸：由于难以表示启发式知识，因此只能盲目地使用推理规则，这样当系统知识量较大时，容易发生组合爆炸</li>
<li>  系统效率低：它把推理演算与知识含义截然分开，抛弃了表达内容中所含有的语义信息，往往使推理过程冗长，降低了系统效率</li>
</ul>
<h4 id="产生式表示法"><a href="#产生式表示法" class="headerlink" title="产生式表示法"></a>产生式表示法</h4><p>事实：事实是断言一个语言变量的值或断言多个语言变量之间关系的陈述句。</p>
<h5 id="事实的表示方法"><a href="#事实的表示方法" class="headerlink" title="事实的表示方法"></a>事实的表示方法</h5><p>（对象，属性，值）</p>
<p>例：</p>
<blockquote>
<p>(snow, color, white) 或（雪，颜色，白）。其中，对象就是语言变量。</p>
</blockquote>
<p>（关系，对象 1，对象 2）</p>
<p>例</p>
<blockquote>
<p>(love, Wang Feng, country) 或（ 热爱，王峰，祖国）</p>
</blockquote>
<h5 id="规则的表示"><a href="#规则的表示" class="headerlink" title="规则的表示"></a>规则的表示</h5><p>产生式也叫产生式规则，或简称规则。<br>规则的基本形式<br>IF P THEN Q 或者 P→Q<br>其中，P 是前提，也称或前件，给出了该产生式可否使用的先决条件。Q 是结论或操作，也称后件，给出当 P 满足时，应该推出的结论或执行的动作。</p>
<blockquote>
<p>&lt;规则&gt; ：：= &lt;前提&gt; → &lt;结论&gt;<br>&lt;前提&gt; ：：= &lt;简单条件&gt; | &lt;复合条件&gt;<br>&lt;结论&gt; ：：= &lt;事实&gt; | &lt;动作&gt;<br>&lt;复合条件&gt; ：：= &lt;简单条件&gt; And &lt;简单条件&gt; [( And &lt;简单条件&gt; … )]<br>| &lt;简单条件&gt; Or &lt;简单条件&gt; [( OR&lt;简单条件&gt; … )]<br>&lt;动作&gt; ：：= &lt;动作名&gt;| [(&lt;变元&gt;, … )]</p>
</blockquote>
<h5 id="产生式表示的特性"><a href="#产生式表示的特性" class="headerlink" title="产生式表示的特性"></a>产生式表示的特性</h5><h6 id="主要优点-1"><a href="#主要优点-1" class="headerlink" title="主要优点"></a>主要优点</h6><ul>
<li>  自然性：采用“如果……，则……”的形式，人类的判断性知识基本一致。</li>
<li>  模块性：规则是规则库中最基本的知识单元，各规则之间只能通过综合数据库发生联系，而不能相互调用，从而增加了规则的模块性。</li>
<li>  有效性：产生式知识表示法既可以表示确定性知识，又可以表示不确定性知识，既有利于表示启发性知识，又有利于表示过程性知识。</li>
</ul>
<h6 id="主要缺点-1"><a href="#主要缺点-1" class="headerlink" title="主要缺点"></a>主要缺点</h6><ul>
<li>  效率较低：各规则之间的联系必须以综合数据库为媒介。并且，其求解过程是一种反复进行的“匹配—冲突消解—执行”过程。这样的执行方式将导致执行的低效率。</li>
<li>  不便于表示结构性知识：由于产生式表示中的知识具有一致格式，且规则之间不能相互调用，因此那种具有结构关系或层次关系的知识则很难以自然的方式来表示。</li>
</ul>
<h4 id="语义网络表示法"><a href="#语义网络表示法" class="headerlink" title="语义网络表示法"></a>语义网络表示法</h4><h5 id="语义网络"><a href="#语义网络" class="headerlink" title="语义网络"></a>语义网络</h5><p>语义网络是一种用<strong>实体</strong>及其<strong>语义关系</strong>来表达知识的有向图。</p>
<p>结点：代表实体，表示事物、概念、情况、属性、状态、事件、动作等<br>弧：代表语义关系，表示所连两个实体之间的语义联系，必须带有标识</p>
<h6 id="语义基元"><a href="#语义基元" class="headerlink" title="语义基元"></a>语义基元</h6><p>最基本的语义单位。</p>
<p>可用三元组(节点一，弧，节点二)来描述</p>
<p>基本网元结构：</p>
<h6 id="语义关系"><a href="#语义关系" class="headerlink" title="语义关系"></a>语义关系</h6><ul>
<li><p>实例关系： ISA<br>  体现的是“具体与抽象”的概念，含义为“是一个”，表示一件事物是另一件事物的一个实例。</p>
</li>
<li><p>分类关系： AKO<br>  也称泛化关系，体现的是“子类与超类”的概念，含义为“是一种”，表示一个事物是另一个事物的一种类型。</p>
</li>
<li><p>成员关系： A-Member-of<br>  体现的是“个体与集体”的关系，含义为“是一员”，表示一个事物是另一个事物的一个成员。</p>
</li>
<li><p>属性关系：<br>  指事物和其属性之间的关系。<br>  常用的有：<br>  Have：含义为“有”，表示一个结点具有另一个结点所描述的属性<br>  Can：含义为 “能”、“会”，表示一个结点能做另一个结点的事情</p>
</li>
<li><p>包含关系（聚类关系）：<br>  指具有组织或结构特征的“部分与整体”之间的关系。常用的包含关系是 Part-of ：含义为“是一部分”，表示一个事物是另一个事物的一部分。</p>
</li>
<li><p>时间关系<br>  指不同事件在其发生时间方面的先后次序关系。<br>  常用的时间关系有：<br>  Before：含义为“在前”<br>  After: 含义为“在后”</p>
</li>
<li><p>位置关系<br>  指不同事物在位置方面的关系。<br>  常用的有：<br>  Located-on：含义为“在…上面”<br>  Located-under：含义为“在…下面”<br>  Located-at：含义为“在…”</p>
</li>
<li><p>相近关系<br>  指不同事物在形状、内容等方面相似或接近。<br>  常用的相近关系有：<br>  Similar-to：含义为“相似”<br>  Near-to：含义为“接近”</p>
</li>
</ul>
<h5 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h5><h6 id="一元关系"><a href="#一元关系" class="headerlink" title="一元关系"></a>一元关系</h6><p>指可以用一元谓词 P(x)表示的关系。谓词 P 说明实体的性质、属性等。</p>
<h6 id="二元关系"><a href="#二元关系" class="headerlink" title="二元关系"></a>二元关系</h6><p>可用二元谓词 P(x,y)表示的关系。其中，x,y 为实体，P 为实体之间的关系。</p>
<h6 id="多元关系"><a href="#多元关系" class="headerlink" title="多元关系"></a>多元关系</h6><p>可用多元谓词 P(x1，x2，……)表示的关系。其中，个体 x1，x2，……为实体，谓词 P 说明这些实体之间的关系。</p>
<h5 id="语义网络表示的特性"><a href="#语义网络表示的特性" class="headerlink" title="语义网络表示的特性"></a>语义网络表示的特性</h5><h6 id="主要优点："><a href="#主要优点：" class="headerlink" title="主要优点："></a>主要优点：</h6><ul>
<li>  结构性: 把事物的属性以及事物间的各种语义联系显式地表示出来，是一种结构化的知识表示方法。在这种方法中，下层结点可以继承、新增、变异上层结点的属性。</li>
<li>  联想性: 本来是作为人类联想记忆模型提出来的，它着重强调事物间的语义联系，体现了人类的联想思维过程。</li>
<li>  自然性: 语义网络可以比较直观把知识表示出来，符合人们表达事物间关系的习惯。</li>
</ul>
<h6 id="主要缺点："><a href="#主要缺点：" class="headerlink" title="主要缺点："></a>主要缺点：</h6><ul>
<li>  非严格性: 没有象谓词那样严格的形式表示体系，一个给定语义网络的含义完全依赖于处理程序对它所进行的解释，通过语义网络所实现的推理不能保证其正确性。</li>
<li>  复杂性: 语义网络表示知识的手段是多种多样的，这虽然对其表示带来了灵活性，但同时也由于表示形式的不一致，使得它的处理增加了复杂性。</li>
</ul>
<h4 id="框架表示法"><a href="#框架表示法" class="headerlink" title="框架表示法"></a>框架表示法</h4><p>&lt;框架名&gt;<br>槽名 1： 侧面名 11 值 111，值 112，…<br>侧面名 12 值 121，值 122，…<br>:<br>槽名 2： 侧面名 21 值 211，值 212，…<br>侧面名 22 值 221，值 222，…<br>:<br>:<br>:<br>槽名 n： 侧面名 n1 值 n11，值 n12，…<br>侧面名 n2 值 n21，值 n22，…<br>:<br>侧面名 nm 值 nm1，值 nm2，…</p>
<p>例：</p>
<blockquote>
<p>一个直接描述硕士生有关情况的框架<br>Frame <MASTER> \框架名<br>Name：Unit（Last-name，First-name） \姓名<br>Sex：Area（male，female） \性别<br>Default： male \缺省值<br>Age：Unit（Years） \年龄<br>Major：Unit（Major） \专业<br>Field：Unit（Field） \方向<br>Advisor：Unit（Last-name，First-name） \导师<br>Project ：Area（National，Provincial，Other） \科研项目<br>Default：National<br>Paper：Area（SCI，EI，Core，General） \论文<br>Default：Core<br>Address：&lt; S-Address&gt; \住址<br>Telephone：Home Unit（Number） \电话<br>Mobile Unit（Number）</p>
</blockquote>
<h5 id="框架表示法的特性"><a href="#框架表示法的特性" class="headerlink" title="框架表示法的特性"></a>框架表示法的特性</h5><h6 id="框架表示法的优点"><a href="#框架表示法的优点" class="headerlink" title="框架表示法的优点"></a>框架表示法的优点</h6><ul>
<li>  结构性：最突出特点是善于表示结构性知识，它能够把知识的内部结构关系以及知识间的特殊联系表示出来。</li>
<li>  深层性： 框架表示法不仅可以从多个方面、多重属性表示知识，因此能用来表达事物间复杂的深层联系。</li>
<li>  继承性：在框架系统中，下层框架可以继承上层框架的槽值，这样既减少知识冗余，又较好地保证了知识的一致性。</li>
<li>  自然性：框架能把与谋个实体或实体集相关特性都集中在一起，从而高度模拟了人脑对实体多方面、多层次的存储结构，直观自然，易于理解。</li>
</ul>
<h6 id="框架表示法的不足"><a href="#框架表示法的不足" class="headerlink" title="框架表示法的不足"></a>框架表示法的不足</h6><ul>
<li>  缺乏框架的形式理论：至今，还没有建立框架的形式理论，其推理和一致性检查机制并非基于良好定义的语义。</li>
<li>  缺乏过程性知识表示：框架系统不便于表示过程性知识，缺乏如何使用框架中知识的描述能力。</li>
<li>  清晰性难以保证：由于各框架本身的数据结构不一定相同，从而框架系统的清晰性很难保证。</li>
</ul>
<h3 id="确定性知识推理方法"><a href="#确定性知识推理方法" class="headerlink" title="确定性知识推理方法"></a>确定性知识推理方法</h3><h4 id="产生式推理"><a href="#产生式推理" class="headerlink" title="产生式推理"></a>产生式推理</h4><h5 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h5><h6 id="综合数据库-DB"><a href="#综合数据库-DB" class="headerlink" title="综合数据库 DB"></a>综合数据库 DB</h6><p>存放推理过程的各种当前信息。<br>作为推理过程选择可用规则的依据。</p>
<h6 id="规则库-RB"><a href="#规则库-RB" class="headerlink" title="规则库 RB"></a>规则库 RB</h6><p>用于存放推理所需要的所有规则，是整个产生式系统的知识集。<br>是产生式系统能够进行推理的根本。</p>
<h6 id="控制系统"><a href="#控制系统" class="headerlink" title="控制系统"></a>控制系统</h6><p>亦称推理机，用于控制整个产生式系统的运行，决定问题求解过程的推理线路。</p>
<h5 id="产生式的正向推理"><a href="#产生式的正向推理" class="headerlink" title="产生式的正向推理"></a>产生式的正向推理</h5><p>从已知事实出发、正向使用规则，也称为数据驱动推理或前向链推理。</p>
<ol>
<li>把用户提供的初始证据放入综合数据库；</li>
<li>检查综合数据库中是否包含了问题的解，若已包含，则求解结束，并成功推出；否则执行下一步；</li>
<li>检查知识库中是否有可用知识，若有，形成当前可用知识集，执行下一步；否则转 5。</li>
<li>按照某种冲突消解策略，从当前可用知识集中选出一条规则进行推理，并将推出的新事实加入综合数据库中，然后转 2。</li>
<li>询问用户是否可以进一步补充新的事实，若可补充，则将补充的新事实加入综合数据库中，然后转(3)；否则表示无解，失败退出。</li>
</ol>
<p><img src="/images/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/image-20220528200655805.png" alt="image-20220528200655805"></p>
<h5 id="产生式的逆向推理"><a href="#产生式的逆向推理" class="headerlink" title="产生式的逆向推理"></a>产生式的逆向推理</h5><p>从某个假设目标出发，逆向使用规则，亦称为目标驱动推理或逆向链推理.</p>
<ol>
<li> 将要求证的目标（称为假设）构成一个假设集；</li>
<li> 从假设集中选出一个假设，检查该假设是否在综合数据库中，若在，则该假设成立，此时，若假设集为空，则成功退出，否则仍执行(2)；若该假设不在数据库中，则执行下一步；</li>
<li> 检查该假设是否可由知识库的某个知识导出，若不能由某个知识导出，则询问用户该假设是否为可由用户证实的原始事实，若是，该假设成立，并将其放入综合数据库，再重新寻找新的假设，若不是，则转(5)；若能由某个知识导出，则执行下一步；</li>
<li> 将知识库中可以导出该假设的所有知识构成一个可用知识集；</li>
<li> 检查可用知识集是否为空，若是，失败退出；否则执行下一步；</li>
<li> 按冲突消解策略从可用知识集中取出一个知识，继续；</li>
<li> 将该知识的前提中的每个子条件都作为新的假设放入假设集，然后转(2)。</li>
</ol>
<p><img src="/images/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/image-20220528203153846.png" alt="image-20220528203153846"></p>
<h4 id="自然演绎推理"><a href="#自然演绎推理" class="headerlink" title="自然演绎推理"></a>自然演绎推理</h4><p>从一组已知为真的事实出发，直接运用经典逻辑中的推理规则推出结论的过程称为自然演绎过程。</p>
<h5 id="等价式"><a href="#等价式" class="headerlink" title="等价式"></a>等价式</h5><p>设 P 与 Q 是 D 上的两个谓词公式，若对 D 上的任意解释，P 与 Q 都有相同的真值，则称 P 与 Q 在 D 上是等价的。如果 D 是任意非空个体域，则称 P 与 Q 是等价的，记作 P⇔Q。</p>
<ol>
<li>双重否定律 ¬ ¬ P ⇔ P</li>
<li>交换律 (P∨Q) ⇔ (Q∨P)， ( P∧Q) ⇔ ( Q∧P)</li>
<li>结合律 (P∨Q)∨R ⇔ P∨(Q∨R) (P∧Q)∧R ⇔ P∧(Q∧R)</li>
<li>分配律 P∨(Q∧R) ⇔ (P∨Q)∧(P∨) P∧(Q∨R) ⇔ (P∧Q)∨(P∧R)</li>
<li>摩根定律 ¬ (P∨Q) ⇔ ¬ P∧ ¬ Q， ¬ (P∧Q) ⇔ ¬ P∨ ¬ Q</li>
<li>吸收律 P∨(P∧Q) ⇔ P， P∧(P∨Q) ⇔ P</li>
<li>补余律 P∨ ¬ P ⇔ T, P∧ ¬ P ⇔ F</li>
<li>连词化归律 P→Q ⇔ ¬PQ. P↔Q ⇔ (P→Q)∧(Q→). P↔Q ⇔ (P∧Q)∨(Q∧P)</li>
<li>量词转换律 ¬ (∃x)P ⇔ (∀x)( ¬ P)， ¬ (∀x)P ⇔ (∃x) (¬ P)</li>
<li>量词分配律 (∀x) (P∧Q) ⇔ (∀x)P∧(∀x)Q<br>(∃x) (P∨Q) ⇔ (∃x)P∨(∃x)Q</li>
</ol>
<h5 id="永真蕴涵式"><a href="#永真蕴涵式" class="headerlink" title="永真蕴涵式"></a>永真蕴涵式</h5><p>对谓词公式 P 和 Q，如果 P→Q 永真，则称 P 永真蕴含 Q，且称 Q 为 P 的逻辑结论，P 为 Q 的前提，记作 P ⇒ Q。</p>
<ol>
<li>化简式 P∧Q ⇒ P， P∧Q ⇒ Q</li>
<li>附加式 P ⇒ P∨Q， Q ⇒ P∨Q</li>
<li>析取三段论 ﹁ P, P∨Q ⇒ Q</li>
<li>假言推理 P, P→Q ⇒ Q</li>
<li>拒取式 ¬Q, P→Q ⇒ ¬P</li>
<li>假言三段论 P→Q, Q→R ⇒P→R</li>
<li>二难推理 P∨Q, P→R, Q→R ⇒ R</li>
<li>全称固化 (∀x)P(x) ⇒ P(y)其中，y 是个体域中的任一个体，依此可消去谓词公式中的全称量词。</li>
<li>存在固化 (∃x)P(x) ⇒ P(y)其中，y 是个体域中某一个可以使 P(y)为真的个体，依此可消去谓词公式中的存在量词。</li>
</ol>
<h5 id="置换"><a href="#置换" class="headerlink" title="置换"></a>置换</h5><p>在一个谓词公式中用置换项去替换变量。</p>
<h5 id="合一"><a href="#合一" class="headerlink" title="合一"></a>合一</h5><p>寻找项对变量的置换，使两个谓词公式一致。</p>
<p>例：</p>
<blockquote>
<p>设已知如下事实：</p>
</blockquote>
<pre><code>      A,  B,  A→C,  B∧C→D,  D→Q
</code></pre>
<p>求证：Q 为真。<br>证明：因为 A, A→C⇒ C 假言推理<br>B, C⇒ B∧C 引入合取词<br>B∧C，B∧C→D ⇒ D 假言推理<br>D, D→Q ⇒ Q 假言推理<br>因此，Q 为真</p>
<h4 id="归纳演绎推理"><a href="#归纳演绎推理" class="headerlink" title="归纳演绎推理"></a>归纳演绎推理</h4><p>思想：要证明 P→Q 永真，只要能够证明 P∧﹁Q 是不可满足即可(原因是：﹁ (P→Q) ⇔ ﹁(﹁ P∨Q) ⇔ P∧﹁ Q</p>
<p>如果谓词公式 P 对非空个体域 D 上的任一解释都取得真值 T，则称 P 在 D 上是永真的；如果 P 在任何非空个体域上均是永真的，则称 P 永真。</p>
<p>对于谓词公式 P，如果至少存在 D 上的一个解释，使公式 P 在此解释下的真值为 T，则称公式 P 在 D 上是可满足的</p>
<p>如果谓词公式 P 对非空个体域 D 上的任一解释都取真值 F，则称 P 在 D 上是永假的；如果 P 在任何非空个体域上均是永假的，则称 P 永假。</p>
<h5 id="前束范式"><a href="#前束范式" class="headerlink" title="前束范式"></a>前束范式</h5><p>设 F 为一谓词公式，如果其中的所有量词均非否定地出现在公式的最前面，且它们的辖域为整个公式，则称 F 为前束范式。一般形式：<br>(Q1x1)……(Qnxn)M(x1,x2,……,xn)<br>其中，Qi(i=1,2,……,n)为前缀，它是一个由全称量词或存在量词组成的量词串； M(x1,x2,……,xn )为母式，它是一个不含任何量词的谓词公式。<br>例如，(∀x) (∀y) (∃z)(P(x)∧Q(y,z)∨R(x,z))是前束范式。</p>
<h5 id="Skolem-范式"><a href="#Skolem-范式" class="headerlink" title="Skolem 范式"></a>Skolem 范式</h5><p>如果前束范式中所有的存在量词都在全称量词之前，则称这种形式的谓词公式为 Skolem 范式。<br>例如，(∃x) (∃z) (∀y)(P(x)∨Q(y,z)∧R(x,z))是 Skolem 范式。<br>任一谓词公式均可化为与其对应的 Skolem 范式</p>
<p>原子谓词公式及其否定统称为文字。<br>例如，P(x)、Q(x)、﹁ P(x)、 ﹁ Q(x)等都是文字。<br>任何文字的析取式称为子句。<br>例如，P(x)∨Q(x)，P(x，f(x))∨Q(x，g(x))都是子句。<br>不含任何文字的子句称为空子句。<br>由于空子句不含有任何文字，也就不能被任何解释所满足，因此空子句是永假的，不可满足的。<br>空子句一般被记为 □ 或 NIL。<br>由子句或空子句所构成的集合称为子句集。</p>
]]></content>
      <categories>
        <category>课程学习</category>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>课程学习</tag>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>人机交互技术期末复习</title>
    <url>/135xyq.github.io/2022/01/08/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92%E6%8A%80%E6%9C%AF%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="人机交互知识点总结"><a href="#人机交互知识点总结" class="headerlink" title="人机交互知识点总结"></a>人机交互知识点总结</h1><h2 id="考试题型及分值分布："><a href="#考试题型及分值分布：" class="headerlink" title="考试题型及分值分布："></a>考试题型及分值分布：</h2><ol>
<li>选择题（10题、20分）</li>
<li>填空题（10题、20分）</li>
<li>判断题（可选、5题、10分）</li>
<li>解答题（5、6题、30分）</li>
<li>分析计算题（1、2题、20分）<br>注意：<strong>答案有多条时，用1、2、3形式分别列出。</strong></li>
</ol>
<h2 id="考查内容"><a href="#考查内容" class="headerlink" title="考查内容"></a>考查内容</h2><ol>
<li>掌握人机交互技术基本概念、研究内容及发展趋势</li>
<li>主要人机交互设备及其主要原理</li>
<li>行为模型、结构模型的主要研究内容及其特点，掌握模型的相互转换</li>
<li>能够根据案例分析某软件结构的行为模型或结构模型</li>
<li>掌握图形用户界面的基本原则</li>
<li>掌握移动互联网设计的基本原则及其特点</li>
<li>掌握几种基本的软件体系结构</li>
<li>熟悉LOTOS的几种关系及其语法</li>
<li>什么是可用性及其可用性的基本原则</li>
<li>案例综合分析</li>
</ol>
<h2 id="掌握人机交互技术基本概念、研究内容及发展趋势-P1"><a href="#掌握人机交互技术基本概念、研究内容及发展趋势-P1" class="headerlink" title="掌握人机交互技术基本概念、研究内容及发展趋势(P1)"></a>掌握人机交互技术基本概念、研究内容及发展趋势(P1)</h2><h3 id="人机交互技术基本概念"><a href="#人机交互技术基本概念" class="headerlink" title="人机交互技术基本概念"></a>人机交互技术基本概念</h3><p>人机交互是指关于设计、评价和实现供人们使用的交互式计算机系统，并围绕相关的主要现象进行研究的学科。<br>狭义的讲:人机交互技术主要是研究<strong>人与计算机</strong>和<strong>计算机到人</strong>的<strong>信息交换</strong>两部分。</p>
<h3 id="人机交互的研究内容"><a href="#人机交互的研究内容" class="headerlink" title="人机交互的研究内容"></a>人机交互的研究内容</h3><h4 id="1-人机交互界面的表示模型与设计方法"><a href="#1-人机交互界面的表示模型与设计方法" class="headerlink" title="1. 人机交互界面的表示模型与设计方法"></a>1. 人机交互界面的表示模型与设计方法</h4><p>一个交互界面的优劣，直接影响软件开发的成败。友好的人机交互界面的开发离不开好的交互模型和设计方法。</p>
<h4 id="2-可用性分析与评估"><a href="#2-可用性分析与评估" class="headerlink" title="2. 可用性分析与评估"></a>2. 可用性分析与评估</h4><p>它关系到人机交互能否达到用户期待的目标，以及实现这一目标的效率与便捷性。</p>
<h4 id="3-多通道交互技术"><a href="#3-多通道交互技术" class="headerlink" title="3. 多通道交互技术"></a>3. 多通道交互技术</h4><p>研究视觉、听觉、触觉和力觉等多通道信息的融合理论和方法。<br>多通道交互主要研究多通道交互界面的表示模型、多通道交互界面的评估方法以及多通道信息的融合等。<br>其中，多通道融合是多通道用户界面研究的重点和难点。</p>
<h4 id="4-认知与智能用户界面"><a href="#4-认知与智能用户界面" class="headerlink" title="4. 认知与智能用户界面"></a>4. 认知与智能用户界面</h4><p>目标是：是人机交互和人-人交互一样自然、方便。</p>
<h4 id="5-群件"><a href="#5-群件" class="headerlink" title="5. 群件"></a>5. 群件</h4><p>群件是指为群组提供计算机支持的协作环境，主要涉及个人或群组间的信息传递、群组内的信息共享、业务过程自动化与协调以及人和过程之间的交互活动等。</p>
<h4 id="6-web设计"><a href="#6-web设计" class="headerlink" title="6. web设计"></a>6. web设计</h4><p>web设计重点研究web界面的信息交互模型和结构、web界面设计的基本思想和原则、web设计的工具和技术，以及web界面设计的可用性分析与评估方法等内容。</p>
<h4 id="7-移动界面设计"><a href="#7-移动界面设计" class="headerlink" title="7. 移动界面设计"></a>7. 移动界面设计</h4><h3 id="人机交互技术发展趋势"><a href="#人机交互技术发展趋势" class="headerlink" title="人机交互技术发展趋势"></a>人机交互技术发展趋势</h3><h4 id="1-命令行交互阶段"><a href="#1-命令行交互阶段" class="headerlink" title="1. 命令行交互阶段"></a>1. 命令行交互阶段</h4><p>通过键盘输入数据和命令信息，界面输出以字符为主，因此这种人机交互方法缺乏自然性。</p>
<h4 id="2-图形用户界面交互阶段（GUI）"><a href="#2-图形用户界面交互阶段（GUI）" class="headerlink" title="2. 图形用户界面交互阶段（GUI）"></a>2. 图形用户界面交互阶段（GUI）</h4><p>与命令行界面相比，图形用户界面的自然性和交互效率都有较大的提高。<br>图形用户界面很大程度上依赖<strong>菜单选择</strong>和<strong>交互构件</strong>。</p>
<h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><ol>
<li>鼠标驱动的界面便于初学者使用，但重复性的菜单选择会给有经验的用户造成不方便。</li>
<li>图形用户界面需要占用较多的屏幕空间，并且难以表达和支持非空间性的抽象信息的交互。</li>
</ol>
<h4 id="3-自然和谐的人机交互阶段"><a href="#3-自然和谐的人机交互阶段" class="headerlink" title="3. 自然和谐的人机交互阶段"></a>3. 自然和谐的人机交互阶段</h4><ol>
<li>多通道交互</li>
<li>情感计算</li>
<li>虚拟现实</li>
<li>智能用户界面</li>
<li>自然语言理解</li>
</ol>
<h2 id="主要人机交互设备及其主要原理-P42"><a href="#主要人机交互设备及其主要原理-P42" class="headerlink" title="主要人机交互设备及其主要原理(P42)"></a>主要人机交互设备及其主要原理(P42)</h2><h3 id="输入设备"><a href="#输入设备" class="headerlink" title="输入设备"></a>输入设备</h3><h4 id="文本输入设备"><a href="#文本输入设备" class="headerlink" title="文本输入设备"></a>文本输入设备</h4><h5 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h5><h6 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h6><p>一般由按键、导电塑胶、编码器、接口电路组成。</p>
<h6 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h6><p>键盘得每一个按键对应一个编码，当用户按下一个按键时，导电塑胶将线路板上的这个按键的排线接通，键盘中的编码器能够迅速将此键盘所对应的编码通过接口电路输送到计算机的键盘缓冲器中，由计算机识别处理。</p>
<h5 id="手写输入设备"><a href="#手写输入设备" class="headerlink" title="手写输入设备"></a>手写输入设备</h5><p>手写板是一种常见的支持手写输入设备的交互设备。</p>
<h6 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h6><ol>
<li>电阻式压力手写板</li>
<li>电磁式感应手写板</li>
<li>电容式触控手写板</li>
</ol>
<h6 id="电阻式压力手写板"><a href="#电阻式压力手写板" class="headerlink" title="电阻式压力手写板"></a>电阻式压力手写板</h6><p>组成：一层可变形的电阻薄膜、一层固定的电阻薄膜、中间由空气相隔离。</p>
<p>原理：当用笔或手接触手写板时，上层电阻受压变形并与下层电阻相接触，下层电阻就能判断笔或手指的位置。</p>
<p>缺点：</p>
<ol>
<li>由于通过感应材料的变形判断位置，感应材料易疲劳，使用寿命较短；</li>
<li>感应不是很灵敏，使用时压力不够没有感应，压力过大又易损伤感应板。</li>
</ol>
<h6 id="电磁式手写板"><a href="#电磁式手写板" class="headerlink" title="电磁式手写板"></a>电磁式手写板</h6><p>原理：手写板的下方电路通电后，在一定空间范围内形成电磁场，来感应带有线圈的笔尖的位置进行工作。</p>
<p>缺点：</p>
<ol>
<li>对电压要求较高，电压达不到要求就会出现工作不稳定或不能工作的情况；</li>
<li>抗电磁干扰较差，易于其他电磁设备发生干扰；</li>
<li>手写笔笔尖是活动部件，使用寿命短；</li>
<li>必须有手写笔才能工作，不能用手指直接操作</li>
</ol>
<h6 id="电容式手写板"><a href="#电容式手写板" class="headerlink" title="电容式手写板"></a>电容式手写板</h6><p>原理：通过人体的电容来感知手指的位置，即当使用者的手指接触到触控板的瞬间，就在板的表面产生一个电容。在触控板的表面附着着一种传感矩阵，这种矩阵与特殊芯片一起，持续不断地跟踪使用者手指电容的“轨迹”得到位置。</p>
<h4 id="图像输入设备"><a href="#图像输入设备" class="headerlink" title="图像输入设备"></a>图像输入设备</h4><h5 id="二维扫描仪"><a href="#二维扫描仪" class="headerlink" title="二维扫描仪"></a>二维扫描仪</h5><h6 id="组成："><a href="#组成：" class="headerlink" title="组成："></a>组成：</h6><p>光学系统、步进电机</p>
<h6 id="光学系统"><a href="#光学系统" class="headerlink" title="光学系统"></a>光学系统</h6><p>将光线照射到稿件上，产生的发射光或透射光经过反光镜组反射到图像传感器（CCD）中，CCD将光电信号转为数字图像信号。</p>
<h6 id="步进电机"><a href="#步进电机" class="headerlink" title="步进电机"></a>步进电机</h6><p>控制光学系统在传动导轨上平行移动，对待扫稿件逐行进行扫描，最终完成全部稿件的扫描。</p>
<h6 id="指标性能"><a href="#指标性能" class="headerlink" title="指标性能"></a>指标性能</h6><ol>
<li>扫描速度</li>
<li>分辨率</li>
</ol>
<p>扫描速度决定了扫描仪的工作效率，分辨率决定了最高扫描精度。</p>
<p>分辨率受光学部分、硬件部分和软件部分三个因素影响。</p>
<h5 id="数字摄像头"><a href="#数字摄像头" class="headerlink" title="数字摄像头"></a>数字摄像头</h5><p>直接捕捉影像，然后通过计算机的串口、并口或USB接口传送到计算机。</p>
<h6 id="组成-1"><a href="#组成-1" class="headerlink" title="组成"></a>组成</h6><p>感光部件、简单的镜头、数据传输线路</p>
<h6 id="衡量因素"><a href="#衡量因素" class="headerlink" title="衡量因素"></a>衡量因素</h6><ol>
<li>感光元件的类型</li>
<li>像素数</li>
<li>解析度</li>
<li>视频速度</li>
<li>镜头的好坏</li>
</ol>
<h4 id="三维信息输入设备"><a href="#三维信息输入设备" class="headerlink" title="三维信息输入设备"></a>三维信息输入设备</h4><h5 id="三维扫描仪"><a href="#三维扫描仪" class="headerlink" title="三维扫描仪"></a>三维扫描仪</h5><h6 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h6><p>根据传感方式的不同：接触式和非接触式</p>
<h6 id="接触式"><a href="#接触式" class="headerlink" title="接触式"></a>接触式</h6><p>原理：探测头直接接触物体表面，把探测头反馈回来的光电信号转换为描述物体表面形状的数字信息。</p>
<p>优点：有较高的准确性和可靠性</p>
<p>缺点：测量速度慢、费用较高、探头易磨损</p>
<h6 id="非接触式"><a href="#非接触式" class="headerlink" title="非接触式"></a>非接触式</h6><p>主要有三维激光扫描仪和结构光式三维扫描仪。</p>
<p>优点：扫描速度快、易于操作、对物体表面损伤少。</p>
<p>三维激光扫描仪通过高速激光扫描测量技术，获取被测对象表面的空间坐标数据。</p>
<p>常用TOF（飞行时间）测量法或三角测量法进行深度数据的获取。</p>
<p>（1）TOF测量法</p>
<p>通过激光二极管向物体发射近红外波长的激光束，通过测量激光在仪器和目标物体表面的往返时间，计算仪器和点之间的距离，从而计算出目标点的深度。</p>
<p>（2）三角测量法</p>
<p>三角测量法是一种线扫描技术，通过线激光器向被测物体投射一条激光射线，激光线受到物体表面形状的调制，形成反应物体表面轮廓的曲线，利用扫描仪内部内置的摄像头拍摄曲线图像，根据激光器和摄像头之间的三角关系，根据双目视觉方法，反求出激光亮线处物体的深度信息。</p>
<p>结构光三维扫描仪</p>
<p>是一种面扫描技术，通过投影仪向被测物体投射光栅模板图像，光栅在物体表面发生调制变形，其周期与相位的变化反映了物体表面的三维信息。通过相机拍摄物体表面的光栅图像，检测出相应相位变化值，再利用双目视觉方法计算出三维数据。</p>
<p>三维扫描仪的性能指标主要包括扫描的速度、精度和范围等。</p>
<h5 id="动作捕捉设备"><a href="#动作捕捉设备" class="headerlink" title="动作捕捉设备"></a>动作捕捉设备</h5><h6 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h6><p>动作捕捉设备在运动物体的关键部位设置跟踪点，由系统捕捉跟踪点在三维空间中运动的轨迹，再经过计算机处理后，得到物体的运动数据。</p>
<h6 id="分类-2"><a href="#分类-2" class="headerlink" title="分类"></a>分类</h6><ol>
<li>机械式</li>
<li>光学式</li>
<li>电磁式</li>
</ol>
<h6 id="光学式运动捕捉的原理"><a href="#光学式运动捕捉的原理" class="headerlink" title="光学式运动捕捉的原理"></a>光学式运动捕捉的原理</h6><p>利用计算机视觉原理，通过对目标上特定光点的监视和跟踪来完成运动捕捉的任务。对于空间中的一个点，只要它同时为两部摄像机所见，则根据同一时刻两部摄像机所拍摄的图像和对应参数，可以计算出该点该时刻的空间位置。</p>
<h5 id="体感输入设备"><a href="#体感输入设备" class="headerlink" title="体感输入设备"></a>体感输入设备</h5><p>原理和应用和光学式捕捉设备类似。</p>
<h4 id="指点输入设备"><a href="#指点输入设备" class="headerlink" title="指点输入设备"></a>指点输入设备</h4><p>指点设备常用于完成一些定位和选择物体的交互任务。</p>
<h5 id="鼠标及控制杆"><a href="#鼠标及控制杆" class="headerlink" title="鼠标及控制杆"></a>鼠标及控制杆</h5><p>鼠标根据工作原理 不同可以分为 机械鼠标和光电鼠标。</p>
<p>控制杆的移动导致屏幕上光标的移动，根据两者的移动关系可以将其分为移动定位和压力定位。</p>
<p>移动定位的控制杆：屏幕上的光标依据控制杆的位移而移动，因而位移是非常重要的定位特征。<br>压力定位的控制杆：其受到的压力被转化为屏幕上光标的移动速度。</p>
<h5 id="触摸屏"><a href="#触摸屏" class="headerlink" title="触摸屏"></a>触摸屏</h5><h6 id="组成-2"><a href="#组成-2" class="headerlink" title="组成"></a>组成</h6><p>触摸检测部件、触摸屏控制器。</p>
<p>触摸屏检测部件：安装在显示器屏幕前面，用于检测用户触摸位置，然后传送给触摸屏控制器。</p>
<p>触摸屏控制器：处理从触摸检测部件接收到的触摸信息，并将它转换成触点坐标，再传送给CPU，同时接受CPU发出来的命令并加以执行。</p>
<h6 id="分类-3"><a href="#分类-3" class="headerlink" title="分类"></a>分类</h6><p>电阻式触摸屏、电容式触摸屏、基于光学的触摸屏</p>
<h6 id="电阻式触摸屏"><a href="#电阻式触摸屏" class="headerlink" title="电阻式触摸屏"></a>电阻式触摸屏</h6><p>优点：原理简单、工艺要求低、价格低廉</p>
<p>电阻式触摸屏是一种传感器，通过转换触摸点的物理位置坐标（X,Y）得到代表X坐标和Y坐标的电压。</p>
<h6 id="电容式触摸屏"><a href="#电容式触摸屏" class="headerlink" title="电容式触摸屏"></a>电容式触摸屏</h6><p>由四层复合玻璃组成，利用人体的电流感应进行工作。</p>
<p>缺点：</p>
<ol>
<li>当较大面积的手掌或手持的导体物靠近电容屏而未触摸时就能引起电容屏的误动作，在潮湿的天气，这种情况尤为严重。</li>
<li>用带手套的手或手持不导电的物体触摸时没有反应，这是因为引入了更为绝缘的介质。</li>
</ol>
<h6 id="基于光学的触摸屏"><a href="#基于光学的触摸屏" class="headerlink" title="基于光学的触摸屏"></a>基于光学的触摸屏</h6><p>优点：高扩展性、低成本、易搭建</p>
<h3 id="输出设备"><a href="#输出设备" class="headerlink" title="输出设备"></a>输出设备</h3><h4 id="光栅显示器"><a href="#光栅显示器" class="headerlink" title="光栅显示器"></a>光栅显示器</h4><p>显示器是计算机的重要输出设备，是人机对话的重要工具。它的主要功能是接收主机发出的信息，经过一系列的变换，最后以<strong>点阵</strong>的形式将文字和图形显示出来。 </p>
<h5 id="光栅显示器工作原理"><a href="#光栅显示器工作原理" class="headerlink" title="光栅显示器工作原理"></a>光栅显示器工作原理</h5><p>常见的光栅显示器包括阴极线管显示器（CRT）、等离子显示器和液晶（LCD）显示器</p>
<h6 id="CRT显示器的组成"><a href="#CRT显示器的组成" class="headerlink" title="CRT显示器的组成"></a>CRT显示器的组成</h6><ol>
<li>阴极</li>
<li>电平控制器</li>
<li>聚焦系统</li>
<li>加速系统</li>
<li>偏转系统</li>
<li>阳极荧光粉涂层</li>
</ol>
<p>这六部分都在真空管内。</p>
<p>阴极、 电平控制器、 聚焦系统、 加速系统统称为电子枪。</p>
<h6 id="CRT显示器工作原理"><a href="#CRT显示器工作原理" class="headerlink" title="CRT显示器工作原理"></a>CRT显示器工作原理</h6><ol>
<li>当显像管内部的电子枪阴极发出的电子束，经强度控制、聚焦和加速后变成细小的电子流，再经过偏转线圈的作用向正确目标偏离，穿越荫罩的小孔或栅栏，轰击到荧光屏上的荧光粉发出光线。</li>
<li>彩色CRT光栅扫描显示器有三个电子枪，它的荧光屏上涂有三种荧光物质，分别能发红、绿、蓝三种颜色的光。</li>
</ol>
<h6 id="等离子显示器"><a href="#等离子显示器" class="headerlink" title="等离子显示器"></a>等离子显示器</h6><p>等离子显示器诞生于二十世纪60年代，它采用等离子管作为发光材料，1个等离子管负责一个像素的显示：等离子管内的氖氙混合气体在高压电极的刺激下产生紫外线，紫外线照射涂有三色荧光粉的玻璃板，荧光粉受激发出可见光 。</p>
<p>优点：重量较轻、完全无X射线辐射，而且屏幕亮度非常均匀，不存在明显的亮区和暗区；由于各个发光单元的结构完全相同，因此不会出现CRT显示器那样存在某些区域聚焦不良或因使用时间过长出现散焦的毛病。</p>
<p>缺点：是价格较高，由于显示屏上的玻璃较薄使屏幕较脆弱。</p>
<h6 id="液晶显示器"><a href="#液晶显示器" class="headerlink" title="液晶显示器"></a>液晶显示器</h6><p>在充电条件下，液晶能改变分子排列，继而造成光线的扭曲或折射。</p>
<p>液晶显示器工作原理是通过能阻塞或传递光的液晶材料，传递来自周围的或内部光源的偏振光。以电流刺激液晶分子产生点、线、面配合背部灯管构成画面。</p>
<p>LCD比CRT显示器具有更好的图像清晰度，画面稳定性和更低的功率消耗，但液晶材质粘滞性比较大，图像更新需要较长响应时间，因此不适合显示动态图象。</p>
<h5 id="光栅显示器的技术指标"><a href="#光栅显示器的技术指标" class="headerlink" title="光栅显示器的技术指标"></a>光栅显示器的技术指标</h5><ol>
<li>扫描方式：分为逐行扫描和隔行扫描（已淘汰）；</li>
<li>刷新频率：屏幕刷新速度，75Hz是最低要求；</li>
<li>点距：同一像素中两颜色相近的磷光的距离。越小，图像越细腻</li>
<li>分辨率：屏幕上水平方向和垂直方向上所显示的点数，分辨率越高图像越清晰，且能增加屏幕上的信息容量。</li>
<li>亮度：显示白色图形白块的亮度，并不是越亮越好；</li>
<li>对比度：显示的画面或字符与屏幕背景底色的亮度对比。对比度越大，显示的字符或画面越清晰。</li>
<li>尺寸：屏幕尺寸实际上指显现管的尺寸。</li>
</ol>
<h5 id="显卡"><a href="#显卡" class="headerlink" title="显卡"></a>显卡</h5><p>显示器必须依靠显卡提供的显示信号才能显示出各种字符和图像，显卡是连接显示器和个人计算机主板的重要设备。</p>
<h6 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h6><p>根据CPU提供的指令和有关数据进行相应的处理，并把处理结果转换为显示器能够接受的文字和图像显示信号，通过屏幕显示出来。</p>
<h6 id="显卡组成："><a href="#显卡组成：" class="headerlink" title="显卡组成："></a>显卡组成：</h6><p>显卡BIOS芯片、图像处理芯片（GPU）(核心)、显存、数模转换器芯片（RAMDAC）芯片、接口。</p>
<h4 id="投影仪"><a href="#投影仪" class="headerlink" title="投影仪"></a>投影仪</h4><p>将数字图像或视频投射到幕布上的设备。<br>从数字信号到光信号的转换设备。</p>
<p>根据投影仪的工作方式不同，主要分为CRT型、LCD型及DLP型三种不同类型的投影仪，而其中LCD投影仪与DLP投影仪又是目前商用投影仪中的主流。</p>
<h4 id="打印机"><a href="#打印机" class="headerlink" title="打印机"></a>打印机</h4><p>打印机是目前非常通用的一种输出设备，其结构可分为机械装置和控制电路两部分。</p>
<p>常见的有针式、喷墨、激光打印机三类。</p>
<p>打印分辨率、速度、幅面、最大打印能力等是衡量打印机性能的重要指标。</p>
<h4 id="3D打印机"><a href="#3D打印机" class="headerlink" title="3D打印机"></a>3D打印机</h4><p>3D打印机又称三维打印机，它以数字模型文件为输入，运用特殊蜡材、粉末状金属或塑料等可粘合材料，通过打印一层层的粘合材料来制造三维的物体。</p>
<p>3D打印机与传统打印机最大的区别在于它使用的“墨水”是实实在在的原材料，可用于打印的介质种类多样，从繁多的塑料到金属、陶瓷以及橡胶类物质。有些打印机还能结合不同介质，令打印出来的物体一头坚硬而另一头柔软。</p>
<h5 id="分类-4"><a href="#分类-4" class="headerlink" title="分类"></a>分类</h5><p>分为喷墨式，熔积成型，激光烧结三种类型的3D打印机</p>
<h4 id="语音交互设备"><a href="#语音交互设备" class="headerlink" title="语音交互设备"></a>语音交互设备</h4><p>语音作为一种重要的交互手段，日益受到人们的重视。</p>
<h5 id="基本的语音交互设备"><a href="#基本的语音交互设备" class="headerlink" title="基本的语音交互设备"></a>基本的语音交互设备</h5><ol>
<li>耳机</li>
<li>麦克风</li>
<li>声卡</li>
</ol>
<h3 id="虚拟现实交互设备"><a href="#虚拟现实交互设备" class="headerlink" title="虚拟现实交互设备"></a>虚拟现实交互设备</h3><h4 id="三维空间定位设备"><a href="#三维空间定位设备" class="headerlink" title="三维空间定位设备"></a>三维空间定位设备</h4><h5 id="空间跟踪定位器"><a href="#空间跟踪定位器" class="headerlink" title="空间跟踪定位器"></a>空间跟踪定位器</h5><p>又称三维空间传感器，是一种能实时地检测物体空间运动的装置，可以得到物体在六个自由度上相对于某个固定物体的位移，包括X、Y、Z坐标上的位置以及围绕X、Y、Z轴的旋转值（转动、俯仰、摇摆）。称为“非接触式传感器”。</p>
<h6 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h6><ol>
<li>定位精度：传感器所能测出来的最小位置变化。</li>
<li>位置修改速率：传感器在一秒内所能完成的测量次数。</li>
<li>延时：被检测物体的某个动作与传感器测出该动作的时间间隔。</li>
</ol>
<h5 id="数据手套"><a href="#数据手套" class="headerlink" title="数据手套"></a>数据手套</h5><p>在虚拟环境中，操作者通过数据手套可以用手去抓会推动虚拟物体，以及做出各种手势命令。</p>
<h6 id="数据手套的作用："><a href="#数据手套的作用：" class="headerlink" title="数据手套的作用："></a>数据手套的作用：</h6><ol>
<li>捕捉手指和手腕的瞎蒙对运动，提供各种手势信号；</li>
<li>配合一个六自由度的跟踪器，跟踪手的实际位置和方向。</li>
</ol>
<h6 id="组成-3"><a href="#组成-3" class="headerlink" title="组成"></a>组成</h6><ol>
<li>位置、方向传感器</li>
<li>沿每个手指背部安装的一组有保护套的光纤导线。</li>
</ol>
<h5 id="触觉和力反馈器"><a href="#触觉和力反馈器" class="headerlink" title="触觉和力反馈器"></a>触觉和力反馈器</h5><p>手指触觉反馈器的实现主要通过视觉、气压感、振动触觉、电子触觉和神经模拟。</p>
<h4 id="三维显示设备"><a href="#三维显示设备" class="headerlink" title="三维显示设备"></a>三维显示设备</h4><h5 id="立体视觉"><a href="#立体视觉" class="headerlink" title="立体视觉"></a>立体视觉</h5><h6 id="立体视觉原理"><a href="#立体视觉原理" class="headerlink" title="立体视觉原理"></a>立体视觉原理</h6><p>通过立体摄像机获取具有细微差别的左右两组图像，然后通过相应的3D显示技术分别播放给人的左、右眼以模拟人在现实中观察物体的情形，从而在人脑中呈现虚拟的立体场景。</p>
<h6 id="立体视觉显示技术"><a href="#立体视觉显示技术" class="headerlink" title="立体视觉显示技术"></a>立体视觉显示技术</h6><p>主动式立体模式和被动式立体模式。</p>
<p>主动式立体模式常用于立体电视及立体投影仪设备，对应用户的左右眼影像将按照顺序<strong>交替显示</strong>，用户使用LCD立体眼镜保持与立体影像的同步，这种模式可以产生高质量的立体效果。</p>
<p>被动式立体模式常用于影院环境，需要使用两套显示设备以及投影设备分别生成左右眼影像并进行投影，不同的投影分别使用不同角度的<strong>偏振光</strong>来区别左右眼影像，用户使用偏振光眼镜保持立体影像的同步。</p>
<h6 id="头盔式显示器"><a href="#头盔式显示器" class="headerlink" title="头盔式显示器"></a>头盔式显示器</h6><p>头盔式显示器（Head Mounted Display，HMD，）是一种立体图形显示设备，可单独与主机相连以接受来自主机的三维虚拟现实场景信息。</p>
<p>分类：单通道和双通道。</p>
<h5 id="投影拼接融合的沉浸式显示环境"><a href="#投影拼接融合的沉浸式显示环境" class="headerlink" title="投影拼接融合的沉浸式显示环境"></a>投影拼接融合的沉浸式显示环境</h5><p>投影拼接融合是指将多台投影仪所投射出的画面进行边缘融入，显示出无缝、大幅面、高亮度、高分辨率的整幅画面，为观众提供全沉浸式的观看体验及多用户参与的交互体验。</p>
<h6 id="投影拼接融合技术组成部分"><a href="#投影拼接融合技术组成部分" class="headerlink" title="投影拼接融合技术组成部分"></a>投影拼接融合技术组成部分</h6><ol>
<li>几何校正:对投影图像变形失真和重叠区域画面纹理不齐进行的误差校正方法。</li>
<li>亮度/色彩校正：对于投影的画面拼接中有投影光线和画面重叠部分的融合处理。</li>
</ol>
<h6 id="投影拼接融合分类"><a href="#投影拼接融合分类" class="headerlink" title="投影拼接融合分类"></a>投影拼接融合分类</h6><p>根据拼接融合方式，分为：手动拼接融合和自动拼接融合。</p>
<p>手动拼接融合的步骤：</p>
<ol>
<li>几何校正：为每个投影仪的实际投影区域添加控制网格，通过调整控制网格实现投影区域的拼接。细化并调整控制网格，以使得投影画面的重叠区域实现精准对齐。</li>
<li>亮度融合：手动拖动调整每台投影仪实际投影区域的重合区域亮度衰减曲线，以消除重合区域的过暗与过亮现象。</li>
<li>颜色融合：分别调整每台投影仪白色、红色、绿色、蓝色值阈值，使得两台投影仪颜色基本相同。</li>
</ol>
<p>手动拼接实现简单，拼接效果可控；但是手动拼接系统需要专业人员操作，拼接耗时，且拼接效果取决于操作人员的主观判断。</p>
<h5 id="裸眼立体显示设备"><a href="#裸眼立体显示设备" class="headerlink" title="裸眼立体显示设备"></a>裸眼立体显示设备</h5><h6 id="裸眼立体显示器实现技术分类"><a href="#裸眼立体显示器实现技术分类" class="headerlink" title="裸眼立体显示器实现技术分类"></a>裸眼立体显示器实现技术分类</h6><ol>
<li>视差壁（Parallax Barrier）技术</li>
<li>柱状透镜（Lenticular Lens）技术</li>
</ol>
<h2 id="行为模型、结构模型的主要研究内容及其特点，掌握模型的相互转换-P121"><a href="#行为模型、结构模型的主要研究内容及其特点，掌握模型的相互转换-P121" class="headerlink" title="行为模型、结构模型的主要研究内容及其特点，掌握模型的相互转换(P121)"></a>行为模型、结构模型的主要研究内容及其特点，掌握模型的相互转换(P121)</h2><h3 id="行为模型"><a href="#行为模型" class="headerlink" title="行为模型"></a>行为模型</h3><h4 id="GOMS"><a href="#GOMS" class="headerlink" title="GOMS"></a>GOMS</h4><p>通过目标 (Goal)、操作 (Operator)、方法 (Method) 以及选择规则 (Selection) 四个元素来描述用户的行为。</p>
<p>GOMS是在交互系统中用来分析建立用户行为的模型。它采用“分而治之”的思想，将一个任务进行多层次的细化</p>
<ol>
<li>目标 Goals<br>目标就是用户执行任务最终想要得到的结果,它可以在不同的层次中进行定义。</li>
<li>操作 Operators<br>操作是任务分析到最低层时的行为，是用户为了完成任务所必须执行的基本动作。 </li>
<li>方法 Methods<br>方法是描述如何完成目标的过程。一个方法本质上来说是内部的算法，用来确定子目标序列及完成目标所需要的操作。</li>
<li>选择 Selection<br>选择是用户要遵守的判定规则，以确定在特定环境下所要使用的方法。<br>当有多个方法可供选择时，GOMS中并不认为这是一个随机的选择，而是尽量来预测会使用哪个方法,这需要根据特定用户、系统的状态、目标的细节来预测要选择哪种方法。</li>
</ol>
<h5 id="GOMS的应用"><a href="#GOMS的应用" class="headerlink" title="GOMS的应用"></a>GOMS的应用</h5><p>作为一种人机交互界面表示的理论模型，GOMS是人机交互研究领域内少有的几个广为人知的模型之一，并被称为最成熟的工程典范，该模型在计算机系统的评估方面也有广泛的应用。</p>
<h5 id="GOMS的局限性"><a href="#GOMS的局限性" class="headerlink" title="GOMS的局限性"></a>GOMS的局限性</h5><ul>
<li>GOMS没有清楚的描述错误处理的过程，假设用户完全按一种正确的方式进行人机交互，因此只针对那些不犯任何错误的专家用户。</li>
<li>GOMS对于任务之间的关系描述过于简单,只有顺序和选择.另外选择关系通过非形式化的附加规则描述，实现起来也比较困难。</li>
<li>GOMS把所有的任务都看作是面向操作目标的，而忽略了一些任务所要解决的问题本质以及用户间的个体差异，它的建立不是基于现有的认知心理学，无法代表真正的认知过程。   </li>
</ul>
<h4 id="LOTOS"><a href="#LOTOS" class="headerlink" title="LOTOS"></a>LOTOS</h4><p>国际标准形式描述语言，适于描述具有并发、交互、反馈和不确定性等特点的并发（concurrent）系统中的行为。</p>
<p>开始作为一种描述网络协议的语言，由于交互系统、特别是多通道交互系统有并发系统的特点，因此成为用来描述交互系统的行为模型。</p>
<h5 id="LOTOS算子的思想"><a href="#LOTOS算子的思想" class="headerlink" title="LOTOS算子的思想"></a>LOTOS算子的思想</h5><ul>
<li>系统的外部可见行为可以看作是由一个有时序关系的交互序列组成。</li>
<li>系统由一系列进程组成，进程同环境之间通过称为“关口”（gates）的交互点进行交互。</li>
<li>两个以上的进程在执行同一个外部可见的行为时会发生交互操作，进行数据交换、信息传递、协调同步等操作。</li>
<li>进程行为用“行为表达式”来描述，复杂的行为由简单的行为表达式通过表示时序关系的LOTOS算符组合而成。</li>
<li>在将LOTOS思想用于人机交互的行为模型时，用进程之间的约束关系来描述交互子任务之间的关系。 </li>
</ul>
<h5 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符(*)"></a>基本运算符(*)</h5><ul>
<li><p>T1 ||| T2（交替Interleaving）<br>T1和T2两个任务相互独立执行，可按任意顺序执行，但永远不会同步。 </p>
</li>
<li><p>T1 [] T2（选择Choice）<br>需要在T1，T2中选择一个执行，一旦选择某一个后，必须执行它直到结束，在这中间另一个再无执行机会。 </p>
</li>
<li><p>T1 | [a1,…,an] | T2（同步Synchronization）<br>任务T1，T2必须在动作（a1,……，an）处保持同步 </p>
</li>
<li><p>T1 [&gt; T2（禁止Deactivation）<br>一旦T2任务被执行，T1便无效（不活动）</p>
</li>
<li><p>T1 &gt;&gt; T2（允许Enabling）<br>当T1成功结束后才允许T2执行 </p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/bafe3765f1e848338faaf7d6c13fd2a2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA562xLi4=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GOAL:中国象棋</span><br><span class="line">  [&gt;:</span><br><span class="line">  GOAL:运行</span><br><span class="line">    |||:</span><br><span class="line">    *GOAL:走棋</span><br><span class="line">      ACTION:自动记录棋谱</span><br><span class="line">      &gt;&gt;:</span><br><span class="line">      GOAL:当前方走</span><br><span class="line">        &gt;&gt;:</span><br><span class="line">        OPRATOR:拾取棋子</span><br><span class="line">        OPRATOR:放置棋子 </span><br><span class="line">      GOAL:对弈方走 </span><br><span class="line">        &gt;&gt;</span><br><span class="line">        OPRATOR:拾取棋子</span><br><span class="line">        OPRATOR:放置棋子</span><br><span class="line">    *GOAL:打谱</span><br><span class="line">       []:</span><br><span class="line">       OPRATOR:加速</span><br><span class="line">       OPRATOR:减速</span><br><span class="line">       OPRATOR:暂停</span><br><span class="line">       OPRATOR:恢复</span><br><span class="line">  GOAL:退出</span><br></pre></td></tr></table></figure>

<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>LOTOS最大的优越性在于可以构造一套现成的自动化工具，利用这些工具，可自动进行错误检测，但它过于形式化的记法比较晦涩难懂。</p>
<h4 id="UAN"><a href="#UAN" class="headerlink" title="UAN"></a>UAN</h4><p>UAN—User Action Notation</p>
<p>UAN是一种简单的符号语言，主要描述用户的行为序列以及在执行任务时所用的界面物理对象。</p>
<p>尽管UAN属于一种行为模型，但作为一种任务描述语言，它又涉及一定程度的系统行为的描述，因而它兼有行为模型和结构模型的一些特点。</p>
<h5 id="UAN的特点"><a href="#UAN的特点" class="headerlink" title="UAN的特点"></a>UAN的特点</h5><ol>
<li><p>预定义一些标识符</p>
</li>
<li><p>采用一种表格结构来表示任务</p>
<table>
<thead>
<tr>
<th align="center">任务：任务名称</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">用户行为</td>
<td>界面反馈</td>
<td>界面状态</td>
</tr>
</tbody></table>
</li>
<li><p>界面被分解成一些类似层次结构的异步任务，每个任务的实现都用表格来描述，用户动作的关联性和时序关系由表格的行列对齐关系和从上到下、从左到右的阅读顺序来确定。</p>
</li>
</ol>
<h5 id="UAN的标识符"><a href="#UAN的标识符" class="headerlink" title="UAN的标识符"></a>UAN的标识符</h5><ol>
<li>用户动作标识符</li>
<li>条件选择标识符</li>
</ol>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>UAN模型更接近于实现，界面状态和界面反馈用一般的程序语言描述，实现起来比较方便，当然这种描述由于接近于程序语言，因此设计时需要一定的编程基础</p>
<p>UAN模型在精确刻画各成分之间的各种平行和串行的时序关系方面尚显不足，任务之间的时序关系没有明确表示出来，当所描述的界面使用多种输入设备和有若干可选交互路径时，比较繁琐。 </p>
<h5 id="层次化的界面描述方法"><a href="#层次化的界面描述方法" class="headerlink" title="层次化的界面描述方法"></a>层次化的界面描述方法</h5><p>任务分析(GOMS) –&gt; 逐步精化(LOTOS) –&gt;  原子任务说明(UAN)</p>
<h4 id="G-U-L模型"><a href="#G-U-L模型" class="headerlink" title="G-U-L模型"></a>G-U-L模型</h4><p>可以考虑将GOMS、UAN、LOTOS中模型结合为一个预测行为模型：G-U-L模型。</p>
<p>G-U-L运用GOMS原理为基础进行任务分解，建立基本的行为模型，原子操作由UAN模型描述，在此基础上，运用LOTOS算符来表示任务目标之间的时序关系。</p>
<p>在G-U-L模型中没有加入规则，在表示目标之间的关系中也未考虑同步。这主要考虑到规则的转换要涉及到推理、建立知识库等问题，而同步的问题的描述和转换也非常的复杂，这会在工作的初期造成非常大的困难。</p>
<h3 id="结构模型"><a href="#结构模型" class="headerlink" title="结构模型"></a>结构模型</h3><h4 id="产生式规则"><a href="#产生式规则" class="headerlink" title="产生式规则"></a>产生式规则</h4><p><strong>形式化语言的描述</strong>，这种结构的方法从理论上可以引导界面设计者及界面工具的设计者进行有效的设计。</p>
<p>又称为上下文无关文法，将人机交互对话看作是一种语言，运用<strong>基于语法</strong>的方法来描述交互对话。</p>
<p>产生式规则是一种形式化语言，这些规则可用于描述人机交互界面。产生式规则的一般形式是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if  condition  then  action</span><br><span class="line">这些规则可以表示为不同的形式，如</span><br><span class="line">condition → action</span><br><span class="line">condition：action</span><br></pre></td></tr></table></figure>

<p>规则定义的顺序并不重要，只要与规则中的条件相匹配，就可以激活相应的动作。产生式规则系统可以是事件引导的，也可以是状态引导的，或者两者都有。 </p>
<h5 id="事件引导的系统"><a href="#事件引导的系统" class="headerlink" title="事件引导的系统"></a>事件引导的系统</h5><h6 id="事件的主要类型"><a href="#事件的主要类型" class="headerlink" title="事件的主要类型"></a>事件的主要类型</h6><ul>
<li><p>用户事件（user event），Sel-line表示从菜单中选择line命令，C-point 和D-point表示用户在绘图平面上单击和双击鼠标 </p>
</li>
<li><p>内部事件，用于保持对话状态，如start-line 表示开始画线后的状态，rest- line表示选择了第一个点之后的状态。 </p>
</li>
<li><p>系统响应事件，以尖括号表示可见或可听的系统响应，如<code>&lt;highlight  &#39;line&#39;&gt;</code>，把菜单项’line’ 高亮度显示，<code>&lt;draw  line&gt;</code>表示在屏幕上显示直线，<code>&lt;rubber  band  on&gt; </code>表示橡皮筋绘制方式打开，<code>&lt;rubber band  off&gt;</code>表示橡皮筋绘制方式关闭。 </p>
</li>
</ul>
<h6 id="对话控制"><a href="#对话控制" class="headerlink" title="对话控制"></a>对话控制</h6><ul>
<li>对话控制主要负责事件的产生和规则的匹配，可以看到在每一时刻系统内存中会保存一些内部事件，当产生一个事件时，可能是用户事件（如单击鼠标），也可能是内部事件（如时钟事件等）。</li>
<li>对话控制就要将所有的产生式规则与事件集合进行匹配，这个过程是复杂的而且是耗时的，当产生式很多并且产生式规则的条件复杂时，匹配算法的效率就显的更为重要，因此需要设计好的数据结构和匹配算法来提高匹配规则的效率。</li>
<li>可以将规则和事件进行分组和分层。 </li>
</ul>
<h5 id="状态引导的系统"><a href="#状态引导的系统" class="headerlink" title="状态引导的系统"></a>状态引导的系统</h5><p>状态引导的系统在系统内存保存的不再是动态的随时进出的事件，而是一些表示系统的<strong>当前状态</strong>的属性，这些属性在不同的时刻有不同的值。</p>
<h6 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h6><ul>
<li>当产生式规则的条件和状态匹配时将激活该产生式规则，对于某一特定的属性，如果前面的状态需要改变成新的状态时才需要在产生规则的后面标注。</li>
<li>属性的永久特性有时会引起一些奇怪的错误。</li>
</ul>
<h5 id="混合引导系统"><a href="#混合引导系统" class="headerlink" title="混合引导系统"></a>混合引导系统</h5><p>有的对话过程比较适合于事件引导方式，有的对话过程适合于状态引导方式，当然也可以将两者结合起来，例如采用下面的形式：<br>event: condition → action<br>来描述一个产生式规则，事件用来计划产生式规则，如果条件不满足，即当前系统内存中的状态和产生式的规则不匹配，则无法激活规则，另外当状态改变时，产生式规则中的action本身也可以产生新的事件，从而可以激活另一条规则。 </p>
<h5 id="产生式规则总结"><a href="#产生式规则总结" class="headerlink" title="产生式规则总结"></a>产生式规则总结</h5><ul>
<li>描述操作时序能力强，并发顺序均可</li>
<li>无法描述误操作</li>
<li>界面复杂时，状态、事件复杂，产生式过多，要求产生式匹配算法性能高</li>
</ul>
<h4 id="状态转换网络"><a href="#状态转换网络" class="headerlink" title="状态转换网络"></a>状态转换网络</h4><p>用结构化的方法来描述人机交互的一般过程，是一种图示化的结构。</p>
<p>状态转换网络（STN）的基本思想是定义一个具有一定数量状态的转换机，称之为有限状态机-Finite State Machine(FSM)，FSM从外部世界中接收到事件，并能使FSM从一个状态转换到另一个状态。</p>
<h5 id="传统状态转换网络"><a href="#传统状态转换网络" class="headerlink" title="传统状态转换网络"></a>传统状态转换网络</h5><h6 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h6><p>当发生一个外部或内部事件时，系统就会从一个状态转换到另外一个状态，这称为状态转换。</p>
<p>外部事件主要由用户操作外部输入设备来产生，内部事件可以是系统产生的事件，如时钟事件，也可以是为了改变系统的状态和行为而产生的事件，如当一个任务完成后可以激活另一个任务等。</p>
<p>一个状态转换与一对状态相关联。</p>
<p>一般的系统具有很多个状态，假设系统由n个状态组成，状态之间的转换最多可能有n*(n-1)个。</p>
<p><img src="https://img-blog.csdnimg.cn/7e6fec3c63db44e4abb57af67eedc1ed.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA562xLi4=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h6 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h6><ul>
<li><p>状态转换网络比相应的文本解决方案更易于设计、理解、修改和文档化，它给出了对行为的精确的、甚至是格式化的定义。</p>
</li>
<li><p>存在着一定的局限性，一个最大的缺陷是需要定义出系统的所有状态，这对于小型的系统是没有问题的，但是在一个较大的系统中，系统会很快崩溃，状态的数目是呈指数级增长的，同时状态的增长直接导致了状态转换网络过于复杂、无法实际应用。  </p>
</li>
</ul>
<h5 id="扩展状态转换网络"><a href="#扩展状态转换网络" class="headerlink" title="扩展状态转换网络"></a>扩展状态转换网络</h5><p><img src="https://img-blog.csdnimg.cn/4fe6587e131442d58798b1542a05172f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA562xLi4=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h3 id="行为模型和结构模型的转换-P140-P148"><a href="#行为模型和结构模型的转换-P140-P148" class="headerlink" title="行为模型和结构模型的转换 (P140~P148)"></a>行为模型和结构模型的转换 (P140~P148)</h3><h2 id="掌握图形用户界面的基本原则-P100"><a href="#掌握图形用户界面的基本原则-P100" class="headerlink" title="掌握图形用户界面的基本原则(P100)"></a>掌握图形用户界面的基本原则(P100)</h2><h3 id="图形用户界面的主要思想"><a href="#图形用户界面的主要思想" class="headerlink" title="图形用户界面的主要思想"></a>图形用户界面的主要思想</h3><h4 id="1-桌面隐喻"><a href="#1-桌面隐喻" class="headerlink" title="1. 桌面隐喻"></a>1. 桌面隐喻</h4><p>桌面隐喻是指在用户界面中用人们熟悉的桌面上的图例清楚地表示计算机可以处理的能力。</p>
<h4 id="2-所见即所得"><a href="#2-所见即所得" class="headerlink" title="2. 所见即所得"></a>2. 所见即所得</h4><p>在WYSIWYG交互界面中，其所显示的用户交互行为与应用程序最终产生的结果是一致的。</p>
<h4 id="3-直接操纵"><a href="#3-直接操纵" class="headerlink" title="3. 直接操纵"></a>3. 直接操纵</h4><p>直接操纵是指可以把操作的对象、属性、关系显式地表示出来，用光笔、鼠标、触摸屏或数据手套等指点设备直接从屏幕上获取形象化命令与数据的过程。</p>
<h3 id="图形用户界面设计的一般原则"><a href="#图形用户界面设计的一般原则" class="headerlink" title="图形用户界面设计的一般原则"></a>图形用户界面设计的一般原则</h3><ol>
<li>界面具有一致性</li>
<li>常用操作有快捷方式</li>
<li>提供必要的错误处理能力</li>
<li>提供信息反馈</li>
<li>允许可逆操作</li>
<li>设计良好的联机帮助</li>
<li>合理划分并高效地使用显示屏幕</li>
</ol>
<h2 id="掌握移动互联网设计的基本原则及其特点"><a href="#掌握移动互联网设计的基本原则及其特点" class="headerlink" title="掌握移动互联网设计的基本原则及其特点"></a>掌握移动互联网设计的基本原则及其特点</h2><h3 id="移动互联网的简介-P211"><a href="#移动互联网的简介-P211" class="headerlink" title="移动互联网的简介(P211)"></a>移动互联网的简介(P211)</h3><p>移动互联网概念的理解可能因人而异，特别是与无线互联网（Wireless Internet）可能会当成一回事。<br>从概念上而言，移动与无线是两个不同的概念，<br>在很多情况下，无线与移动是两个重叠的概念，但在另外一些情况下，这两者又有明显的区别，这也使得移动互联网的概念可以从狭义与广义两个角度来理解。 </p>
<ul>
<li>从狭义的角度上来讲，移动互联网指的就是基于分组交换技术的无线数据通信技术，有时可能会被称之为无线互联网（Wireless Internet）。 </li>
<li>从广义的角度上来讲，移动互联网不一定局限于一般的无线数据通信方式，与无线互联网的概念有一定的区别，我们可以从设备的移动性与数据连接方式这两个方面来说明。</li>
</ul>
<h3 id="Web界面设计原则-P187"><a href="#Web界面设计原则-P187" class="headerlink" title="Web界面设计原则(P187)"></a>Web界面设计原则(P187)</h3><h4 id="1-以用户为中心"><a href="#1-以用户为中心" class="headerlink" title="1. 以用户为中心"></a>1. 以用户为中心</h4><p>要求把用户放在第一位。设计时既要考虑用户的共性，同时也要考虑他们之间的差异性。</p>
<h4 id="2-一致性"><a href="#2-一致性" class="headerlink" title="2. 一致性"></a>2. 一致性</h4><p>Web界面设计还必须考虑内容和形式的一致性。其次，Web界面自身的风格也要一致性，保持统一的整体形象。</p>
<h4 id="3-简洁与明确"><a href="#3-简洁与明确" class="headerlink" title="3. 简洁与明确"></a>3. 简洁与明确</h4><p>Web界面设计是设计的一种，要求简练、明确。</p>
<h4 id="4-体现特色"><a href="#4-体现特色" class="headerlink" title="4.体现特色"></a>4.体现特色</h4><p>只有丰富特色、内容翔实的网页才能使浏览者驻足阅读。特色鲜明的Web网站是精心策划的结果，只有独特的创意和赏心悦目的网页设计才能在一瞬间打动浏览者。</p>
<h4 id="5-兼顾不同的浏览器"><a href="#5-兼顾不同的浏览器" class="headerlink" title="5. 兼顾不同的浏览器"></a>5. 兼顾不同的浏览器</h4><h4 id="6-明确的导航设计"><a href="#6-明确的导航设计" class="headerlink" title="6. 明确的导航设计"></a>6. 明确的导航设计</h4><p>网站首页导航应尽量展现整个网站的架构和内容，要能让浏览者确切地知道自己在整个网站中的位置，可以确定下一步的浏览去向。</p>
<h3 id="移动界面设计存在的限制-P217"><a href="#移动界面设计存在的限制-P217" class="headerlink" title="移动界面设计存在的限制(P217)"></a>移动界面设计存在的限制(P217)</h3><ol>
<li>资源相对匮乏</li>
<li>移动设备的种类繁多</li>
<li>连接方式复杂</li>
</ol>
<h3 id="移动界面设计的原则"><a href="#移动界面设计的原则" class="headerlink" title="移动界面设计的原则"></a>移动界面设计的原则</h3><ol>
<li>简单直观</li>
<li>个性化设计</li>
<li>易于检索</li>
<li>界面风格一致</li>
<li>避免不必要的文本输入</li>
<li>根据用户的要求使服务个性化</li>
<li>最大限度地避免用户出错</li>
<li>文本信息应当本地化</li>
</ol>
<h2 id="掌握几种基本的软件体系结构"><a href="#掌握几种基本的软件体系结构" class="headerlink" title="掌握几种基本的软件体系结构"></a>掌握几种基本的软件体系结构</h2><h2 id="熟悉LOTOS的几种关系及其语法-P124"><a href="#熟悉LOTOS的几种关系及其语法-P124" class="headerlink" title="熟悉LOTOS的几种关系及其语法(P124)"></a>熟悉LOTOS的几种关系及其语法(P124)</h2><ul>
<li><p>T1 ||| T2（交替Interleaving）<br>T1和T2两个任务相互独立执行，可按任意顺序执行，但永远不会同步。 </p>
</li>
<li><p>T1 [] T2（选择Choice）<br>需要在T1，T2中选择一个执行，一旦选择某一个后，必须执行它直到结束，在这中间另一个再无执行机会。 </p>
</li>
<li><p>T1 | [a1,…,an] | T2（同步Synchronization）<br>任务T1，T2必须在动作（a1,……，an）处保持同步 </p>
</li>
<li><p>T1 [&gt; T2（禁止Deactivation）<br>一旦T2任务被执行，T1便无效（不活动）</p>
</li>
<li><p>T1 &gt;&gt; T2（允许Enabling）<br>当T1成功结束后才允许T2执行 </p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/c87f8d7319344282aee17bc5e2522ef6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA562xLi4=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/eda4dc20664b476ab8b832c2230e203e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA562xLi4=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GOAL:中国象棋</span><br><span class="line">  [&gt;:</span><br><span class="line">  GOAL:运行</span><br><span class="line">    |||:</span><br><span class="line">    *GOAL:走棋</span><br><span class="line">      ACTION:自动记录棋谱</span><br><span class="line">      &gt;&gt;:</span><br><span class="line">      GOAL:当前方走</span><br><span class="line">        &gt;&gt;:</span><br><span class="line">        OPRATOR:拾取棋子</span><br><span class="line">        OPRATOR:放置棋子 </span><br><span class="line">      GOAL:对弈方走 </span><br><span class="line">        &gt;&gt;</span><br><span class="line">        OPRATOR:拾取棋子</span><br><span class="line">        OPRATOR:放置棋子</span><br><span class="line">    *GOAL:打谱</span><br><span class="line">       []:</span><br><span class="line">       OPRATOR:加速</span><br><span class="line">       OPRATOR:减速</span><br><span class="line">       OPRATOR:暂停</span><br><span class="line">       OPRATOR:恢复</span><br><span class="line">  GOAL:退出</span><br></pre></td></tr></table></figure>

<h2 id="什么是可用性及其可用性的基本原则（P247）"><a href="#什么是可用性及其可用性的基本原则（P247）" class="headerlink" title="什么是可用性及其可用性的基本原则（P247）"></a>什么是可用性及其可用性的基本原则（P247）</h2><h3 id="可用性定义"><a href="#可用性定义" class="headerlink" title="可用性定义"></a>可用性定义</h3><p>指特定的用户在特定环境下使用产品并达到特定目标的效力、效率和满意的程度。<br>这五个方面集中反映了用户对产品的需求，从它们的英文表达上被归纳为五个“E：</p>
<ol>
<li>有效性：怎样准确、完整地完成工作或达到目标</li>
<li>效率：怎样快速地完成工作</li>
<li>吸引力：用户界面如何吸引用户进行交互并在使用中得到满意和满足</li>
<li>容错能力：产品避免错误的发生并帮助用户修正错误的能力</li>
<li>易于学习：支持用户对产品的入门使用及在以后使用过程中的持续学习</li>
</ol>
<h3 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h3><h4 id="1-可学习型"><a href="#1-可学习型" class="headerlink" title="1. 可学习型"></a>1. 可学习型</h4><p>可学习性是指交互系统能否让新手学会如何使用系统，以及如何达到最佳交互效能。</p>
<h5 id="1-可预见性"><a href="#1-可预见性" class="headerlink" title="1. 可预见性"></a>1. 可预见性</h5><p>不应该让用户感到过分惊奇；用户利用前面交互过程的了解就足以确定后面交互的结果。</p>
<h5 id="2-同步性"><a href="#2-同步性" class="headerlink" title="2. 同步性"></a>2. 同步性</h5><p>指用户依据界面当前状态评估过去操作造成影响的能力，也就是说用户能不能同步地知道交互操作的结果。</p>
<h5 id="3-熟悉性"><a href="#3-熟悉性" class="headerlink" title="3. 熟悉性"></a>3. 熟悉性</h5><h5 id="4-通用性"><a href="#4-通用性" class="headerlink" title="4. 通用性"></a>4. 通用性</h5><p>在交互中尽可能地提供一些通用的或能够从现有功能类推出来的功能。</p>
<h5 id="5-一致性"><a href="#5-一致性" class="headerlink" title="5. 一致性"></a>5. 一致性</h5><p>在相似的环境下或执行相似任务时一般会执行相似的行为。</p>
<h4 id="2-灵活性"><a href="#2-灵活性" class="headerlink" title="2.灵活性"></a>2.灵活性</h4><p>灵活性体现了用户与系统交流信息方式的多样性。</p>
<h5 id="1-可定制性"><a href="#1-可定制性" class="headerlink" title="1. 可定制性"></a>1. 可定制性</h5><p>用户或系统修改界面的能力。</p>
<h5 id="2-对话主动性"><a href="#2-对话主动性" class="headerlink" title="2. 对话主动性"></a>2. 对话主动性</h5><p>将人机交互的双方看作是一对对话者，重点是谁是对话的发起人。</p>
<h5 id="3-多线程"><a href="#3-多线程" class="headerlink" title="3. 多线程"></a>3. 多线程</h5><h5 id="4-可互换性"><a href="#4-可互换性" class="headerlink" title="4. 可互换性"></a>4. 可互换性</h5><p>任务的执行可以在系统控制和用户控制间进行转移。</p>
<h5 id="5-可替换性"><a href="#5-可替换性" class="headerlink" title="5. 可替换性"></a>5. 可替换性</h5><p>要求等量的数值可以彼此交换。</p>
<h4 id="3-鲁棒性"><a href="#3-鲁棒性" class="headerlink" title="3.鲁棒性"></a>3.鲁棒性</h4><p>用户使用计算机的目的是达到某种目标。能不能成功地达到目标和能不能对到达的目标进行评估就体现为交互的鲁棒性.</p>
<h5 id="1-可观察性"><a href="#1-可观察性" class="headerlink" title="1. 可观察性"></a>1. 可观察性</h5><p>允许用户通过观察交互界面的表现来了解系统的内部状态。</p>
<h5 id="2-可恢复性"><a href="#2-可恢复性" class="headerlink" title="2. 可恢复性"></a>2. 可恢复性</h5><p>用户意识到发生了错误并进行更正的能力。</p>
<h5 id="3-响应性"><a href="#3-响应性" class="headerlink" title="3. 响应性"></a>3. 响应性</h5><p>反映了系统与用户之间交流的频率。</p>
<h5 id="4-任务规范性"><a href="#4-任务规范性" class="headerlink" title="4. 任务规范性"></a>4. 任务规范性</h5><p>系统为完成交互任务所提供的功能是否规范。</p>
<h2 id="案例综合分析-P277"><a href="#案例综合分析-P277" class="headerlink" title="案例综合分析(P277)"></a>案例综合分析(P277)</h2>]]></content>
      <categories>
        <category>课程学习</category>
        <category>人机交互</category>
      </categories>
      <tags>
        <tag>课程学习</tag>
        <tag>人机交互</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程期末知识点总结</title>
    <url>/135xyq.github.io/2021/12/30/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="网络编程知识点总结"><a href="#网络编程知识点总结" class="headerlink" title="网络编程知识点总结"></a>网络编程知识点总结</h1><h2 id="套接字地址，通用形式"><a href="#套接字地址，通用形式" class="headerlink" title="套接字地址，通用形式"></a>套接字地址，通用形式</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span>&#123;</span>  <span class="comment">/*保存地址的结构*/</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> sa_len; <span class="comment">/*总长度*/</span></span><br><span class="line">	<span class="keyword">sa_family_t</span> sa_family; <span class="comment">/*地址族*/</span></span><br><span class="line">	<span class="keyword">char</span> sa_data[<span class="number">14</span>]; <span class="comment">/*实际更长：地址值*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="互联网地址，互联网风格"><a href="#互联网地址，互联网风格" class="headerlink" title="互联网地址，互联网风格"></a>互联网地址，互联网风格</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>&#123;</span></span><br><span class="line">	<span class="keyword">unit8_t</span> sin_len;  <span class="comment">/*总长度*/</span></span><br><span class="line">	<span class="keyword">sa_family_t</span> sa_family; <span class="comment">/*地址类型*/</span></span><br><span class="line">	<span class="keyword">in_port_t</span>  sin_port; <span class="comment">/*协议端口号*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>；/*<span class="title">IP</span>地址*/</span></span><br><span class="line"><span class="class">	<span class="title">sin_zero</span>[8]； /*未使用（设置为0）*/</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="两种传输服务的套接字类型"><a href="#两种传输服务的套接字类型" class="headerlink" title="两种传输服务的套接字类型"></a>两种传输服务的套接字类型</h2><p>UDP:不可靠的数据报<br>TCP：可靠的、面向字节流的</p>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><h4 id="客户端服务端之间没有连接"><a href="#客户端服务端之间没有连接" class="headerlink" title="客户端服务端之间没有连接"></a>客户端服务端之间没有连接</h4><ul>
<li>发送数据前不握手</li>
<li>发送方式显式的将IP目的地址和端口 # 附加到每个数据包</li>
<li>接受方从收到的数据包中提取发送方的IP地址和端口号</li>
</ul>
<h4 id="UDP传输的数据可能丢失或接受顺序错误"><a href="#UDP传输的数据可能丢失或接受顺序错误" class="headerlink" title="UDP传输的数据可能丢失或接受顺序错误"></a>UDP传输的数据可能丢失或接受顺序错误</h4><h4 id="简单的UDP程序"><a href="#简单的UDP程序" class="headerlink" title="简单的UDP程序"></a>简单的UDP程序</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LINELEN 128</span></span><br><span class="line"><span class="comment">/* 1) initialize sockaddr_in structure */</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;serverin, <span class="number">0</span>, <span class="keyword">sizeof</span>(serverin));</span><br><span class="line">serverin.sin_family = AF_INET;</span><br><span class="line">serverin.sin_addr.s_addr = inet_addr(SERVER_HOST_ADDR);</span><br><span class="line">serverin.sin_port = htons(SERVER_PORT);</span><br><span class="line"><span class="comment">/* 2) Create a socket */</span></span><br><span class="line"><span class="keyword">if</span> ((clientSocket = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">err(<span class="number">1</span>, “create socket<span class="string">&quot;);</span></span><br><span class="line"><span class="string">/* 3) formulate a request */</span></span><br><span class="line"><span class="string">char buf[LINELEN+1];</span></span><br><span class="line"><span class="string">int nchars; /* char count read in buf */</span></span><br><span class="line"><span class="string">fgets(buf, sizeof(buf), stdin);</span></span><br><span class="line"><span class="string">buf[LINELEN] = &#x27;\0&#x27;; /* insure null-terminated */</span></span><br><span class="line"><span class="string">nchars = strlen(buf);</span></span><br><span class="line"><span class="string">/* 4) send the request */</span></span><br><span class="line"><span class="string">(void) sendto(clientSocket, buf, nchars, 0, </span></span><br><span class="line"><span class="string">(struct sockaddr *)&amp;serverin, sizeof(serverin));</span></span><br><span class="line"><span class="string">/* 5) receive the reply */</span></span><br><span class="line"><span class="string">if (recv(clientSocket, buf, sizeof(buf), 0) &lt; 0)</span></span><br><span class="line"><span class="string">err(1, &quot;</span>recv socket<span class="string">&quot;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">/* 6) handle the response */</span></span><br><span class="line"><span class="string">fputs(buf, stdout);</span></span><br><span class="line"><span class="string">fflush(stdout);</span></span><br></pre></td></tr></table></figure>


<h3 id="创建UDP和TCP通信端点sockfd"><a href="#创建UDP和TCP通信端点sockfd" class="headerlink" title="创建UDP和TCP通信端点sockfd"></a>创建UDP和TCP通信端点sockfd</h3><p><a href="https://www.jianshu.com/p/066d99da7cbd">socket详解</a></p>
<h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sockfd;sockfd = socket(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h4 id="UDP-1"><a href="#UDP-1" class="headerlink" title="UDP"></a>UDP</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sockfd;sockfd = socket(PF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>


<h2 id="FD-ZERO、FD-SET、FD-CLR、FD-ISSET"><a href="#FD-ZERO、FD-SET、FD-CLR、FD-ISSET" class="headerlink" title="FD_ZERO、FD_SET、FD_CLR、FD_ISSET"></a><a href="https://www.cnblogs.com/skyofbitbit/p/3654466.html">FD_ZERO、FD_SET、FD_CLR、FD_ISSET</a></h2><ol>
<li>FD_ZERO(fd_set * fdset);将指定的文件描述符集清空，在对文件描述符集合进行设置前，必须对其进行初始化，如果不清空，由于在系统分配内存空间后，通常并不作清空处理，所以结果是不可知的。</li>
<li>FD_SET(fd_set * fdset);用于在文件描述符集合中增加一个新的文件描述符。</li>
<li>FD_CLR(fd_set * fdset);用于在文件描述符集合中删除一个文件描述符。</li>
<li>FD_ISSET(int fd,fd_set * fdset);用于测试指定的文件描述符是否在该集合中。</li>
</ol>
<h2 id="select"><a href="#select" class="headerlink" title="select"></a><a href="https://www.cnblogs.com/skyofbitbit/p/3654466.html">select</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readset, fd_set *writeset,fd_set* exceptset, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="nfds"><a href="#nfds" class="headerlink" title="nfds"></a>nfds</h3><p>需要检查的文件描述字个数（即检查到fd_set的第几位），数值应该比三组fd_set中所含的最大fd值更大，一般设为三组fd_set中所含的最大 fd值加1（如在readset,writeset,exceptset中所含最大的fd为5，则nfds=6，因为fd是从0开始的）。设这个值是为提高效率，使函数不必检查fd_set的所有1024位。</p>
<h3 id="readset"><a href="#readset" class="headerlink" title="readset"></a>readset</h3><p>用来检查可读性的一组文件描述字。</p>
<h3 id="writeset"><a href="#writeset" class="headerlink" title="writeset"></a>writeset</h3><p>用来检查可写性的一组文件描述字。</p>
<h3 id="exceptset"><a href="#exceptset" class="headerlink" title="exceptset"></a>exceptset</h3><p>用来检查是否有异常条件出现的文件描述字。(注：错误不包括在异常条件之内)</p>
<h3 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h3><p>用于描述一段时间长度，如果在这个时间内，需要监视的描述符没有事件发生则函数返回，返回值为0。</p>
<h2 id="ai-family"><a href="#ai-family" class="headerlink" title="ai_family"></a>ai_family</h2><p>ai_family参数指定调用者期待返回的套接口地址结构的类型。它的值包括三种：AF_INET，AF_INET6和AF_UNSPEC。如果指定AF_INET，那么函数九不能返回任何IPV6相关的地址信息；如果仅指定了AF_INET6，则就不能返回任何IPV4地址信息。AF_UNSPEC则意味着函数返回的是适用于指定主机名和服务名且适合任何协议族的地址</p>
<h2 id="ntohs-将一个无符号短整型数从网络字节顺序转换为主机字节顺序。"><a href="#ntohs-将一个无符号短整型数从网络字节顺序转换为主机字节顺序。" class="headerlink" title="ntohs:将一个无符号短整型数从网络字节顺序转换为主机字节顺序。"></a>ntohs:将一个无符号短整型数从网络字节顺序转换为主机字节顺序。</h2><h2 id="htonl-将主机数转换成无符号长整形的网络字节顺序。"><a href="#htonl-将主机数转换成无符号长整形的网络字节顺序。" class="headerlink" title="htonl:将主机数转换成无符号长整形的网络字节顺序。"></a>htonl:将主机数转换成无符号长整形的网络字节顺序。</h2><h2 id="htons-htons是将整型变量从主机字节顺序转变成网络字节顺序，-就是整数在地址空间存储方式变为高位字节存放在内存的低地址处。"><a href="#htons-htons是将整型变量从主机字节顺序转变成网络字节顺序，-就是整数在地址空间存储方式变为高位字节存放在内存的低地址处。" class="headerlink" title="htons:htons是将整型变量从主机字节顺序转变成网络字节顺序， 就是整数在地址空间存储方式变为高位字节存放在内存的低地址处。"></a>htons:htons是将整型变量从主机字节顺序转变成网络字节顺序， 就是整数在地址空间存储方式变为高位字节存放在内存的低地址处。</h2><h2 id="ntohl-ntohl-指的是ntohl函数，是将一个无符号长整形数从网络字节顺序转换为主机字节顺序，-ntohl-返回一个以主机字节顺序表达的数。"><a href="#ntohl-ntohl-指的是ntohl函数，是将一个无符号长整形数从网络字节顺序转换为主机字节顺序，-ntohl-返回一个以主机字节顺序表达的数。" class="headerlink" title="ntohl:ntohl()指的是ntohl函数，是将一个无符号长整形数从网络字节顺序转换为主机字节顺序， ntohl()返回一个以主机字节顺序表达的数。"></a>ntohl:ntohl()指的是ntohl函数，是将一个无符号长整形数从网络字节顺序转换为主机字节顺序， ntohl()返回一个以主机字节顺序表达的数。</h2><h2 id="FTP使用TCP传输而不是UDP"><a href="#FTP使用TCP传输而不是UDP" class="headerlink" title="FTP使用TCP传输而不是UDP"></a>FTP使用TCP传输而不是UDP</h2><h2 id="如果没有错误产生，则accept-返回一个描述所接受包的SOCKET类型的值。否则的话，返回INVALID-SOCKET错误，应用程序可通过调用WSAGetLastError-来获得特定的错误代码。如果addr与addrlen中有一个为零NULL，将不返回所接受的套接口远程地址的任何信息。"><a href="#如果没有错误产生，则accept-返回一个描述所接受包的SOCKET类型的值。否则的话，返回INVALID-SOCKET错误，应用程序可通过调用WSAGetLastError-来获得特定的错误代码。如果addr与addrlen中有一个为零NULL，将不返回所接受的套接口远程地址的任何信息。" class="headerlink" title="如果没有错误产生，则accept()返回一个描述所接受包的SOCKET类型的值。否则的话，返回INVALID_SOCKET错误，应用程序可通过调用WSAGetLastError()来获得特定的错误代码。如果addr与addrlen中有一个为零NULL，将不返回所接受的套接口远程地址的任何信息。"></a>如果没有错误产生，则accept()返回一个描述所接受包的SOCKET类型的值。否则的话，返回INVALID_SOCKET错误，应用程序可通过调用WSAGetLastError()来获得特定的错误代码。如果addr与addrlen中有一个为零NULL，将不返回所接受的套接口远程地址的任何信息。</h2><h2 id="调用fork的返回值"><a href="#调用fork的返回值" class="headerlink" title="调用fork的返回值"></a>调用fork的返回值</h2><ol>
<li>在父进程中，fork返回新创建子进程的进程ID；</li>
<li>在子进程中，fork返回0；</li>
<li>如果出现错误，fork返回一个负值；</li>
</ol>
<h2 id="listen只能由TCP服务器程序调用"><a href="#listen只能由TCP服务器程序调用" class="headerlink" title="listen只能由TCP服务器程序调用"></a><a href="https://www.cnblogs.com/love-yh/p/7518552.html">listen</a>只能由TCP服务器程序调用</h2><h2 id="recvfrom-中-buflen不能为0"><a href="#recvfrom-中-buflen不能为0" class="headerlink" title="recvfrom 中 buflen不能为0"></a><a href="http://blog.sina.com.cn/s/blog_4171e80d01000asy.html">recvfrom</a> 中 buflen不能为0</h2><h2 id="ssize-t-read-int-fd-void-buf-size-t-count-成功返回读取的字节数，出错返回-1并设置errno，如果在调read之前已到达文件末尾，则这次read返回0。参数count是请求读取的字节数，读上来的数据保存在缓冲区buf中，同时文件的当前读写位置向后移"><a href="#ssize-t-read-int-fd-void-buf-size-t-count-成功返回读取的字节数，出错返回-1并设置errno，如果在调read之前已到达文件末尾，则这次read返回0。参数count是请求读取的字节数，读上来的数据保存在缓冲区buf中，同时文件的当前读写位置向后移" class="headerlink" title="ssize_t read(int fd, void * buf, size_t count);成功返回读取的字节数，出错返回-1并设置errno，如果在调read之前已到达文件末尾，则这次read返回0。参数count是请求读取的字节数，读上来的数据保存在缓冲区buf中，同时文件的当前读写位置向后移"></a>ssize_t read(int fd, void * buf, size_t count);成功返回读取的字节数，出错返回-1并设置errno，如果在调read之前已到达文件末尾，则这次read返回0。参数count是请求读取的字节数，读上来的数据保存在缓冲区buf中，同时文件的当前读写位置向后移</h2><h2 id="size-t-write-int-fd-const-void-buf-size-t-count-write-会把指针buf所指的内存写入count个字节到参数fd所指的文件内。当然，文件读写位置也会随之移动。如果顺利write-会返回实际写入的字节数。当有错误发生时则返回-1，错误代码存入errno中。"><a href="#size-t-write-int-fd-const-void-buf-size-t-count-write-会把指针buf所指的内存写入count个字节到参数fd所指的文件内。当然，文件读写位置也会随之移动。如果顺利write-会返回实际写入的字节数。当有错误发生时则返回-1，错误代码存入errno中。" class="headerlink" title="size_t write (int fd,const void * buf,size_t count);write()会把指针buf所指的内存写入count个字节到参数fd所指的文件内。当然，文件读写位置也会随之移动。如果顺利write()会返回实际写入的字节数。当有错误发生时则返回-1，错误代码存入errno中。"></a>size_t write (int fd,const void * buf,size_t count);write()会把指针buf所指的内存写入count个字节到参数fd所指的文件内。当然，文件读写位置也会随之移动。如果顺利write()会返回实际写入的字节数。当有错误发生时则返回-1，错误代码存入errno中。</h2><h2 id="servname-、nodename、hints"><a href="#servname-、nodename、hints" class="headerlink" title="servname 、nodename、hints"></a><a href="https://www.cnblogs.com/LubinLew/p/POSIX-getaddrinfo.html">servname 、nodename、hints</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getaddrinfo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> nodename, <span class="comment">/* host 或者IP地址 */</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> servname, <span class="comment">/* 十进制端口号 或者常用服务名称如&quot;ftp&quot;、&quot;http&quot;等 */</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> struct addrinfo *<span class="keyword">restrict</span> hints, <span class="comment">/* 获取信息要求设置 */</span></span></span></span><br><span class="line"><span class="params"><span class="function">    struct addrinfo **<span class="keyword">restrict</span> res)</span></span>; <span class="comment">/* 获取信息结果 */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="pthread"><a href="#pthread" class="headerlink" title="pthread"></a><a href="https://blog.csdn.net/networkhunter/article/details/100218945">pthread</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *thread, <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">void</span> *(*start_routine)(<span class="keyword">void</span>*), <span class="keyword">void</span> *arg)</span></span>; </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,<span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destory</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex )</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;  </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pthread_attr_setschedpolicy(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">int</span> policy);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>课程学习</category>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>课程学习</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>软件工程经济学期末复习</title>
    <url>/135xyq.github.io/2022/01/06/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%AD%A6%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="软件工程经济学知识点总结"><a href="#软件工程经济学知识点总结" class="headerlink" title="软件工程经济学知识点总结"></a>软件工程经济学知识点总结</h1><p><a href="https://blog.csdn.net/qq_45808923/article/details/122382500">公式正常版</a></p>
<h2 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h2><ul>
<li>选择：20分</li>
<li>判断：20分</li>
<li>计算：20分</li>
<li>综合：25分</li>
<li>论述：15分</li>
</ul>
<h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><h3 id="工程经济性："><a href="#工程经济性：" class="headerlink" title="工程经济性："></a>工程经济性：</h3><p>生产性工程项目的直接目的是<strong>盈利</strong></p>
<p>非生产性工程项目的直接目的虽不是经济性的,但建设和运行中也必须重视成本。</p>
<p>一切工程都具有经济性。就工程与经济的关系而言,工程是手段,经济才是目的。</p>
<p>工程经济系统的载体——<strong>建设项目</strong></p>
<h3 id="工程管理"><a href="#工程管理" class="headerlink" title="工程管理"></a>工程管理</h3><p>是对一个工程从概念设想到正式运营的全过程（具体工作包括：投资机会研究、初步可行性研究、最终可行性研究、勘察设计、招标、采购、施工、试运行等）进行管理。</p>
<p>关注“工程—经济系统”的<strong>可持续性</strong>、<strong>可协调性</strong>、<strong>可补偿性</strong></p>
<h3 id="工程分析的基本方法"><a href="#工程分析的基本方法" class="headerlink" title="工程分析的基本方法"></a>工程分析的基本方法</h3><ol>
<li>费用效益分析法：通过项目的投入（即费用）和产出（即效益）的定量对比分析，考察工程项目的<br>费用、效益状况，研究建设项目的经济性。</li>
<li>费用效果分析法：耗费采用货币计量，效果采用非货币计量的定量分析方法 。</li>
<li>预测法：在科学地把握项目的发展规律基础上，描述项目未来建设和运营中的诸多经济要素，以及对相关主体带来的影响，预先度量项目的费用和效益或效果 </li>
<li>价值工程方法： 在剖析功能（效用）的基础上，追踪影响价值的功能，通过功能定义、分析、评 价，系统地认识功能结构，提示完善功能设计、降低费用和提高价值的途径。</li>
<li>系统分析法：对项目的考察不局限在一方面或几个方面，要做全面综合评价，进行系统分析。</li>
</ol>
<h3 id="工程分析的基本原则"><a href="#工程分析的基本原则" class="headerlink" title="工程分析的基本原则"></a>工程分析的基本原则</h3><h4 id="经济效益原则：基本原则"><a href="#经济效益原则：基本原则" class="headerlink" title="经济效益原则：基本原则"></a>经济效益原则：基本原则</h4><p>有用的产出与投入的对比关系</p>
<h5 id="经济效益是一个比较的概念"><a href="#经济效益是一个比较的概念" class="headerlink" title="经济效益是一个比较的概念"></a>经济效益是一个比较的概念</h5><ul>
<li>绝对量的比较 —— 净效益 = 效益 - 耗费</li>
<li>相对量的比较 —— 效益耗费比 = 效益/耗费</li>
<li>净效益耗费比 = 净效益/耗费 </li>
</ul>
<h5 id="经济效益分类"><a href="#经济效益分类" class="headerlink" title="经济效益分类"></a>经济效益分类</h5><ul>
<li>有形效益和无形效益</li>
<li>直接效益和相关效益</li>
<li>宏观效益和微观效益</li>
<li>短期效益和长期效益</li>
</ul>
<h4 id="可持续发展原则"><a href="#可持续发展原则" class="headerlink" title="可持续发展原则"></a>可持续发展原则</h4><ol>
<li>首先要注意资源的可持续利用</li>
<li>其次应注意项目和生态—社会系统的协调和优化</li>
<li>再次要在在长远和全局的角度来分析问题、研究问题</li>
</ol>
<h4 id="资源合理配置和有效使用原则"><a href="#资源合理配置和有效使用原则" class="headerlink" title="资源合理配置和有效使用原则"></a>资源合理配置和有效使用原则</h4><p>科学地、合理地 解决工程项目的“资源稀缺性”与人们日益增长的 需要之间的矛盾。</p>
<p>恰当遴选方案，慎重投资决策，努力实现资源的合理配置和有效使用，使资源的边际收益最大化和系统整体优化。</p>
<h2 id="第二章-资金的时间价值"><a href="#第二章-资金的时间价值" class="headerlink" title="第二章 资金的时间价值"></a>第二章 资金的时间价值</h2><h3 id="社会再生产过程"><a href="#社会再生产过程" class="headerlink" title="社会再生产过程"></a>社会再生产过程</h3><ul>
<li>购买阶段:货币(货币资本) -&gt; 劳动与生产资料(生产资本)</li>
<li>生产阶段:劳动与生产资料(生产资本) -&gt; 商品(商品资本)</li>
<li>销售阶段:商品(商品资本) -&gt; 货币(货币资本)</li>
</ul>
<h3 id="资金时间价值"><a href="#资金时间价值" class="headerlink" title="资金时间价值"></a>资金时间价值</h3><p>资金在社会再生产过程中随着时间推移而产生的<strong>增值</strong>叫资金的时间价值。</p>
<h4 id="资金时间价值的实质"><a href="#资金时间价值的实质" class="headerlink" title="资金时间价值的实质"></a>资金时间价值的实质</h4><p>劳动作用于生产资料创造的新价值，即生产阶段由于劳动的作用，使得商品资本超过生产资本的余额。</p>
<h4 id="资金时间价值的客观性"><a href="#资金时间价值的客观性" class="headerlink" title="资金时间价值的客观性"></a>资金时间价值的客观性</h4><p>资金时间价值产生于客观存在的社会再生产，是社会再生产规律的客观反映，因而具有客观性。</p>
<h3 id="单利和复利"><a href="#单利和复利" class="headerlink" title="单利和复利"></a>单利和复利</h3><h4 id="单利"><a href="#单利" class="headerlink" title="单利"></a>单利</h4><p>就是仅对初始本金计息，不对计算期内产生的利息计算利息的计息方法。</p>
<p>$$F = P(1+ni)$$</p>
<h4 id="复利"><a href="#复利" class="headerlink" title="复利"></a>复利</h4><p>在计息时不仅要考虑初始本金的利息，还要考虑期间所产生利息的利息。</p>
<p>$$F = P(1+i)^n$$</p>
<h3 id="资金的等值运算"><a href="#资金的等值运算" class="headerlink" title="资金的等值运算"></a>资金的等值运算</h3><ul>
<li><p>P:现值<br>绝对概念：0时点上的资金价值<br>相对概念：确定的某时点的之前任一时点的资金价值</p>
</li>
<li><p>F:终值<br>绝对概念：计算期期末的资金价值<br>相对概念：确定的某一时点之后任一时点的资金价值</p>
</li>
<li><p>A:年金<br>狭义：连续发生在每年年末且绝对数值相等的现金流序列<br>广义：连续地发生在每期期末且绝对数值相等的现金流序列</p>
</li>
<li><p>i:期利率</p>
</li>
<li></li>
<li><p>n:时间</p>
</li>
</ul>
<h4 id="一次支付终值公式"><a href="#一次支付终值公式" class="headerlink" title="一次支付终值公式"></a>一次支付终值公式</h4><p>条件：已知P、i、n,求终值F</p>
<p>$$F = P(1+i)^n = P(F/P,i,n)$$</p>
<p>$(1+i)^n$  为一次支付终值系数,$(F/P,i,n)$</p>
<h4 id="一次支付现值公式"><a href="#一次支付现值公式" class="headerlink" title="一次支付现值公式"></a>一次支付现值公式</h4><p>条件：已知F、i、n,求终值P</p>
<p>$$P = F(1+i)^{-n} = F(P/F,i,n)$$</p>
<p>$(1+i)^{-n}$  为一次支付现值系数,$(P/F,i,n)$</p>
<p>例：</p>
<blockquote>
<p>某公司测试工程师年工资总额按照15%的比例递增，8年后能确保工资总支出为1000万元，试计算现在工资总支出为多少？<br>    P＝1000（P／F，15%，8）<br>      ＝ 326.9（万元）</p>
</blockquote>
<h4 id="年金终值公式"><a href="#年金终值公式" class="headerlink" title="年金终值公式"></a>年金终值公式</h4><p>条件：已知A、i、n,求终值F</p>
<p>$F  = A + A(1+i) + A(1+i)^2 + ··· + A(1+i)^{n-2} + A(1+i)^{n-1}$<br>    $= A[a+(1+i) + (1+i)^2 + ··· + (1+i)^{n-1}]$<br>    $= A[(1+i)^{n - 1}] / i$<br>    $= A(F/A,i,n)$</p>
<p>$[(1+i)^{n - 1}] / i$ 为年金终值系数,$(F/A,i,n)$</p>
<p>例：</p>
<blockquote>
<p>某人从事软件开发工作，当年年初开始连续5年，每年缴纳72000元住房公积金，按规定在第七年末可一次提取公积金总额。若投资收益率为15%。问：此人到时可获得本利多少？<br>F＝72000（F／A，15%,5）（F／P，15%，2）<br>  ＝72000×6.7423×1.3225<br>  ＝64.2（万元）</p>
</blockquote>
<h4 id="偿债基金公式"><a href="#偿债基金公式" class="headerlink" title="偿债基金公式"></a>偿债基金公式</h4><p>条件：已知F、i、n，求年金A<br>与年金终值公式互为逆运算</p>
<p>$$ A = Fi / [(1+i)^n - 1] = F(A/F,i,n)$$</p>
<p>$i / [(1+i)^n - 1]$为债偿基金系数,$(A/F,i,n)$</p>
<h4 id="资金回收公式"><a href="#资金回收公式" class="headerlink" title="资金回收公式"></a>资金回收公式</h4><p>条件：已知P、i、n;求年金A</p>
<p>$ F = P(1+i)^n $<br>$ F = A[(1+i)^n - 1] / i$</p>
<p>$ P(1+i)^n  = A[(1+i)^n - 1] / i$<br>$ A = Pi(1+i)^n / [(1+i)^n - 1] = P(A/P,i,n)$</p>
<p>$i(1+i)^n / [(1+i)^n - 1]$为资金回收系数$(A/P,i,n)$</p>
<h4 id="年金现值公式"><a href="#年金现值公式" class="headerlink" title="年金现值公式"></a>年金现值公式</h4><p>条件：已知A、i、n;求现值P</p>
<p>$ F = P(1+i)^n $<br>$ F = A[(1+i)^n - 1] / i$</p>
<p>$ P(1+i)^n  = A[(1+i)^n - 1] / i$<br>$ P = A[(1+i)^n - 1] / [i(1+i)^n] = A(P/A,i,n)$</p>
<p>$ P = A[(1+i)^n - 1] / [i(1+i)^n] $为年金现值系数，$(P/A,i,n)$</p>
<p>例：</p>
<blockquote>
<p>在深圳买房按揭贷款600万元，按揭期间10年，按揭期间内等额偿还本息。若年利率8%，问每年应还款多少，每年偿还的利息是多少？<br>A＝P（A／P，i，n）<br>＝600×（A／P，8%，10）<br>＝89.4（万元）</p>
</blockquote>
<h5 id="永久年金"><a href="#永久年金" class="headerlink" title="永久年金"></a>永久年金</h5><p>当$n\rightarrow \infty$使，称为永久年金，<br>$$ P = A/i$$</p>
<blockquote>
<p>某人计划用购房的方式解决住房问题。房价50万元。某人只有12万元资金，余款需贷款解决，贷款年利率4%，在未来10年内等额偿还。若基准折现率5%，问某人购房总支出相当于现在一次性付款多少？<br>A＝P（A／P，i，n）<br>＝（50-12）×（A／P，4%，10）<br>＝4.68（万元）<br>P＝A/i<br>  ＝4.68÷5%<br>  ＝93.6（万元）</p>
</blockquote>
<h3 id="名义利率和实际利率"><a href="#名义利率和实际利率" class="headerlink" title="名义利率和实际利率"></a>名义利率和实际利率</h3><h4 id="名义利率"><a href="#名义利率" class="headerlink" title="名义利率"></a>名义利率</h4><p>年利率为r，一年计息m次，当m≠1时，称r为名义利率。<br>所谓名义利率即非实际计息的利率。</p>
<h4 id="实际利率"><a href="#实际利率" class="headerlink" title="实际利率"></a>实际利率</h4><p>期利率为$r/m$。对资金计息不以r为利率标准，而在每个计息期间却以$r/m$为利率标准计息。<br>实际利率即实际上以年为计息周期的利率</p>
<p>$$i = (1＋r/m)^m－1$$</p>
<h2 id="第三章-建设项目评价的基本经济要素"><a href="#第三章-建设项目评价的基本经济要素" class="headerlink" title="第三章 建设项目评价的基本经济要素"></a>第三章 建设项目评价的基本经济要素</h2><h3 id="投资"><a href="#投资" class="headerlink" title="投资"></a>投资</h3><ul>
<li>名词角度解释：投资就是为了获得未来期望收益而预先垫付的资本。</li>
<li>动词角度解释：是维持建设项目存在的基础。通过投资为项目经济性运营—生产经营—搭建平台，以支撑其作为投资者及其他相关各方获益方式的存在。在项目的存续期间，资本一直存在于项目中。项目终结时，被投资者回收。</li>
</ul>
<p><strong>投资是被项目占用的资源。</strong></p>
<h4 id="投资分类"><a href="#投资分类" class="headerlink" title="投资分类"></a>投资分类</h4><ol>
<li>直接投资和间接投资</li>
<li>短期投资和长期投资</li>
<li>初创投资和后续投资</li>
</ol>
<h5 id="直接投资和间接投资"><a href="#直接投资和间接投资" class="headerlink" title="直接投资和间接投资"></a>直接投资和间接投资</h5><ul>
<li>直接投资:用于经营性资产——建设项目的投资，以期通过投资人对资产运营管理而获利。</li>
<li>间接投资:又称证券投资，是指用于金融资产的 投资，以期通过对金融产品的操作而获益。</li>
</ul>
<h5 id="短期投资和长期投资"><a href="#短期投资和长期投资" class="headerlink" title="短期投资和长期投资"></a>短期投资和长期投资</h5><ul>
<li>短期投资:能够随时变现、持有时间不超过一年的投资。主要指对现金、应收账款、存货、短期 有价证券等的投资，长期有价证券如能随时变现 亦可用于短期投资。</li>
<li>长期投资:不可能或不准备在一年内变现的投资，主要指对厂房、机器设备等固定资产和对专 利权、商标权等无形资产的投资，也包括股权投 资、债券投资和其他投资。</li>
</ul>
<h4 id="建设项目投资构成"><a href="#建设项目投资构成" class="headerlink" title="建设项目投资构成"></a>建设项目投资构成</h4><p><img src="https://img-blog.csdnimg.cn/b100a93872354de39d5f51a7cdf2c3ac.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA562xLi4=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/e3212e7b047144bea8175aa83882c4cb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA562xLi4=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h5 id="固定资产"><a href="#固定资产" class="headerlink" title="固定资产"></a>固定资产</h5><p>固定资产是项目赖以运营获利的基本条件。其在使用过程中因磨损而性能不断劣化，价值量逐渐贬损。为维持项目的基本生产运营——获利条件，在项目投产运营后用折旧的方式对其贬值的价值量予以弥补。**<strong>在项目终了时，固定资产的残值被回收。</strong></p>
<p><strong>固定资产原值=固定资产净值+固定资产折旧</strong></p>
<h5 id="流动资金"><a href="#流动资金" class="headerlink" title="流动资金"></a>流动资金</h5><p>流动资金是指项目投产运营后，为维持项目正常生产运营所占用的全部周转资金。它是在生产期 内为了保持生产经营的永续性和连续状态而垫付的资金。<br>流动资金在生产经营期间被项目长期占用，在<strong>项目终了时被全额回收。</strong></p>
<h3 id="折旧和摊销"><a href="#折旧和摊销" class="headerlink" title="折旧和摊销"></a>折旧和摊销</h3><p>折旧（摊销）是固定（其他）资产价值磨损的<strong>补偿金</strong>。</p>
<p>将固定（其他）资产因磨损而失去的价值逐渐转移到产品成本中去，而后再从产品销售收入中回收的财务处理方法。这种通过计入产品成本而回收的资产的转移价值称为折旧费。</p>
<h4 id="线性折旧法"><a href="#线性折旧法" class="headerlink" title="线性折旧法"></a>线性折旧法</h4><p>各期提的折旧额是相等的，是一种平均计算方法。</p>
<h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><ol>
<li>平均年限法</li>
<li>工作量法</li>
</ol>
<h5 id="平均年限法"><a href="#平均年限法" class="headerlink" title="平均年限法"></a>平均年限法</h5><p>$$ D = K_0R$$<br>$$ R = (1 - f_s) / N$$</p>
<p>$D$—年折旧额，$K_0$—原值，$R$—折旧率，$f_s$—净残值率，$N$—折旧年限</p>
<h5 id="工作量法"><a href="#工作量法" class="headerlink" title="工作量法"></a>工作量法</h5><p>$$ D = SR$$<br>$$R＝K_0（1 - f_s）/ S $$</p>
<p>$S$-工作量，$D$—年折旧额，$K_0$—原值，$R$—折旧率，$f_s$—净残值率，</p>
<p>例：</p>
<blockquote>
<p>机房服务器原值120万元，折旧年限20 年。预计净残值为4.8万元，试计算该设备年、月折旧额。<br>R =（1－fs）/T<br>  =（1-4.8/120）/20<br>D = K0<em>R<br>  = 120</em>（1-4.8/120）/20</p>
</blockquote>
<h3 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h3><p><strong>成本反映了项目对劳动的消耗</strong></p>
<p>成本是为了获得未来收益而付出的代价。<br>是指以货币形式表现的消耗在产品（服务）中的<strong>物化劳动价值</strong>和<strong>活劳动价值</strong>之和。<br>成本是使产品（服务）得以实现而消耗的生产力要素。所以成本必须在商品销售中得到补偿，得以维持再生产过程 。</p>
<h4 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h4><h5 id="1-要素成本"><a href="#1-要素成本" class="headerlink" title="1. 要素成本"></a>1. 要素成本</h5><ul>
<li>外购原材料</li>
<li>外购燃料、动力</li>
<li>工资及福利</li>
<li>固定资产折旧</li>
<li>修理费</li>
<li>无形资产及其他资产摊销</li>
<li>利息支出</li>
<li>其他费用</li>
</ul>
<h5 id="2-经营成本"><a href="#2-经营成本" class="headerlink" title="2. 经营成本"></a>2. 经营成本</h5><p>经营成本是<strong>付现</strong>的成本。</p>
<p>非现金支出的项目不包含在经营成本中。</p>
<p>经营成本 = 总成本 - 折旧费 - 摊销费 - 财务费用<br>或<br>经营成本 = 外购原材料、燃料、动力费 + 工资及福利 + 修理费 + 其他费用</p>
<h5 id="3-机会成本"><a href="#3-机会成本" class="headerlink" title="3. 机会成本"></a>3. 机会成本</h5><p>又称择一成本，择机代价。是指在经济决策过程中，因选择某一方案而放弃其余方案所付出的代价或丧失的潜在利益。</p>
<p>机会成本的概念确立在资源稀缺性基本原理的框架下。基于资源的稀缺性，项目或企业中的某种资源常常有多种用途，即有多种使用的“机会”。而任何一个投放机会的选定必然意味着其他所有机会即被放弃，并因而放弃与之相伴的潜在收益。那么在该选定机会上的所付出的代价，即机会成本，就是诸多其他投资机会中可能收益的最大值——最佳替代用途价值。</p>
<h5 id="4-沉没成本"><a href="#4-沉没成本" class="headerlink" title="4. 沉没成本"></a>4. 沉没成本</h5><p>沉没成本是发生在<strong>决策之前</strong>，与决策问题无关的费用</p>
<p>沉没成本发生在决策以前，是决策事项的历史成本，不论对目前的决策事项做何抉择，它都是一笔“已然”状态的支出，因而对目前的决策不构成影响。所以在进行方案优选时，对沉没成本不予考虑。</p>
<h3 id="税收及分类"><a href="#税收及分类" class="headerlink" title="税收及分类"></a>税收及分类</h3><h4 id="分类-2"><a href="#分类-2" class="headerlink" title="分类"></a>分类</h4><ol>
<li>关税</li>
<li>增值税</li>
<li>营业税</li>
<li>流转税附加</li>
<li>消费税</li>
<li>资源税</li>
<li>企业所得税</li>
</ol>
<h5 id="增值税"><a href="#增值税" class="headerlink" title="增值税"></a>增值税</h5><p>增值税是指以应税产品所增加的价值，即增值额为征税对象的一种税。增值额就是一个生产环节的销售收入额，扣除同期消耗了的外购原材料、燃料动力和计入成本的包装物金额后的数额。<br>增值税纳税主体是在我国境内销售货物或者提供加工修理修配劳务以及进口货物的单位和个人。<br>增值税实行价外征收，根据发票注明税金进行税款抵扣的制度。即</p>
<p>增值税额 = 销项税额 - 进项税额 = 销售额（不含税）× 增值税率－进项额（不含税）× 增值税率</p>
<p>例： </p>
<blockquote>
<p>某项目年产电子产品2.3万件，销售价格为15400元，外购原材料15748万元m，燃料动力为2052万元。产品征收增值税，税率为17%。问：该项目每年缴纳的增值税金为多少？<br>销项税 = 销售额（不含税）×增值税率<br>        =[销售额（含税）/（1+增值税率）]×增值税率<br>        =[2.3×15400（1+17%）]×17%<br>        =5146.5万元<br>进项税=进项额（不含税）×增值税率<br>        =[进项额（含税）/（1+增值税率）]×增值税率<br>        =[（15748+2052/（1+17%）]×17%<br>        =2586.32万元<br>增值税 = 销项税 - 进项税<br> = 5146.5 - 2586.32<br> = 2560.18 万元</p>
</blockquote>
<h5 id="企业所得税"><a href="#企业所得税" class="headerlink" title="企业所得税"></a>企业所得税</h5><p>企业所得税是对在我国境内的企业和其他取得收入组织的应税所得开征的一个税种。<br>在境内的企业和其他取得应税收入的组织，不论出资人国籍身份、企业形态统一适用《企业所得税法》。个人独资企业、合伙企业不适用本法。<br>企业所得税的税率为25％</p>
<p>企业所得税 = (营业收入 - 总成本 - 营业税金 - 前一季度亏损) × 所得税税率</p>
<h3 id="利润"><a href="#利润" class="headerlink" title="利润"></a>利润</h3><p>利润是反映劳动净成果的效益类指标，包括营业利润、投资净收益以及营业外收支净额。</p>
<p>营业利润=营业收入－总成本－营业税及附加</p>
<p>投资净收益是投资收益扣除投资损失后的余额。</p>
<p>营业外收支净额指营业外收入减去营业外支出后的数额。</p>
<p>利润总额＝营业利润＋投资净收益＋营业外收支净额</p>
<p>净利润＝利润总额－所得税</p>
<h2 id="第四章-建设项目的经济性评价指标体系"><a href="#第四章-建设项目的经济性评价指标体系" class="headerlink" title="第四章 建设项目的经济性评价指标体系"></a>第四章 建设项目的经济性评价指标体系</h2><p>建设项目的经济性评价指标体系——能够客观衡量项目经济效益状况的标尺。</p>
<ul>
<li>盈利能力指标：净现值、内部收益率、投资 回收期等</li>
<li>偿债能力指标：利息备付率、偿债备付率等</li>
<li>财务生存（可持续）能力指标：项目投资计划累计净现金流量</li>
</ul>
<h3 id="评价指标按经济性质可以分为"><a href="#评价指标按经济性质可以分为" class="headerlink" title="评价指标按经济性质可以分为"></a>评价指标按经济性质可以分为</h3><ol>
<li>时间型指标：投资回收期、借款偿还期</li>
<li>价值型指标：净现值、净年值等</li>
<li>效率型指标： 内部收益率、净现值率、投资收益率、资本金利润率等</li>
</ol>
<h4 id="投资会回收期"><a href="#投资会回收期" class="headerlink" title="投资会回收期"></a>投资会回收期</h4><p>投资回收期，也称<strong>返本期</strong>，是从项目投资开始（第0年）算起，用项目投产后的收益回收全部投资所需的时间长度。一般以年为单位计</p>
<h5 id="静态投资回收期"><a href="#静态投资回收期" class="headerlink" title="静态投资回收期"></a>静态投资回收期</h5><p>不考虑资金的时间价值因素的投资回收期。</p>
<p>$P_t$ — 投资回收期<br>$CI$  —现金流入量<br>$CO$  —现金流出量<br>$(CI - CO)_t$  —第t年的净现金流量<br>$T$   —累积净现金流量首次为非负值所对应的年份</p>
<p>$$\sum_{t=0}^{P_t}(CI - CO)_t = 0$$</p>
<p>$$P_t = T - 1 +  \frac{第(T - 1)年净现金流累计值的绝对值}{第T年的现金流}$$</p>
<p>如果投资在期初一次投入，且每年的净收益固定不变，则可表示为：</p>
<p>$$ P_t = \frac{K}{R}$$</p>
<p>$K$ —投资总额<br>$R$ —年收益</p>
<h5 id="动态投资回收期"><a href="#动态投资回收期" class="headerlink" title="动态投资回收期"></a>动态投资回收期</h5><p>考虑资金时间价值因素的投资回收期。</p>
<p>$NCF_t$ —第t年的净现金流量<br>$T$   —累积净现金流量现值首次为非负值所对应的年份</p>
<p>$$\sum_{t=0}^{P_t}NCF_t(1+i_c)^{-t} = 0 $$</p>
<p>$$P_t = T - 1 +  \frac{第(T - 1)年净现金流现值累计值的绝对值}{第T年的现金流的现值}$$</p>
<p>例：</p>
<blockquote>
<p>某方案的年净现金流如下表，已知基准折现率为10%，试求方案的投资回收期。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">年份</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
</tr>
</thead>
<tbody><tr>
<td align="center">NCF</td>
<td align="center">-100</td>
<td align="center">20</td>
<td align="center">30</td>
<td align="center">60</td>
<td align="center">60</td>
<td align="center">60</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">年份</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
</tr>
</thead>
<tbody><tr>
<td align="center">NCF</td>
<td align="center">-100</td>
<td align="center">20</td>
<td align="center">30</td>
<td align="center">60</td>
<td align="center">60</td>
<td align="center">60</td>
</tr>
<tr>
<td align="center">NCF累计</td>
<td align="center">-100</td>
<td align="center">-80</td>
<td align="center">-50</td>
<td align="center">10</td>
<td align="center">70</td>
<td align="center">130</td>
</tr>
<tr>
<td align="center">NCF折现</td>
<td align="center">-100</td>
<td align="center">18.18</td>
<td align="center">24.79</td>
<td align="center">45.08</td>
<td align="center">40.98</td>
<td align="center">37.26</td>
</tr>
<tr>
<td align="center">折现累计</td>
<td align="center">-100</td>
<td align="center">-81.82</td>
<td align="center">-57.02</td>
<td align="center">-11.95</td>
<td align="center">29.03</td>
<td align="center">66.29</td>
</tr>
</tbody></table>
<p>静态投资回收期：Pt =4-1+50/60=3.8（年）<br>动态投资回收期：Pt =5-1+11.95/40.98=4.29（年）</p>
<h5 id="投资回收期的评价"><a href="#投资回收期的评价" class="headerlink" title="投资回收期的评价"></a>投资回收期的评价</h5><ul>
<li>优点：概念明确,简单易算；既反映方案的盈利性又反映方案的风险。</li>
<li>缺点：它只反映了项目投资回收前的盈利情况，而不能反映投资回收后的盈利情况，因而对项目在整个寿命期内的经济效益反映是不全面的。</li>
</ul>
<p>因此，投资回收期通常不能独立判断项目是否可行。目前在项目评价中不再作为主要指标使用。</p>
<h4 id="净现值"><a href="#净现值" class="headerlink" title="净现值"></a>净现值</h4><p>净现值（Net Present Value，简计为NPV）是指建设项目在整个寿命期内，各年的净现金流按既定的折现率折算到计算期初的现值之和。</p>
<p>净现值是考察建设项目在其计算期内盈利能力的主要动态评价指标。其一般表达式为：</p>
<p>$$NPV = \sum_{t=0}^{n}NCF_t(P / F ,i_c,t)$$</p>
<p>$NCF_t$  —第t年的净现金流量<br>$i_c$    —既定的折现率<br>$n$      —项目计算期</p>
<p>评价建设项目的经济可行性，评价标准为：$NPV &gt;= 0$</p>
<h5 id="净现值函数"><a href="#净现值函数" class="headerlink" title="净现值函数"></a>净现值函数</h5><p>用来表示净现值与折现率之间变化关系的函数。对于既定的项目实施方案，NPV随着i的变化表现出某种变化规律。<br>一般随着i的增加，NPV逐渐变，NPV=f（i）呈减函数变化趋势</p>
<p>例：</p>
<blockquote>
<p>某项目的年净现金流入下表，若基准折现率为10% ，评价项目。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">年份</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
</tr>
</thead>
<tbody><tr>
<td align="center">NCF</td>
<td align="center">-1000</td>
<td align="center">200</td>
<td align="center">300</td>
<td align="center">300</td>
<td align="center">300</td>
</tr>
</tbody></table>
<p>NPV=-127.23<br>由于NPV＜0，所以，该项目不可行</p>
<h5 id="净现值的评价"><a href="#净现值的评价" class="headerlink" title="净现值的评价"></a>净现值的评价</h5><ul>
<li>优点：计算简便；计算结果稳定，不会因算术方法的不同而带来任何差异；考虑了资金时间价值并全面考虑了项目在整个寿命期内的经济状况；直接以货币量表示项目的净收益，经济意义明确直观。</li>
<li>缺点：一是只反映资金的总量使用效果，而不反映资金的使用效率。在一些类别的项目评价时，比如金融资产投资项目，可能更需要关注资金的报酬率。此时净现值因无法评定可接受的备选项目的报酬率高低；二是必须预先设定一个较符合经济现实的基准收益率。而基准收益率的确定是一个比较复杂困难的问题。</li>
</ul>
<h4 id="内部收益率"><a href="#内部收益率" class="headerlink" title="内部收益率"></a>内部收益率</h4><p>内部收益率（Internal Rate of Return，简计为IRR）<br>使得项目计算期内各年净现金流量的现值累计值，即净现值等于零时的折现率。</p>
<p>$$\sum_{t=0}^{n}NCF_t(1 + IRR)^{-t} = 0 $$</p>
<p><img src="https://img-blog.csdnimg.cn/1564ebdc60f647828a6d17bc74bd2b1f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA562xLi4=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p>$$IRR = i_1 + \frac{NPV_1}{NPV_1 + | NPV_2 |}(i_2 - i_1)$$</p>
<p>注意：**$i_2 - i_1 &lt; 5% $,且 $NPV_1 &gt; 0,NPV_2 &lt; 0$**  </p>
<p>内部收益率表示方案存在于项目中的投资<br>（未被回收的投资）可以实现的盈利（收益）能力。</p>
<h5 id="评价标准"><a href="#评价标准" class="headerlink" title="评价标准"></a>评价标准</h5><p>$$IRR \ge i_c$$</p>
<h5 id="内部收益率的评价"><a href="#内部收益率的评价" class="headerlink" title="内部收益率的评价"></a>内部收益率的评价</h5><ul>
<li>优点：其大小完全取决于项目本身的现金流大小及分布，不受外界因素干预，客观真实地反映了 方案的经济性；</li>
<li>缺点：计算较烦琐，并且对于非常规项目，净现值方程会出现多解或无解的情形，从而可能使内 部收益率指标失效；内部收益率只反映项目占用资金的使用效率，而不能反映其总量使用效果。</li>
</ul>
<h4 id="利息备付率"><a href="#利息备付率" class="headerlink" title="利息备付率"></a>利息备付率</h4><p>利息备付率也称已获利息倍数，是指项目在借款偿还期内各年可用于支付利息的息税前利润与当 期应付利息费用的比值</p>
<p>$$ICR = \frac{EBIT}{PI}$$</p>
<p>$ICR$   —利息备付率<br>$PI$    —计入成本的应付利息<br>$EBIT$  —息税前利润</p>
<p>$$ EBIT = 净利润 + 计入成本的利息 + 所得税税金  = 毛利润 + 计入成本的利息$$</p>
<p>利息备付率从付息资金来源的充裕性角度反映项目<strong>偿付债务利息</strong>的保障程度。</p>
<p>理论上讲，利息备付率应<strong>大于2</strong>。工程经济分析中，应结合债权人要求确定其具体评价标准。</p>
<h4 id="偿债备付率（DSCR）"><a href="#偿债备付率（DSCR）" class="headerlink" title="偿债备付率（DSCR）"></a>偿债备付率（DSCR）</h4><p>偿债备付率是指借款偿还期内，各年可用于还本付息的资金与当年应还本付息额的比值</p>
<p>$$DSCR = \frac{EBITAD - T_{AX}}{PD}$$</p>
<p>$DESCR$    —偿债备付率<br>$EBITAD$   —息税前折旧摊销前利润<br>$T_{AX}$   —企业所得税额<br>$PD$       —应还本付息金额</p>
<p>$$EBITAD = 息税前金额 + 折旧 + 摊销$$</p>
<p>偿债备付率表示用于还本付息的资金偿还债务资金本息的保障程度。</p>
<p>理论上：$DSCR  &gt; 1$, 实际上：$DSCR \ge 1.3$</p>
<h2 id="第六章-建设项目融资"><a href="#第六章-建设项目融资" class="headerlink" title="第六章 建设项目融资"></a>第六章 建设项目融资</h2><h3 id="融资总体"><a href="#融资总体" class="headerlink" title="融资总体"></a>融资总体</h3><p>所谓融资主体，是指以其名义进行资金的融通活动、并由其对融资行为承担相应责任的当事人。</p>
<p>建设项目融资主体主要有<strong>既有企业法人融资主体</strong>和<strong>新设项目法人融资主体</strong>。</p>
<h4 id="既有企业法人融资"><a href="#既有企业法人融资" class="headerlink" title="既有企业法人融资"></a>既有企业法人融资</h4><p>以下情况应该使用：</p>
<ol>
<li>既有法人经济实力较为雄厚，具有很好的承担全部融资责任的实力。</li>
<li>新建项目与既有企业的资产和经营活动密切联系。</li>
<li>项目自身盈利能力较差，但项目建设和存续对企业整体的持续发展具有重要作用。</li>
</ol>
<h4 id="新设项目法人融资"><a href="#新设项目法人融资" class="headerlink" title="新设项目法人融资"></a>新设项目法人融资</h4><p>新设项目法人融资是指新设项目法人为项目的建设进行融资、并承担融资责任和风险的融资活动。</p>
<p>新设法人融资是以新组建的具有独立法人资格的项目公司为融资主体的资金筹措活动。采用新设项目法人融资方式的建设项目，项目法人大多是<strong>企业法人</strong>，这类项目一般为新建项目，也可以是将既有企业法人的一部分资产剥离出去后重新组建的新的项目法人的改扩建项目。</p>
<h3 id="资金来源"><a href="#资金来源" class="headerlink" title="资金来源"></a>资金来源</h3><p>$$建设项目资金来源渠道<br>\begin{cases}<br>国内资金<br>\begin{cases}<br>财政资金<br>\begin{cases}<br>财政预算内资金 \<br>财政预算外资金<br>\end{cases}<br>\ \ \金融机构信贷资金<br>\begin{cases}<br>政策性银行信贷资金\<br>商业性银行信贷资金 \<br>非银行金融机构资金<br>\end{cases}<br>\ \ \ 其他资金<br>\begin{cases}<br>其他单位资金 \<br>居民个人资金 \<br>企业内部自由资金<br>财政预算外资金<br>\end{cases}<br>\end{cases}<br>\ \ \国外资金<br>\begin{cases}<br>政府资金<br>\begin{cases}<br>政府财政资金 \<br>出口信贷资金<br>\end{cases}<br>\ \ \金融机构或组织资金<br>\begin{cases}<br>世界银行等国际金融组织资金 \<br>外国商业银行资金 \<br>国外非银行金融机构资金<br>\end{cases}<br>\ \ \国外其他资金<br>\begin{cases}<br>企业资金 \<br>居民资金<br>\end{cases}<br>\end{cases}<br>\end{cases}$$</p>
<h3 id="资本金制度"><a href="#资本金制度" class="headerlink" title="资本金制度"></a>资本金制度</h3><p>资本金是指在项目总投资中，由投资者认缴的出资额。对于建设项目来说是非债务性资金，项目法人不承担这部分资金的任何利息和债务；投资者可按其出资的比例依法享有所有者权益，也可转让其出资及其相应权益，但不得以任何方式抽回。</p>
<h4 id="资本金出资方式："><a href="#资本金出资方式：" class="headerlink" title="资本金出资方式："></a>资本金出资方式：</h4><p>货币出资，实物、工业产权、 非专利技术、土地使用权作价出资。对作为资本金 的实物、工业产权、非专利技术、土地使用权，必 须经过有资格的资产评估机构依照法律、法规评估 作价，不得高估或低估。以工业产权、非专利技术 作价出资的比例不得超过投资项目资本金总额的 20%，国家对采用高新技术成果有特别规定的除 外。</p>
<h4 id="资本金占项目总投资比例"><a href="#资本金占项目总投资比例" class="headerlink" title="资本金占项目总投资比例"></a>资本金占项目总投资比例</h4><table>
<thead>
<tr>
<th align="center">投资行业</th>
<th align="center">占比</th>
</tr>
</thead>
<tbody><tr>
<td align="center">交通运输、煤炭项目</td>
<td align="center">35%及以上</td>
</tr>
<tr>
<td align="center">钢铁、邮电、化肥项目</td>
<td align="center">25%及以上</td>
</tr>
<tr>
<td align="center">电力、机电、建材、化工、石油加工、有色、轻工、纺织、商贸及其他行业的项目</td>
<td align="center">20%及以上</td>
</tr>
</tbody></table>
<h4 id="资金的筹集方式"><a href="#资金的筹集方式" class="headerlink" title="资金的筹集方式"></a>资金的筹集方式</h4><p>$$资金筹集方式<br>\begin{cases}<br>资本金的筹集方式<br>\begin{cases}<br>吸收直接投资<br>\begin{cases}<br>国家资本金 \ \<br>法人资本金 \ \<br>个人资本金 \ \<br>外商资本金<br>\end{cases}<br>\ \ \发行股票<br>\begin{cases}<br>优先股 \ \<br>普通股<br>\end{cases}<br>\ \ \ 发行可转换公司债券<br>\end{cases}<br>\ \ \债务资金的筹集方式<br>\begin{cases}<br>银行贷款<br>\begin{cases}<br>商业性银行贷款 \ \<br>政策性银行贷款（国家开发银行、中国进出口银行、中国农业发展银行）<br>\end{cases}<br>\ \ \ 发行债券<br>\ \  \金融租赁<br>\ \ \ 国外债务融资<br>\begin{cases}<br>国际商业银行贷款 \<br>外国政府贷款 \<br>国际金融机构贷款<br>\end{cases}<br>\ \ \ 出口信贷<br>\ \ \国际债券<br>\end{cases}<br>\end{cases}<br>$$</p>
<h5 id="吸收直接投资"><a href="#吸收直接投资" class="headerlink" title="吸收直接投资"></a>吸收直接投资</h5><p>吸收直接投资是指建设项目按照“共同投资、共同经营、共担风险、共享利润”的原则，直接吸收国家、法人、个人和外商投入资本的一种资本金筹集方式。</p>
<h6 id="国家资本金"><a href="#国家资本金" class="headerlink" title="国家资本金"></a>国家资本金</h6><p>国家资本金是指有权代表国家部门或者机构用预算内资金、各类专项建设基金投入建设项目形成的资本金 。<br>特点：产权归国家所有；资金运用和处置受国家严格控制；在国有建设项目中被普遍采用。</p>
<h6 id="法人资本金"><a href="#法人资本金" class="headerlink" title="法人资本金"></a>法人资本金</h6><p>法人资本金是指由企业法人以其可以支配的法人资产投入建设项目形成的资本金 。<br>特点：发生在企业法人之间、以参与利润分配为目的，灵活多样的出资形式。</p>
<h5 id="发行股票"><a href="#发行股票" class="headerlink" title="发行股票"></a>发行股票</h5><h6 id="优先股"><a href="#优先股" class="headerlink" title="优先股"></a>优先股</h6><p>是一种兼具资本金和债务资金特点的有价证券。优先股是相对于普通股而言的。主要指在利润分红及剩余财产分配的权利方面，优先于普通股。</p>
<p>特征：</p>
<ol>
<li>股息率事先固定，不参与公司的分红，但可以先于普通股获得股息。</li>
<li>优先股的权利范围小。优先股股东一般没有选举权和被选举权，对股份公司的重大经营<strong>无投票权</strong>，但在某些情况下可以享有投票权。</li>
<li>如果公司破产清算，优先股的索偿权先于普通股，而次于债权人。</li>
</ol>
<p>发行目的：<br>帮助公司渡过财务难关，增加公司资产又不影响普通股股东的控制权。融资方案分析和财务分析中应视为项目资本金。</p>
<h6 id="普通股"><a href="#普通股" class="headerlink" title="普通股"></a>普通股</h6><p>是随着企业利润变动而变动的一种股份。</p>
<p>特征：</p>
<ol>
<li>股息和分红由公司的经营业绩来确定。</li>
<li>如果公司破产清算，普通股在债权人、优先股股东之后分得公司的剩余财产。</li>
</ol>
<h5 id="可转换债券"><a href="#可转换债券" class="headerlink" title="可转换债券"></a>可转换债券</h5><p>可转换公司债券（convertible bonds）是指根据发行公司债募集办法的规定，债券持有人可将其转换为发行公司的股票。债券持有人有权选择是否将其所持债券转换为股票。</p>
<h6 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h6><p><strong>筹资灵活</strong>，既可为投资者增加灵活的投资机会，<strong>资金成本低</strong>，可为发行公司调整资本结构或减缓财务压力提供便利。可转换债券兼有债权性、股权性和可转换性的特征，持有人享有其他债券持有人不享有的转股权。筹资效率高，<strong>可转换债券的利息进入运营成本，在所得税前列支</strong>。在工程经济分析中，可转换债券一般作为项目债务资金处理</p>
<h5 id="资本金融资的特点"><a href="#资本金融资的特点" class="headerlink" title="资本金融资的特点"></a>资本金融资的特点</h5><ol>
<li>所筹资金是项目的权益资本，是其他方式筹资的基础，可增强融资主体的信用基础和举债能力。</li>
<li>没有到期偿还等财务问题，融资的财务风险较低。</li>
<li>不具有抵税功效，资金成本较高。</li>
<li>上市公开发行股票，必须公开披露信息，接受投资者和社会公众的监督。</li>
</ol>
<h5 id="银行贷款"><a href="#银行贷款" class="headerlink" title="银行贷款"></a>银行贷款</h5><p>政策性银行有：国家开发银行、中国进出口银行、中国农业发展银行</p>
<h5 id="发行债券"><a href="#发行债券" class="headerlink" title="发行债券"></a>发行债券</h5><p>债券投资者是企业的债权人，不是所有者，无权参与或干涉企业经营管理，但有权按期收回本息。</p>
<h5 id="融资租赁"><a href="#融资租赁" class="headerlink" title="融资租赁"></a>融资租赁</h5><p>它是指<strong>出租人</strong>作为<strong>买受人</strong>与<strong>出卖人</strong>订立买卖合同，购买承租人<strong>指定</strong>的租赁物，并提供给<strong>承租人</strong>使用、收益的租赁方式。融资租赁是一种融资和融物相结合，通过融物达到融资目的的有效手段。</p>
<h5 id="债务资金融资特点："><a href="#债务资金融资特点：" class="headerlink" title="债务资金融资特点："></a>债务资金融资特点：</h5><ol>
<li>是项目的债务资本，到期偿还，融资财务风险较高。</li>
<li>资金成本税前列支，具有抵税作用，资金成本较低。</li>
<li>融资渠道广泛，融资方式多样化</li>
</ol>
<h3 id="新型项目融资模式"><a href="#新型项目融资模式" class="headerlink" title="新型项目融资模式"></a>新型项目融资模式</h3><h4 id="BOT项目融资模式"><a href="#BOT项目融资模式" class="headerlink" title="BOT项目融资模式"></a>BOT项目融资模式</h4><p>BOT模式是国际上近十几年来逐渐兴起的一种基础设施建设的融资模式,是一种利用外资和民营资本兴建基础设施的新兴融资 模式。BOT是Build(建设)-Operate(经营)-Transfer(转让)的缩写, 代表一个完整的项目融资过程。</p>
<h4 id="ABS项目融资模式"><a href="#ABS项目融资模式" class="headerlink" title="ABS项目融资模式"></a>ABS项目融资模式</h4><p>“资产支持证券化”融资模式，是指以目标项目所拥有的资产为基础，以该项目资产的未来预期收益为保证，在资本市场上发行高级债券来筹集资金的的一种融资方式。</p>
<h4 id="PPP项目融资模式"><a href="#PPP项目融资模式" class="headerlink" title="PPP项目融资模式"></a>PPP项目融资模式</h4><p>公共部门与私人企业合作。是指政府、私人营利性企业和非营利性企业基于某个项 目而形成的相互合作关系的形式。</p>
<h4 id="产品支付项目融资模式"><a href="#产品支付项目融资模式" class="headerlink" title="产品支付项目融资模式"></a>产品支付项目融资模式</h4><p>国际贷款人在 提供项目贷款后，将根据项目融资文件直接取得一定比例的项 目产品或该部分产品，并以此进行偿本付息的项目融资方式。贷款偿还前，贷款方拥有项目的部分或全部产品，借款方清偿 债务时把贷款方的贷款看做这些产品销售收入折现后的净值。</p>
<h3 id="资金成本"><a href="#资金成本" class="headerlink" title="资金成本"></a>资金成本</h3><p>资金成本（Cost of Capital）就是企业为筹措和使用资金而付出的代价。</p>
<p>资金成本内容包括<strong>用资费用</strong>和<strong>筹资费用</strong>两部分：<br>用资费用：指企业在投资和经营过程中因获得资金的使用和收益权而付出的费用。如股利、利息等。<br>筹资费用：指企业在筹措资金过程中而付出的费用。如银行借款手续费。</p>
<h4 id="资金成本作用"><a href="#资金成本作用" class="headerlink" title="资金成本作用"></a>资金成本作用</h4><ol>
<li>资金成本是比较筹资方式的依据。</li>
<li>资金成本是评价和选择投资项目的重要标准。</li>
<li>资金成本是进行<strong>资金结构决策</strong>的依据。</li>
</ol>
<h5 id="资本金资本成本"><a href="#资本金资本成本" class="headerlink" title="资本金资本成本"></a>资本金资本成本</h5><h6 id="优先股资金成本"><a href="#优先股资金成本" class="headerlink" title="优先股资金成本"></a>优先股资金成本</h6><p>$K_p$ ——优先股成本；<br>$D_p$ ——优先股年股利，按票面价格计算；<br>$P_0$ ——优先股筹资额，按发行价格计算；<br>$f$ ——优先股筹资费用率。</p>
<p>$$K_p = \frac{D_p}{S_p(1- f)}$$</p>
<p>例：</p>
<blockquote>
<p>某互联网公司上市发行优先股股票，总面值100万元，发行总价为150万元，筹资费率为4％，<br>股息年利率为12％，试确定该优先股的资金成本。</p>
</blockquote>
<p>$$K_p =  \frac{D_p}{S_p(1- f)} = \frac{100 \times 12%}{150 \times (1-4%)} = 8.33%$$</p>
<h6 id="债务资金成本"><a href="#债务资金成本" class="headerlink" title="债务资金成本"></a>债务资金成本</h6><p>债券资金成本中的利息在税前支付，具有抵税效应。债券的筹资费用一般较高，这类费用主要包括申请发行债券的手续费、债券注册费、印刷费、上市费以及摊销费用等。</p>
<p>$K_h$  ——债券资金成本；<br>$B_0$  ——债券的筹资额，以发行价格计算；<br>$I$   ——债券年利息额，以票面价格计算<br>$T$   ——项目主体所得税税率<br>$f$ ——筹资费用率。</p>
<p>$$K_h = \frac{I(1-T)}{B_0(1-f)}$$</p>
<p>例：</p>
<blockquote>
<p>案例：某互联网公司发行总面额为500元的10年期债券，票面利率为2%，发行费用率为5%，公司所得税税率为25%。确定该债券的资金成本。解：根据公式得</p>
</blockquote>
<p>$$K_h = \frac{I(1-T)}{B_0(1-f)} = \frac{500 \times 12% \times (1-25%)}{500 \times (1-5%)} = 9.47%$$</p>
<h6 id="综合资金成本"><a href="#综合资金成本" class="headerlink" title="综合资金成本"></a>综合资金成本</h6><p>综合资本成本（Overall Cost of Capital）是指企业全部长 期资本的总成本。亦称加权平均资本成本（ Weighted  Average Cost of Capital，缩写为WACC）。</p>
<p>$K_w$ ——综合资本成本，即加权平均资本成本；<br>$K_j$ ——第j种个别资本成本；<br>$W_j$ ——第j种个别资本占全部资本的比重，即权数。</p>
<p>$$K_w = \sum_{j=1}^{n}K_jW_j$$</p>
<p>例：</p>
<blockquote>
<p>某项目发起人筹集的总资金为500万元，其中银行借款100万元，债券资金50万元，普通股250万元，留存盈余100万元；其资金成本分别为6.7%、9.1%、7%、11.26%、11%，确定该公司的加权平均资金成本。</p>
</blockquote>
<p>$$K_w = \sum_{j=1}^{n}K_jW_j = 6.7% \times \frac{100}{500} + 9.17% \times \frac{50}{500} +  11.26% \times \frac{250}{500} +  11% \times \frac{100}{500} = 10.09% $$</p>
<h3 id="资金结构和筹资优化"><a href="#资金结构和筹资优化" class="headerlink" title="资金结构和筹资优化"></a>资金结构和筹资优化</h3><h4 id="资金结构"><a href="#资金结构" class="headerlink" title="资金结构"></a>资金结构</h4><p>资金结构是指项目投资总额中各种资金的构成及其比例关系。对建设项目来说资金结构主要包括<strong>资本金与债务资金的比例</strong>、<strong>资本金内部结构比例</strong>和<strong>债务资金内部结构比例</strong>。</p>
<h4 id="筹资风险"><a href="#筹资风险" class="headerlink" title="筹资风险"></a>筹资风险</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>筹资风险的概念：又称财务风险，是指因借款而增加的风险，是项目因借入资金而产生的丧失偿债能力的可能性和项目利润的可变性。</p>
<h5 id="主要影响因素"><a href="#主要影响因素" class="headerlink" title="主要影响因素"></a>主要影响因素</h5><p>影响筹资风险的主要因素：资本供求的变化、利率水平的变动、项目获利能力的变化、资金结构（财务杠杆的利用程度）的变化。财务杠杆对筹资风险影响最大</p>
<h4 id="筹资优化"><a href="#筹资优化" class="headerlink" title="筹资优化"></a>筹资优化</h4><ul>
<li>资金结构的优化：财务杠杆系数  </li>
<li>筹资期限结构优化：还款时间节点</li>
<li>筹资利率结构优化：利率组合</li>
<li>筹资币种结构优化：不同币种</li>
<li>筹资方式的可转换性：债券、股票转换</li>
</ul>
<h2 id="第七章-建设项目评价"><a href="#第七章-建设项目评价" class="headerlink" title="第七章 建设项目评价"></a>第七章 建设项目评价</h2><h3 id="财务评价"><a href="#财务评价" class="headerlink" title="财务评价"></a>财务评价</h3><p>又称企业经济评价。根据<strong>现行国家财税制度和价格体系</strong>，分析、计算项目的直接效益和直接费用，以考察项目的盈利能力、清偿能力和财务生存能力等财务状况，据以判别项目的<strong>财务可行性</strong>。</p>
<p>站在项目的立场上，按照微观利益最大化的原则，以项目为边界，以项目系统的实际发生为依据，分析、计算项目的财务效益和费用，考察项目对财务主体的财务贡献，据此判断项目在财务上的可行性，为投资决策、融资决策和其他有关方面决策提供依据。</p>
<h4 id="财务评价分类"><a href="#财务评价分类" class="headerlink" title="财务评价分类"></a>财务评价分类</h4><p>融资前财务评价：考察项目自身的经济性，为后续工作提供基础。<br>融资后财务评价：考察在既定融资方案基础上，项目对投资人的贡献及其运行状况。</p>
<h4 id="融资前财务评价"><a href="#融资前财务评价" class="headerlink" title="融资前财务评价"></a>融资前财务评价</h4><p>融资前财务评价<strong>不考虑债务资金的筹集</strong>、<strong>使用和偿本付息等融资问题</strong>（假设所需全部资金均为项目所有）对项目建设和运营效益的影响，以考察<strong>项目自身的财务可行性</strong>。在初步可行性研究阶段，可以只进行融资前财务评价。</p>
<p>$$融资前财务评价的现金流<br>\begin{cases}<br>现金流入<br>\begin{cases}<br>营业收入 \<br>补贴收入 \<br>固定资产残值 \<br>流动资金回收<br>\end{cases}<br>\ \ \现金流出<br>\begin{cases}<br>建设投资 \<br>流动资金 \<br>经营成本 \<br>增值税 \<br>营业税金\<br>附加<br>\end{cases}<br>\end{cases}<br>$$</p>
<h4 id="融资后财务评价"><a href="#融资后财务评价" class="headerlink" title="融资后财务评价"></a>融资后财务评价</h4><p>在确定的融资方案基础上进行的项目财务评价。融资后财务评价考虑了债务资金的筹集、使用和还本付息等融资问题对项目建设和运营效益的影响，以考察<strong>项目对投资者的财务贡献</strong>。</p>
<p>融资前评价是站在项目的角度，考察项目的财务可行性；融资后评价是站在投资者的角度，考察项目对资本金和其他投资的贡献，判断项目满足投资者投资期望的程度。</p>
<h5 id="资本金财务评价。现金流量由以下科目构成："><a href="#资本金财务评价。现金流量由以下科目构成：" class="headerlink" title="资本金财务评价。现金流量由以下科目构成："></a>资本金财务评价。现金流量由以下科目构成：</h5><ul>
<li>现金流入：营业收入、补贴收入、固定资产残值及流动资金回收。</li>
<li>现金流出：项目资本金投入、经营成本、营业税金及附加、企业所得税、借款的偿本与付息。</li>
</ul>
<h5 id="投资各方财务评价。投资各方财务评价的现金流量由以下科目构成："><a href="#投资各方财务评价。投资各方财务评价的现金流量由以下科目构成：" class="headerlink" title="投资各方财务评价。投资各方财务评价的现金流量由以下科目构成："></a>投资各方财务评价。投资各方财务评价的现金流量由以下科目构成：</h5><ul>
<li>现金流入：利润分配、资产处置收益分配、租赁费收入、技术转让或使用收入。</li>
<li>现金流出：实缴资本、租赁资产支出。 </li>
</ul>
<p>$$财务评价<br>\begin{cases}<br>融资前评价 - 盈利能力评价<br>\begin{cases}<br>动态评价 - 项目投资现金流分析 - 项目投资财务净现值<br>\ \静态评价 - 投资回收期<br>\end{cases}<br>\ \ \ 融资后评价<br>\begin{cases}<br>盈利能力评价<br>\begin{cases}<br>动态评价<br>\begin{cases}<br>项目资本金现金流分析 - 资本金财务收益率 \ \<br>投资各方现金流分析 - 各方财务收益率<br>\end{cases}<br>\ \ 静态评价 - 资本金利润率、总投资收益率<br>\end{cases}<br>\ \ \偿债能力评价 - 利息备付率、偿债备付率<br>\  \ \财务生存能力评价 - 项目财务计划现金流分析 - 盈余资金<br>\end{cases}<br>\end{cases}<br>$$<br><img src="https://img-blog.csdnimg.cn/d5a91a19e01a4180a90b7f858940001d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA562xLi4=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p>2.融资后财务评价<br>2.1盈利能力评价<br>    资本金现金流<br>        现金流入：营业收入、补贴收入、固定资产残值及流动资金回收。<br>        现金流出：资本金投入、经营成本、营业税金及附加、企业所得税、借款的偿本付息。<br>    ——资本金现金流量表<br>2.2偿债能力评价<br>   ——利润与利润分配表：营业收入、补贴收入、营业税金及附加、总成本费用、利润总额、所得税、净利润、可供分配利润、法定盈余公积金、可供投资者分配利润、优先股股利、普通股股利、未分配利润、息税前利润（利润总额+利息）、息税折旧摊销前利润（EBIT+折旧+摊销）<br>   ——借款还本付息计划表：期初余额、当期发生数额、当期应计利息、当期还本付息、其中：还本 、付息、期末余额<br>2.3财务生存能力评价<br>   ——财务计划现金流量表<br>2.3.1经营活动净现金流：<br>    现金流入：营业收入、增值税销项税额、补贴收入<br>    现金流出：经营成本、增值税进项税额、营业税及附加、增值税、所得税<br>2.3.2投资活动净现金流<br>    现金流出：建设投资、流动资金<br>2.3.3融资活动净现金流<br>    现金流入：项目资本金、建设投资借款、流动资金借款、短期借款<br>    现金流出：各种利息支付、借款本金偿还</p>
<h2 id="第八章-建设项目的国民经济评价"><a href="#第八章-建设项目的国民经济评价" class="headerlink" title="第八章 建设项目的国民经济评价"></a>第八章 建设项目的国民经济评价</h2><p>建设项目财务评价是以<strong>现行市场价格体系</strong>为评价基础的。现金流计算中的基本经济要素的价格都取自于市场价格体系。而市场发育不成熟、不完善，市场价格可能存在背离价值的“扭曲”和偏离供求关系的“失真”所以导致财务评价基础有一定的缺陷。</p>
<h3 id="国民经济评价的经济内涵"><a href="#国民经济评价的经济内涵" class="headerlink" title="国民经济评价的经济内涵"></a>国民经济评价的经济内涵</h3><ul>
<li>可以从宏观上优化配置国家的有限资源</li>
<li>可以真实反映工程项目对国民经济的净贡献</li>
<li>可以使投资决策更科学化</li>
</ul>
<h3 id="评价的项目范围"><a href="#评价的项目范围" class="headerlink" title="评价的项目范围"></a>评价的项目范围</h3><ul>
<li>具有垄断特征的项目</li>
<li>产出具有公共产品的特征的项目</li>
<li>外部效果显著的项目</li>
<li>资源开发项目</li>
<li>涉及国家安全的项目</li>
<li>受过度行政干预的项目</li>
</ul>
<h3 id="国民经济评价和财务评价的比较"><a href="#国民经济评价和财务评价的比较" class="headerlink" title="国民经济评价和财务评价的比较"></a>国民经济评价和财务评价的比较</h3><p>$$国民经济评价和财务评价的比较<br>\begin{cases}<br>相同点<br>\begin{cases}<br>提供决策依据；<br>\ \评价基础相同；<br>\ \评价分析方法、指标类似<br>\end{cases}<br>\ \ \不同点<br>\begin{cases}<br>评价角度不同；(财务评价：企业；国民经济评价：国家)<br>\ \费用和效益的划分不同；(财务评价：以项目系统为边界，以内部效果为计算基础；国民经济评价：以国民经济系统为边界，以项目的全部效果(内部和外部)为基础)<br>\ \使用的价格体系不同(财务评价；预测价格；国民经济评价：影子价格)<br>\ \采用的评价参数不同。<br>\end{cases}<br>\end{cases}<br>$$</p>
<h3 id="外部效果"><a href="#外部效果" class="headerlink" title="外部效果"></a>外部效果</h3><p>建设项目<strong>间接效益</strong>和<strong>间接费用</strong>的统称，是由于项目实施所导致的在项目之外未计入项目直接效益与直接费用的效果。</p>
<h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><ol>
<li>环境影响效果；环境污染费用</li>
<li>价格影响效果；大量出口导致同类产品价格下跌</li>
<li>相邻效果；上下游企业的发展</li>
<li>技术扩散效果；技术革新</li>
<li>乘数效果；闲置资源有效利用</li>
<li>无形效果；人力、生命质量、疾控、生活秩序等</li>
</ol>
<h3 id="转移支付"><a href="#转移支付" class="headerlink" title="转移支付"></a>转移支付</h3><p>在国民经济框架下，一个部门向另一个部门支付的财富，而这笔财富并未带来社会财富总量的变化</p>
<h3 id="影子价格"><a href="#影子价格" class="headerlink" title="影子价格"></a>影子价格</h3><p>某一种资源处于最优配置时，其<strong>边际增量</strong>对社会福利的贡献值。</p>
<h4 id="影子价格的确定"><a href="#影子价格的确定" class="headerlink" title="影子价格的确定"></a>影子价格的确定</h4><h5 id="1-由市场价格调整影子价格"><a href="#1-由市场价格调整影子价格" class="headerlink" title="1. 由市场价格调整影子价格"></a>1. 由市场价格调整影子价格</h5><h6 id="具有市场价格的商品影子价格的确定"><a href="#具有市场价格的商品影子价格的确定" class="headerlink" title="具有市场价格的商品影子价格的确定"></a>具有市场价格的商品影子价格的确定</h6><ul>
<li>对处于竞争性市场环境中的商品，取该市场价格为影子价格</li>
<li>若对原来有冲击，则求出两者的平均值</li>
</ul>
<h5 id="2-可外贸货物的影子价格"><a href="#2-可外贸货物的影子价格" class="headerlink" title="2. 可外贸货物的影子价格"></a>2. 可外贸货物的影子价格</h5><p>$$出口产出物的影子价格 = 离岸价(FOB) \times 影子汇率 - 出口费用 $$</p>
<p>$$进口投入物的影子价格 = 到岸价(CIF)  \times 影子汇率 + 进口费用 $$</p>
<p>$$影子汇率 = 影子汇率换算系数 \times 官方牌价汇率$$<br>我国影子汇率换算系数为1.08</p>
<h5 id="3-特殊投入物的影子价格"><a href="#3-特殊投入物的影子价格" class="headerlink" title="3. 特殊投入物的影子价格"></a>3. 特殊投入物的影子价格</h5><h6 id="人力资源的影子价格"><a href="#人力资源的影子价格" class="headerlink" title="人力资源的影子价格"></a>人力资源的影子价格</h6><p>$$影子工资 = 劳动力的机会成本 + 新增资源消耗$$</p>
<p>$$影子工资 = 财务工资 \times 影子工资换算系数$$</p>
<h6 id="土地影子价格"><a href="#土地影子价格" class="headerlink" title="土地影子价格"></a>土地影子价格</h6><p>$$土地影子价格 = 土地机会成本 + 新增资源消耗$$</p>
<p>新增资源消耗主要包括：拆迁费、安置费和其他费用</p>
<h2 id="第九章-不确定性分析和风险分析"><a href="#第九章-不确定性分析和风险分析" class="headerlink" title="第九章 不确定性分析和风险分析"></a>第九章 不确定性分析和风险分析</h2><h3 id="不确定性分析"><a href="#不确定性分析" class="headerlink" title="不确定性分析"></a>不确定性分析</h3><p>项目不确定性是指对于<strong>项目未来经济状况</strong>（尤其是收益和损失）的<strong>分布范围</strong>和<strong>状态</strong>不能确知的性质。</p>
<h4 id="项目不确定性产生的原因"><a href="#项目不确定性产生的原因" class="headerlink" title="项目不确定性产生的原因"></a>项目不确定性产生的原因</h4><h5 id="主观原因"><a href="#主观原因" class="headerlink" title="主观原因"></a>主观原因</h5><ol>
<li>信息的不完全性及不充分</li>
<li>人的有限理性</li>
</ol>
<h5 id="客观原因"><a href="#客观原因" class="headerlink" title="客观原因"></a>客观原因</h5><ol>
<li>经济环境因素的影响</li>
<li>技术环境因素的影响</li>
<li>政策及法律环境因素的影响</li>
<li>市场供求变化的影响</li>
<li>社会文化环境因素的影响</li>
<li>自然条件和资源因素的影响</li>
</ol>
<h4 id="不确定性分析的步骤"><a href="#不确定性分析的步骤" class="headerlink" title="不确定性分析的步骤"></a>不确定性分析的步骤</h4><ol>
<li>鉴定项目的主要不确定性因素</li>
<li>预测和估计不确定性因素的变动范围</li>
<li>选择不确定性分析的方法</li>
<li>确定分析的结果</li>
<li>提示项目实施风险</li>
</ol>
<h3 id="盈亏平衡分析"><a href="#盈亏平衡分析" class="headerlink" title="盈亏平衡分析"></a>盈亏平衡分析</h3><p>不确定性因素的变化，影响着建设项目的经济效果，当这些因素的变化达到某一临界值时，可能致使原来盈利的项目变为亏损项目，并导致项目比选的结果发生质的变化。盈亏平衡分析的目的就是找出这种由盈利到亏损、由优到劣的临界点，据此考察建设项目对运营状态变化的<strong>适应能力</strong>、<strong>承受能力</strong>和<strong>抵御风险能力</strong></p>
<h4 id="盈亏平衡分析的概念"><a href="#盈亏平衡分析的概念" class="headerlink" title="盈亏平衡分析的概念"></a>盈亏平衡分析的概念</h4><p>根据项目<strong>产（销）量、成本与利润</strong>之间的经济数量关系，通过分析项目的<strong>盈亏平衡点</strong>（Break-Even-Point，BEP），考察项目对运营状态变化的适应能力、承受能力和抵御风险能力，是评价项目财务可靠性的不确定性分析方法。盈亏平衡分析在<strong>财务评价环境</strong>中进行。</p>
<h4 id="线性盈亏平衡分析"><a href="#线性盈亏平衡分析" class="headerlink" title="线性盈亏平衡分析"></a>线性盈亏平衡分析</h4><p>基本假设:</p>
<ol>
<li>销售量等于产量；</li>
<li>固定成本和单位变动成本固定不变；</li>
<li>销售单价相对固定；</li>
<li>生产单一产品，或多种产品但可以换算为单一产品。</li>
</ol>
<p>$p$ —单位产品销售价格（单价）<br>$Q$ —年销售量（产量）<br>$v$ —单位产品可变成本<br>$F$ —年度固定成本<br>$P$ —年度总利润<br>$S$ —年度销售收入<br>$C$ —年度总成本费用<br>$r$ —营业税税率</p>
<p>年度销售收入函数：$$S = pQ$$<br>年度总成本费用函数：$$C＝F + vQ$$<br>年度总利润函数: $$P  = S - C - Sr$$</p>
<h5 id="盈亏平衡点"><a href="#盈亏平衡点" class="headerlink" title="盈亏平衡点"></a>盈亏平衡点</h5><ol>
<li><p>以年产销量表示：$Q_0$表好似盈亏平衡点产量<br>$$ Q_0 = F / (p - v - pr)$$</p>
</li>
<li><p>以销售收入表示：$S_0表示销售收入的盈亏平衡点$<br>$$S_0  = pQ_0  = pF / (p -v -pr)$$</p>
</li>
<li><p>以生产能力利用率表示：$a_0$为生产能力利用率的盈亏平衡点，$Q_s$表示设计生产能力</p>
</li>
</ol>
<p>$$a_0 = (Q_0 / Q_s) \times 100%$$<br>当$a_0 \le 70%$ ,项目具有较好的抗风险能力</p>
<h5 id="经营安全度"><a href="#经营安全度" class="headerlink" title="经营安全度"></a>经营安全度</h5><p>$$A = \frac{(Q_s - Q_0)}{Q_s}$$</p>
<p>$A$ —经营安全度</p>
<p>$A$越大，经营的安全性越大，$A \ge 70%$时，项目经营安全。</p>
<p>例：</p>
<blockquote>
<p>某方案设计年产量为30万件，估计产品单价为10元，单 位可变成本为8元，年固定成本为40万元，营业税率为 5%。试分别用产量、销售收入、生产能力利用率表示盈 亏平衡点，并计算经营安全度。</p>
</blockquote>
<p>Q0＝F／(p-v-pr)＝400000／（10-8-10×5%）＝266667（件）<br>S0＝p×F／(p-v-pr)＝10×400000/（10-8-10×5%）＝2666667<br>（元）<br>а0＝（Q0/Qs）×100%＝266667／300000＝88.9%<br>A＝1-а0=1-88.9%=11.1%<br>由于а0＞70%，A＜30%，所以项目经营风险较高，财务运营可靠性不高</p>
<h3 id="敏感性分析"><a href="#敏感性分析" class="headerlink" title="敏感性分析"></a>敏感性分析</h3><p>敏感性分析，也称灵敏度分析，是不确定性分析中常用的方法之一。通过敏感性分析发现敏感性因素，为进一步的风险分析打下基础。</p>
<p>敏感性分析是通过分析<strong>不确定性因素的变化</strong>对项目经济效益评价指标的影响，从中找出敏感因素，估计项目效益对 其敏感程度揭示经济效益指标及评价结论对不确定性因素的敏感性，粗略以此预测项目风险，并为进一步的风险分析作铺垫的不确定分析方法。</p>
<h4 id="分类-3"><a href="#分类-3" class="headerlink" title="分类"></a>分类</h4><p>敏感性分析分为<strong>单因素敏感性分析</strong>与<strong>多因素敏感性分析</strong>。 </p>
<p>单因素敏感性分析是指进行敏感性分析时，假定只有单一 因素是变化的，其它因素保持不变，用以分析单一因素对经济评价指标的影响以及评价指标对单一因素的敏感程度；<br>多因素敏感性分析是指在同时有两个或两个以上的因素发生变化时，分析这些变化的因素对经济评价指标的影响程度和评价指标对它们的敏感程度。为了找出对评价指标影响最大的敏感性不确定因素，通常采用单因素敏感性分析的方法。</p>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol>
<li>选择不确定性因素</li>
<li>预测不确定性因素的变动范围或幅度</li>
<li>确定进行敏感性分析的指标</li>
<li>计算各变动因素的敏感度系数和转换值</li>
<li>寻找敏感因素，进行项目风险的粗略分析</li>
</ol>
<p>例：</p>
<blockquote>
</blockquote>
<table>
<thead>
<tr>
<th align="center">主要参数</th>
<th align="center">投  资 K（万元）</th>
<th align="center">年营业收入  S（万元）</th>
<th align="center">年经营成本  C（万元）</th>
<th align="center">期末残值 L（万元）</th>
<th align="center">寿命 n（年）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">估算值</td>
<td align="center">1500</td>
<td align="center">600</td>
<td align="center">250</td>
<td align="center">200</td>
<td align="center">6</td>
</tr>
</tbody></table>
<p>基准折现率10%，项目实施中，投资、年营业收入、年经营成本均可能在±10%、±20%范围波动，试分别就年销售收入、投资、年经营成本进行项目敏感性分析。</p>
<p>解：<br>（1）选定项目的净年值（NAV）为评价指标。<br>（2）计算基本方案的净年值。<br>NAV = [-1500(A/P,10%,6)+600-250+200(A/F,10%,6)]万元<br>= 31.52 万元<br>（3）确定因素变动幅度为：-20%、-10%、+10%、-20%。<br>（4）计算相应的净年值变动率。<br>如 △S/S=+10%，即S=[600(1+10%)]万元=660万元，则：<br>NAV = [-1500(A/P,10%,6)+660-250+200(A/F,10%,6)]万元<br>= 91.52 万元<br>△ NPV=( 91.52- 31.52）=60 万元<br>△ NPV/ NPV= 60 / 31.52 =190.36%<br>（5）计算净年值指标对于年销售收入的敏感度系数。<br>如 NAV对于S的敏感度系数，S=190.36%/105=19.04</p>
<p>计算净年值指标对于年销售收入的敏感度系数。<br>如年销售收入，令：<br>NAV = -1500(A/P,10%,6)+600(1+Z)-250+200(A/F,10%,6)=0<br>解得：Z=-5.32%</p>
<h4 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h4><p>敏感性分析虽然分析了不确定性因素的变化对方案的经济效益的影响，但它并不能说明不确定性因素发生变动的可能性大小，即<strong>发生变动的概率</strong>，而这种概率与项目的风险大小直接相关。实际上，有些因素变动尽管对项目经济效果影响很大，即为敏感因素，但由于其发生的可能性很小，所以给项目带来的风险并不大；而另外一些因素虽然它们变动对项目的经济效益影响不大，不是敏感因素，但因其发生的可能性很大，反而可能给项目带来很大的风险。对这类问题的分析，敏感性分析无法解决，而应借助于风险分析。</p>
<h3 id="风险分析"><a href="#风险分析" class="headerlink" title="风险分析"></a>风险分析</h3><p>风险一般是指因某种不确定性引起的行动的<strong>潜在损失</strong>。<br>但在决策理论中，它们之间的差别在于关键的两点：</p>
<ol>
<li>风险条件下的决策，意味着决策者可以列出一个决策的所有可能后果，及与之相关的出现概率，这种决策称之为风险型决策。</li>
<li>不确定性条件下的决策，则意味着决策者不能列出全部可能 后果，或者不能确定各种后果的出现概率。这种决策称之为不确定性决策。<br>事实上，不确定性条件下的决策比之风险条件下的决策，决策者面临着更大的风险。</li>
</ol>
<p>把知道发生可能性（概率）的不确定性称为风险。<br>把不知道发生可能性（概率）的称为不确定性。即风险是可以或能够估量的不确定性，而不确定性（狭义的不确定性）是不能够估量的。</p>
<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ol>
<li>风险识别</li>
<li>风险测度</li>
<li>风险评价</li>
<li>风险应对</li>
</ol>
<h4 id="风险概率分布的两种形式"><a href="#风险概率分布的两种形式" class="headerlink" title="风险概率分布的两种形式"></a>风险概率分布的两种形式</h4><h5 id="离散型概率分布"><a href="#离散型概率分布" class="headerlink" title="离散型概率分布"></a>离散型概率分布</h5><p>输入变量可能值是有限个数。各种状态的 概率取值之和等于1，它适用于变量取值个数不多的输入变量。</p>
<h5 id="连续型概率分布"><a href="#连续型概率分布" class="headerlink" title="连续型概率分布"></a>连续型概率分布</h5><p>输入变量的取值充满一个区间。</p>
<p><img src="https://img-blog.csdnimg.cn/e59d1631bec84f5fa20945e5fd2b09ea.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA562xLi4=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h4 id="风险分析方法"><a href="#风险分析方法" class="headerlink" title="风险分析方法"></a>风险分析方法</h4><h5 id="列表法"><a href="#列表法" class="headerlink" title="列表法"></a>列表法</h5><h5 id="概率树法"><a href="#概率树法" class="headerlink" title="概率树法"></a>概率树法</h5><p>概率树的画法：用来矩形表示方案结点，从方案结点引出的直线叫做方案枝，用⚪来表示状态结点，从状态结点引出的直线叫状态枝，同时把风险要素的各种状态及相应概率写在状态枝上，同时把各种状态下的收益写在概率树的 左三角号末端。</p>
<p>例：书(P180)</p>
<blockquote>
<p>某商品住宅小区开发项目现金流量的估计 值如表9-6所示，根据经验推断，销售收入和开发成本为离散型随机变量，其值在基本方案参数估计值的基础上可能发生的变化及其概率见表9-7。试确定该项目净现值大于等于零的概率。基准收益率ic=12%</p>
<table>
<thead>
<tr>
<th>年份</th>
<th>1</th>
<th>2</th>
<th>3</th>
</tr>
</thead>
<tbody><tr>
<td>销售收入</td>
<td>857</td>
<td>7143</td>
<td>17446</td>
</tr>
<tr>
<td>开发成本</td>
<td>5888</td>
<td>4873</td>
<td>6900</td>
</tr>
<tr>
<td>其他税费</td>
<td>56</td>
<td>464</td>
<td>1196</td>
</tr>
<tr>
<td>净现金流量</td>
<td>-5087</td>
<td>1806</td>
<td>9350</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>概率  变幅 因素</th>
<th>-20%</th>
<th>0</th>
<th>+20%</th>
</tr>
</thead>
<tbody><tr>
<td>销售收入</td>
<td>0.2</td>
<td>0.6</td>
<td>0.2</td>
</tr>
<tr>
<td>开发成本</td>
<td>0.1</td>
<td>0.3</td>
<td>0.6</td>
</tr>
</tbody></table>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/2fa9c9f689a144c5ae00e1b29a23e387.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA562xLi4=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h5 id="蒙特卡洛法"><a href="#蒙特卡洛法" class="headerlink" title="蒙特卡洛法"></a>蒙特卡洛法</h5><p>蒙特卡洛模拟法（简称模拟法）是通过<strong>反复地进行随机抽样</strong>来模拟各种随机变量的变化，进而计算分析项目经济效果指标的概率分布的一种分析方法。<br>当变量数或状态数超过3个时，运用概率树分析的工作量将很大。这时，可以采用模拟法，通过随机抽样的方法生成服从特定概率分布的建设投资、销售收入、经营成本等数据，并据此计算净现值、内部收益率等评价指标。经过反复地抽样、计算，当样本数足够大时，便可获得评价指标的概率分布以及累计概率分布、期望值、方差、标准差、离散系数等数据，从而估计项目的风险。</p>
<h6 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h6><p>a．确定风险分析所采用的评价指标；<br>b．确定影响项目评价指标的主要风险因素；<br>c．估计主要风险因素的概率分布，并用数学模型表示；<br>d．为各风险因素独立抽取随机数；<br>e．将抽得的各随机数转化为各风险因素的抽样值；<br>f．将抽样值组成一组项目评价基础数据，并据计算相应的评价指标；<br>g．重复d～f步骤，直至达到预定的模拟次数；<br>h．整理模拟结果，计算评价指标的期望值、方差、标准差、离散系数以及累计概率等，并可绘制累计概率图。</p>
<p>例：书(P181)</p>
<h2 id="第十章-可行性研究"><a href="#第十章-可行性研究" class="headerlink" title="第十章 可行性研究"></a>第十章 可行性研究</h2><p>可行性研究（Feasibility  Study）是在项目寿命周期中，项目策划决策阶段的一个重要内容，可行性研究也成为可行性分析。它主要是对拟投资的项目进行全面、综合技术经济分析。</p>
<h3 id="项目的生命周期（八个阶段）"><a href="#项目的生命周期（八个阶段）" class="headerlink" title="项目的生命周期（八个阶段）"></a>项目的生命周期（八个阶段）</h3><ol>
<li>策划决策阶段:项目建议书、可行性研究</li>
<li>勘察设计阶段：初步设计、技术设计、施工图设计</li>
<li>建设准备阶段：施工招投标、订立合同、办理施工许可</li>
<li>施工阶段</li>
<li>生产准备阶段</li>
<li>竣工验收阶段</li>
<li>项目后评审阶段</li>
<li>项目清理</li>
</ol>
<p>对项目进行可行性分析的一个核心是对项目投资合理性的论证，也就是对项目进行经济评价（财务评价和国民经济评价），需要应用我们所学的工程经济学基本原理与方法对拟投资项目在整个项目寿命期内，各种投入和产出（经济性评价要素）进行分析，因此说，工程经济学基本原理和方法在实践中的一个应用领域就是针对项目的可行性研究。</p>
<h3 id="可行性研究考察项目"><a href="#可行性研究考察项目" class="headerlink" title="可行性研究考察项目"></a>可行性研究考察项目</h3><p>$$考察项目<br>\begin{cases}<br>技术上的先进性、适用性 \ \<br>经济上的合理性、盈利性 \ \<br>实施上的可能性、风险性<br>\end{cases}<br>$$</p>
<h3 id="可行性研究的作用"><a href="#可行性研究的作用" class="headerlink" title="可行性研究的作用"></a>可行性研究的作用</h3><ol>
<li>作为项目投资决策的依据； </li>
<li>作为向银行等金融机构或金融组织申请贷款、筹集资金的依据； </li>
<li>作为项目主管部门商谈合同、签订协议的依据； </li>
<li>作为编制设计和进行建设工作的依据； </li>
<li>作为项目组织管理，机构设置，技术、设备采用等工作的依据； </li>
<li>作为申报项目和接受相关部门评审的依据。</li>
</ol>
<h3 id="可行性研究报告的编制框架"><a href="#可行性研究报告的编制框架" class="headerlink" title="可行性研究报告的编制框架"></a>可行性研究报告的编制框架</h3><ol>
<li>总论</li>
<li>市场需求调查、预测和拟建规模</li>
<li>原材料、能源、公共基础设施情况</li>
<li>建厂条件和厂址方案</li>
<li>工艺技术和设备选择</li>
<li>节能分析</li>
<li>环境影响评价</li>
<li>劳动安全卫生与消防</li>
<li>企业组织、劳动定员及员工培训</li>
<li>项目实施进度</li>
<li>投资估算与项目融资</li>
<li>经济评价</li>
<li>社会评价</li>
<li>综合评价</li>
<li>附件</li>
</ol>
]]></content>
      <categories>
        <category>课程学习</category>
        <category>软件工程经济学</category>
      </categories>
      <tags>
        <tag>课程学习</tag>
        <tag>软件工程经济学</tag>
      </tags>
  </entry>
  <entry>
    <title>毛概题库</title>
    <url>/135xyq.github.io/2022/06/15/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E6%AF%9B%E6%A6%82%E9%A2%98%E5%BA%93/</url>
    <content><![CDATA[<h1 id="毛概题库"><a href="#毛概题库" class="headerlink" title="毛概题库"></a>毛概题库</h1><h2 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h2><h3 id="单选题"><a href="#单选题" class="headerlink" title="单选题"></a>单选题</h3><p>在马克思列宁主义同中国工人运动的紧密结合中，中国共产党在（）年应运而生。<br>A: 1911<br>B: 1919<br>C: 1921<br>D: 1927<br>正确答案: C</p>
<p>1938年，毛泽东在党的六届六中全会上作（）的报告，第一次向全党提出“马克思主义中国化”的任务。<br>A: 《论新阶段》<br>B: 《论联合政府》<br>C: 《愚公移山》<br>D: 《论人民民主专政》<br>正确答案: A</p>
<p>在毛泽东思想的指导下，中国共产党团结带领中国人民，（），创造了新民主主义革命的伟大成就，建立了人民当家作主的中华人民共和国，实现了民族独立人民解放。<br>A: 浴血奋战百折不挠<br>B: 自力更生发愤图强<br>C: 解放思想锐意进取<br>D: 自信自强守正创新<br>正确答案: A</p>
<p>下列各项中，不属于新民主主义革命的胜利的意义的是（）。<br>A: 彻底结束了旧中国半殖民地半封建社会的历史<br>B: 彻底结束了旧中国一盘散沙的局面<br>C: 彻底废除了列强强加给中国的不平等条约和帝国主义在中国的一切特权<br>D: 实现了中华民族有史以来最为广泛而深刻的社会变革<br>正确答案: D</p>
<p>新中国成立后，在毛泽东思想的指导下，中国共产党团结带领中国人民，（），创造了社会主义革命和建设的伟大成就，实现了中华民族有史以来最为广泛而深刻的社会变革，实现了一穷二白人口众多的东方大国大步迈进社会主义社会的伟大飞跃，为实现中华民族伟大复兴奠定了根本政治前提和制度基础。<br>A: 浴血奋战百折不挠<br>B: 自力更生发愤图强<br>C: 解放思想锐意进取<br>D: 自信自强守正创新<br>正确答案: B</p>
<p>1978年召开的（），实现了新中国成立以来党的历史上具有深远意义的伟大转折，开启了改革开放和社会主义现代化建设新时期。<br>A: 党的七届二中全会<br>B: 党的十一届三中全会<br>C: 党的十一届六中全会<br>D: 党的十八届三中全会<br>正确答案: B</p>
<p>从党的十一届三中全会到十八大，中国共产党高举中国特色社会主义伟大旗帜，团结带领中国人民，（），创造了改革开放和社会主义现代化建设的伟大成就，为实现中华民族伟大复兴提供了充满新的活力的体制保证和快速发展的物质条件。<br>A: 浴血奋战百折不挠<br>B: 自力更生发愤图强<br>C: 解放思想锐意进取<br>D: 自信自强守正创新<br>正确答案: C</p>
<p>在习近平新时代中国特色社会主义思想的指导下，中国共产党团结带领中国人民，（），统揽伟大斗争伟大工程伟大事业伟大梦想，创造了新时代中国特色社会主义的伟大成就，为实现中华民族伟大复兴提供了更为完善的制度保证更为坚实的物质基础更为主动的精神力量。<br>A: 浴血奋战百折不挠<br>B: 自力更生发愤图强<br>C: 解放思想锐意进取<br>D: 自信自强守正创新<br>正确答案: D</p>
<p>2018年，（）通过的宪法修正案把马克思列宁主义毛泽东思想邓小平理论“三个代表”重要思想科学发展观习近平新时代中国特色社会主义思想共同确立为国家指导思想。<br>A: 十三届全国人大一次会议<br>B: 十三届全国人大二次会议<br>C: 十三届全国人大三次会议<br>D: 十三届全国人大四次会议<br>正确答案: A</p>
<h3 id="多选题"><a href="#多选题" class="headerlink" title="多选题"></a>多选题</h3><p>马克思主义是我们（）的强大思想武器。<br>A: 认识世界<br>B: 把握规律<br>C: 追求真理<br>D: 改造世界<br>正确答案: ABCD</p>
<p>马克思主义是（），自诞生以来就始终占据着真理和道义的制高点。<br>A: 科学的理论<br>B: 人民的理论<br>C: 实践的理论<br>D: 不断发展的开放的理论<br>正确答案: ABCD</p>
<p>近代以来的各种思潮中，未能改变旧中国的社会性质和中国人民的悲惨命运的有（）。<br>A: 自由主义<br>B: 社会达尔文主义<br>C: 无政府主义<br>D: 民粹主义<br>正确答案: ABCD</p>
<p>学好“毛泽东思想和中国特色社会主义理论体系概论”课程，就要全面理解马克思主义中国化理论成果的（），深刻认识中国化马克思主义既一脉相承又与时俱进的理论品质。<br>A: 科学内涵<br>B: 理论体系<br>C: 思想精髓<br>D: 精神实质<br>正确答案: ABCD</p>
<p>学好“毛泽东思想和中国特色社会主义理论体系概论”课程，就要系统把握马克思主义中国化理论成果所蕴含的马克思主义立场观点和方法，坚定中国特色社会主义（）。<br>A: 道路自信<br>B: 理论自信<br>C: 制度自信<br>D: 文化自信<br>正确答案: ABCD</p>
<p>学好“毛泽东思想和中国特色社会主义理论体系概论”课程，就要紧密联系（），紧密结合全面建设社会主义现代化国家的实际，紧密联系自己的思想实际。<br>A: 党史<br>B: 新中国史<br>C: 改革开放史<br>D: 社会主义发展史<br>正确答案: ABCD</p>
<p>学好“毛泽东思想和中国特色社会主义理论体系概论”课程，就要把（）有机统一起来，自觉投身于中国特色社会主义伟大实践，为实现中华民族伟大复兴作出应有的贡献。<br>A: 理论与实践<br>B: 理想与现实<br>C: 主观与客观<br>D: 知与行<br>正确答案: ABCD</p>
<h3 id="判断题"><a href="#判断题" class="headerlink" title="判断题"></a>判断题</h3><p>一个民族要走在时代前列，就一刻不能没有理论思维，一刻不能没有思想指引。<br>正确答案: 对</p>
<p>马克思主义只有中国化才能在中国大地上闪耀真理光芒，也只有实现中国化才能救中国发展中国发展社会主义。<br>正确答案: 对</p>
<p>1840年鸦片战争以后，中国迫切需要新的思想引领救亡运动，迫切需要新的组织凝聚革命力量。<br>正确答案: 对</p>
<p>面对中国的特殊国情，应该教条式地对待马克思列宁主义。<br>正确答案: 错</p>
<p>马克思主义中国化既是解决中国实际问题的客观需要，又是马克思主义理论本身发展的内在要求。<br>正确答案: 对</p>
<p>马克思主义只有实现中国化，解决中国的实际问题，才能体现其科学性和生命力，彰显其强大力量。<br>正确答案: 对</p>
<p>毛泽东思想是被实践证明了的关于中国革命和建设的正确的理论原则和经验总结，是中国共产党集体智慧的结晶。<br>正确答案: 对</p>
<p>只有社会主义才能救中国，只有社会主义才能发展中国。<br>正确答案: 对</p>
<p>在邓小平理论的指导下，20世纪的中国又一次发生了翻天覆地的变化。<br>正确答案: 对</p>
<p>“三个代表”重要思想是加强和改进党的建设推进社会主义自我完善和发展的强大理论武器，丰富和发展了中国特色社会主义理论体系。<br>正确答案: 对</p>
<p>科学发展观是马克思主义关于发展的世界观和方法论的集中体现，是马克思主义中国化的重大成果。<br>正确答案: 对</p>
<p>改革开放是决定当代中国前途命运的关键一招。<br>正确答案: 对</p>
<p>毛泽东思想和中国特色社会主义理论体系，同马克思列宁主义一起，是中国共产党长期坚持的指导思想和全国各族人民团结奋斗的共同思想基础。<br>正确答案: 对</p>
<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="单选题-1"><a href="#单选题-1" class="headerlink" title="单选题"></a>单选题</h3><p>（）开启了我们党独立自主解决中国革命实际问题的新阶段，在最危急关头挽救了党挽救了红军挽救了中国革命。<br>A: 党的一大<br>B: 八七会议<br>C: 古田会议<br>D: 遵义会议<br>正确答案: D</p>
<p>（）将毛泽东思想写入党章，确立为党必须长期坚持的指导思想。<br>A: 党的五大<br>B: 党的六大<br>C: 党的七大<br>D: 党的八大<br>正确答案: C</p>
<p>中国的武装斗争，是无产阶级领导的以（）为主体的革命战争。<br>A: 农民<br>B: 工人<br>C: 知识分子<br>D: 民族资产阶级<br>正确答案: A</p>
<p>下列各项中，不属于中国共产党在中国革命中战胜敌人的三大法宝的是（）。<br>A: 教条主义<br>B: 统一战线<br>C: 武装斗争<br>D: 党的建设<br>正确答案: A</p>
<p>在社会主义制度建立以后，毛泽东又领导全党和全国人民积极探索适合中国国情的社会主义建设道路，提出了一系列具有战略意义的正确思想和方针，其中不包括（）。<br>A: 只注重发展重工业，走出一条适合我国国情的中国工业化道路<br>B: 在科学文化工作中实行“百花齐放百家争鸣”<br>C: 必须严格区分和正确处理敌我矛盾和人民内部矛盾<br>D: 调动一切积极因素，化消极因素为积极因素，团结全国各族人民建设社会主义强大国家<br>正确答案: A</p>
<p>（）从组织上确立了党对军队的领导，是建设无产阶级领导的新型人民军队的重要开端。<br>A: 八七会议<br>B: 南昌起义<br>C: 三湾改编<br>D: 遵义会议<br>正确答案: C</p>
<p>下列各项中，不属于毛泽东思想所提出的对敌策略的是（）。<br>A: 区别对待分化瓦解<br>B: 同时与所有敌人斗争到底<br>C: 争取多数反对少数各个击破<br>D: 有理有利有节<br>正确答案: B</p>
<p>无产阶级及其政党要实现自己对同盟者的领导，所必须具备的条件不包括（）。<br>A: 率领被领导者向着共同的敌人作坚决斗争并取得胜利<br>B: 向被领导者无条件妥协退让<br>C: 对被领导者给以物质利益，至少不损害其利益<br>D: 给被领导者以政治教育<br>正确答案: B</p>
<p>（）通过的《中国共产党中央委员会关于建国以来党的若干历史问题的决议》对毛泽东和毛泽东思想的历史地位作出了科学的实事求是的评价。<br>A: 党的七届二中全会<br>B: 党的十一届三中全会<br>C: 党的十一届六中全会<br>D: 党的八届三中全会<br>正确答案: C</p>
<p>贯穿于毛泽东思想各个组成部分的立场观点和方法，是毛泽东思想的活的灵魂，其基本方面不包括（）。<br>A: 实事求是<br>B: 群众路线<br>C: 本本主义<br>D: 独立自主<br>正确答案: C</p>
<p>关于实事求是的内涵，下列理解中错误的是（）。<br>A: 一切从实际出发<br>B: 只关注实际，不研究理论<br>C: 理论联系实际<br>D: 坚持在实践中检验真理和发展真理<br>正确答案: B</p>
<p>坚持实事求是的正确做法不包括（）。<br>A: 深入实际了解事物的本来面貌<br>B: 把握事物内在必然联系<br>C: 按照客观规律办事<br>D: 放弃个体主观能动性<br>正确答案: D</p>
<p>坚持实事求是，就要清醒认识和正确把握我国基本国情，其具体做法不包括（）。<br>A: 坚持从我国基本国情出发来制定一切路线方针政策<br>B: 超越现实超越阶段而急于求成<br>C: 坚决纠正因循守旧故步自封的观念和做法<br>D: 牢牢立足基本国情这个最大实际<br>正确答案: B</p>
<p>群众路线本质上体现的是马克思主义关于（）是历史的创造者这一基本原理。<br>A: 人民群众<br>B: 杰出人物<br>C: 自然地理环境<br>D: 哲学思想<br>正确答案: A</p>
<p>关于独立自主的内涵，下列理解中错误的是（）。<br>A: 坚持独立思考，走自己的路<br>B: 坚定不移地维护民族独立捍卫国家主权<br>C: 把立足点放在依靠自己力量的基础上，同时积极争取外援，开展国际经济文化交流<br>D: 拒绝学习外国一切经验<br>正确答案: D</p>
<p>下列各项中，不符合独立自主的和平外交政策的是（）。<br>A: 主张以和平方式解决国际争端<br>B: 反对各种形式的霸权主义和强权政治<br>C: 反对以强凌弱<br>D: 根据所能获得实际利益的预期来决定自己的立场和政策<br>正确答案: D</p>
<h3 id="多选题-1"><a href="#多选题-1" class="headerlink" title="多选题"></a>多选题</h3><p>毛泽东思想是在我国（）的实践过程中，在总结我国革命和建设正反两方面历史经验的基础上，逐步形成和发展起来的。<br>A: 新民主主义革命<br>B: 社会主义革命<br>C: 社会主义建设<br>D: 改革开放和社会主义现代化建设<br>正确答案: ABC</p>
<p>毛泽东在（）等著作中，分析了中国社会各阶级在革命中的地位和作用，提出了新民主主义革命的基本思想。<br>A: 《中国社会各阶级的分析》<br>B: 《湖南农民运动考察报告》<br>C: 《论人民民主专政》<br>D: 《论十大关系》<br>正确答案: AB</p>
<p>土地革命战争时期，以毛泽东为主要代表的中国共产党人，在同党内一度盛行的（）的错误倾向的斗争中，逐步开辟了农村包围城市武装夺取政权的革命道路。<br>A: 把马克思主义教条化<br>B: 把共产国际决议神圣化<br>C: 把马克思列宁主义的基本原理同中国具体实际结合起来<br>D: 把苏联经验神圣化<br>正确答案: ABD</p>
<p>毛泽东在（）等著作中，提出并阐述了农村包围城市武装夺取政权的思想，标志着毛泽东思想的初步形成。<br>A: 《中国的红色政权为什么能够存在?》<br>B: 《井冈山的斗争》<br>C: 《星星之火，可以燎原》<br>D: 《反对本本主义》<br>正确答案: ABCD</p>
<p>毛泽东在（）等著作中，运用马克思主义的认识论和辩证法，系统分析了党内“左”的和右的错误的思想根源。<br>A: 《实践论》<br>B: 《论持久战》<br>C: 《矛盾论》<br>D: 《抗日游击战争的战略问题》<br>正确答案: AC</p>
<p>毛泽东在（）等理论著作中，科学阐述了新民主主义革命的对象动力领导力量性质和前途等基本问题。<br>A: 《〈共产党人〉发刊词》<br>B: 《中国革命和中国共产党》<br>C: 《新民主主义论》<br>D: 《论联合政府》<br>正确答案: ABCD</p>
<p>关于社会主义革命和社会主义建设的重要思想，集中体现于毛泽东（）等著作中，是毛泽东思想的丰富和发展。<br>A: 《在中国共产党第七届中央委员会第二次全体会议上的报告》<br>B: 《论人民民主专政》<br>C: 《论十大关系》<br>D: 《关于正确处理人民内部矛盾的问题》<br>正确答案: ABCD</p>
<p>毛泽东系统解决了如何把以农民为主要成分的革命军队建设成为一支（）的新型人民军队的问题。<br>A: 无产阶级性质<br>B: 地主阶级性质<br>C: 具有严格纪律<br>D: 同人民群众保持亲密联系<br>正确答案: ACD</p>
<p>针对历史上党内斗争中存在过的“左”的错误，毛泽东提出（）的正确方针，强调在党内斗争中要达到既弄清思想又团结同志的目的。<br>A: 惩前毖后<br>B: 残酷斗争<br>C: 治病救人<br>D: 无情打击<br>正确答案: AC</p>
<p>中华人民共和国成立前后，鉴于我们党已成为领导全国政权的党，毛泽东多次提出务必使同志们继续地保持（）的作风，务必使同志们继续地保持艰苦奋斗的作风。<br>A: 谦虚<br>B: 谨慎<br>C: 不骄<br>D: 不躁<br>正确答案: ABCD</p>
<p>毛泽东把（）运用于党的全部工作，在中国革命和建设的长期艰苦奋斗中形成了具有中国共产党人特色的立场观点和方法，丰富和发展了马克思列宁主义。<br>A: 辩证唯物主义<br>B: 机械唯物主义<br>C: 历史唯物主义<br>D: 历史唯心主义<br>正确答案: AC</p>
<p>毛泽东思想在（）思想政治工作和文化工作外交工作和党的建设等方面，以独创性的理论丰富和发展了马克思列宁主义。<br>A: 新民主主义革命<br>B: 社会主义革命和建设<br>C: 军队和国防建设<br>D: 政策和策略<br>正确答案: ABCD</p>
<p>毛泽东思想关于社会主义建设的基本思想观点，仍具有重要的现实指导作用，其中包括（）。<br>A: 关于正确认识和处理社会主义社会基本矛盾两类不同性质的矛盾尤其是人民内部矛盾的思想<br>B: 关于调动一切积极因素为社会主义事业服务的思想<br>C: 关于走中国工业化道路的思想<br>D: 关于完善社会主义政治制度扩大社会主义民主等思想<br>正确答案: ABCD</p>
<h3 id="判断题-1"><a href="#判断题-1" class="headerlink" title="判断题"></a>判断题</h3><p>没有中国革命和建设的丰富实践，没有对中国革命和建设经验的深刻总结，就不可能有毛泽东思想。<br>正确答案: 对</p>
<p>全心全意为人民服务是人民军队的唯一宗旨。<br>正确答案: 对</p>
<p>必须根据政治形势阶级关系和实际情况及其变化制定党的政策，把原则性和灵活性结合起来。<br>正确答案: 对</p>
<p>弱小的革命力量一定无法最终战胜强大的反动力量。<br>正确答案: 错</p>
<p>掌握思想教育，是团结全党进行伟大政治斗争的中心环节。<br>正确答案: 对</p>
<p>注重思想建党理论强党，是我们党的鲜明特色和光荣传统。<br>正确答案: 对</p>
<p>党员不但要在组织上入党，而且要在思想上入党，经常注意以无产阶级思想改造和克服各种非无产阶级思想。<br>正确答案: 对</p>
<p>理论和实践相结合的作风，和人民群众紧密地联系在一起的作风，以及自我批评的作风，是中国共产党区别于其他任何政党的显著标志。<br>正确答案: 对</p>
<p>崇古抑今，是马克思主义的根本观点，是中国共产党人认识世界改造世界的根本要求。<br>正确答案: 错</p>
<p>马克思主义经典作家通过穷尽真理而一劳永逸地解决了各国革命实践中的问题。<br>正确答案: 错</p>
<p>群众路线是我们党的生命线和根本工作路线，是我们党永葆青春活力和战斗力的重要传家宝。<br>正确答案: 对</p>
<p>杰出人物是历史发展和社会进步的主体力量。<br>正确答案: 错</p>
<p>全心全意为人民服务，是我们党一切行动的根本出发点和落脚点，是我们党区别于其他一切政党的根本标志。<br>正确答案: 对</p>
<p>检验党的一切工作的成效，最终只需要以经济发展速度为最高标准。<br>正确答案: 错</p>
<p>贯穿于毛泽东思想科学体系中的立场观点和方法是最能体现毛泽东思想理论本质特点的思想内容。<br>正确答案: 对</p>
<p>毛泽东思想关于社会主义建设的理论，为开创和发展中国特色社会主义作了重要的理论准备。<br>正确答案: 对</p>
<p>毛泽东思想所体现的独特理论风格给新时期党的理论创新进一步推进马克思主义大众化以重要的启迪。<br>正确答案: 对</p>
<p>任何时候都不能动摇高举毛泽东思想旗帜的原则。<br>正确答案: 对</p>
<p>毛泽东思想形成和发展的历史条件，与我们今天面临的形势和任务有很大的不同，这减弱和降低了毛泽东思想的科学价值。<br>正确答案: 错</p>
<p>怎样科学评价毛泽东和毛泽东思想的问题，关系到怎样看待党和国家过去几十年奋斗和前进的历史，关系到党的团结国家的安定，也关系到党和国家未来的发展前途。<br>正确答案: 对</p>
<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="单选题-2"><a href="#单选题-2" class="headerlink" title="单选题"></a>单选题</h3><p>在半殖民地半封建的近代中国，（）是各种矛盾中最主要的矛盾。<br>A: 地主阶级和资产阶级的矛盾<br>B: 帝国主义和中华民族的矛盾<br>C: 封建主义和人民大众的矛盾<br>D: 传统文化和西方文化的矛盾<br>正确答案: B</p>
<p>（）开辟了世界无产阶级社会主义革命的新纪元，标志着人类历史开始了由资本主义向社会主义转变的进程。<br>A: 法国大革命的胜利<br>B: 马克思主义的创立<br>C: 俄国十月革命的胜利<br>D: 中国共产党的成立<br>正确答案: C</p>
<p>以（）为标志，中国进入新民主主义革命阶段。<br>A: 戊戌变法<br>B: 辛亥革命<br>C: 五四运动<br>D: 北伐战争<br>正确答案: C</p>
<p>“（）”是以毛泽东为主要代表的中国共产党人在实践中总结出来的关于中国革命道路问题的科学概念。<br>A: 城市罢工<br>B: 工农武装割据<br>C: 议会民主斗争<br>D: 非暴力不合作<br>正确答案: B</p>
<p>关于新民主主义革命的总路线，下列理解中错误的是（）。<br>A: 新民主主义革命是无产阶级领导的革命<br>B: 新民主主义革命是资产阶级领导的革命<br>C: 新民主主义革命是人民大众的革命<br>D: 新民主主义革命反对帝国主义封建主义和官僚资本主义的革命<br>正确答案: B</p>
<p>分清敌友是革命的首要问题，中国革命的主要敌人不包括（）。<br>A: 帝国主义<br>B: 封建主义<br>C: 官僚资本主义<br>D: 民族资产阶级<br>正确答案: D</p>
<p>（）是中国革命的首要对象，其发动的一系列侵略战争给中华民族带来了无尽的战乱和灾难。<br>A: 官僚资本主义<br>B: 帝国主义<br>C: 封建主义<br>D: 买办阶级<br>正确答案: B</p>
<p>（）是中国社会进步和发展的最大障碍，是近代中国贫困落后和一切灾难祸害的总根源。<br>A: 封建主义<br>B: 帝国主义<br>C: 资本主义<br>D: 功利主义<br>正确答案: B</p>
<p>关于反对封建主义的内涵，下列理解中错误的是（）。<br>A: 在经济上消灭封建制度<br>B: 在政治上消灭军阀的专制统治<br>C: 与地主阶级达成妥协<br>D: 为中国的经济现代化和政治民主化创造条件<br>正确答案: C</p>
<p>关于官僚资本主义，下列描述中错误的是（）。<br>A: 通过国家垄断金融机构，滥发纸币和国债而疯狂侵吞社会财富<br>B: 通过建立国家专卖制度控制大量商品和物资而大肆牟取暴利<br>C: 通过超经济的特权垄断一些行业的经营权而压迫和兼并私人资本主义企业<br>D: 在自由竞争中充分发挥自身优势而发展壮大的资本主义<br>正确答案: D</p>
<p>在不同历史阶段，随着社会主要矛盾的变化，中国革命的主要对象有所不同，其具体体现不包括（）。<br>A: 在国共合作的大革命时期，革命的主要对象是帝国主义支持下的北洋军阀<br>B: 在土地革命战争时期，革命的主要对象是民族资产阶级<br>C: 在抗日战争时期，革命的主要对象是日本帝国主义<br>D: 在解放战争时期，革命的主要对象是美帝国主义支持下的国民党反动派<br>正确答案: B</p>
<p>（）是新的社会生产力的代表，是中国革命最基本的动力。<br>A: 无产阶级<br>B: 农民阶级<br>C: 地主阶级<br>D: 民族资产阶级<br>正确答案: A</p>
<p>关于中国无产阶级，下列描述中错误的是（）。<br>A: 是近代中国最进步的阶级<br>B: 伴随着外国资本主义在中国直接经营企业而产生<br>C: 是新的社会生产力的代表<br>D: 其产生与中国民族工业的产生和发展无关<br>正确答案: D</p>
<p>（）是中国革命的主力军，具有强烈的反帝反封建的革命要求。<br>A: 农民<br>B: 工人<br>C: 学生<br>D: 小商人<br>正确答案: A</p>
<p>（）是无产阶级最可靠的同盟军，同样受帝国主义封建主义和官僚资本主义的压迫。<br>A: 贫雇农<br>B: 中农<br>C: 富农<br>D: 地主<br>正确答案: A</p>
<p>下列各项中，不属于城市小资产阶级的是（）。<br>A: 知识分子<br>B: 小商人<br>C: 买办分子<br>D: 手工业者<br>正确答案: C</p>
<p>中国共产党对待民族资产阶级的正确政策不包括（）。<br>A: 在经济上实行保护民族工商业的政策<br>B: 在政治上争取民族资产阶级<br>C: 理解和包容民族资产阶级的动摇性和妥协性<br>D: 对民族资产阶级又斗争又联合<br>正确答案: C</p>
<p>下列各项中，不属于一般无产阶级的基本优点的是（）。<br>A: 与先进的生产方式相联系<br>B: 没有私人占有的生产资料<br>C: 富于组织纪律性<br>D: 掌握生产资料<br>正确答案: D</p>
<p>中国无产阶级自身的特点和优点不包括（）。<br>A: 因为身受外国资本主义本国封建势力和资产阶级的三重压迫而缺少革命力量<br>B: 分布集中，有利于无产阶级队伍的组织和团结<br>C: 成员中的大部分出身于破产农民，和农民有着天然的联系<br>D: 在革命斗争中比任何别的阶级都来得坚决和彻底<br>正确答案: A</p>
<p>新民主主义革命与旧民主主义革命相比有新的内容和特点，其集中表现不包括（）。<br>A: 新民主主义革命的领导力量是中国无产阶级及其先锋队——中国共产党<br>B: 新民主主义革命的指导思想是马克思列宁主义<br>C: 新民主主义革命是世界无产阶级社会主义革命的一部分<br>D: 新民主主义革命的前途是资本主义<br>正确答案: D</p>
<p>新民主主义革命与社会主义革命性质不同，其表现不包括（）。<br>A: 新民主主义革命在政治上争取和联合民族资产阶级去反对共同的敌人<br>B: 新民主主义革命在经济上保护民族工商业，容许有利于国计民生的私人资本主义发展<br>C: 新民主主义革命要建立的是资产阶级专政，而不是无产阶级专政<br>D: 新民主主义革命仍然属于资产阶级民主主义革命的范畴<br>正确答案: C</p>
<p>毛泽东在党的七大所作的政治报告（）中，进一步把新民主主义的政治经济和文化与党的基本纲领联系起来，进行了具体阐述。<br>A: 《论持久战》<br>B: 《论联合政府》<br>C: 《矛盾论》<br>D: 《论十大关系》<br>正确答案: B</p>
<p>关于新民主主义的政治纲领，下列理解中错误的是（）。<br>A: 推翻帝国主义和封建主义的统治<br>B: 建立一个无产阶级领导的以工农联盟为基础的各革命阶级联合专政的新民主主义的共和国<br>C: 新民主主义共和国不同于欧美式的资产阶级专政的共和国<br>D: 新民主主义共和国和苏联式的无产阶级专政的社会主义共和国完全相同<br>正确答案: D</p>
<p>新民主主义国家的国体是（）领导的以工农联盟为基础，包括小资产阶级民族资产阶级和其他反帝反封建的人们在内的各革命阶级的联合专政。<br>A: 无产阶级<br>B: 地主阶级<br>C: 民族资产阶级<br>D: 城市小资产阶级<br>正确答案: A</p>
<p>关于新民主主义的经济纲领，下列描述中错误的是（）。<br>A: 消灭民族资产阶级<br>B: 没收官僚资产阶级的垄断资本归新民主主义的国家所有<br>C: 保护民族工商业<br>D: 没收封建地主阶级的土地归农民所有<br>正确答案: A</p>
<p>关于土地革命路线，下列描述中错误的是（）。<br>A: 依靠贫雇农<br>B: 团结中农<br>C: 向地主妥协<br>D: 有步骤有分别地消灭封建剥削制度<br>正确答案: C</p>
<p>关于新民主主义文化，下列描述中错误的是（）。<br>A: 反对帝国主义压迫，主张中华民族的尊严和独立<br>B: 尊重中国的历史，反对民族虚无主义<br>C: 反对封建时代创造的一切文化<br>D: 以人民群众的实践作为创作的源泉，坚持为人民大众服务<br>正确答案: C</p>
<p>中国革命必须走农村包围城市武装夺取政权的道路，是由中国所处的时代特点和具体国情决定的，其具体表现不包括（）。<br>A: 中国的无产阶级根本不可能像在资本主义国家那样，先在城市经过长期的公开的合法斗争，然后再组织武装起义，夺取政权<br>B: 中国革命的主要斗争形式只能是武装斗争，以革命的武装消灭反革命的武装，相应的主要组织形式必然是军队<br>C: 必须充分地发动农民，否则就无法摧毁帝国主义和封建地主阶级反动统治的基础<br>D: 农民作为同盟军是不可靠的，这就要求无产阶级及其政党必须深入农村，从解决农民的土地问题入手<br>正确答案: D</p>
<p>毛泽东在（）中，对新民主主义革命的基本经验作了集中概括，丰富和发展了马克思主义关于无产阶级领导人民革命的理论。<br>A: 《论人民民主专政》<br>B: 《实践论》<br>C: 《井冈山的斗争》<br>D: 《关于正确处理人民内部矛盾的问题》<br>正确答案: A</p>
<h3 id="多选题-2"><a href="#多选题-2" class="headerlink" title="多选题"></a>多选题</h3><p>下列各项中，不能完成反帝反封建的革命任务的有（）。<br>A: 不触动封建根基的自强运动和改良主义<br>B: 旧式的农民战争<br>C: 资产阶级革命派领导的民主革命<br>D: 照搬西方资本主义的其他种种方案<br>正确答案: ABCD</p>
<p>在领导农村革命根据地的斗争实践中，毛泽东相继写下了（）等文章，提出了“工农武装割据”思想，初步形成了农村包围城市的革命道路理论。<br>A: 《中国的红色政权为什么能够存在?》<br>B: 《井冈山的斗争》<br>C: 《星星之火，可以燎原》<br>D: 《论持久战》<br>正确答案: ABC</p>
<p>中国革命走农村包围城市武装夺取政权的道路，根本在于处理好（）之间的关系。<br>A: 土地革命<br>B: 武装斗争<br>C: 议会民主斗争<br>D: 农村革命根据地建设<br>正确答案: ABD</p>
<p>新民主主义革命时期，中国共产党领导的统一战线，先后经历了（）等几个时期，为新民主主义革命的胜利作出了重要贡献。<br>A: 第一次国共合作的统一战线<br>B: 工农民主统一战线<br>C: 抗日民族统一战线<br>D: 人民民主统一战线<br>正确答案: ABCD</p>
<p>党在领导新民主主义革命的过程中，逐步形成了（）的优良作风，这是中国共产党区别于其他任何政党的显著标志。<br>A: 理论联系实际<br>B: 密切联系群众<br>C: 批评与自我批评相结合<br>D: 教条主义<br>正确答案: ABC</p>
<h3 id="判断题-2"><a href="#判断题-2" class="headerlink" title="判断题"></a>判断题</h3><p>认清中国国情，是解决中国革命问题的基本前提。<br>正确答案: 对</p>
<p>在近代中国，帝国主义的侵略为中国资本主义的发展创造了一切条件，并能使中国发展成为资本主义国家。<br>正确答案: 错</p>
<p>在近代中国，中国民族资本主义发展成为中国经济的主要形式，并在整个社会经济中占据主导地位。<br>正确答案: 错</p>
<p>近代中国的社会性质和主要矛盾，决定了中国革命是无产阶级革命。<br>正确答案: 错</p>
<p>新民主主义革命应当一步到位，直接完成社会主义革命任务。<br>正确答案: 错</p>
<p>新民主主义革命理论是适应新民主主义革命实践的需要，在认真总结中国革命经验教训的基础上形成的。<br>正确答案: 对</p>
<p>近代中国社会和革命斗争的发展，迫切期待新的阶级及其政党领导新的革命，呼唤新的革命理论的产生。<br>正确答案: 对</p>
<p>没有中国革命的实践，没有党对革命实践经验的概括和总结，新民主主义革命理论就无法形成和发展。<br>正确答案: 对</p>
<p>新民主主义革命总路线反映了中国革命的基本规律，指明了中国革命的对象动力领导力量，是新民主主义革命的指导路线。<br>正确答案: 对</p>
<p>分清敌友是新民主主义革命的首要问题。<br>正确答案: 对</p>
<p>近代中国所遭受的最大的压迫是来自帝国主义的民族压迫。<br>正确答案: 对</p>
<p>地主阶级是在政治上经济上文化上阻碍中国社会前进而没有丝毫进步作用的阶级，是中国经济现代化和政治民主化的主要障碍。<br>正确答案: 对</p>
<p>如果不推翻帝国主义的统治，就不能消灭封建地主阶级的统治。<br>正确答案: 对</p>
<p>如果推翻了地主阶级，就难以组织起强大的革命队伍来推翻帝国主义在中国的统治。<br>正确答案: 错</p>
<p>工人阶级只有与农民阶级结成巩固的联盟，才能形成强大的力量，才能完成反帝反封建的革命任务。<br>正确答案: 对</p>
<p>农民的革命动力作用可以全靠农民自身努力而得到充分发挥。<br>正确答案: 错</p>
<p>无产阶级的领导权是中国革命的中心问题，也是新民主主义革命理论的核心问题。<br>正确答案: 对</p>
<p>区别新旧两种不同范畴的民主主义革命的根本标志是，革命的领导权是掌握在无产阶级手中还是掌握在资产阶级手中。<br>正确答案: 对</p>
<p>帝国主义希望中国民族资产阶级能够建立独立的资产阶级共和国。<br>正确答案: 错</p>
<p>建立以工农联盟为基础的广泛的统一战线是无产阶级及其政党实现对各革命阶级的领导的关键。<br>正确答案: 对</p>
<p>中国的新民主主义革命实质上就是无产阶级领导下的农民革命。<br>正确答案: 对</p>
<p>近代中国半殖民地半封建社会的性质和中国革命的历史任务，决定了中国革命仍然是旧式的一般的资产阶级民主主义的革命<br>正确答案: 错</p>
<p>新民主主义革命与社会主义革命中间不容横插一个资产阶级专政。<br>正确答案: 对</p>
<p>只有认清新民主主义革命和社会主义革命的区别，又认清两者的联系，才能正确地领导中国革命。<br>正确答案: 对</p>
<p>资产阶级共和国的道路已被实践证明在中国行不通。<br>正确答案: 对</p>
<p>中国社会的性质决定了中国革命的历史进程必须分两步走。<br>正确答案: 对</p>
<p>在新民主主义的国家制度下，让私人资本主义经济无法获得任何发展的便利，有益于社会向前发展。<br>正确答案: 错</p>
<p>共产党的任务是经过长期合法斗争以进入起义和战争，先占城市后取乡村。<br>正确答案: 错</p>
<p>中国革命能走农村包围城市武装夺取政权的道路，是由中国所处的时代特点和特殊国情决定的。<br>正确答案: 对</p>
<p>中国革命道路理论，是党运用马克思主义的立场观点和方法，分析研究和解决中国革命具体问题的光辉典范，对于推进马克思主义中国化具有重要的方法论意义。<br>正确答案: 对</p>
<p>近代中国社会最大的压迫是民族压迫，决定了无产阶级及其政党可以把一切爱国的不愿受帝国主义奴役的人们团结在自己的周围。<br>正确答案: 对</p>
<p>在革命斗争中要依据革命的需要，对资产阶级实行既联合又斗争的策略。<br>正确答案: 对</p>
<p>在半殖民地半封建的旧中国，革命人民只有武装起来，以武装的革命反对武装的反革命。<br>正确答案: 对</p>
<p>没有一支人民的军队，便没有人民的一切，就不可能有人民的解放和国家的独立。<br>正确答案: 对</p>
<p>坚持党对军队的绝对领导，是建设新型人民军队的根本原则，是保持人民军队无产阶级性质和建军宗旨的根本前提，也是毛泽东建军思想的核心。<br>正确答案: 对</p>
<p>加强党的建设，必须同党的政治路线紧密联系起来，在贯彻执行党的政治纲领和路线中推进党的建设。<br>正确答案: 对</p>
<p>中国共产党对统一战线武装斗争和党的建设这三个基本问题的认识是逐步明确的。<br>正确答案: 对</p>
<p>中国新民主主义革命的伟大胜利，有力地鼓舞和推动了世界上被压迫民族和被压迫人民反抗帝国主义殖民主义的斗争，极大地增强了他们反对帝国主义斗争的信心，增强了世界人民争取和平的力量。<br>正确答案: 对</p>
<h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><h3 id="单选题-3"><a href="#单选题-3" class="headerlink" title="单选题"></a>单选题</h3><p>（）是我国从新民主主义到社会主义的过渡时期。<br>A: 从全面内战爆发到中华人民共和国成立<br>B: 从中华人民共和国成立到抗美援朝战争胜利<br>C: 从中华人民共和国成立到社会主义改造基本完成<br>D: 从解放战争胜利到土地改革基本完成<br>正确答案: C</p>
<p>在新民主主义时期，随着土地改革的基本完成，（）逐步成为我国社会的主要矛盾。<br>A: 地主阶级和资产阶级的矛盾<br>B: 帝国主义和中华民族的矛盾<br>C: 工人阶级和资产阶级的矛盾<br>D: 封建主义和人民大众的矛盾<br>正确答案: C</p>
<p>（）提出了使中国“稳步地由农业国转变为工业国，由新民主主义国家转变为社会主义国家”即“两个转变”同时并举的思想。<br>A: 党的一大<br>B: 遵义会议<br>C: 党的六届六中全会<br>D: 党的七届二中全会<br>正确答案: D</p>
<p>到（）年，我国国民经济得以恢复，民主革命遗留任务已经完成，经济政治及社会面貌发生巨大变化。<br>A: 1949<br>B: 1952<br>C: 1954<br>D: 1956<br>正确答案: B</p>
<p>党在过渡时期总路线的主要内容被概括为“一化三改”，其中“三改”不包括（）。<br>A: 对个体农业的社会主义改造<br>B: 对手工业的社会主义改造<br>C: 对资本主义工商业的社会主义改造<br>D: 对军工业的社会主义改造<br>正确答案: D</p>
<p>关于适合我国情况的农业社会主义改造道路，下列描述中错误的是（）。<br>A: 对农民不能采取剥夺的办法，只能引导说服和教育，使其自愿地走合作化的道路<br>B: 只需要发展农民在互助合作上的积极性，不需要关注他们在个体经济上的积极性<br>C: 依靠贫下中农，发展互助合作，由逐步限制到最后消灭富农剥削<br>D: 高级社实行生产资料农民集体所有按劳付酬，取消土地分红<br>正确答案: B</p>
<p>关于适合我国情况的对资本主义工商业进行社会主义改造的道路，下列描述中错误的是（）。<br>A: 用强制的方法改造资本主义工商业<br>B: 将工人阶级和民族资产阶级之间存在着的对抗性矛盾转化为非对抗性矛盾并按照人民内部矛盾来处理<br>C: 采取从低级到高级的国家资本主义的过渡形式<br>D: 把资本主义工商业者改造成为自食其力的社会主义劳动者<br>正确答案: A</p>
<p>对资本主义工商业实行和平赎买的优点不包括（）。<br>A: 有利于发挥私营工商业在国计民生方面的积极作用<br>B: 有利于争取和团结民族资产阶级<br>C: 有利于激化工人阶级和民族资产阶级之间的对抗性矛盾<br>D: 有利于发挥民族资产阶级中大多数人的知识才能技术专长和管理经验<br>正确答案: C</p>
<p>我国能够采取赎买的方式对资本主义工商业进行和平改造的原因不包括（）。<br>A: 民族资产阶级既有剥削工人取得利润的一面，又有拥护宪法愿意接受社会主义改造的一面<br>B: 中国共产党与民族资产阶级长期保持着统一战线的关系<br>C: 我国建立了强大的社会主义国营经济并掌握了国家的经济命脉<br>D: 我国工人阶级和民族资产阶级之间不存在矛盾<br>正确答案: D</p>
<p>关于我国社会主义改造中出现的国家资本主义经济，下列描述中错误的是（）。<br>A: 在人民政府管理之下<br>B: 用各种形式和国营社会主义经济联系着<br>C: 主要是为了资本家的利润而存在<br>D: 受工人监督<br>正确答案: C</p>
<p>国家资本主义有初级形式和高级形式之分，下列各项中，属于高级形式的国家资本主义的是（）。<br>A: 统购包销<br>B: 公私合营<br>C: 委托加工<br>D: 计划订货<br>正确答案: B</p>
<p>适合我国情况的对资本主义工商业进行社会主义改造的道路，把资本主义工商业者改造成为自食其力的社会主义劳动者，其作用和意义不包括（）。<br>A: 对企业的改造和对人的改造相结合<br>B: 改造资本家个人与消灭他们所属的资产阶级相结合<br>C: 避免了激烈的阶级对抗，减少了改造的阻力<br>D: 阻碍了生产力的发展和社会的进步<br>正确答案: D</p>
<p>在进行社会主义改造向社会主义过渡的进程中，中国共产党积累了丰富的历史经验，其中不包括（）。<br>A: 坚持社会主义工业化建设与社会主义改造同时并举<br>B: 采取积极引导逐步过渡的方式<br>C: 用和平方法进行改造<br>D: 完全照搬了列宁在俄国对资产阶级进行和平赎买的成功经验<br>正确答案: D</p>
<p>到1956年我国社会主义改造基本完成时，“（）”计划的主要指标已提前完成，到1957年，各项指标均超额完成。<br>A: 一五<br>B: 二五<br>C: 三五<br>D: 四五<br>正确答案: A</p>
<p>经过“一五”期间的大规模建设，我国以（）为重点的社会主义工业化基础已初步建立。<br>A: 重工业<br>B: 轻工业<br>C: 农业<br>D: 商业<br>正确答案: A</p>
<p>中国共产党坚持社会主义改造与社会主义工业化同时并举的方针，在深刻的社会变革中的重要意义不包括（）。<br>A: 阻碍生产力发展<br>B: 保持社会稳定<br>C: 逐步改善人民生活<br>D: 推动社会进步<br>正确答案: A</p>
<p>1954年9月，第一届全国人民代表大会的召开和（）的制定及颁布施行，为各族人民参与国家政治生活提供了必要条件和保证，为逐步健全和完善我国社会主义政治制度奠定了坚实的基础。<br>A: 《中华人民共和国婚姻法》<br>B: 《中华人民共和国宪法》<br>C: 《中华人民共和国土地改革法》<br>D: 《中华人民共和国民法（草稿）》<br>正确答案: B</p>
<p>社会主义基本制度确立后，伴随着社会经济制度和社会经济结构的根本变化，我国社会的阶级关系也发生了根本的变化，其具体表现不包括（）。<br>A: 帝国主义侵略势力已经被清除出中国大陆<br>B: 官僚资产阶级已经在中国内地被消灭<br>C: 民族资产阶级已经成为国家的领导阶级<br>D: 广大劳动人民从此摆脱了被剥削被奴役的地位<br>正确答案: C</p>
<p>社会主义基本制度的确立不仅再次证明了马克思列宁主义的真理性，而且以其独创性的理论原则和经验总结丰富和发展了（）理论。<br>A: 空想社会主义<br>B: 科学社会主义<br>C: 封建主义<br>D: 资本主义<br>正确答案: B</p>
<h3 id="多选题-3"><a href="#多选题-3" class="headerlink" title="多选题"></a>多选题</h3><p>适合我国情况的农业社会主义改造道路，要遵循（）的原则，以互助合作的优越性吸引农民走互助合作道路。<br>A: 自愿互利<br>B: 典型示范<br>C: 国家帮助<br>D: 强制剥夺<br>正确答案: ABC</p>
<p>（）是党在农村的依靠力量，解决了在农村依靠农民大多数和建立无产阶级优势的问题。<br>A: 贫农<br>B: 上中农<br>C: 下中农<br>D: 富农<br>正确答案: AC</p>
<p>对手工业的社会主义改造，党和政府采取了（）的方针。<br>A: 积极领导<br>B: 顺其自然<br>C: 稳步前进<br>D: 迅猛突进<br>正确答案: AC</p>
<p>在手工业的社会主义改造过程中，党和政府采取（）的方法，使手工业者自愿参加到手工业合作社中来。<br>A: 说服教育<br>B: 示范<br>C: 强制<br>D: 国家帮助<br>正确答案: ABD</p>
<p>初级形式的国家资本主义是国家对私营工商业实行（）等。<br>A: 委托加工<br>B: 计划订货<br>C: 统购包销<br>D: 经销代销<br>正确答案: ABCD</p>
<p>初级形式的国家资本主义对私营工商业的利润，按（）等方面进行分配。<br>A: 国家所得税<br>B: 企业公积金<br>C: 工人福利费<br>D: 资方红利<br>正确答案: ABCD</p>
<p>在资本主义工商业的社会主义改造中，国家对资方在职人员和资方代理人（），通过改造阶级成分的方式达到从整体上消灭资产阶级的目的。<br>A: 在政治上适当安排<br>B: 在工作上发挥作用<br>C: 在生产上排除在外<br>D: 在生活上妥善照顾<br>正确答案: ABD</p>
<p>我国对农业手工业和资本主义工商业的改造，都采取了（）的方式。<br>A: 区别对象<br>B: 积极引导<br>C: 逐步过渡<br>D: 盲目推进<br>正确答案: ABC</p>
<h3 id="判断题-3"><a href="#判断题-3" class="headerlink" title="判断题"></a>判断题</h3><p>新民主主义社会是由新民主主义向社会主义转变的独立的社会形态。<br>正确答案: 错</p>
<p>在新民主主义时期，民族资产阶级作为一个剥削阶级，必须被彻底消灭，无法团结和改造。<br>正确答案: 错</p>
<p>在新民主主义社会中，社会主义的因素在政治上居于领导地位，非社会主义因素在经济上居于领导地位。<br>正确答案: 错</p>
<p>新民主主义社会是属于社会主义体系的，是逐步过渡到社会主义社会的过渡性质的社会。<br>正确答案: 对</p>
<p>要从根本上改变中国贫穷落后的面貌，把中国从一个落后的农业国变为一个先进的工业国，就必须实现国家的工业化。<br>正确答案: 对</p>
<p>实现社会主义工业化，是国家独立和富强的必然要求和必要条件。<br>正确答案: 对</p>
<p>中国社会经济状况不允许走资本主义道路，如果搞资本主义只能成为帝国主义的附庸。<br>正确答案: 对</p>
<p>马克思恩格斯在创立科学社会主义理论时，就提出了从资本主义社会向社会主义社会过渡的问题。<br>正确答案: 对</p>
<p>国家资本主义是一种独立的经济形态，其性质必然是资本主义的。<br>正确答案: 错</p>
<p>全行业公私合营后，企业的生产关系仍然是资本主义的。<br>正确答案: 错</p>
<p>在社会主义改造过程中，党和政府所采取的实际步骤，总是力求使之与促进工业化进程和经济发展的要求相适应，而不允许对生产力造成破坏。<br>正确答案: 对</p>
<p>坚持用和平的办法，不仅保证了我国社会主义改造的顺利进行，而且维护了社会的稳定，极大地促进了社会主义事业的发展。<br>正确答案: 对</p>
<p>我国的社会主义改造取得了历史性的胜利，也出现了一些失误和偏差，但是，不能因为出现这些失误和偏差而否定社会主义改造的伟大意义。<br>正确答案: 对</p>
<p>判断历史的功绩，不是根据历史活动家没有提供现代所要求的东西，而是根据他们比他们的前辈提供了新的东西。<br>正确答案: 对</p>
<p>我国社会主义改造的基本完成是一个伟大的历史性胜利，是中国共产党紧紧依靠人民所作出的伟大创造。<br>正确答案: 对</p>
<p>社会主义公有制成为我国社会的经济基础，标志着中国历史上长达数千年的阶级剥削制度的结束和社会主义基本制度的确立。<br>正确答案: 对</p>
<p>经济文化比较落后的国家无法先于发达国家实行社会主义革命建立社会主义制度。<br>正确答案: 错</p>
<p>世界历史发展的一般规律不仅丝毫不排斥个别发展阶段在发展的形式或顺序上表现出特殊性，反而以此为前提。<br>正确答案: 对</p>
<p>中国无法在没有实现工业化的情况下进入社会主义。<br>正确答案: 错</p>
<p>中国的社会主义可以不经过社会生产力的极大发展就超越初级阶段。<br>正确答案: 错</p>
<p>社会主义基本制度的确立是中国历史上最深刻最伟大的社会变革，为当代中国一切发展进步奠定了制度基础，也为中国特色社会主义制度的创新和发展提供了重要前提。<br>正确答案: 对</p>
<p>社会主义基本制度的确立，极大地提高了工人阶级和广大劳动人民的积极性创造性，极大地促进了我国社会生产力的发展。<br>正确答案: 对</p>
<p>我国工业化现代化建设取得的辉煌成就，离不开选择了社会主义道路这个根本的前提条件。<br>正确答案: 对</p>
<p>实现中华民族伟大复兴，必须建立符合我国实际的先进社会制度。<br>正确答案: 对</p>
<p>社会主义基本制度的确立，使广大劳动人民真正成为国家的主人。<br>正确答案: 对</p>
<p>社会主义基本制度的确立，是马克思列宁主义关于社会主义革命理论在中国的正确运用和创造性发展的结果。<br>正确答案: 对</p>
<h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><h3 id="单选题-4"><a href="#单选题-4" class="headerlink" title="单选题"></a>单选题</h3><p>毛泽东的（）初步总结了我国社会主义建设的经验，明确提出要以苏为鉴，独立自主地探索适合中国情况的社会主义建设道路。<br>A: 《论持久战》<br>B: 《论十大关系》<br>C: 《中国的红色政权为什么能够存在?》<br>D: 《井冈山的斗争》<br>正确答案: B</p>
<p>党在八大前后，特别是毛泽东在1957年2月所作的（）的报告，系统论述了社会主义社会矛盾的理论。<br>A: 《关于正确处理人民内部矛盾的问题》<br>B: 《论联合政府》<br>C: 《新民主主义论》<br>D: 《论人民民主专政》<br>正确答案: A</p>
<p>下列各项中，不属于人民内部矛盾的是（）。<br>A: 工人农民同知识分子之间的矛盾<br>B: 政府和人民群众之间的矛盾<br>C: 人民同反抗社会主义革命敌视和破坏社会主义建设的社会势力和社会集团的矛盾<br>D: 国家机关某些工作人员的官僚主义作风同群众之间的矛盾<br>正确答案: C</p>
<p>在人民民主专政下面，解决人民内部矛盾要采用民主的方法，其具体做法不包括（）。<br>A: 讨论的方法<br>B: 批评的方法<br>C: 说服教育的方法<br>D: 强迫从事劳动的方法<br>正确答案: D</p>
<p>针对人民内部矛盾在具体实践中的不同情况，毛泽东提出了一系列具体方针原则，其中不包括（）。<br>A: 对于人民群众和政府机关的矛盾，只需要加强对群众的思想教育<br>B: 对于民族之间的矛盾，实行民族平等团结互助的方针，着重反对大汉族主义，也要反对地方民族主义<br>C: 对于科学文化领域里的矛盾，实行“百花齐放百家争鸣”的方针，通过自由讨论和科学实践艺术实践去解决<br>D: 对于共产党和民主党派的矛盾，实行在坚持社会主义道路和共产党领导的前提下“长期共存互相监督”的方针<br>正确答案: A</p>
<p>在（）中，毛泽东明确提出了中国工业化道路的问题，主要是指重工业轻工业和农业的发展关系问题，要走一条有别于苏联的中国工业化道路。<br>A: 《关于正确处理人民内部矛盾的问题》<br>B: 《论联合政府》<br>C: 《新民主主义论》<br>D: 《井冈山的斗争》<br>正确答案: A</p>
<p>下列各项中，不符合毛泽东所提出的工业化发展思路的是（）。<br>A: 重工业和轻工业同时并举<br>B: 中央工业和地方工业同时并举<br>C: 投入全部精力发展沿海工业<br>D: 大型企业和中小型企业同时并举<br>正确答案: C</p>
<p>走中国工业化道路，必须采取正确的经济建设方针，其中不包括（）。<br>A: 正确处理国家集体与个人的关系<br>B: 顾全大局，突出重点<br>C: 统筹兼顾，全面安排，综合平衡<br>D: 拒斥资本主义国家先进的科学技术和管理经验<br>正确答案: D</p>
<p>走中国工业化道路，必须调整和完善所有制结构，下列各项中，不符合“三个主体，三个补充”的设想的是（）。<br>A: 一定数量的个体经济是国家经济和集体经济的补充<br>B: 按照市场变化在国家计划许可范围内的自由生产是计划生产的补充<br>C: 自由市场是社会主义的统一市场的主体<br>D: 一定范围内的国家领导的自由市场是国家市场的补充<br>正确答案: C</p>
<p>走中国工业化道路，必须积极探索适合我国情况的经济体制和运行机制，下列各项中，不符合“两参一改三结合”的企业管理制度的是（）。<br>A: 干部参加劳动<br>B: 全社会参加管理<br>C: 改革不合理的规章制度<br>D: 工人群众领导干部和技术人员三结合<br>正确答案: B</p>
<h3 id="多选题-4"><a href="#多选题-4" class="headerlink" title="多选题"></a>多选题</h3><p>《论十大关系》中的前三条讲（），实际上是在论述如何开辟一条和苏联有所不同的中国工业化道路问题。<br>A: 重工业和轻工业农业的关系<br>B: 沿海工业和内地工业的关系<br>C: 经济建设和国防建设的关系<br>D: 国家资本主义和民族资本主义的关系<br>正确答案: ABC</p>
<p>《论十大关系》中的后五条，讲（）中国和外国的关系，论述的是政治生活和思想文化生活领域如何调动各种积极因素的问题。<br>A: 汉族与少数民族的关系<br>B: 党与非党的关系<br>C: 革命和反革命的关系<br>D: 是非关系<br>正确答案: ABCD</p>
<p>在中国这样的国家，社会主义建设具有（）。<br>A: 艰难性<br>B: 复杂性<br>C: 长期性<br>D: 短期性<br>正确答案: ABC</p>
<p>社会主义改造基本完成后，党的八大指出，我们国内的主要矛盾是（）。<br>A: 人民对于建立先进的工业国的要求同落后的农业国的现实之间的矛盾<br>B: 人民对于经济文化迅速发展的需要同当前经济文化不能满足人民需要的状况之间的矛盾<br>C: 人民日益增长的物质文化需要同落后的社会生产之间的矛盾<br>D: 人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾<br>正确答案: AB</p>
<p>正确处理政治思想领域的人民内部矛盾，要实行“团结一批评一团结”的方针，坚持（）的方法。<br>A: 说服教育<br>B: 批判<br>C: 讨论<br>D: 斗争<br>正确答案: AC</p>
<p>正确处理物质利益分配方面的人民内部矛盾，就要实行（）的方针，兼顾国家集体和个人三方面的利益<br>A: 统筹兼顾<br>B: 平均分配<br>C: 适当安排<br>D: 牺牲个人<br>正确答案: AC</p>
<p>正确处理科学文化领域里的矛盾，就要实行“（）”的方针，通过自由讨论和科学实践艺术实践去解决。<br>A: 百花齐放<br>B: 杜绝争议<br>C: 崇古抑今<br>D: 百家争鸣<br>正确答案: AD</p>
<p>正确处理共产党和民主党派的矛盾，就要实行在坚持社会主义道路和共产党领导的前提下“（）”的方针<br>A: 长期共存<br>B: 互相监督<br>C: 勾心斗角<br>D: 互相提防<br>正确答案: AB</p>
<p>由于受苏联工业化模式的影响，我国一度过多强调（）的建设，影响了农业和轻工业的发展，造成了一定程度的比例失调。<br>A: 手工业<br>B: 重工业<br>C: 基础设施<br>D: 金融业<br>正确答案: BC</p>
<p>如果我们不建设起强大的现代化的（），我们就不能摆脱落后和贫困，我们的革命就不能达到目的。<br>A: 工业<br>B: 农业<br>C: 交通运输业<br>D: 国防<br>正确答案: ABCD</p>
<p>毛泽东提出，社会主义现代化的战略目标，是要把中国建设成为一个具有（）的强国。<br>A: 现代农业<br>B: 现代工业<br>C: 现代国防<br>D: 现代科学技术<br>正确答案: ABCD</p>
<p>走中国工业化道路，必须采取正确的经济建设方针，党的八大提出了（）的方针。<br>A: 鼓足干劲大力提高经济增长率<br>B: 既反保守又反冒进<br>C: 在综合平衡中稳步前进<br>D: 集中全力发展重工业<br>正确答案: BC</p>
<h3 id="判断题-4"><a href="#判断题-4" class="headerlink" title="判断题"></a>判断题</h3><p>实现马克思主义与中国实际的“第二次结合”，就是要照抄照搬苏联经验。<br>正确答案: 错</p>
<p>社会主义建设的积极因素与消极因素在一定条件下是可以互相转化的。<br>正确答案: 对</p>
<p>调动一切积极因素为社会主义事业服务，必须坚持中国共产党的领导。<br>正确答案: 对</p>
<p>调动一切积极因素为社会主义事业服务，必须发展社会主义民主政治。<br>正确答案: 对</p>
<p>我国社会主义改造的任务完成以后，国内的社会矛盾和阶级关系发生重大变化，无产阶级同资产阶级之间的矛盾已经基本解决。<br>正确答案: 对</p>
<p>社会主义社会不存在矛盾。<br>正确答案: 错</p>
<p>社会主义社会的基本矛盾是在生产关系和生产力基本适应上层建筑和经济基础基本适应条件下的矛盾。<br>正确答案: 对</p>
<p>社会主义社会的基本矛盾是在人民根本利益一致基础上的矛盾，是非对抗性的矛盾。<br>正确答案: 对</p>
<p>敌我矛盾和人民内部矛盾不会互相转化。<br>正确答案: 错</p>
<p>毛泽东关于社会主义社会矛盾的学说，为正确处理社会主义社会各种矛盾创造良好的社会环境和政治环境，提供了基本的理论依据，也为后来的社会主义改革奠定了理论基础。<br>正确答案: 对</p>
<p>实现工业化是中国近代以来历史发展的必然要求，也是民族独立和国家富强的必要条件。<br>正确答案: 对</p>
<p>中华人民共和国的成立，为我国实现工业化提供了根本的政治前提。<br>正确答案: 对</p>
<p>只有农业发展了，工业才有原料和市场，才有可能为建立重工业积累较多的资金。<br>正确答案: 对</p>
<p>知识分子是工人阶级的一部分。<br>正确答案: 对</p>
<p>走中国工业化道路，必须积极探索适合我国情况的经济体制和运行机制。<br>正确答案: 对</p>
<p>关于社会主义建设的正确的理论原则和经验总结，丰富和发展了毛泽东思想，对我国社会主义建设发挥了重要指导作用，为开启新时期新道路奠定了重要的思想基础。<br>正确答案: 对</p>
<p>中国的社会主义与马克思恩格斯设想的在生产力高度发达基础上建立的社会主义完全相同。<br>正确答案: 错</p>
<p>社会主义建设有固定不变的模式，各个国家可以无视具体国情而照搬照抄。<br>正确答案: 错</p>
<p>我们党领导人民进行社会主义建设的改革开放前和改革开放后两个历史时期，相互联系又有重大区别，但本质上都是我们党领导人民进行社会主义建设的实践探索。<br>正确答案: 对</p>
<p>改革开放前的社会主义实践探索为改革开放后的社会主义实践探索积累了经验并准备了条件，改革开放后的社会主义实践探索是对前一个时期探索的坚持改革发展。<br>正确答案: 对</p>
<h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><h3 id="单选题-5"><a href="#单选题-5" class="headerlink" title="单选题"></a>单选题</h3><p>1978年冬，（）的18户农民创造了包干到户，这个办法简便易行，成效显著，受到农民欢迎。<br>A: 安徽省凤阳县小岗村<br>B: 江苏省江阴市华西村<br>C: 浙江省诸暨市枫桥镇<br>D: 山西省昔阳县大寨村<br>正确答案: A</p>
<p>1978年12月召开的（），确定把全党工作的着重点转移到社会主义现代化建设上来，作出实行改革开放的重大决策，实现了党的历史上具有深远意义的伟大转折。<br>A: 党的七届二中全会<br>B: 党的十一届三中全会<br>C: 党的十一届六中全会<br>D: 党的十三届四中全会<br>正确答案: B</p>
<p>（）冲破了“两个凡是”的严重束缚，在全国引起强烈反响，引发了关于真理标准的大讨论，推动了各条战线各个领域拨乱反正的启动和开展。<br>A: 《纪念白求恩》<br>B: 《为人民服务》<br>C: 《愚公移山》<br>D: 《实践是检验真理的唯一标准》<br>正确答案: D</p>
<p>（）为党的十一届三中全会的召开作了重要的思想准备，对于改变党和国家的历史命运，产生了重大而深远的影响。<br>A: “问题与主义”论战<br>B: 科学与玄学论战<br>C: 真理标准问题大讨论<br>D: 人性问题讨论<br>正确答案: C</p>
<p>1982年邓小平在（）开幕词中明确指出：“把马克思主义的普遍真理同我国的具体实际结合起来，走自己的道路，建设有中国特色的社会主义，这就是我们总结长期历史经验得出的基本结论。”<br>A: 党的十一大<br>B: 党的十二大<br>C: 党的十三大<br>D: 党的十四大<br>正确答案: B</p>
<p>1984年党的十二届三中全会作出了（），提出了社会主义经济是公有制基础上的有计划的商品经济。<br>A: 《中共中央关于整党的决定》<br>B: 《中共中央关于社会主义精神文明建设指导方针的决议》<br>C: 《中共中央关于制定国民经济和社会发展第七个五年计划的建议》<br>D: 《关于经济体制改革的决定》<br>正确答案: D</p>
<p>1987年召开的（）第一次比较系统地论述了我国社会主义初级阶段理论，明确概括和全面阐发了党的“一个中心两个基本点”的基本路线。<br>A: 党的十二大<br>B: 党的十三大<br>C: 党的十四大<br>D: 党的十五大<br>正确答案: B</p>
<p>1997年召开的（）正式提出“邓小平理论”这一概念，深刻阐述了邓小平理论的历史地位和指导意义。<br>A: 党的十三大<br>B: 党的十四大<br>C: 党的十五大<br>D: 党的十六大<br>正确答案: C</p>
<p>（）年的宪法修正案正式将邓小平理论载入宪法。<br>A: 1988<br>B: 1993<br>C: 1999<br>D: 2004<br>正确答案: C</p>
<p>（）是邓小平在领导改革开放和现代化建设这一新的革命过程中，不断提出和反复思考的首要的基本的理论问题。<br>A: 什么是社会主义怎样建设社会主义<br>B: 建设一个什么样的党怎样建设党<br>C: 实现什么样的发展怎样发展<br>D: 新时代坚持和发展什么样的中国特色社会主义怎样坚持和发展中国特色社会主义<br>正确答案: A</p>
<p>邓小平关于社会主义本质的概括，遵循了（）的基本原则，反映了人民的利益和时代的要求。<br>A: 空想社会主义<br>B: 新自由主义<br>C: 国家资本主义<br>D: 科学社会主义<br>正确答案: D</p>
<p>1978年12月13日，邓小平在中央工作会议闭幕会上作题为（）的讲话，这个讲话是解放思想开辟新时期新道路的宣言书，实际上成为随后召开的党的十一届三中全会的主题报告。<br>A: 《改革是中国的第二次革命》<br>B: 《坚持四项基本原则》<br>C: 《解放思想，实事求是，团结一致向前看》<br>D: 《在武昌深圳珠海上海等地的谈话要点》<br>正确答案: C</p>
<p>1992年初邓小平（），是全面改革进程中思想解放的科学总结。<br>A: 《在武昌深圳珠海上海等地的谈话要点》<br>B: 《解放思想，实事求是，团结一致向前看》<br>C: 《保持香港的繁荣和稳定》<br>D: 《改革是中国发展生产力的必由之路》<br>正确答案: A</p>
<p>关于社会主义初级阶段的论断，下列理解中错误的是（）。<br>A: 我国已经进入社会主义社会<br>B: 我国必须坚持而不能离开社会主义<br>C: 我国的社会主义社会还处在不发达的阶段<br>D: 我国必须正视并且迅速超越社会主义初级阶段<br>正确答案: D</p>
<p>“以（）为中心”回答了社会主义的根本任务问题，体现了发展生产力的本质要求。<br>A: 经济建设<br>B: 政治建设<br>C: 文化建设<br>D: 社会建设<br>正确答案: A</p>
<p>“坚持四项基本原则”，回答了解放和发展生产力的政治保证问题，体现了（）基本制度的要求。<br>A: 社会主义<br>B: 资本主义<br>C: 共产主义<br>D: 封建主义<br>正确答案: A</p>
<p>“坚持改革开放”，回答了（）问题，体现了解放生产力的本质要求。<br>A: 社会主义的本质要求<br>B: 解放和发展生产力的政治保证<br>C: 社会主义的根本任务<br>D: 社会主义的发展动力和外部条件<br>正确答案: D</p>
<p>邓小平“三步走”的发展战略构想的第一步是，从1981年到（）年实现国民生产总值比1980年翻一番，解决人民的温饱问题。<br>A: 1985<br>B: 1990<br>C: 1995<br>D: 2000<br>正确答案: B</p>
<p>邓小平“三步走”的发展战略构想的第二步是，从1991年到20世纪末，使国民生产总值再翻一番，达到（）水平。<br>A: 温饱<br>B: 小康<br>C: 全面小康<br>D: 富裕<br>正确答案: B</p>
<p>邓小平“三步走”的发展战略构想的第三步是，到（），国民生产总值再翻两番，达到中等发达国家水平，基本实现现代化。然后在这个基础上继续前进。<br>A: 20世纪末<br>B: 建党一百年时<br>C: 21世纪中叶<br>D: 21世纪末<br>正确答案: C</p>
<p>关于改革的理解，下列各项中错误的是（）。<br>A: 改革将把一个经济文化比较落后的社会主义中国变成一个现代化的社会主义国家<br>B: 改革是一个阶级推翻另一个阶级的革命<br>C: 改革要从根本上改变束缚我国生产力发展的经济体制<br>D: 改革要建立充满生机和活力的社会主义新经济体制<br>正确答案: B</p>
<p>改革是一项崭新的事业，是一个大试验，其要求不包括（）。<br>A: 胆子要大，步子要稳<br>B: 不能因循守旧，四平八稳<br>C: 为了尽快成功，可以超越社会发展阶段<br>D: 要以“三个有利于”为标准来判断改革和各方面工作的是非得失<br>正确答案: C</p>
<p>关于对外开放，下列说法中错误的是（）。<br>A: 加强国际交往，引进发达国家的先进经验先进科学技术和资金<br>B: 要发挥自己的比较优势，使国内经济与国际经济实现必要的互接互补<br>C: 实行对外开放，就不需要再艰苦奋斗和自力更生<br>D: 对外开放是对世界所有国家的开放<br>正确答案: C</p>
<p>改革开放开始后的一个很长时期内，我国经济体制改革的核心问题是如何正确认识和处理（）的关系。<br>A: 计划与市场<br>B: 投资与贸易<br>C: 无产阶级与资产阶级<br>D: 发展与安全<br>正确答案: A</p>
<p>关于社会主义市场经济理论，下列理解中错误的是（）。<br>A: 计划经济和市场经济不是划分社会制度的标志<br>B: 社会主义实行市场经济要把计划的手段和市场的手段结合起来<br>C: 市场经济作为资源配置的一种方式本身不具有制度属性<br>D: 计划的手段无法调节经济活动<br>正确答案: D</p>
<p>坚持（）的结合，是社会主义市场经济的特色所在优势所在。<br>A: 社会主义制度与市场经济<br>B: 资本主义制度与市场经济<br>C: 社会主义制度与计划经济<br>D: 资本主义制度与计划经济<br>正确答案: A</p>
<h3 id="多选题-5"><a href="#多选题-5" class="headerlink" title="多选题"></a>多选题</h3><p>邓小平始终站在时代潮流的前面，热情地（）人民群众的生机勃勃的伟大创造。<br>A: 支持<br>B: 鼓励<br>C: 保护<br>D: 引导<br>正确答案: ABCD</p>
<p>解放思想实事求是的思想路线，体现了（）的世界观方法论，体现了革命胆略和科学精神的统一。<br>A: 辩证唯物主义<br>B: 空想社会主义<br>C: 历史唯物主义<br>D: 教条主义<br>正确答案: AC</p>
<p>邓小平关于社会主义初级阶段的论断，使我们对社会主义建设的（）有了更加清醒的认识。<br>A: 长期性<br>B: 复杂性<br>C: 简单性<br>D: 艰巨性<br>正确答案: ABD</p>
<p>判断改革和各方面工作的是非得失，归根到底，要以（）为标准。<br>A: 是否有利于发展社会主义社会的生产力<br>B: 是否有利于增强社会主义国家的综合国力<br>C: 是否有利于提高人民的生活水平<br>D: 是否有利于激化人民内部矛盾<br>正确答案: ABC</p>
<p>改革开放以来，随着企业自主权的逐步扩大和经营机制的逐步转换，多种经济成分参与的流通体制的逐步形成，促进了（）信息在城乡市场的流动，初步显示了市场的作用和活力。<br>A: 物资<br>B: 劳力<br>C: 资金<br>D: 技术<br>正确答案: ABCD</p>
<p>邓小平强调，党的各级干部，首先是领导干部，要重视马克思主义的理论学习，从而加强我们工作中的（）。<br>A: 原则性<br>B: 系统性<br>C: 预见性<br>D: 创造性<br>正确答案: ABCD</p>
<p>邓小平强调，要坚持和健全民主集中制加强和改进党的基层组织建设，按照“（）”的方针培养和选拔德才兼备的领导干部。<br>A: 革命化<br>B: 年轻化<br>C: 知识化<br>D: 专业化<br>正确答案: ABCD</p>
<p>邓小平指出，领导制度组织制度问题更带有（）。<br>A: 根本性<br>B: 全局性<br>C: 稳定性<br>D: 长期性<br>正确答案: ABCD</p>
<p>邓小平开创性地提出了（）“一国两制”等具有浓厚中国特色的新概念新范畴，建构了中国特色社会主义理论的基本框架。<br>A: 社会主义本质<br>B: 社会主义初级阶段<br>C: 党的基本路线<br>D: 改革开放<br>正确答案: ABCD</p>
<p>邓小平理论第一次比较系统地初步回答了中国社会主义的（）外部条件政治保证战略步骤党的领导和依靠力量以及祖国统一等一系列基本问题，指导我们党制定了在社会主义初级阶段的基本路线。<br>A: 发展道路<br>B: 发展阶段<br>C: 根本任务<br>D: 发展动力<br>正确答案: ABCD</p>
<p>邓小平理论使改革开放后的中国发生天翻地覆的变化，迎来了（）文艺的繁荣科学的春天。<br>A: 思想的解放<br>B: 经济的发展<br>C: 政治的昌明<br>D: 教育的勃兴<br>正确答案: ABCD</p>
<h3 id="判断题-5"><a href="#判断题-5" class="headerlink" title="判断题"></a>判断题</h3><p>以新的思想观点去继承发展马克思主义，不是马克思主义者。<br>正确答案: 错</p>
<p>当今世界是互相孤立的世界，中国的发展必须脱离世界。<br>正确答案: 错</p>
<p>邓小平理论总结历史又正视现实放眼未来，把马克思主义基本原理同中国的国情和时代特征结合起来，在研究新情况解决新问题的过程中形成发展起来。<br>正确答案: 对</p>
<p>南方谈话是邓小平理论的集大成之作，从理论上深刻地回答了当时困扰和束缚人们思想的一系列重大问题，推动改革开放和社会主义现代化建设进入新阶段。<br>正确答案: 对</p>
<p>我国社会主义在改革开放前所经历的曲折和失误，归根到底就在于对什么是社会主义怎样建设社会主义这个问题没有完全搞清楚。<br>正确答案: 对</p>
<p>改革开放以来在前进中遇到的一些犹疑和困惑，归根到底就在于对什么是社会主义怎样建设社会主义这个问题没有完全搞清楚。<br>正确答案: 对</p>
<p>搞清楚什么是社会主义怎样建设社会主义，关键是要在“以阶级斗争为纲”的基础上进一步认清社会主义的本质。<br>正确答案: 错</p>
<p>邓小平关于社会主义本质的概括，廓清了不合乎时代进步和社会发展规律的模糊观念，摆脱了长期以来拘泥于具体模式而忽略社会主义本质的错误倾向。<br>正确答案: 对</p>
<p>在改革开放和现代化建设进程中，邓小平在关键时刻作出的每一项重大决策，都体现了解放思想实事求是的思想路线。<br>正确答案: 对</p>
<p>社会主义本身是共产主义的初级阶段，而我们中国又处在社会主义的高级阶段。<br>正确答案: 错</p>
<p>社会主义初级阶段理论基于对中国国情的准确把握，揭示了当代中国的历史方位。<br>正确答案: 对</p>
<p>社会主义初级阶段理论是建设中国特色社会主义的总依据，是对马克思主义关于社会主义发展阶段理论的重大发展和重大突破。<br>正确答案: 对</p>
<p>自力更生艰苦创业是我们党的优良传统，也是实现社会主义初级阶段奋斗目标的根本立足点。<br>正确答案: 对</p>
<p>以经济建设为中心的确定是党在新时期实现的最根本的拨乱反正。<br>正确答案: 对</p>
<p>以经济建设为中心是兴国之要，是党和国家兴旺发达长治久安的根本要求。<br>正确答案: 对</p>
<p>党的基本路线既紧紧抓住了中国现阶段的主要矛盾，又体现了运用社会主义社会基本矛盾运动的规律，全面推动历史进步，实现民富国强民族振兴的要求。<br>正确答案: 对</p>
<p>发展是硬道理，中国解决所有问题的关键是要靠借助国外援助来搞发展。<br>正确答案: 错</p>
<p>社会生产力的巨大发展，劳动生产率的大幅度提高，最主要的是靠科学的力量技术的力量。<br>正确答案: 对</p>
<p>科学技术是第一生产力。<br>正确答案: 对</p>
<p>“863计划”是科学家的战略眼光与政治家的高瞻远瞩相结合的产物，凝练了我国发展高科技的战略需求。<br>正确答案: 对</p>
<p>“863计划”的实施有力推动了我国高技术的进步及其产业发展，成为中国科学技术发展的一面旗帜。<br>正确答案: 对</p>
<p>在我国落后的生产力基础上实现社会主义现代化是一项十分艰巨的事业，必须有步骤分阶段实现。<br>正确答案: 对</p>
<p>实现“三步走”的发展战略，是真正对人类作出了贡献，就更加能够体现社会主义制度的优越性。<br>正确答案: 对</p>
<p>在中国搞现代化不能追求太高的速度，但速度低了也不行。<br>正确答案: 对</p>
<p>改革是中国的第二次革命。<br>正确答案: 对</p>
<p>改革就是否定和抛弃我们建立起来的社会主义基本制度。<br>正确答案: 错</p>
<p>改革只是对原有经济体制的细枝末节的修补。<br>正确答案: 错</p>
<p>改革是社会主义社会发展的直接动力。<br>正确答案: 对</p>
<p>关起门来搞建设是不行的，把自己孤立于世界之外是不利的。<br>正确答案: 对</p>
<p>社会主义作为后起的崭新的社会制度，必须大胆借鉴吸收人类社会包括资本主义社会创造出来的全部文明成果，结合新的实践进行新的创造，为我所用。<br>正确答案: 对</p>
<p>对外开放要高度珍惜并坚决维护中国人民经过长期奋斗得来的独立自主权利。<br>正确答案: 对</p>
<p>计划经济是社会主义的基本特征，市场经济是资本主义特有的东西。<br>正确答案: 错</p>
<p>建立社会主义市场经济体制是我们党的一个伟大创举，是我国经济体制改革在实践和理论上的重大突破。<br>正确答案: 对</p>
<p>越是集中力量发展经济，越是加快改革开放的步伐，就越需要社会主义精神文明提供强大的精神动力和智力支持，以保证物质文明建设的顺利进行。<br>正确答案: 对</p>
<p>邓小平的一系列“两手抓”，有利于克服实际工作中存在的“一手硬一手软”的问题，为我们党的领导方法和工作方法充实了新的内容。<br>正确答案: 对</p>
<p>完成祖国统一大业，是中华民族的根本利益所在，是全中国人民包括台湾同胞港澳同胞和海外侨胞的共同愿望。<br>正确答案: 对</p>
<p>反对分裂，坚持统一，是中华民族自古以来就有的传统。<br>正确答案: 对</p>
<p>“一国两制”是面对现实解决问题的好办法，顺应历史潮流，有功于民族，有益于人民。<br>正确答案: 对</p>
<p>台湾问题是国内战争遗留下来的问题，属于中国的内政，不容许外国干涉。<br>正确答案: 对</p>
<p>邓小平理论，是马克思列宁主义基本原理与当代中国实际和时代特征相结合的产物，是马克思列宁主义毛泽东思想的继承和发展，是全党全国人民集体智慧的结晶。<br>正确答案: 对</p>
<p>邓小平理论坚持解放思想实事求是，在新的实践基础上继承前人又突破陈规，开拓了马克思主义的新境界。<br>正确答案: 对</p>
<p>中国共产党所领导的改革开放从一开始就具有明确的社会主义方向。<br>正确答案: 对</p>
<p>邓小平理论为我们坚持走自己的路，建设中国特色社会主义提供了根本遵循。<br>正确答案: 对</p>
<p>邓小平理论是中国共产党和中国人民宝贵的精神财富，是改革开放和社会主义现代化建设的科学指南，是党和国家必须长期坚持的指导思想。<br>正确答案: 对</p>
<h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><h3 id="单选题-6"><a href="#单选题-6" class="headerlink" title="单选题"></a>单选题</h3><p>党的十四届四中全会通过了（），分析了党的建设面临的形势<br>A: 《中共中央关于加强党的建设几个重大问题的决定》<br>B: 《中共中央关于建立社会主义市场经济体制若干问题的决定》<br>C: 《中共中央关于制定国民经济和社会发展“九五”计划和2010年远景目标的建议》<br>D: 《中共中央关于加强社会主义精神文明建设若干重要问题的决议》<br>正确答案: A</p>
<p>2001年7月1日，江泽民在庆祝中国共产党成立（）周年大会上的讲话中全面阐述了“三个代表”重要思想的科学内涵和基本内容<br>A: 70<br>B: 75<br>C: 80<br>D: 85<br>正确答案: C</p>
<p>《在庆祝中国共产党成立八十周年大会上的讲话》回答了（）这一重大理论和实践问题。<br>A: 什么是社会主义怎样建设社会主义<br>B: 在新的历史条件下建设一个什么样的党怎样建设党<br>C: 新形势下实现什么样的发展怎样发展<br>D: 新时代坚持和发展什么样的中国特色社会主义怎样坚持和发展中国特色社会主义<br>正确答案: B</p>
<p>（）将“三个代表”重要思想与马克思列宁主义毛泽东思想和邓小平理论一道确立为党必须长期坚持的指导思想，并写入党章。<br>A: 党的十三大<br>B: 党的十四大<br>C: 党的十五大<br>D: 党的十六大<br>正确答案: D</p>
<p>党的十四届三中全会通过的（），勾画了建立社会主义市场经济体制的蓝图和基本框架。<br>A: 《关于加强党的建设几个重大问题的决定》<br>B: 《关于制定国民经济和社会发展“九五”计划和2010年远景目标的建议》<br>C: 《关于加强社会主义精神文明建设若干重要问题的决议》<br>D: 《关于建立社会主义市场经济体制若干问题的决定》<br>正确答案: D</p>
<p>（）年12月，中国正式加入世界贸易组织，标志着中国对外开放进入历史新阶段。<br>A: 1987<br>B: 1992<br>C: 2001<br>D: 2008<br>正确答案: C</p>
<h3 id="多选题-6"><a href="#多选题-6" class="headerlink" title="多选题"></a>多选题</h3><p>伴随着改革开放和发展社会主义市场经济的进程，我国社会生活发生了广泛而深刻的变化，（）等的多样化进一步发展，这给国家的政治经济文化和社会生活的各个方面带来深刻影响。<br>A: 社会经济成分<br>B: 组织形式<br>C: 利益分配<br>D: 就业方式<br>正确答案: ABCD</p>
<p>江泽民2000年6月在中央思想政治工作会议上提出的（），实际上深刻揭示了“三个代表”重要思想产生的历史起点和逻辑起点，反映了“三个代表”重要思想提出的时代背景和发展的现实依据。<br>A: 如何认识社会主义发展的历史进程<br>B: 如何认识资本主义发展的历史进程<br>C: 如何认识我国社会主义改革实践过程对人们思想的影响<br>D: 如何认识当今的国际环境和国际政治斗争带来的影响<br>正确答案: ABCD</p>
<p>江泽民在党的十六大报告中，全面阐述了“三个代表”重要思想形成的（）。<br>A: 时代背景<br>B: 历史地位<br>C: 精神实质<br>D: 指导意义<br>正确答案: ABCD</p>
<p>我们想事情，做工作，想得对不对，做得好不好，根本的衡量尺度，就是（）。<br>A: 人民拥护不拥护<br>B: 人民赞成不赞成<br>C: 人民高兴不高兴<br>D: 人民答应不答应<br>正确答案: ABCD</p>
<p>“三个代表”重要思想把（）统一起来，从深层次上揭示了社会主义制度不断完善和发展的途径。<br>A: 发展先进生产力<br>B: 发展先进文化<br>C: 实现最广大人民的根本利益<br>D: 关起门来搞建设<br>正确答案: ABC</p>
<p>“三个代表”重要思想从（）方面揭示了社会主义制度自我完善和发展的途径。<br>A: 物质基础<br>B: 文化支撑<br>C: 社会基础<br>D: 经济救援<br>正确答案: ABC</p>
<h3 id="判断题-6"><a href="#判断题-6" class="headerlink" title="判断题"></a>判断题</h3><p>减少参与经济全球化是包括我国在内的发展中国家实现现代化的必由之路。<br>正确答案: 错</p>
<p>“三个代表”重要思想是立足于党的历史总结党的历史经验得出的重要结论。<br>正确答案: 对</p>
<p>“三个代表”重要思想是在应对中国社会经济发展中出现的各种实际问题过程中形成和发展起来的。<br>正确答案: 对</p>
<p>“三个代表”重要思想，是我们党在理论和实践上不断探索和开拓的结果。<br>正确答案: 对</p>
<p>一个政权也好，一个政党也好，其前途命运最终取决于人心向背，不能赢得最广大人民的支持，就必然垮台。<br>正确答案: 对</p>
<p>贯彻“三个代表”要求，关键在坚持与时俱进，核心在保持党的先进性，本质在坚持执政为民。<br>正确答案: 对</p>
<p>始终代表中国先进生产力的发展要求，大力促进先进生产力的发展，是我们党站在时代前列，保持先进性的根本体现和根本要求。<br>正确答案: 对</p>
<p>大力发展社会主义先进文化，必须牢牢把握先进文化的前进方向。<br>正确答案: 对</p>
<p>人民是我们国家的主人，是决定我国前途和命运的根本力量，是历史的真正创造者。<br>正确答案: 对</p>
<p>我们全部工作的出发点和落脚点，就是不断实现好维护好发展好最广大人民的根本利益。<br>正确答案: 对</p>
<p>党要承担起推动中国社会进步的历史责任，必须始终紧紧抓住发展这个执政兴国的第一要务。<br>正确答案: 对</p>
<p>离开发展，坚持党的先进性发挥社会主义制度的优越性和实现民富国强都无从谈起。<br>正确答案: 对</p>
<p>建设社会主义政治文明，是我国改革开放和社会主义现代化建设发展的必然要求，是我们党领导人民坚持和发展人民民主长期实践的必然结论。<br>正确答案: 对</p>
<p>“三个代表”重要思想创造性地运用了马克思列宁主义毛泽东思想特别是邓小平理论，形成了富有独创性的新的理论成果。<br>正确答案: 对</p>
<p>“三个代表”重要思想是对马克思列宁主义毛泽东思想和邓小平理论的继承和发展，是中国特色社会主义理论体系的重要组成部分。<br>正确答案: 对</p>
<p>始终做到“三个代表”，是我们党的立党之本执政之基力量之源。<br>正确答案: 对</p>
<p>中国共产党始终代表中国先进生产力的发展要求，体现了发展社会主义经济建设社会主义物质文明的理想和价值目标。<br>正确答案: 对</p>
<p>中国共产党始终代表中国先进文化的前进方向，体现了发展社会主义文化建设社会主义精神文明的理想和价值目标。<br>正确答案: 对</p>
<p>中国共产党始终代表中国最广大人民的根本利益，强调以人民群众的利益要求和实践为最高价值标准和评价标准，体现了我们党的宗旨和我们国家的性质。<br>正确答案: 对</p>
<p>“三个代表”重要思想反映了当代世界和中国的发展变化对党和国家工作的新要求，是加强和改进党的建设推进我国社会主义自我完善和发展的强大理论武器，是党和国家必须长期坚持的指导思想。<br>正确答案: 对</p>
<h2 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h2><h3 id="单选题-7"><a href="#单选题-7" class="headerlink" title="单选题"></a>单选题</h3><p>党的十六届三中全会通过的（）第一次提出科学发展观。<br>A: 《中共中央关于深化行政管理体制和机构改革的意见》<br>B: 《中共中央关于完善社会主义市场经济体制若干问题的决定》<br>C: 《中共中央关于加强党的执政能力建设的决定》<br>D: 《中共中央关于制定国民经济和社会发展第十一个五年规划的建议》<br>正确答案: B</p>
<p>科学发展观对（）等重大问题作出了新的科学回答，把我们对中国特色社会主义规律的认识提高到新的水平。<br>A: 什么是社会主义怎样建设社会主义<br>B: 在新的历史条件下建设一个什么样的党怎样建设党<br>C: 新形势下实现什么样的发展怎样发展<br>D: 新时代坚持和发展什么样的中国特色社会主义怎样坚持和发展中国特色社会主义<br>正确答案: C</p>
<p>（）通过的《中国共产党章程（修正案）》把科学发展观同马克思列宁主义毛泽东思想邓小平理论“三个代表”重要思想一道，确立为党必须长期坚持的指导思想。<br>A: 党的十五大<br>B: 党的十六大<br>C: 党的十七大<br>D: 党的十八大<br>正确答案: D</p>
<p>（）是科学发展观的核心立场，集中体现了马克思主义历史唯物论的基本原理，体现了我们党全心全意为人民服务的根本宗旨和推动经济社会发展的根本目的。<br>A: 以人为本<br>B: 单纯追求经济增长<br>C: 注重多出快出政绩<br>D: 形式主义<br>正确答案: A</p>
<p>下列各项中，不符合科学发展观的基本要求的是（）。<br>A: 全面发展<br>B: 协调发展<br>C: 唯速度发展<br>D: 可持续发展<br>正确答案: C</p>
<p>统筹兼顾是科学发展观的根本方法，深刻体现了（）在发展问题上的科学运用。<br>A: 唯物辩证法<br>B: 唯心辩证法<br>C: 形而上学<br>D: 形象思维<br>正确答案: A</p>
<p>我国自（）年1月1日起废止《中华人民共和国农业税条例》，农业税的取消给亿万农民带来了看得见摸得着的实惠。<br>A: 1992<br>B: 2006<br>C: 2012<br>D: 2020<br>正确答案: B</p>
<h3 id="多选题-7"><a href="#多选题-7" class="headerlink" title="多选题"></a>多选题</h3><p>科学发展观是在（）的基础上形成和发展的。<br>A: 深刻分析国际形势<br>B: 照搬照抄苏联模式<br>C: 顺应世界发展趋势<br>D: 借鉴国外发展经验<br>正确答案: ACD</p>
<p>2004年3月，胡锦涛在中央人口资源环境座谈会上发表重要讲话，深刻阐明了科学发展观提出的背景意义，明确界定了“（）”的深刻内涵和基本要求<br>A: 以人为本<br>B: 全面发展<br>C: 协调发展<br>D: 可持续发展<br>正确答案: ABCD</p>
<p>党的十七届五中全会强调，在当代中国，坚持发展是硬道理的本质要求，就是坚持科学发展，更加注重（），促进社会公平正义。<br>A: 以人为本<br>B: 全面协调可持续发展<br>C: 统筹兼顾<br>D: 保障和改善民生<br>正确答案: ABCD</p>
<p>坚持可持续发展，必须走（）的文明发展道路。<br>A: 生产发展<br>B: 生活富裕<br>C: 生态良好<br>D: 竭泽而渔<br>正确答案: ABC</p>
<p>（）安定有序人与自然和谐相处，是构建社会主义和谐社会的总要求。<br>A: 民主法治<br>B: 公平正义<br>C: 诚信友爱<br>D: 充满活力<br>正确答案: ABCD</p>
<p>科学发展观最鲜明的精神实质是（）。<br>A: 解放思想<br>B: 实事求是<br>C: 与时俱进<br>D: 求真务实<br>正确答案: ABCD</p>
<p>发展观是关于发展的（）的总体看法和根本观点，决定了经济社会发展的总体战略和基本模式，对经济社会发展实践具有根本性全局性的重大影响。<br>A: 本质<br>B: 目的<br>C: 内涵<br>D: 要求<br>正确答案: ABCD</p>
<h3 id="判断题-7"><a href="#判断题-7" class="headerlink" title="判断题"></a>判断题</h3><p>科学发展观是在深刻把握我国基本国情和新的阶段性特征的基础上形成和发展的。<br>正确答案: 对</p>
<p>党带领人民战胜各种风险挑战坚持和发展中国特色社会主义的成功探索，是科学发展观形成的实践基础。<br>正确答案: 对</p>
<p>树立和落实科学发展观，这是二十多年改革开放实践的经验总结，是战胜非典疫情给我们的重要启示。<br>正确答案: 对</p>
<p>科学发展观是马克思主义同当代中国实际和时代特征相结合的产物，是马克思主义关于发展的世界观和方法论的集中体现。<br>正确答案: 对</p>
<p>科学发展观是马克思主义中国化重大成果，是中国共产党集体智慧的结晶。<br>正确答案: 对</p>
<p>推动经济社会发展是科学发展观的第一要义。<br>正确答案: 对</p>
<p>以人为本就是以最广大人民的根本利益为本。<br>正确答案: 对</p>
<p>统筹兼顾深刻揭示了实现科学发展促进社会和谐的基本途径，是正确处理经济社会发展中重大关系的方针原则。<br>正确答案: 对</p>
<p>科学发展观是对邓小平理论“三个代表”重要思想的创造性发展，把中国特色社会主义理论体系推进到新境界，赋予当代中国马克思主义勃勃生机。<br>正确答案: 对</p>
<h2 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h2><h3 id="单选题-8"><a href="#单选题-8" class="headerlink" title="单选题"></a>单选题</h3><p>1981年，（）通过《关于建国以来党的若干历史问题的决议》，明确指出：“在社会主义改造基本完成以后，我国所要解决的主要矛盾，是人民日益增长的物质文化需要同落后的社会生产之间的矛盾。<br>A: 党的七届二中全会<br>B: 党的十一届三中全会<br>C: 党的十一届六中全会<br>D: 党的八大<br>正确答案: C</p>
<p>中国特色社会主义进入新时代，我国社会主要矛盾已经转化为（）。<br>A: 帝国主义和中华民族的矛盾<br>B: 人民对于经济文化迅速发展的需要同当前经济文化不能满足人民需要的状况之间的矛盾<br>C: 人民日益增长的物质文化需要同落后的社会生产之间的矛盾<br>D: 人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾<br>正确答案: D</p>
<p>（）是当前世界上最大的发展中国家。<br>A: 印度<br>B: 中国<br>C: 巴西<br>D: 俄罗斯<br>正确答案: B</p>
<p>从（）来看，新时代是全国各族人民团结奋斗不断创造美好生活逐步实现全体人民共同富裕的时代。<br>A: 历史脉络<br>B: 实践主题<br>C: 人民性<br>D: 世界性<br>正确答案: C</p>
<p>中国特色社会主义进入新时代，意味着（）在21世纪的中国焕发出强大生机活力。<br>A: 空想社会主义<br>B: 封建主义<br>C: 资本主义<br>D: 科学社会主义<br>正确答案: D</p>
<p>中国特色社会主义拓展了（）国家走向现代化的途径，给世界上那些既希望加快发展又希望保持自身独立性的国家和民族提供了全新选择。<br>A: 发展中<br>B: 发达<br>C: 资本主义<br>D: 共产主义<br>正确答案: A</p>
<p>当代（）正经历着本国历史上最为广泛而深刻的社会变革，也正在进行着人类历史上最为宏大而独特的实践创新。<br>A: 美国<br>B: 英国<br>C: 中国<br>D: 日本<br>正确答案: C</p>
<p>下列各项中，不属于世界百年未有之大变局的基本内涵的是（）。<br>A: 国际格局和国际体系正在发生深刻调整<br>B: 全球治理体系的发展演变陷入停滞<br>C: 国际力量对比正在发生近代以来最具革命性的变化<br>D: 世界范围呈现出影响人类历史进程和趋向的重大态势<br>正确答案: B</p>
<p>下列各项中，不属于世界百年未有之大变局的主要表现的是（）。<br>A: 世界经济版图的稳定不变前所未有<br>B: 新一轮科技革命和产业变革带来的新陈代谢和激烈竞争前所未有<br>C: 全球治理体系的不适应不对称前所未有<br>D: 人类前途命运的休戚与共前所未有<br>正确答案: A</p>
<p>当今世界正经历百年未有之大变局，全球治理体系的不适应不对称前所未有，（）主导的国际政治经济秩序越来越难以为继<br>A: 西方发达国家<br>B: 发展中国家<br>C: 东方新兴国家<br>D: 社会主义国家<br>正确答案: A</p>
<p>新冠肺炎疫情全球大流行成为世界百年未有之大变局的新变量催化剂，推动大变局不断向纵深发展，其表现不包括（）。<br>A: 让复苏乏力的世界经济雪上加霜<br>B: 凸显出西方资本主义主导下国际体系的严重弊端<br>C: 加快了国际力量此消彼长<br>D: 导致资本主义即将被社会主义取代<br>正确答案: D</p>
<p>我们具备过去难以想象的良好发展条件，但也面临着各种可以预见和难以预见的困难和问题，其具体表现不包括（）。<br>A: 形势环境变化之快<br>B: 时代主题转换之猛<br>C: 改革发展稳定任务之重<br>D: 矛盾风险挑战之多<br>正确答案: B</p>
<p>习近平新时代中国特色社会主义思想，坚持辩证唯物主义和历史唯物主义，紧密结合新的时代条件和实践要求，系统回答（  ）。<br>A: 什么是社会主义怎样建设社会主义<br>B: 在新的历史条件下建设一个什么样的党怎样建设党<br>C: 新形势下实现什么样的发展怎样发展<br>D: 新时代坚持和发展什么样的中国特色社会主义怎样坚持和发展中国特色社会主义<br>正确答案: D</p>
<p>（）是高瞻远瞩统揽全局，善于把握事物发展总体趋势和方向的思维方法。<br>A: 创新思维<br>B: 战略思维<br>C: 法治思维<br>D: 底线思维<br>正确答案: B</p>
<p>在马克思主义哲学方面，习近平新时代中国特色社会主义思想提出（）的思想，是对马克思主义社会矛盾学说的新发展。<br>A: 新时代我国社会主要矛盾发生变化<br>B: 坚持和完善社会主义基本经济制度，使市场在资源配置中起决定性作用和更好发挥政府作用<br>C: 坚持和加强党的全面领导推进党的自我革命<br>D: 坚持和完善中国特色社会主义制度推进国家治理体系和治理能力现代化<br>正确答案: A</p>
<p>在政治经济学方面，习近平新时代中国特色社会主义思想提出坚持和完善社会主义基本经济制度，使（）在资源配置中起决定性作用和更好发挥政府作用等思想，是对马克思主义经济学说的新发展。<br>A: 市场<br>B: 企业<br>C: 商业行会<br>D: 党支部<br>正确答案: A</p>
<p>在科学社会主义方面，习近平新时代中国特色社会主义思想提出（）的思想，是对马克思主义建党学说的新发展<br>A: 坚持和完善中国特色社会主义制度推进国家治理体系和治理能力现代化<br>B: 坚持和加强党的全面领导推进党的自我革命<br>C: 构建人类命运共同体<br>D: 新时代我国社会主要矛盾发生变化<br>正确答案: B</p>
<p>在科学社会主义方面，习近平新时代中国特色社会主义思想提出坚持和完善中国特色社会主义制度推进国家治理体系和治理能力现代化的思想，是对（）的新发展。<br>A: 马克思主义生产力理论<br>B: 马克思主义经济学说<br>C: 马克思主义国家学说<br>D: 马克思主义世界历史理论<br>正确答案: C</p>
<p>在科学社会主义方面，习近平新时代中国特色社会主义思想提出构建人类命运共同体的思想，是对（）的新发展。<br>A: 马克思主义建党学说<br>B: 马克思主义世界历史理论<br>C: 马克思主义社会矛盾学说<br>D: 马克思主义生产力理论<br>正确答案: B</p>
<p>当今世界，人类社会再次面临何去何从的历史当口，其所要面对的全球性挑战和问题不包括（）。<br>A: 全球经济增长需要新动力<br>B: 贫富差距鸿沟完全弥合<br>C: 地区热点问题此起彼伏<br>D: 旧有国际政治经济体系弊端丛生<br>正确答案: B</p>
<p>关于维护世界和平与安全，习近平新时代中国特色社会主义思想倡导的国际交往观不包括（）。<br>A: 对话<br>B: 不对抗<br>C: 结伴<br>D: 结盟<br>正确答案: D</p>
<p>关于维护世界和平与安全，习近平新时代中国特色社会主义思想倡导的新安全观不包括（）。<br>A: 综合<br>B: 合作<br>C: 孤立<br>D: 可持续<br>正确答案: C</p>
<p>下列各项中，不符合习近平新时代中国特色社会主义思想所要推动构建的新型国际关系的是（）。<br>A: 零和博弈<br>B: 相互尊重<br>C: 公平正义<br>D: 合作共赢<br>正确答案: A</p>
<p>习近平新时代中国特色社会主义思想所倡导的全球治理观不包括（）。<br>A: 共商<br>B: 共建<br>C: 共享<br>D: 互盟<br>正确答案: D</p>
<p>习近平新时代中国特色社会主义思想所倡导的新型文明观不包括（）。<br>A: 平等<br>B: 互鉴<br>C: 对抗<br>D: 包容<br>正确答案: C</p>
<h3 id="多选题-8"><a href="#多选题-8" class="headerlink" title="多选题"></a>多选题</h3><p>以习近平同志为核心的党中央以巨大的政治勇气和强烈的责任担当，（），解决了许多长期想解决而没有解决的难题，办成了许多过去想办而没有办成的大事。<br>A: 提出一系列新理念新思想新战略<br>B: 出台一系列重大方针政策<br>C: 推出一系列重大举措<br>D: 推进一系列重大工作<br>正确答案: ABCD</p>
<p>改革开放和社会主义现代化建设取得全方位的开创性的历史性成就，党和国家事业发生深层次的根本性的历史性变革，其重要影响有（）。<br>A: 极大增强了我国的综合国力国际影响力<br>B: 极大增强了人民获得感幸福感安全感<br>C: 为党和国家事业全面发展奠定了更加坚实的基础<br>D: 为中国特色社会主义进入新时代作出了开创性贡献<br>正确答案: ABCD</p>
<p>中国特色社会主义进入新时代，人民美好生活需要日益广泛，不仅对物质文化生活提出了更高要求，而且在（）安全环境等方面的要求日益增长。<br>A: 民主<br>B: 法治<br>C: 公平<br>D: 正义<br>正确答案: ABCD</p>
<p>中国特色社会主义进入新时代，在（）上都具有重大意义。<br>A: 中华人民共和国发展史<br>B: 中华民族发展史<br>C: 世界社会主义发展史<br>D: 人类社会发展史<br>正确答案: ABCD</p>
<p>当今世界正经历百年未有之大变局，世界经济版图发生的深刻变化前所未有，（）在世界经济中占据越来越大的份额。<br>A: 新兴经济体<br>B: 成熟经济体<br>C: 发展中国家<br>D: 发达国家<br>正确答案: AC</p>
<p>世界百年未有之大变局正在加速演变，国际金融危机深层次影响持续发酵，世界经济增长乏力，催生（）孤立主义等思潮不断抬头<br>A: 政治极化<br>B: 种族冲突<br>C: 民粹主义<br>D: 贸易保护主义<br>正确答案: ABCD</p>
<p>世界百年未有之大变局正在加速演变，（）等非传统安全威胁持续蔓延。<br>A: 恐怖主义<br>B: 网络安全<br>C: 重大传染性疾病<br>D: 气候变化<br>正确答案: ABCD</p>
<p>世界百年未有之大变局正在加速演变，人类面临许多共同挑战，（）等问题越来越严重。<br>A: 治理赤字<br>B: 信任赤字<br>C: 发展赤字<br>D: 和平赤字<br>正确答案: ABCD</p>
<p>习近平新时代中国特色社会主义思想，正是在（）的过程中创立并不断丰富发展的。<br>A: 把握世界发展大势<br>B: 应对全球共同挑战<br>C: 维护人类共同利益<br>D: 完善全球治理体系<br>正确答案: ABCD</p>
<p>新的历史条件下，党面临的执政环境和社会条件已经并继续发生着深刻变化，下列各项中，属于中国共产党在新的历史条件下面临的“四大考验”的有（）。<br>A: 长期执政考验<br>B: 改革开放考验<br>C: 市场经济考验<br>D: 外部环境考验<br>正确答案: ABCD</p>
<p>新的历史条件下，党面临的执政环境和社会条件已经并继续发生着深刻变化，下列各项中，属于中国共产党在新的历史条件下面临的“四大危险”的有（）。<br>A: 精神懈怠危险<br>B: 能力不足危险<br>C: 脱离群众危险<br>D: 消极腐败危险<br>正确答案: ABCD</p>
<p>中华民族伟大复兴正处于关键时期，中国共产党和中国人民迫切需要（）的科学理论。<br>A: 凝心聚力<br>B: 严守教条<br>C: 谋篇布局<br>D: 攻坚克难<br>正确答案: ACD</p>
<p>习近平新时代中国特色社会主义思想，正是在不断推进党的自我革命，实现党的（）的过程中创立并不断丰富发展的。<br>A: 自我净化<br>B: 自我完善<br>C: 自我革新<br>D: 自我提高<br>正确答案: ABCD</p>
<p>习近平新时代中国特色社会主义思想，以崭新的思想内容丰富和发展了马克思主义，形成了一个（）内在统一的科学理论体系。<br>A: 主题鲜明<br>B: 系统全面<br>C: 逻辑严密<br>D: 内涵丰富<br>正确答案: ABCD</p>
<p>习近平从（）强大生命力等多方位多角度对新时代坚持和发展什么样的中国特色社会主义作出了深刻回答。<br>A: 理论渊源<br>B: 历史根据<br>C: 本质特征<br>D: 独特优势<br>正确答案: ABCD</p>
<p>关于新时代坚持和发展的中国特色社会主义，下列理解中正确的有（）。<br>A: 中国特色社会主义是既坚持科学社会主义基本原则，又是具有鲜明实践特色理论特色民族特色时代特色的社会主义<br>B: 中国特色社会主义是中国特色社会主义道路理论制度文化四位一体的社会主义<br>C: 中国特色社会主义是统揽伟大斗争伟大工程伟大事业伟大梦想的社会主义<br>D: 中国特色社会主义是根植于中国大地反映中国人民意愿适应中国和时代发展进步要求的社会主义<br>正确答案: ABCD</p>
<p>中国特色社会主义是既坚持科学社会主义基本原则，又是具有（）的社会主义。<br>A: 鲜明实践特色<br>B: 鲜明理论特色<br>C: 鲜明民族特色<br>D: 鲜明时代特色<br>正确答案: ABCD</p>
<p>中国特色社会主义是统揽（）的社会主义。<br>A: 伟大斗争<br>B: 伟大工程<br>C: 伟大事业<br>D: 伟大梦想<br>正确答案: ABCD</p>
<p>中国特色社会主义是（）的社会主义。<br>A: 根植于中国大地<br>B: 照搬苏联经验<br>C: 反映中国人民意愿<br>D: 适应中国和时代发展进步要求<br>正确答案: ACD</p>
<p>习近平以一系列战略性前瞻性创造性的观点，深刻回答了新时代坚持和发展中国特色社会主义的总目标总任务总体布局战略布局和发展方向发展方式（）等基本问题。<br>A: 发展动力<br>B: 战略步骤<br>C: 外部条件<br>D: 政治保证<br>正确答案: ABCD</p>
<p>党的十八大以来，以习近平同志为核心的党中央在领导推进新时代治国理政的实践中，提出许多具有时代性实践性创造性的重大思想观点，形成了习近平强军思想（）等。<br>A: 习近平经济思想<br>B: 习近平生态文明思想<br>C: 习近平外交思想<br>D: 习近平法治思想<br>正确答案: ABCD</p>
<p>习近平新时代中国特色社会主义思想，彰显和贯穿着坚定的理想信念（）。<br>A: 真挚的人民情怀<br>B: 高度的自觉自信<br>C: 无畏的担当精神<br>D: 科学的思想方法<br>正确答案: ABCD</p>
<p>习近平新时代中国特色社会主义思想的理论特质包括（）强化战略思维发扬斗争精神。<br>A: 秉持人民至上<br>B: 彰显历史自觉<br>C: 坚持实事求是<br>D: 突出问题导向<br>正确答案: ABCD</p>
<p>习近平新时代中国特色社会主义思想彰显历史自觉，注重从历史现实未来的贯通中把握历史规律和发展趋势，其具体表现有（）。<br>A: 联系5000多年中华文明史来思考中华民族的前途命运<br>B: 联系500多年世界社会主义发展史来认识社会主义运动的前进方向<br>C: 联系中国近代以来180多年奋斗史来理解中华民族伟大复兴的正确道路<br>D: 联系100年革命建设改革的历程来把握党的历史方位和历史使命<br>正确答案: ABCD</p>
<p>党的十八大以来，我们党直面矛盾改革创新攻坚克难，充分彰显了强烈的问题意识鲜明的问题导向，其具体表现有（）。<br>A: 持之以恒纠“四风”<br>B: 刮骨疗毒反腐败<br>C: 啃下贫中之贫“硬骨头”<br>D: 打赢蓝天碧水净土保卫战<br>正确答案: ABCD</p>
<p>习近平新时代中国特色社会主义思想蕴含的斗争精神，为党领导人民栉风沐雨砥砺前行，有效应对重大挑战（）提供了强大动能。<br>A: 有效抵御重大风险<br>B: 有效克服重大阻力<br>C: 有效化解重大矛盾<br>D: 有效解决重大问题<br>正确答案: ABCD</p>
<p>在政治经济学方面，习近平新时代中国特色社会主义思想提出创新（）的新发展理念，是对马克思主义生产力理论的新发展。<br>A: 协调<br>B: 绿色<br>C: 开放<br>D: 共享<br>正确答案: ABCD</p>
<p>习近平新时代中国特色社会主义思想系统阐述了民族复兴的（），为实现中华民族伟大复兴的中国梦提供了强大精神力量，标注了正确前进方向。<br>A: 深刻内涵<br>B: 历史方位<br>C: 实现路径<br>D: 战略步骤<br>正确答案: ABCD</p>
<p>习近平新时代中国特色社会主义思想以敢于啃硬骨头敢于涉险滩的决心推进全面深化改革，加强（），把我国制度优势更好转化为国家治理效能。<br>A: 系统治理<br>B: 依法治理<br>C: 综合治理<br>D: 源头治理<br>正确答案: ABCD</p>
<p>习近平新时代中国特色社会主义思想推动中国特色社会主义制度更加完善国家治理体系和治理能力现代化水平明显提高，为政治稳定经济发展文化繁荣（）提供了有力保障。<br>A: 民族团结<br>B: 人民幸福<br>C: 社会安宁<br>D: 国家统一<br>正确答案: ABCD</p>
<p>习近平新时代中国特色社会主义思想倡导世界各国加强发展合作，推动经济全球化朝着更加开放（）的方向发展。<br>A: 包容<br>B: 普惠<br>C: 平衡<br>D: 共赢<br>正确答案: ABCD</p>
<p>习近平新时代中国特色社会主义思想倡导世界各国加强发展合作，提升全球发展的（）。<br>A: 公平性<br>B: 有效性<br>C: 协同性<br>D: 排斥性<br>正确答案: ABC</p>
<p>关于全球治理，习近平新时代中国特色社会主义思想倡导（）的合作观。<br>A: 开放<br>B: 融通<br>C: 互利<br>D: 共赢<br>正确答案: ABCD</p>
<p>关于文明交流互鉴，习近平新时代中国特色社会主义思想倡导和平发展（）的人类共同价值。<br>A: 公平<br>B: 正义<br>C: 民主<br>D: 自由<br>正确答案: ABCD</p>
<p>关于文明交流互鉴，习近平新时代中国特色社会主义思想强调坚持求同存异，加强不同文明交流对话，展现了（）的思想力量。<br>A: 让文明交流超越文明隔阂<br>B: 让文明互鉴超越文明冲突<br>C: 让文明共存超越文明优越<br>D: 让文明竞争超越文明共融<br>正确答案: ABC</p>
<h3 id="判断题-8"><a href="#判断题-8" class="headerlink" title="判断题"></a>判断题</h3><p>中国特色社会主义进入新时代是我国发展新的历史方位。<br>正确答案: 对</p>
<p>中国特色社会主义进入新时代是我国社会主要矛盾转化的必然结果。<br>正确答案: 对</p>
<p>社会主要矛盾状况及其变化是社会发展阶段性划分的重要依据，对社会主要矛盾的科学判断是制定党的路线方针政策的基本依据。<br>正确答案: 对</p>
<p>我国社会主要矛盾的变化改变了我们对我国社会主义所处历史阶段的判断。<br>正确答案: 错</p>
<p>我国仍处于并将长期处于社会主义初级阶段的基本国情没有变，必须坚持党的基本路线不落后于时代，尽可能超越实际跨越阶段。<br>正确答案: 错</p>
<p>中国特色社会主义进入新时代意味着近代以来久经磨难的中华民族迎来了从站起来富起来到强起来的伟大飞跃。<br>正确答案: 对</p>
<p>当今世界正经历百年未有之大变局，大变局带来大挑战，也带来大机遇。<br>正确答案: 对</p>
<p>当今世界正经历百年未有之大变局，全球治理越来越向着更加不公平不合理的方向发展。<br>正确答案: 错</p>
<p>我国发展步入近代以来的最好时期，正处于实现中华民族伟大复兴的关键时期。<br>正确答案: 对</p>
<p>在14亿多人口的中国实现社会主义现代化是人类历史上从未有过的壮举。<br>正确答案: 对</p>
<p>中国改革需要“涉深水”和“闯险滩”，需要防范化解“黑天鹅”“灰犀牛”事件等各种重大风险。<br>正确答案: 对</p>
<p>中国共产党是实现中华民族伟大复兴的根本保证。<br>正确答案: 对</p>
<p>中华优秀传统文化是中华民族的根和魂，是中国特色社会主义植根的文化沃土。<br>正确答案: 对</p>
<p>中国共产党人是马克思主义的坚定信仰者和实践者，也是中华优秀传统文化的忠实传承者和弘扬者。<br>正确答案: 对</p>
<p>党的十八大以来，我们党的全部理论和实践探索都是围绕坚持和发展中国特色社会主义来展开深化和拓展的。<br>正确答案: 对</p>
<p>人民是历史的创造者，是真正的英雄，是决定党和国家前途命运的根本力量。<br>正确答案: 对</p>
<p>只要科学地认识准确地把握正确地解决时代问题，就能够把我们的社会不断推向前进。<br>正确答案: 对</p>
<p>敢于斗争敢于胜利，是中国共产党不可战胜的强大精神力量。<br>正确答案: 对</p>
<p>中华民族伟大复兴是可以轻轻松松实现的。<br>正确答案: 错</p>
<p>习近平新时代中国特色社会主义思想是新时代中国共产党的思想旗帜，是国家政治生活和社会生活的根本指针，是引领中国影响世界的当代中国马克思主义21世纪马克思主义。<br>正确答案: 对</p>
<p>习近平新时代中国特色社会主义思想以全新视野深化了对共产党执政规律社会主义建设规律和人类社会发展规律的认识。<br>正确答案: 对</p>
<p>在当代中国，坚持和发展习近平新时代中国特色社会主义思想，就是真正坚持和发展马克思主义，就是真正坚持和发展科学社会主义。<br>正确答案: 对</p>
<p>习近平新时代中国特色社会主义思想是全党全国各族人民团结奋斗的共同思想基础，是全面建设社会主义现代化国家实现中华民族伟大复兴中国梦的行动指南。<br>正确答案: 对</p>
<p>中国特色社会主义是建成社会主义现代化强国实现中华民族伟大复兴的必由之路。<br>正确答案: 对</p>
<p>没有国家治理现代化，就没有中华民族的伟大复兴。<br>正确答案: 对</p>
<p>实现中华民族伟大复兴，关键在中国共产党。<br>正确答案: 对</p>
<p>习近平新时代中国特色社会主义思想是具有鲜明开放性品格的科学理论体系，将在指导当代中国伟大实践历史进程中不断增添鲜活的时代内容，展现出更强大更有说服力的真理力量和实践力量。<br>正确答案: 对</p>
<h2 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h2><h3 id="单选题-9"><a href="#单选题-9" class="headerlink" title="单选题"></a>单选题</h3><p>2012年11月，习近平在参观（）展览时首次提出中国梦。<br>A: 《伟大胜利 历史贡献》<br>B: 《伟大历程 辉煌成就》<br>C: 《伟大的变革》<br>D: 《复兴之路》<br>正确答案: D</p>
<p>习近平在参观《复兴之路》展览时首次提出中国梦，引用（）诠释了中华民族的昨天。<br>A: “为有牺牲多壮志”<br>B: “雄关漫道真如铁”<br>C: “四海翻腾云水怒”<br>D: “忽报人间曾伏虎”<br>正确答案: B</p>
<p>习近平在参观《复兴之路》展览时首次提出中国梦，引用（）诠释了中华民族的今天。<br>A: “踏遍青山人未老”<br>B: “玉宇澄清万里埃”<br>C: “人间正道是沧桑”<br>D: “一唱雄鸡天下白”<br>正确答案: C</p>
<p>习近平在参观《复兴之路》展览时首次提出中国梦，引用（）诠释了中华民族的明天。<br>A: “柳暗花明又一村”<br>B: “门前流水尚能西”<br>C: “晴空一鹤排云上”<br>D: “长风破浪会有时”<br>正确答案: D</p>
<p>实现中国梦必须走中国道路，下列做法中错误的是（）。<br>A: 不走封闭僵化的老路<br>B: 不走改旗易帜的邪路<br>C: 积极学习借鉴人类文明的一切有益成果<br>D: 接受所有建议批评和说教<br>正确答案: D</p>
<p>实现中国梦必须弘扬中国精神，这就是以爱国主义为核心的民族精神和以（）为核心的时代精神。<br>A: 改革创新<br>B: 消极保守<br>C: 教条主义<br>D: 随波逐流<br>正确答案: A</p>
<p>中国越发展，对世界和平与发展就越有利，实现中国梦给世界带来的不会是（）。<br>A: 机遇<br>B: 和平<br>C: 动荡<br>D: 进步<br>正确答案: C</p>
<p>2002年（）正式宣布人民生活总体达到小康水平，并在此基础上提出了全面建设小康社会的奋斗目标。<br>A: 党的十四大<br>B: 党的十五大<br>C: 党的十六大<br>D: 党的十七大<br>正确答案: C</p>
<p>第一个百年奋斗目标指的是，到（）时建成惠及十几亿人口的更高水平的小康社会<br>A: 新中国成立70年<br>B: 建党100年<br>C: 建军100年<br>D: 新中国成立100年<br>正确答案: B</p>
<p>第二个百年奋斗目标指的是，到（）时基本实现现代化，建成社会主义现代化强国。<br>A: 建党120年<br>B: 建军120年<br>C: 新中国成立100年<br>D: 建党150年<br>正确答案: C</p>
<p>全面建设社会主义现代化国家的进程的第一个阶段是（），在全面建成小康社会的基础上，再奋斗15年，基本实现社会主义现代化。<br>A: 从2012年到2020年<br>B: 从2020年到2025年<br>C: 从2020年到2035年<br>D: 从2035年到2049年<br>正确答案: C</p>
<p>全面建设社会主义现代化国家的进程的第二个阶段是（），在基本实现现代化的基础上，再奋斗15年，把我国建成富强民主文明和谐美丽的社会主义现代化强国。<br>A: 从2020年到2035年<br>B: 从2035年到本世纪中叶<br>C: 从2049年到2078年<br>D: 从本世纪中叶到本世纪末<br>正确答案: B</p>
<p>2020年，（）深入分析国际国内形势，就制定国民经济和社会发展第十四个五年规划和2035年远景目标提出建议。<br>A: 党的十九届二中全会<br>B: 党的十九届三中全会<br>C: 党的十九届四中全会<br>D: 党的十九届五中全会<br>正确答案: D</p>
<p>2021年，（）通过《中华人民共和国国民经济和社会发展第十四个五年规划和2035年远景目标纲要》，从“十四五”开局之年开始，我国开启全面建设社会主义现代化国家新征程。<br>A: 十三届全国人大一次会议<br>B: 十三届全国人大二次会议<br>C: 十三届全国人大三次会议<br>D: 十三届全国人大四次会议<br>正确答案: D</p>
<p>从“（）”开局之年开始，我国开启全面建设社会主义现代化国家新征程。<br>A: 十二五<br>B: 十三五<br>C: 十四五<br>D: 十五五<br>正确答案: C</p>
<p>下列各项中，不属于到2035年，我国基本实现社会主义现代化的远景目标的是（）。<br>A: 基本实现国家治理体系和治理能力现代化<br>B: 建成富强民主文明和谐美丽的社会主义现代化强国<br>C: 美丽中国建设目标基本实现<br>D: 基本实现国防和军队现代化<br>正确答案: B</p>
<p>到2035年，我国人均国内生产总值要达到（）水平，中等收入群体显著扩大。<br>A: 中等发达国家<br>B: 新兴发展中国家<br>C: 发达国家<br>D: 美国<br>正确答案: A</p>
<p>从“十四五”开局之年开始，我国开启全面建设社会主义现代化国家新征程，下列各项中，不属于“十四五”时期经济社会发展的重点任务的是（）。<br>A: 坚持创新驱动发展，全面塑造发展新优势<br>B: 加快发展现代产业体系，推动经济体系优化升级<br>C: 依托强大国际市场，全力发展依附型外循环经济<br>D: 全面深化改革，构建高水平社会主义市场经济体制<br>正确答案: C</p>
<p>“十四五”在我国发展中是一个极其重要的五年期，下列各项中，不属于“十四五”时期经济社会发展的重点任务的是（）。<br>A: 优化国土空间布局，推进区域协调发展和新型城镇化<br>B: 优先发展超大城市，全面推进简单粗暴城镇化<br>C: 繁荣发展文化事业和文化产业，提高国家文化软实力<br>D: 推动绿色发展，促进人与自然和谐共生<br>正确答案: B</p>
<p>“十四五”时期是我国全面建设社会主义现代化国家新征程的开局起步期，下列各项中，不属于“十四五”时期经济社会发展的重点任务的是（）。<br>A: 实行高水平对外开放，开拓合作共赢新局面<br>B: 改善人民生活品质，提高社会建设水平<br>C: 统筹发展和安全，建设更高水平的平安中国<br>D: 加快国防和军队现代化，使富国仅作为强军的手段<br>正确答案: D</p>
<p>本世纪中叶，我国将拥有高度的物质文明，其具体体现不包括（）。<br>A: 社会生产力水平大幅提高<br>B: 建成共产主义国家<br>C: 核心竞争力名列世界前茅<br>D: 经济总量和市场规模超越其他国家<br>正确答案: B</p>
<p>本世纪中叶，我国将拥有高度的精神文明，其具体体现不包括（）。<br>A: 践行社会主义核心价值观成为全社会自觉行动<br>B: 国民素质显著提高<br>C: 儒家思想在意识形态领域占据指导地位<br>D: 中国精神中国价值中国力量成为中国发展的重要影响力和推动力<br>正确答案: C</p>
<p>本世纪中叶，我国将拥有高度的社会文明，其具体体现不包括（）。<br>A: 城乡居民将普遍拥有较高的收入富裕的生活健全的基本公共服务<br>B: 公平正义普遍彰显<br>C: 社会充满活力而又规范有序<br>D: 全体人民按需分配完全实现<br>正确答案: D</p>
<p>关于社会主义初级阶段的理解，下列各项中错误的是（）。<br>A: 社会主义初级阶段不是一个静态一成不变停滞不前的阶段<br>B: 社会主义初级阶段是一个自发被动不用费多大气力自然而然就可以跨过的阶段<br>C: 社会主义初级阶段是一个动态积极有为始终洋溢着蓬勃生机活力的过程<br>D: 社会主义初级阶段是一个阶梯式递进不断发展进步日益接近质的飞跃的量的积累和发展变化的过程<br>正确答案: B</p>
<p>社会主义本身是（）的初级阶段，中国又处在社会主义的初级阶段。<br>A: 资本主义<br>B: 共产主义<br>C: 无政府主义<br>D: 工团主义<br>正确答案: B</p>
<p>新发展阶段是（）中的一个阶段，是其中经过几十年积累站到了新的起点上的一个阶段。<br>A: 社会主义初级阶段<br>B: 社会主义中级阶段<br>C: 社会主义高级阶段<br>D: 共产主义初级阶段<br>正确答案: A</p>
<p>下列各项描述中，不符合当今中国的是（）。<br>A: 世界第二大工业国<br>B: 世界第二大经济体<br>C: 世界第一大货物贸易国<br>D: 世界第一大外汇储备国<br>正确答案: A</p>
<p>2020年，我国国内生产总值超过（）元。<br>A: 50万亿<br>B: 80万亿<br>C: 100万亿<br>D: 120万亿<br>正确答案: C</p>
<p>2020年，我国人均国内生产总值超过（）美元。<br>A: 4000<br>B: 6000<br>C: 8000<br>D: 10000<br>正确答案: D</p>
<p>（）是引领发展的第一动力。<br>A: 创新<br>B: 绿色<br>C: 开放<br>D: 协调<br>正确答案: A</p>
<p>新发展阶段必须坚定不移贯彻新发展理念，其中创新发展注重的是解决（）问题。<br>A: 发展动力<br>B: 发展内外联动<br>C: 发展不平衡<br>D: 人与自然和谐共生<br>正确答案: A</p>
<p>新发展阶段必须坚定不移贯彻新发展理念，其中协调发展注重的是解决（）问题。<br>A: 人与自然和谐共生<br>B: 发展不平衡<br>C: 发展动力<br>D: 发展内外联动<br>正确答案: B</p>
<p>新发展阶段必须坚定不移贯彻新发展理念，其中绿色发展注重的是解决（）问题。<br>A: 发展内外联动<br>B: 社会公平正义<br>C: 人与自然和谐共生<br>D: 发展不平衡<br>正确答案: C</p>
<p>新发展阶段必须坚定不移贯彻新发展理念，其中开放发展注重的是解决（）问题。<br>A: 发展不平衡<br>B: 发展动力<br>C: 社会公平正义<br>D: 发展内外联动<br>正确答案: D</p>
<p>新发展阶段必须坚定不移贯彻新发展理念，其中共享发展注重的是解决（）问题。<br>A: 社会公平正义<br>B: 发展内外联动<br>C: 发展动力<br>D: 人与自然和谐共生<br>正确答案: A</p>
<p>（）是我们党执政的最深厚基础和最大底气。<br>A: 人民<br>B: 文化<br>C: 土地<br>D: 社会生产力<br>正确答案: A</p>
<p>从世界比较看，大国经济的特征都是（）为主导内部可循环。<br>A: 内需<br>B: 外需<br>C: 计划<br>D: 投资<br>正确答案: A</p>
<p>我国作为全球第二大经济体和制造业第（）大国，国内经济循环同国际经济循环的关系客观上早有调整的要求。<br>A: 一<br>B: 二<br>C: 三<br>D: 四<br>正确答案: A</p>
<p>构建新发展格局的关键在于（）。<br>A: 永远维持经济的超高速增长<br>B: 经济循环的畅通无阻<br>C: 不断降低劳动力成本<br>D: 竭力提高工业产能<br>正确答案: B</p>
<p>构建新发展格局的最本质特征是（）。<br>A: 实现高水平的自立自强<br>B: 深度参与国际分工<br>C: 关起门来搞建设<br>D: 实现消费品的按需分配<br>正确答案: A</p>
<h3 id="多选题-9"><a href="#多选题-9" class="headerlink" title="多选题"></a>多选题</h3><p>坚持和发展中国特色社会主义的总任务，是实现社会主义现代化和中华民族伟大复兴，在全面建成小康社会的基础上，在本世纪中叶建成富强（）的社会主义现代化强国。<br>A: 民主<br>B: 文明<br>C: 和谐<br>D: 美丽<br>正确答案: ABCD</p>
<p>改革开放以来，我们终于找到了实现中华民族伟大复兴的正确道路，取得了举世瞩目的伟大成就，其具体表现有（）。<br>A: 经济实力综合国力大大增强<br>B: 人民生活显著改善<br>C: 实现了从温饱不足到奔向全面小康的历史性跨越<br>D: 国际地位和国际影响力空前提升<br>正确答案: ABCD</p>
<p>国家的富强民族的振兴都以人民的（）为条件。<br>A: 权利得到保障<br>B: 利益得到实现<br>C: 收入完全均等<br>D: 幸福得到满足<br>正确答案: ABD</p>
<p>中国梦是（）的梦，与世界各国人民的美好梦想息息相通。<br>A: 和平<br>B: 发展<br>C: 合作<br>D: 共赢<br>正确答案: ABCD</p>
<p>必须继续拓展和走好适合中国国情的发展道路，增强对中国特色社会主义的（）。<br>A: 道路自信<br>B: 理论自信<br>C: 制度自信<br>D: 文化自信<br>正确答案: ABCD</p>
<p>中国梦与台湾的前途息息相关，两岸同胞应相互扶持，（），都参与到民族复兴的进程中来，凝成两岸一家亲共圆中国梦的力量。<br>A: 不分党派<br>B: 不分阶层<br>C: 不分宗教<br>D: 不分地域<br>正确答案: ABCD</p>
<p>广大海外侨胞有（），也是实现中国梦的重要力量。<br>A: 赤忱的爱国情怀<br>B: 雄厚的经济实力<br>C: 丰富的智力资源<br>D: 广泛的商业人脉<br>正确答案: ABCD</p>
<p>2020年，中华民族伟大复兴向前迈出了新的一大步，实现了第一个百年奋斗目标，其具体表现有（）。<br>A: “十三五”规划目标任务胜利完成<br>B: 决战脱贫攻坚取得全面胜利<br>C: 全面建成小康社会取得决定性成就<br>D: 我国经济实力科技实力综合国力和人民生活水平跃上新的大台阶<br>正确答案: ABCD</p>
<p>到2035年，我国要基本实现（），建成现代化经济体系。<br>A: 新型工业化<br>B: 新型信息化<br>C: 新型城镇化<br>D: 新型农业现代化<br>正确答案: ABCD</p>
<p>到2035年，我国要建成文化强国（），国民素质和社会文明程度达到新高度，国家文化软实力显著增强。<br>A: 教育强国<br>B: 人才强国<br>C: 体育强国<br>D: 健康中国<br>正确答案: ABCD</p>
<p>在2035年基本实现现代化的基础上，我国将继续奋斗，全面提升我国社会主义物质文明（），到本世纪中叶建成富强民主文明和谐美丽的社会主义现代化强国。<br>A: 政治文明<br>B: 精神文明<br>C: 社会文明<br>D: 生态文明<br>正确答案: ABCD</p>
<p>本世纪中叶，我国将拥有高度的政治文明，形成（）的政治局面.<br>A: 又有集中又有民主<br>B: 又有纪律又有自由<br>C: 只有民主没有集中<br>D: 又有统一意志又有个人心情舒畅生动活泼<br>正确答案: ABD</p>
<p>新发展阶段必须坚定不移贯彻（）共享的发展理念。<br>A: 创新<br>B: 协调<br>C: 绿色<br>D: 开放<br>正确答案: ABCD</p>
<p>贯彻新发展理念必须坚持（），不断推进全体人民共同富裕。<br>A: 全民共享<br>B: 全面共享<br>C: 共建共享<br>D: 渐进共享<br>正确答案: ABCD</p>
<p>新发展理念是一个系统的理论体系，回答了关于发展的（）等一系列理论和实践问题。<br>A: 目的<br>B: 动力<br>C: 方式<br>D: 路径<br>正确答案: ABCD</p>
<p>新发展理念是一个系统的理论体系，阐明了我们党关于发展的（）等重大政治问题。<br>A: 政治立场<br>B: 价值导向<br>C: 发展模式<br>D: 发展道路<br>正确答案: ABCD</p>
<p>要根据新发展阶段的新要求，坚持问题导向，更加精准地贯彻新发展理念，切实解决好发展不平衡不充分的问题，其具体有（）。<br>A: 科技上的“卡脖子”问题<br>B: 城乡区域发展差距较大问题<br>C: 经济社会发展全面绿色转型问题<br>D: 经济全球化出现逆流外部环境越来越复杂多变问题<br>正确答案: ABCD</p>
<p>我国必须坚持立足国内依托国内大市场优势，化解外部冲击和外需下降带来的影响，增强我们的（）。<br>A: 生存力<br>B: 竞争力<br>C: 发展力<br>D: 持续力<br>正确答案: ABCD</p>
<h3 id="判断题-9"><a href="#判断题-9" class="headerlink" title="判断题"></a>判断题</h3><p>现在，我们比历史上任何时期都更接近中华民族伟大复兴的目标，比历史上任何时期都更有信心有能力实现这个目标。<br>正确答案: 对</p>
<p>中国梦这一重要战略思想充分体现了中国共产党高度的历史担当和使命追求，为坚持和发展中国特色社会主义注入了崭新内涵。<br>正确答案: 对</p>
<p>民族不独立国家不富强，人民的生存根本得不到保证，更谈不上人民幸福。<br>正确答案: 对</p>
<p>实现中华民族伟大复兴，不是哪一个人哪一部分人的梦想，而是全体中国人民共同的追求。<br>正确答案: 对</p>
<p>中国梦的实现，不是成就哪一个人哪一部分人，而是造福全体人民。<br>正确答案: 对</p>
<p>每个人的前途命运与国家和民族的前途命运毫无相连。<br>正确答案: 错</p>
<p>每个人向着梦想的不断努力与实现伟大中国梦关系不大。<br>正确答案: 错</p>
<p>中国的梦想，不仅关乎中国的命运，也关系世界的命运。<br>正确答案: 对</p>
<p>美好愿景和伟大梦想的实现与选择走什么样的道路无关。<br>正确答案: 错</p>
<p>只有中国特色社会主义道路才是一条通往复兴梦想的康庄大道人间正道。<br>正确答案: 对</p>
<p>中国积极学习借鉴人类文明的一切有益成果，欢迎一切有益的建议和善意的批评，但绝不接受“教师爷”般颐指气使的说教。<br>正确答案: 对</p>
<p>中国精神是凝心聚力的兴国之魂强国之魂。<br>正确答案: 对</p>
<p>奋力实现中国梦，必须在全社会大力弘扬真抓实干埋头苦干的良好风尚。<br>正确答案: 对</p>
<p>只要一代又—代中国人勠力同心不懈追求接力奋斗，我们一定能够到达中华民族伟大复兴的光辉彼岸。<br>正确答案: 对</p>
<p>全面建成社会主义现代化强国的战略安排既是中国共产党推进民族复兴的重大决策，也是适应我国发展实际作出的必然选择<br>正确答案: 对</p>
<p>正确认识党和人民事业所处的历史方位，是我们党明确阶段性中心任务制定路线方针政策的根本依据。<br>正确答案: 对</p>
<p>人类社会必然走向共产主义，实现这一崇高目标可以一蹴而就。<br>正确答案: 错</p>
<p>发展社会主义不仅是一个长期历史过程，而且是需要划分为不同历史阶段的过程。<br>正确答案: 对</p>
<p>新发展阶段是我们党带领人民迎来从站起来富起来到强起来历史性跨越的新阶段。<br>正确答案: 对</p>
<p>全面建设社会主义现代化国家基本实现社会主义现代化，既是社会主义初级阶段我国发展的要求，也是我国社会主义从初级阶段向更高阶段迈进的要求。<br>正确答案: 对</p>
<p>发展理念是发展行动的先导，是发展思路发展方向发展着力点的集中体现。<br>正确答案: 对</p>
<p>发展理念是否对头，从根本上决定着发展成效乃至成败。<br>正确答案: 对</p>
<p>贯彻新发展理念必须把创新摆在国家发展全局的核心位置，让创新贯穿党和国家一切工作。<br>正确答案: 对</p>
<p>贯彻新发展理念必须正确处理发展中的重大关系，不断增强发展整体性。<br>正确答案: 对</p>
<p>贯彻新发展理念必须实现经济社会发展和生态环境保护协同共进，为人民群众创造良好生产生活环境。<br>正确答案: 对</p>
<p>贯彻新发展理念必须发展更高层次的开放型经济，以扩大开放推进改革发展。<br>正确答案: 对</p>
<p>新发展理念是具有内在联系的集合体，要统一贯彻，不能顾此失彼，也不能相互替代。<br>正确答案: 对</p>
<p>新发展理念中的哪一个理念贯彻不到位，发展进程都会受到影响。<br>正确答案: 对</p>
<p>只有坚持以人民为中心的发展思想，坚持发展为了人民发展依靠人民发展成果由人民共享，才会有正确的发展观现代化观。<br>正确答案: 对</p>
<p>进入新发展阶段，对新发展理念的理解要不断深化，举措要更加精准务实，真正实现高质量发展。<br>正确答案: 对</p>
<p>随着我国社会主要矛盾变化和国际力量对比深刻调整，我国发展面临的内外部风险空前下降。<br>正确答案: 错</p>
<p>构建新发展格局必须充分发挥我们市场资源优势，以巨大国内市场形成构建新发展格局的雄厚支撑。<br>正确答案: 对</p>
<p>构建新发展格局明确了我国经济现代化的路径选择。<br>正确答案: 对</p>
<p>构建新发展格局是应对新发展阶段机遇和挑战贯彻新发展理念的战略选择。<br>正确答案: 对</p>
<h2 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h2><h3 id="单选题-10"><a href="#单选题-10" class="headerlink" title="单选题"></a>单选题</h3><p>习近平经济思想坚持以（）为中心的发展思想。<br>A: 企业<br>B: 资本<br>C: 市场<br>D: 人民<br>正确答案: D</p>
<p>我国经济发展处于“三期叠加”阶段，“三期”中不包括（）。<br>A: 增长速度换挡期<br>B: 结构调整完成期<br>C: 前期刺激政策消化期<br>D: 结构调整阵痛期<br>正确答案: B</p>
<p>习近平经济思想指出，要把处理好（）和市场关系作为经济体制改革的关键。<br>A: 政府<br>B: 企业<br>C: 人大<br>D: 社会组织<br>正确答案: A</p>
<p>现阶段我国经济发展主要矛盾已转化成（）问题，矛盾的主要方面在供给侧。<br>A: 自发性<br>B: 总量性<br>C: 结构性<br>D: 周期性<br>正确答案: C</p>
<p>习近平经济思想指出，要把推进（）作为经济工作的主线，为保持我国经济持续健康发展开出治本良药。<br>A: 供给侧周期性改革<br>B: 供给侧结构性改革<br>C: 供给侧总量性改革<br>D: 供给侧自发性改革<br>正确答案: B</p>
<p>习近平经济思想坚持问题导向部署经济发展新战略，提出以（）为核心提高质量为导向的新型城镇化战略。<br>A: 促进房地产过热发展<br>B: 促进人的城镇化<br>C: 实现100%城镇化率<br>D: 保持国内生产总值高增长率<br>正确答案: B</p>
<p>习近平经济思想指出，要坚持（）工作总基调，正确处理经济发展中稳和进的关系。<br>A: 稳中求进<br>B: 激进跃进<br>C: 凡事求稳<br>D: 但求无过<br>正确答案: A</p>
<p>需求侧管理重在解决总量性问题，注重短期调控，通过刺激或抑制需求来推动经济增长，其主要措施不包括（）。<br>A: 调节税收<br>B: 调节货币信货<br>C: 调节财政支出<br>D: 调整生产结构<br>正确答案: D</p>
<p>我国经济运行面临的突出矛盾和问题，虽然有周期性总量性因素，但根源是重大结构性失衡，其表现不包括（）。<br>A: 实体经济结构性供需失衡<br>B: 虚拟经济发展不足<br>C: 金融和实体经济失衡<br>D: 房地产和实体经济失衡<br>正确答案: B</p>
<p>推动供给侧结构性改革，要用改革的办法推进结构调整，实现由低水平供需平衡向高水平供需平衡跃升，其具体要求不包括（）。<br>A: 减少无效和低端供给<br>B: 扩大有效供给<br>C: 减少中高端供给<br>D: 提升供给体系对国内需求的适配性<br>正确答案: C</p>
<p>推动供给侧结构性改革，就要深化要素市场化配置改革，实现由以价取胜向以质取胜的转变，其具体措施不包括（）。<br>A: 推动化解过剩产能<br>B: 大量进行低水平重复建设<br>C: 完善要素交易规则和服务体系<br>D: 优化存量资源配置<br>正确答案: B</p>
<p>推动供给侧结构性改革，就要加大人力资源培育力度，其具体措施不包括（）。<br>A: 营造本本主义唯学历论的社会氛围<br>B: 激发和保护企业家精神<br>C: 建设知识型技能型创新型劳动者大军<br>D: 弘扬劳动精神劳模精神和工匠精神<br>正确答案: A</p>
<p>加大人力资源培育力度，调动和保护人的积极性，其所要弘扬的精神不包括（）。<br>A: 劳动精神<br>B: 劳模精神<br>C: 工匠精神<br>D: “躺平”精神<br>正确答案: D</p>
<p>推动供给侧结构性改革，就要激发各类市场主体活力，加快建设世界一流企业，其具体举措不包括（）。<br>A: 毫不动摇巩固和发展公有制经济<br>B: 深化国有企业混合所有制改革<br>C: 健全管资本为主的国有资产监管体制<br>D: 为民营企业发展设置各种壁垒<br>正确答案: D</p>
<p>推动供给侧结构性改革，就要持续推进“三去一降一补”，其中的“三去”不包括（）。<br>A: 去产能<br>B: 去库存<br>C: 去质量<br>D: 去杠杆<br>正确答案: C</p>
<p>推动供给侧结构性改革，就要打好防范化解重大风险攻坚战，其所要促进形成的良性循环不包括（）。<br>A: 金融和实体经济的良性循环<br>B: 金融和房地产的良性循环<br>C: 金融体系内部的良性循环<br>D: 地方政府债务和国际投机资本的良性循环<br>正确答案: D</p>
<p>下列各项中，不属于建设现代化经济体系的具体措施的是（）。<br>A: 建设创新引领协同发展的产业体系<br>B: 建设唯求平等罔顾效率的收入分配体系<br>C: 建设资源节约环境友好的绿色发展体系<br>D: 建设多元平衡安全高效的全面开放体系<br>正确答案: B</p>
<p>下列各项中，不属于建设创新引领协同发展的产业体系的具体措施的是（）。<br>A: 把发展经济着力点放在虚拟经济上<br>B: 推动全产业链优化升级<br>C: 发展战略性新兴产业<br>D: 打造具有国际竞争力的数字产业集群<br>正确答案: A</p>
<p>建设创新引领协同发展的产业体系，就要加快发展现代服务业，这对服务业的要求不包括（）。<br>A: 向专业化延伸<br>B: 向价值链低端延伸<br>C: 向高品质升级<br>D: 向多样化升级<br>正确答案: B</p>
<p>下列各项中，不属于建设统一开放竞争有序的市场体系的具体措施的是（）。<br>A: 实施统一的市场准入负面清单制度<br>B: 鼓励形成垄断竞争市场<br>C: 完善要素交易规则和服务体系<br>D: 健全产权执法司法保护制度<br>正确答案: B</p>
<p>下列各项中，不符合统一开放竞争有序的市场体系的要求的是（）。<br>A: 市场准入畅通<br>B: 市场秩序规范<br>C: 市场竞争充分<br>D: 市场无序开放<br>正确答案: D</p>
<p>建设现代化经济体系，就要加快形成现代市场体系，其特点不包括（）。<br>A: 企业自主经营公平竞争<br>B: 取消一切准入限制<br>C: 消费者自由选择自主消费<br>D: 商品和要素自由流动平等交换<br>正确答案: B</p>
<p>下列各项中，不属于建设体现效率促进公平的收入分配体系的具体举措的是（）。<br>A: 坚持按劳分配为主体多种分配方式并存的基本经济制度<br>B: 坚持多劳多得，提高劳动报酬在初次分配中的比重<br>C: 保护所有收入<br>D: 重视发挥第三次分配作用<br>正确答案: C</p>
<p>建设体现效率促进公平的收入分配体系的具体举措不包括（）。<br>A: 缩小中等收入群体<br>B: 增加低收入者收入<br>C: 调节过高收入<br>D: 取缔非法收入<br>正确答案: A</p>
<p>下列各项中，不属于建设彰显优势，协调联动的城乡区域发展体系的具体举措的是（）。<br>A: 优化现代化经济体系的空间布局<br>B: 塑造区域协调发展新格局<br>C: 建立健全城乡融合发展体制机制和政策体系<br>D: 尽快实现人民生活水平完全相同<br>正确答案: D</p>
<p>下列各项中，不属于建设资源节约环境友好的绿色发展体系的具体举措的是（）。<br>A: 全面降低资源利用效率<br>B: 强化绿色发展的法律和政策保障<br>C: 完善生态文明领域统筹协调机制<br>D: 协同推进经济高质量发展和生态环境高水平保护<br>正确答案: A</p>
<p>下列各项中，不属于建设多元平衡安全高效的全面开放体系的具体举措的是（）。<br>A: 完善内外贸一体化调控体系<br>B: 实施自由贸易区提升战略<br>C: 迅猛推进人民币国际化<br>D: 积极参与多双边区域投资贸易合作机制<br>正确答案: C</p>
<p>下列各项中，不属于建设充分发挥市场作用更好发挥政府作用的经济体制的具体举措的是（）。<br>A: 坚持社会主义市场经济体制的基本经济制度<br>B: 健全宏观经济治理体系<br>C: 取消金融监管<br>D: 全面实行政府权责清单制度<br>正确答案: C</p>
<p>建设充分发挥市场作用更好发挥政府作用的经济体制，就要健全宏观经济治理体系，其主要特点不包括（）。<br>A: 目标优化<br>B: 高效协同<br>C: 分工合理<br>D: 指令僵化<br>正确答案: D</p>
<p>下列各项中，不属于建设充分发挥市场作用更好发挥政府作用的经济体制所要实现的目标的是（）。<br>A: 市场机制有效<br>B: 微观主体有活力<br>C: 计划管理全覆盖<br>D: 宏观调控有度<br>正确答案: C</p>
<p>关于政治制度模式，下列说法中错误的是（）。<br>A: 世界上没有完全相同的政治制度模式<br>B: 政治制度不能脱离特定社会政治条件来抽象评判<br>C: 政治制度可以脱离历史文化传统来抽象评判<br>D: 一个国家不能生搬硬套外国政治制度模式<br>正确答案: C</p>
<p>走中国特色社会主义政治发展道路，就要保持政治定力，坚持从国情出发从实际出发，其具体要求不包括（）。<br>A: 割断长期形成的历史传承<br>B: 把握走过的发展道路<br>C: 把握积累的政治经验形成的政治原则<br>D: 把握现实要求着眼解决现实问题<br>正确答案: A</p>
<p>人民政协要以改革创新精神推进履职能力建设，其需要着力增强的能力不包括（）。<br>A: 政治把握能力<br>B: 墨守成规能力<br>C: 联系群众能力<br>D: 合作共事能力<br>正确答案: B</p>
<p>（）着眼新时代党和国家事业全局，明确把坚持马克思主义在意识形态领域的指导地位确立为根本制度。<br>A: 党的十九届一中全会<br>B: 党的十九届二中全会<br>C: 党的十九届三中全会<br>D: 党的十九届四中全会<br>正确答案: D</p>
<p>坚持马克思主义在意识形态领域指导地位的根本制度，就要实施马克思主义理论研究和建设工程，其具体举措不包括（）。<br>A: 不断深化对党的基本理论基本路线基本方略的研究<br>B: 坚持用中国理论阐释中国实践，用中国实践发展中国理论<br>C: 加快照搬西方经验构建哲学社会科学<br>D: 推动马克思主义中国化最新成果进教材进课堂进头脑<br>正确答案: C</p>
<p>坚持马克思主义在意识形态领域指导地位的根本制度，就要加强和改进学校思想政治教育，其具体举措不包括（）。<br>A: 坚持实用主义办学方向<br>B: 落实立德树人根本任务<br>C: 在大中小学循序渐进螺旋上升地开设思政课<br>D: 发挥好思政课教师的重要作用<br>正确答案: A</p>
<p>繁荣发展社会主义文化，就要提升公共文化服务水平，其具体举措不包括（）。<br>A: 加强国家重大文化设施和文化项目建设<br>B: 做强新型主流媒体<br>C: 简单提高文艺作品数量<br>D: 推动公共文化数字化建设<br>正确答案: C</p>
<p>健全现代文化产业体系，就要坚持把（）放在首位社会效益和经济效益相统一。<br>A: 学术效益<br>B: 经济效益<br>C: 社会效益<br>D: 文献效益<br>正确答案: C</p>
<p>繁荣发展社会主义文化，就要健全现代文化产业体系，其具体举措不包括（）。<br>A: 完善文化产业规划和政策<br>B: 弱化文化体制改革<br>C: 实施文化产业数字化战略<br>D: 推动文化和旅游融合发展<br>正确答案: B</p>
<p>关于以人民为中心的发展思想，下列各项中，理解错误的是（）。<br>A: 以人民为中心的发展思想不能只停留在口头上<br>B: 以人民为中心的发展思想不能止步于思想环节<br>C: 以人民为中心的发展思想是一个抽象的玄奥的概念<br>D: 以人民为中心的发展思想要体现在经济社会发展各个环节<br>正确答案: C</p>
<p>改善民生要坚持尽力而为与量力而行的统一，其具体要求不包括（）。<br>A: 根据经济发展和财力状况逐步提高人民生活水平<br>B: 为了尽快实现民生的彻底改善而不惜脱离国情<br>C: 从解决好人民群众普遍关心的突出问题入手<br>D: 做好普惠性基础性兜底性民生建设<br>正确答案: B</p>
<p>在发展中保障和改善民生，就要建设高质量教育体系，其具体举措不包括（）。<br>A: 全面贯彻党的教育方针<br>B: 落实立德树人根本任务<br>C: 全力发展应试教育<br>D: 推进教育公平<br>正确答案: C</p>
<p>在发展中保障和改善民生，就要实施就业优先战略，其具体举措不包括（）。<br>A: 健全有利于更充分更高质量就业的促进机制<br>B: 扩大就业容量<br>C: 提升就业质量<br>D: 搁置结构性就业矛盾<br>正确答案: D</p>
<p>在发展中保障和改善民生，就要优化收入分配结构，其具体举措不包括（）。<br>A: 降低劳动报酬在初次分配中的比重<br>B: 完善再分配机制<br>C: 坚持居民收入增长和经济增长基本同步<br>D: 持续提高低收入群体收入<br>正确答案: A</p>
<p>在发展中保障和改善民生，就要健全多层次社会保障体系，其具体举措不包括（）。<br>A: 优化社会教助和慈善制度<br>B: 将社会保险基金完全交由社会资本运营<br>C: 健全退役军人工作体系和保障制度<br>D: 加快健全多层次社会保障体系<br>正确答案: B</p>
<p>在发展中保障和改善民生，就要全面推进健康中国建设，其具体举措不包括（）。<br>A: 坚持治疗为主的方针，深入实施健康中国行动<br>B: 建设体育强国<br>C: 完善国民健康促进政策<br>D: 织牢国家公共卫生防护网<br>正确答案: A</p>
<p>在社会大局总体稳定的同时，社会治理面临的风险和挑战更加严峻复杂，我国的社会治理工作在很多方面需进一步加强和创新，其具体面临的问题不包括（）。<br>A: 社会利益关系日趋简单<br>B: 社会阶层结构分化<br>C: 社会矛盾和问题交织叠加<br>D: 社会共识凝聚难度不断加大<br>正确答案: A</p>
<p>“枫桥经验”，是指20世纪60年代（）枫桥镇干部群众创造的依靠群众就地化解矛盾的做法。<br>A: 浙江湖州<br>B: 陕西延安<br>C: 福建福州<br>D: 浙江诸暨<br>正确答案: D</p>
<p>新时代“枫桥经验”的主要路径是“三治结合”，其中不包括（）。<br>A: 自治<br>B: 法治<br>C: 人治<br>D: 德治<br>正确答案: C</p>
<p>加强和创新社会治理，就要加强社会心理服务体系建设，其具体举措不包括（）。<br>A: 重视强制化解刚性维稳<br>B: 塑造自尊自信理性平和亲善友爱的社会心态<br>C: 加强和改进思想政治工作<br>D: 推进诚信建设和志愿服务制度化<br>正确答案: A</p>
<p>加强和创新社会治理，核心是（）。<br>A: 人<br>B: 法<br>C: 技术<br>D: 制度<br>正确答案: A</p>
<p>下列各项中，不属于加强社会心理服务体系建设所要塑造的社会心态的是（）。<br>A: 自尊自信<br>B: 理性平和<br>C: 亲善友爱<br>D: 急功近利<br>正确答案: D</p>
<p>加强和创新社会治理，就要构建基层社会治理新格局，其具体举措不包括（）。<br>A: 把更多资源服务管理下沉到基层<br>B: 健全党组织领导村(居)委会主导人民群众为主体的基层社会治理框架<br>C: 健立完全自治的城乡基层治理体系<br>D: 注重发挥家庭家教家风在基层社会治理中的重要作用<br>正确答案: C</p>
<p>生态文明建设中必须严格坚守的三条红线是保障和维护国家生态安全的底线与生命线，其中不包括（）。<br>A: 生态保护红线<br>B: 环境破坏底线<br>C: 环境质量底线<br>D: 资源利用上线<br>正确答案: B</p>
<p>习近平生态文明思想指出，要用最严格制度最严密法治保护生态环境，其具体举措不包括（）。<br>A: 严格沿用过去制度<br>B: 严格用制度管权治吏护蓝增绿<br>C: 保证生态文明建设决策部署落地生根见效<br>D: 落实领导干部生态文明建设责任制<br>正确答案: A</p>
<p>关于我国当前生态文明建设所处的状态，下列描述中错误的是（）。<br>A: 压力叠加负重前行的关键期<br>B: 提供更多优质生态产品以满足人民日益增长的优美生态环境需要的攻坚期<br>C: 呈现持续向好趋势并不断收获稳固成效的完胜期<br>D: 有条件有能力解决生态环境突出问题的窗口期<br>正确答案: C</p>
<p>建设美丽中国，就要加快形成绿色发展方式，调整经济结构和能源结构，其所要培养壮大的产业不包括（）。<br>A: 节能环保产业<br>B: 低端高耗能产业<br>C: 清洁生产产业<br>D: 清洁能源产业<br>正确答案: B</p>
<p>碳达峰是指我国承诺（）年前二氧化碳的排放不再增长，达到保值之后逐步降低。<br>A: 2025<br>B: 2030<br>C: 2035<br>D: 2049<br>正确答案: B</p>
<p>在（）年全国两会上，碳达峰碳中和被首次写入我国政府工作报告。<br>A: 2018<br>B: 2019<br>C: 2020<br>D: 2021<br>正确答案: D</p>
<p>关于自然资源部和生态环境部的组建意义，下列说法中错误的是（）。<br>A: 有效解决了所有者与监管者职责不清晰的问题<br>B: 有效解决了九龙治水问题<br>C: 理顺了生态文明管理体制机制<br>D: 完善了多头治理体制机制<br>正确答案: D</p>
<p>建设美丽中国，就要有效防范生态环境风险， 其具体不包括（）。<br>A: 防止各类生态环境风险积聚扩散<br>B: 把生态环境风险纳入非常态化管理<br>C: 系统构建全过程多层级生态环境风险防范体系<br>D: 着力提升突发环境事件应急处置能力<br>正确答案: B</p>
<p>提高环境治理水平，需要综合运用多种手段，其正确手段不包括（）。<br>A: 完全由政府负责重大项目科技攻关<br>B: 将生态环境成本纳入经济运行成本<br>C: 对涉及经济社会发展的重大生态环境问题开展对策性研究<br>D: 实施积极应对气候变化国家战略<br>正确答案: A</p>
<p>提高环境治理水平，就要充分运用（）手段，撬动更多社会资本进入生态环境保护领域。<br>A: 行政化<br>B: 资本化<br>C: 强制化<br>D: 市场化<br>正确答案: D</p>
<h3 id="多选题-10"><a href="#多选题-10" class="headerlink" title="多选题"></a>多选题</h3><p>习近平经济思想指出，要推动有效市场和有为政府更好结合，发挥政府在（）环境保护中的作用。<br>A: 宏观调控<br>B: 公共服务<br>C: 市场监管<br>D: 社会管理<br>正确答案: ABCD</p>
<p>习近平经济思想坚持问题导向部署经济发展新战略，其具体表现有（）。<br>A: 提出以疏解北京非首都功能为重点的京津冀协同发展战略<br>B: 提出以共抓大保护不搞大开发为原则的长江经济带发展战略<br>C: 提出以促进合作共赢为落脚点的“一带一路”建设<br>D: 提出以促进人的城镇化为核心提高质量为导向的新型城镇化战略<br>正确答案: ABCD</p>
<p>习近平经济思想坚持问题导向部署经济发展新战略，提出以（）为原则的长江经济带发展战略。<br>A: 共抓大保护<br>B: 先污染后治理<br>C: 不搞大开发<br>D: 坚决不开发<br>正确答案: AC</p>
<p>习近平经济思想系统回答了新时代中国特色社会主义经济发展的（）主题主线发展阶段发展理念发展格局发展路径内外关系和工作方法等一系列重大问题.<br>A: 时代背景<br>B: 根本立场<br>C: 政治保障<br>D: 制度基础<br>正确答案: ABCD</p>
<p>把推进供给侧结构性改革作为经济发展的主线，要坚持“（）”等方针。<br>A: 巩固<br>B: 增强<br>C: 提升<br>D: 畅通<br>正确答案: ABCD</p>
<p>深化供给侧结构性改革要坚持质量第一效益优先，推动经济发展（）。<br>A: 质量变革<br>B: 宗旨变革<br>C: 效率变革<br>D: 动力变革<br>正确答案: ACD</p>
<p>供给侧结构性改革是（）的必然要求和选择。<br>A: 培育增长新动力<br>B: 形成先发新优势<br>C: 不断累积过剩产能<br>D: 实现创新引领发展<br>正确答案: ABD</p>
<p>供给侧管理重在解决结构性问题，注重激发经济增长动力，主要通过（）来提高供给体系质量和效率，进而推动经济增长。<br>A: 优化要素配置<br>B: 调节税收<br>C: 调整生产结构<br>D: 调节财政支出<br>正确答案: AC</p>
<p>推动供给侧结构性改革，就要加快实施创新驱动发展战略，其具体措施包括（）。<br>A: 完善国家创新体系<br>B: 提高创新链整体效益<br>C: 提升企业技术创新能力<br>D: 深入推进科技体制改革<br>正确答案: ABCD</p>
<p>坚持创新在我国现代化建设全局中的核心地位，就要面向（），深入实施科教兴国战略人才强国战略创新驱动发展战略。<br>A: 世界科技前沿<br>B: 经济主战场<br>C: 国家重大需求<br>D: 人民生命健康<br>正确答案: ABCD</p>
<p>加快实施创新驱动发展战略，就要健全以（）为导向的科技人才评价体系。<br>A: 创新能力<br>B: 创新质量<br>C: 创新实效<br>D: 创新贡献<br>正确答案: ABCD</p>
<p>实现由以价取胜向以质取胜的转变，就要推进土地（）等要素市场化改革。<br>A: 劳动力<br>B: 资本<br>C: 技术<br>D: 数据<br>正确答案: ABCD</p>
<p>加大人力资源培育力度，就要建设（）劳动者大军。<br>A: 知识型<br>B: 技能型<br>C: 低薪型<br>D: 创新型<br>正确答案: ABD</p>
<p>非公有制经济在我国经济社会发展中的地位和作用没有变，我们毫不动摇（）非公有制经济发展的方针政策没有变，我们致力于为非公有制经济发展营造良好环境和提供更多机会的方针政策没有变。<br>A: 鼓励<br>B: 限制<br>C: 支持<br>D: 引导<br>正确答案: ACD</p>
<p>推动供给侧结构性改革，就要降低（），切实降低企业负担。<br>A: 用能成本<br>B: 物流成本<br>C: 要素成本<br>D: 制度性交易成本<br>正确答案: ABCD</p>
<p>建设现代化经济体系是我国发展的战略目标，也是（）的迫切要求。<br>A: 转变经济发展方式<br>B: 优化经济结构<br>C: 超越经济发展阶段<br>D: 转换经济增长动力<br>正确答案: ABD</p>
<p>只有形成现代化经济体系，才能实现更高质量（）的发展。<br>A: 更有效率<br>B: 更加公平<br>C: 更可持续<br>D: 更为安全<br>正确答案: ABCD</p>
<p>按照建设社会主义现代化强国的要求，加快建设现代化经济体系，是（）的必然要求。<br>A: 遵循经济发展规律<br>B: 适应我国社会主要矛盾变化<br>C: 跳过经济发展“三期叠加”阶段<br>D: 保持经济持续健康发展<br>正确答案: ABD</p>
<p>建设创新引领协同发展的产业体系，就要实现（）协同发展，巩固壮大实体经济根基。<br>A: 实体经济<br>B: 科技创新<br>C: 现代金融<br>D: 人力资源<br>正确答案: ABCD</p>
<p>建设创新引领协同发展的产业体系，就要发展战略性新兴产业，培育（）。<br>A: 新技术<br>B: 新产品<br>C: 新业态<br>D: 新模式<br>正确答案: ABCD</p>
<p>建设体现效率促进公平的收入分配体系，就要健全劳动资本土地（）等生产要素由市场评价贡献按贡献决定报酬的机制。<br>A: 知识<br>B: 技术<br>C: 管理<br>D: 数据<br>正确答案: ABCD</p>
<p>建设体现效率促进公平的收入分配体系，就要健全以（）等为主要手段的再分配调节机制。<br>A: 税收<br>B: 劳动报酬<br>C: 社会保障<br>D: 转移支付<br>正确答案: ACD</p>
<p>建设彰显优势，协调联动的城乡区域发展体系，就要健全（）等机制。<br>A: 区域战略统筹<br>B: 市场一体化发展<br>C: 区域合作互助<br>D: 区际利益补偿<br>正确答案: ABCD</p>
<p>建设多元平衡安全高效的全面开放体系就要完善内外贸一体化调控体系，促进内外贸法律法规监管体制（）等相衔接<br>A: 经营资质<br>B: 质量标准<br>C: 检验检疫<br>D: 认证认可<br>正确答案: ABCD</p>
<p>健全目标优化分工合理高效协同的宏观经济治理体系，需要（）环保区域等政策紧密配合。<br>A: 就业<br>B: 产业<br>C: 投资<br>D: 消费<br>正确答案: ABCD</p>
<p>建设充分发挥市场作用更好发挥政府作用的经济体制，就要建立现代财税金融体制，其具体措施有（）。<br>A: 完善现代税收制度<br>B: 健全政府债务管理制度<br>C: 建设现代中央银行制度<br>D: 完善现代金融监管体系<br>正确答案: ABCD</p>
<p>建设充分发挥市场作用更好发挥政府作用的经济体制，就要全面实行政府权责清单制度，持续优化（）营商环境。<br>A: 市场化<br>B: 法治化<br>C: 脱管化<br>D: 国际化<br>正确答案: ABD</p>
<p>在中国特色社会主义新时代，确保人民享有（）的民主权利，让社会主义民主的优越性更加充分地展示出来。<br>A: 更加广泛<br>B: 更加片面<br>C: 更加充分<br>D: 更加真实<br>正确答案: ACD</p>
<p>实现人民当家作主，就要扩大人民有序政治参与，保证人民依法实行民主选举（）。<br>A: 民主协商<br>B: 民主决策<br>C: 民主管理<br>D: 民主监督<br>正确答案: ABCD</p>
<p>走中国特色社会主义政治发展道路，就要巩固基层政权，完善基层民主制度，保障人民（）。<br>A: 知情权<br>B: 参与权<br>C: 表达权<br>D: 监督权<br>正确答案: ABCD</p>
<p>持续推进政治体制改革，就要推动人大政府政协（）企事业单位社会组织等在党的统一领导下协调行动增强合力。<br>A: 监察机关<br>B: 审判机关<br>C: 检察机关<br>D: 人民团体<br>正确答案: ABCD</p>
<p>人民当家作主制度体系，主要由（）构成。<br>A: 人民代表大会制度<br>B: 中国共产党领导的多党合作和政治协商制度<br>C: 民族区域自治制度<br>D: 基层群众自治制度<br>正确答案: ABCD</p>
<p>健全人民当家作主制度体系，就要支持和保证人大依法行使（）。<br>A: 立法权<br>B: 监督权<br>C: 决定权<br>D: 任免权<br>正确答案: ABCD</p>
<p>中国共产党领导的多党合作和政治协商制度通过（）的安排集中各种意见和建议，推动决策科学化民主化。<br>A: 制度化<br>B: 程序化<br>C: 规范化<br>D: 无序化<br>正确答案: ABC</p>
<p>中国共产党领导的多党合作和政治协商制度有效避免了旧式政党制度囿于（）决策施政导致社会撕裂的弊端。<br>A: 党派利益<br>B: 阶级利益<br>C: 区域利益<br>D: 集团利益<br>正确答案: ABCD</p>
<p>坚定不移走中国特色解决民族问题的正确道路，就要巩固和发展（）的社会主义民族关系。<br>A: 平等<br>B: 团结<br>C: 互助<br>D: 和谐<br>正确答案: ABCD</p>
<p>要坚持不懈开展马克思主义（）宣传教育，打牢中华民族共同体思想基础。<br>A: 祖国观<br>B: 民族观<br>C: 文化观<br>D: 历史观<br>正确答案: ABCD</p>
<p>基层群众自治制度是党领导人民群众在城乡社区治理基层公共事务和公益事业中（），推动基层直接民主的新创造新实践。<br>A: 依法自我管理<br>B: 依法自我服务<br>C: 依法自我教育<br>D: 依法自我监督<br>正确答案: ABCD</p>
<p>我国人民依法实行民主选举（），这些环节扩大了人民有序政治参与，集中反映了全过程民主的具体形式。<br>A: 民主协商<br>B: 民主决策<br>C: 民主管理<br>D: 民主监督<br>正确答案: ABCD</p>
<p>社会主义民主既保证了人民进行民主选举的权利，也保证了人民在（）等方面的权利，是全过程的民主。<br>A: 民主监督<br>B: 民主管理<br>C: 民主协商<br>D: 民主决策<br>正确答案: ABCD</p>
<p>健全人民当家作主制度体系，必须推进协商民主（）发展。<br>A: 广泛<br>B: 多层<br>C: 片面化<br>D: 制度化<br>正确答案: ABD</p>
<p>健全人民当家作主制度体系，必须统筹推进（）人民团体协商基层协商及社会组织协商，保证人民在日常政治生活中有广泛持续深入参与的权利。<br>A: 政党协商<br>B: 人大协商<br>C: 政府协商<br>D: 政协协商<br>正确答案: ABCD</p>
<p>在长期的革命建设和改革过程中，已经结成了由中国共产党领导的，有各民主党派和各人民团体参加的，包括（）的广泛的爱国统一战线。<br>A: 全体社会主义劳动者<br>B: 社会主义事业的建设者<br>C: 拥护社会主义的爱国者<br>D: 拥护祖国统一和致力于中华民族伟大复兴的爱国者<br>正确答案: ABCD</p>
<p>新时代巩固发展爱国统一战线工作，就要坚持（），支持民主党派按照中国特色社会主义参政党要求更好履行职能。<br>A: 长期共存<br>B: 互相监督<br>C: 肝胆相照<br>D: 荣辱与共<br>正确答案: ABCD</p>
<p>新时代巩固发展爱国统一战线工作，就要支持民主党派加强思想组织制度特别是领导班子建设，提高（）解决自身问题能力。<br>A: 政治把握能力<br>B: 参政议政能力<br>C: 组织领导能力<br>D: 合作共事能力<br>正确答案: ABCD</p>
<p>全面贯彻党的宗教工作基本方针，就要引导宗教人士努力为促进（）祖国统一服务。<br>A: 经济发展<br>B: 社会和谐<br>C: 文化繁荣<br>D: 民族团结<br>正确答案: ABCD</p>
<p>（）精神文明创建网络建设管理等文化领城的一切工作和活动都要紧紧围绕坚持马克思主义在意识形态领域指导地位这一根本制度来展开来推进。<br>A: 理论武装<br>B: 新闻宣传<br>C: 文艺创作生产<br>D: 文化体制改革<br>正确答案: ABCD</p>
<p>实施马克思主义理论研究和建设工程，就要深化对中国特色社会主义（）的研究，为理论创新创造提供学理支撑。<br>A: 道路<br>B: 理论<br>C: 制度<br>D: 文化<br>正确答案: ABCD</p>
<p>加强和改进学校思想政治教育，就要深入推进思政课改革创新，不断增强思政课的（）。<br>A: 思想性<br>B: 理论性<br>C: 亲和力<br>D: 针对性<br>正确答案: ABCD</p>
<p>富强民主文明和谐，自由平等公正法治，爱国敬业诚信友善，这24字表达，回答了我们要（）的重大问题。<br>A: 建设什么样的世界<br>B: 建设什么样的国家<br>C: 建设什么样的社会<br>D: 培育什么样的公民<br>正确答案: BCD</p>
<p>社会主义核心价值体系由（）等内容构成。<br>A: 马克思主义指导思想<br>B: 中国特色社会主义共同理想<br>C: 以爱国主义为核心的民族精神和以改革创新为核心的时代精神<br>D: 社会主义荣辱观<br>正确答案: ABCD</p>
<p>一种价值观要真正发挥作用，必须通过强化教育引导（）等，将其融入社会生活。<br>A: 舆论宣传<br>B: 文化熏陶<br>C: 实践养成<br>D: 制度保障<br>正确答案: ABCD</p>
<p>培育和践行社会主义核心价值观，还必须发扬中国人民在长期奋斗中培育继承发展起来的伟大民族精神，这包括（）。<br>A: 伟大创造精神<br>B: 伟大奋斗精神<br>C: 伟大团结精神<br>D: 伟大梦想精神<br>正确答案: ABCD</p>
<p>新时代，坚持以社会主义核心价值观引领文化建设，就要围绕（）展形象的使命任务，推进社会主义文化强国建设。<br>A: 举旗帜<br>B: 聚民心<br>C: 育新人<br>D: 兴文化<br>正确答案: ABCD</p>
<p>我国有着悠久的历史传统和深厚的文化资源，弘扬（），促进全体人民在思想上精神上紧紧团结在一起的显著优势。<br>A: 中华优秀传统文化<br>B: 中华一切传统文化<br>C: 革命文化<br>D: 社会主义先进文化<br>正确答案: ACD</p>
<p>繁荣发展社会主义文化，就要提升公共文化服务水平，全面繁荣（）事业。<br>A: 新闻出版<br>B: 广播影视<br>C: 文学艺术<br>D: 哲学社会科学<br>正确答案: ABCD</p>
<p>提高国家文化软实力，就要构建具有鲜明中国特色的战略传播体系，着力提高国际传播影响力（）。<br>A: 中华文化感召力<br>B: 中国形象亲和力<br>C: 中国话语说服力<br>D: 国际舆论引导力<br>正确答案: ABCD</p>
<p>民生是人民幸福之基社会和谐之本，保证全体人民在现实生活中有（）的获得感幸福感安全感。<br>A: 更多<br>B: 更直接<br>C: 更实在<br>D: 更表面<br>正确答案: ABC</p>
<p>改善民生应当怎样坚持尽力而为与量力而行的统一，做好（）民生建设，在事关基本民生的关键领域持续取得新进展。<br>A: 普惠性<br>B: 基础性<br>C: 兜底性<br>D: 拔高性<br>正确答案: ABC</p>
<p>在发展中保障和改善民生，要抓住人民最关心最直接最现实的利益问题，在幼有所育学有所教劳有所得（）等方面不断取得新进展。<br>A: 病有所医<br>B: 老有所养<br>C: 住有所居<br>D: 弱有所扶<br>正确答案: ABCD</p>
<p>在发展中保障和改善民生，就要加快健全（）的多层次社会保障体系。<br>A: 覆盖全民<br>B: 统筹城乡<br>C: 公平统一<br>D: 可持续<br>正确答案: ABCD</p>
<p>加强和创新社会治理，要逐步实现（），有力推进国家治理现代化。<br>A: 社会治理结构的合理化<br>B: 社会治理方式的科学化<br>C: 治理手段的粗暴化<br>D: 社会治理过程的民主化<br>正确答案: ABD</p>
<p>加强社会治理制度建设，要完善（）公众参与法治保障科技支撑的社会治理体系。<br>A: 党委领导<br>B: 政府负责<br>C: 民主协商<br>D: 社会协同<br>正确答案: ABCD</p>
<p>加强社会治理制度建设，就要充分调动各方面积极性，建设（）的社会治理共同体。<br>A: 人人有责<br>B: 人人尽责<br>C: 人人享有<br>D: 共搭便车<br>正确答案: ABC</p>
<p>创新社会治理体制，就要畅通和规范（）等参与社会治理的途径，真正实现社会共建共治共享。<br>A: 市场主体<br>B: 新社会阶层<br>C: 社会工作者<br>D: 志愿者<br>正确答案: ABCD</p>
<p>（）并举是新时代“枫桥经验”的重要手段。<br>A: 人防<br>B: 物防<br>C: 技防<br>D: 心防<br>正确答案: ABCD</p>
<p>完善社会治安防控体系，就要提高社会治安（）水平。<br>A: 立体化<br>B: 法治化<br>C: 专业化<br>D: 智能化<br>正确答案: ABCD</p>
<p>完善社会治安防控体系，就要形成（）的工作机制。<br>A: 问题联治<br>B: 工作联动<br>C: 平安联创<br>D: 责任平摊<br>正确答案: ABC</p>
<p>完善社会治安防控体系，就要增强社会治安防控的（）。<br>A: 整体性<br>B: 协同性<br>C: 粗放性<br>D: 精准性<br>正确答案: ABD</p>
<p>加强社会心理服务体系建设，就要推进诚信建设和志愿服务制度化，强化（）。<br>A: 社会责任意识<br>B: 唯利是图意识<br>C: 规则意识<br>D: 奉献意识<br>正确答案: ACD</p>
<p>在整个发展过程中，我们都要坚持（）为主的方针，让自然生态美景永驻人间。<br>A: 节约优先<br>B: 改造优先<br>C: 保护优先<br>D: 自然恢复<br>正确答案: ACD</p>
<p>必须贯彻新发展理念，加快形成节约资源和保护环境的（），把经济活动人的行为限制在自然资源和生态环境能够承受的限度内<br>A: 空间格局<br>B: 产业结构<br>C: 生产方式<br>D: 生活方式<br>正确答案: ABCD</p>
<p>从系统工程和全局角度寻求生态环境治理之道，必须（）， 全方位全地域全过程开展生态文明建设。<br>A: 统筹兼顾<br>B: 片面用力<br>C: 整体施策<br>D: 多措并举<br>正确答案: ACD</p>
<p>我国生态环境保护中存在的突出问题大多同（）惩处不得力有关。<br>A: 体制不健全<br>B: 制度不严格<br>C: 法治不严密<br>D: 执行不到位<br>正确答案: ABCD</p>
<p>我国已成为全球生态文明建设的（），主张加快构筑尊崇自然绿色发展的生态体系，共建清洁美丽的世界。<br>A: 重要参与者<br>B: 搭便车者<br>C: 重要贡献者<br>D: 重要引领者<br>正确答案: ACD</p>
<p>建设人与自然和谐共生的现代化，建设美丽中国，必须坚定不移走（）的文明发展道路。<br>A: 生产发展<br>B: 生活富裕<br>C: 生态良好<br>D: 舍弃发展<br>正确答案: ABC</p>
<p>环境治理是系统工程，提高环境治理水平，需要综合运用（）等多种手段。<br>A: 行政<br>B: 市场<br>C: 法治<br>D: 科技<br>正确答案: ABCD</p>
<p>提高环境治理水平，就要实施积极应对气候变化国家战略，推动和引导建立（）的全球气候治理体系，彰显中国负责任大国形象。<br>A: 公平合理<br>B: 各自为战<br>C: 合作共赢<br>D: 以邻为壑<br>正确答案: AC</p>
<h3 id="判断题-10"><a href="#判断题-10" class="headerlink" title="判断题"></a>判断题</h3><p>坚持加强党对经济工作的集中统一领导，就要坚持和完善党中央领导经济工作的体制机制，加强党中央对发展大局大势的分析和把握。<br>正确答案: 对</p>
<p>研判经济形势要跳出经济规律，聚焦局部，盯紧短期变化。<br>正确答案: 错</p>
<p>坚持正确政绩观，就必须简单以生产总值增长率论英雄。<br>正确答案: 错</p>
<p>坚持正确政绩观，就要聚焦短期经济指标的波动而随时做出政策调整。<br>正确答案: 错</p>
<p>宏观调控必须适应发展阶段性特征和经济形势变化，相机抉择，开准药方。<br>正确答案: 对</p>
<p>在当今中国实现经济高质量发展，必须坚持供给侧结构性改革。<br>正确答案: 对</p>
<p>供给侧结构性改革是化解我国经济发展面临困难和矛盾的重大举措。<br>正确答案: 对</p>
<p>加快实施创新驱动发展战略，就要健全社会主义市场经济条件下新型举国体制，打好关键核心技术攻坚战。<br>正确答案: 对</p>
<p>推动供给侧结构性改革，就要加快国有经济布局优化和结构调整，发挥国有经济战略支撑作用。<br>正确答案: 对</p>
<p>只有形成现代化经济体系，才能更好顺应现代化发展潮流和赢得国际竞争主动。<br>正确答案: 对</p>
<p>建设多元平衡安全高效的全面开放体系就要积极促进外需导向和依附型经济协调发展，促进国际收支基本平衡。<br>正确答案: 对</p>
<p>中国特色社会主义政治发展道路是坚持党的本质属性践行党的根本宗旨的必然要求。<br>正确答案: 对</p>
<p>党的领导是人民当家作主和依法治国的根本保证。<br>正确答案: 对</p>
<p>人民当家作主是社会主义民主政治的本质特征。<br>正确答案: 对</p>
<p>走中国特色社会主义政治发展道路，必须坚持正确政治方向。<br>正确答案: 对</p>
<p>我们必须照搬国外一切政治文明成果，并可以为此放弃中国政治制度的根本。<br>正确答案: 错</p>
<p>走中国特色社会主义政治发展道路，必须积极稳妥推进政治体制改革。<br>正确答案: 对</p>
<p>我国是工人阶级领导的以工农联盟为基础的人民民主专政的社会主义国家。<br>正确答案: 对</p>
<p>我国社会主义民主是维护人民根本利益的最广泛最真实最管用的民主。<br>正确答案: 对</p>
<p>人民代表大会制度是符合中国国情体现中国社会主义国家性质能够保证人民当家作主的根本政治制度和最高实现形式。<br>正确答案: 对</p>
<p>人民代表大会制度是党在国家政权中充分发扬民主贯彻群众路线的最好实现形式。<br>正确答案: 对</p>
<p>人民政协民主监督要重点监督党和国家重大方针政策和重要决策部署的贯彻落实。<br>正确答案: 对</p>
<p>民族区域自治制度是中国特色解决民族问题的正确道路的重要内容和制度保障。<br>正确答案: 对</p>
<p>基层群众自治制度是充满活力独具特色符合国情的好制度。<br>正确答案: 对</p>
<p>社会主义民主不是装饰品，不是摆设，而是具体地生动地体现在人民当家作主的全过程各环节。<br>正确答案: 对</p>
<p>有事好商量，众人的事情由众人商量，是人民民主的真谛。<br>正确答案: 对</p>
<p>社会主义的建设事业只能依靠工人农民和知识分子。<br>正确答案: 错</p>
<p>统一战线是增强党的阶级基础扩大党的群众基础巩固党的执政地位的重要法宝。<br>正确答案: 对</p>
<p>统一战线是全面建设社会主义现代化国家实现中华民族伟大复兴的重要法宝。<br>正确答案: 对</p>
<p>中华民族和各民族的关系，是个大家庭和家庭成员的关系，各民族之间的关系是一个大家庭里不同成员的关系。<br>正确答案: 对</p>
<p>无论本土宗教还是外来宗教，都要不断适应我国社会发展，充实时代内涵。<br>正确答案: 对</p>
<p>意识形态关乎旗帜关乎道路关乎国家安全，决定文化前进方向和道路。<br>正确答案: 对</p>
<p>能否树立马克思主义的信仰，直接关系到培养合格的社会主义建设者和接班人问题。<br>正确答案: 对</p>
<p>落实意识形态工作责任制，就要坚持党管宣传党管意识形态党管媒体不动摇。<br>正确答案: 对</p>
<p>落实意识形态工作责任制，就要把意识形态工作领导权分别交付到各类新闻媒体手中。<br>正确答案: 错</p>
<p>核心价值观，是一个民族赖以维系的精神纽带，是一个国家共同的思想道德基础。<br>正确答案: 对</p>
<p>如果没有共同的核心价值观，一个民族一个国家就会魂无定所行无依归。<br>正确答案: 对</p>
<p>能否构建具有强大感召力的核心价值观，关系社会和谐稳定，关系国家长治久安。<br>正确答案: 对</p>
<p>社会主义核心价值观是社会主义核心价值体系的内核凝练和集中表达。<br>正确答案: 对</p>
<p>培育和践行社会主义核心价值观，事关青少年扣好人生的第一粒扣子，必须从小抓起从学校抓起。<br>正确答案: 对</p>
<p>培育和践行社会主义核心价值观，必须立足中华优秀传统文化和革命文化。<br>正确答案: 对</p>
<p>革命文化包含了体现社会主义共产主义价值目标的精神形态，要大力予以传承和弘扬。<br>正确答案: 对</p>
<p>文化是一个国家一个民族的灵魂，是人民的精神家园。<br>正确答案: 对</p>
<p>文化自信是更基础更广泛更深厚的自信，是一个国家一个民族发展中更基本更深沉更持久的力量。<br>正确答案: 对</p>
<p>没有高度的文化自信，没有文化的繁荣兴盛，就没有中华民族伟大复兴。<br>正确答案: 对</p>
<p>在发展经济的基础上不断提高人民生活水平，实现人民群众对美好生活的向往，是党和国家一切工作的根本目的。<br>正确答案: 对</p>
<p>检验我们一切工作的成效，最终只需要看国内生产总值的增长速度。<br>正确答案: 错</p>
<p>就业是人民生存的经济基础和基本保障，是最大的民生工程民心工程根基工程。<br>正确答案: 对</p>
<p>收入分配是民生之源，是改善民生实现发展成果由人民共享最重要最直接的方式。<br>正确答案: 对</p>
<p>人民健康长寿是民族昌盛和国家富强的重要标志。<br>正确答案: 对</p>
<p>加强社会治理，关键在沿用惯例并持之以恒。<br>正确答案: 错</p>
<p>党建统领是新时代“枫桥经验”中的根本保证。<br>正确答案: 对</p>
<p>社会治理的重心要向顶层上移，由地级行政单位主抓。<br>正确答案: 错</p>
<p>生态环境是人类生存和发展的根基，生态环境变化直接影响文明兴衰演替。<br>正确答案: 对</p>
<p>发展经济是为了民生，保护生态环境则会阻碍民生的改善。<br>正确答案: 错</p>
<p>生态文明是人民群众共同参与共同建设共同享有的事业。<br>正确答案: 对</p>
<p>保护生态环境全在每个人的自觉，不需要依靠制度。<br>正确答案: 错</p>
<p>保护生态环境应对气候变化需要世界各国同舟共济共同努力，任何一国都无法置身事外独善其身。<br>正确答案: 对</p>
<p>建设生态文明是关系人民福祉关乎中华民族永续发展的千年大计，是实现中华民族伟大复兴的重要战略任务。<br>正确答案: 对</p>
<p>绿色是生命的象征大自然的底色，更是美好生活的基础人民群众的期盼。<br>正确答案: 对</p>
<p>生态文明体制改革是全面深化改革的重要领域，也是打好污染防治攻坚战的重要保障。<br>正确答案: 对</p>
<p>生态环境安全是国家安全的重要组成部分，是经济社会持续健康发展的重要保障。<br>正确答案: 对</p>
<h2 id="第十一章"><a href="#第十一章" class="headerlink" title="第十一章"></a>第十一章</h2><h3 id="单选题-11"><a href="#单选题-11" class="headerlink" title="单选题"></a>单选题</h3><p>（）是“两个一百年”奋斗目标的第一个百年奋斗目标，是党向人民向历史作出的庄严承诺，是中国人民的共同期盼。<br>A: 全面建成小康社会<br>B: 全面深化改革<br>C: 全面依法治国<br>D: 全面从严治党<br>正确答案: A</p>
<p>全面建成小康社会的目标要求不包括（）。<br>A: 国民素质和社会文明程度显著提高<br>B: 人民生活水平和质量普遍提高<br>C: 经济发展片面追求高速度<br>D: 各方面制度更加成熟更加定型<br>正确答案: C</p>
<p>全面建成小康社会中的“全面”的内涵不包括（）。<br>A: 发展的平衡性<br>B: 发展的协调性<br>C: 发展的可持续性<br>D: 发展的一步到位性<br>正确答案: D</p>
<p>（）是全面小康最大的短板。<br>A: 城市特别是开发区<br>B: 农村特别是贫困地区<br>C: 工业特别是制造业<br>D: 贸易特别是跨洋贸易<br>正确答案: B</p>
<p>打赢（）是全面建成小康社会的底线任务。<br>A: 脱贫攻坚战<br>B: 防范化解重大风险攻坚战<br>C: 污染防治攻坚战<br>D: 化解过剩产能攻坚战<br>正确答案: A</p>
<p>经过八年持续奋斗，到2020年底，现行标准下（）万农村贫困人口全部脱贫。<br>A: 6566<br>B: 7677<br>C: 8788<br>D: 9899<br>正确答案: D</p>
<p>截至2021年，我国中等收入群体已超过（）亿人。<br>A: 1<br>B: 2<br>C: 4<br>D: 8<br>正确答案: C</p>
<p>截至2021年，（）已建成世界上规模最大的社会保障体系。<br>A: 中国<br>B: 美国<br>C: 印度<br>D: 巴西<br>正确答案: A</p>
<p>截至2021年，我国基本医疗保险覆盖已超过（）亿人。<br>A: 7<br>B: 9<br>C: 11<br>D: 13<br>正确答案: D</p>
<p>截至2021年，我国基本养老保险覆盖已近（）亿人。<br>A: 4<br>B: 6<br>C: 8<br>D: 10<br>正确答案: D</p>
<p>（）将“全面建成小康社会”目标提升为“全面建设社会主义现代化国家”，确立全面建设社会主义现代化国家在“四个全面”战略布局中的引领地位。<br>A: 党的十九届五中全会<br>B: 党的十九届四中全会<br>C: 党的十九届三中全会<br>D: 党的十九届二中全会<br>正确答案: A</p>
<p>下列各项中，不属于脱贫攻坚经验的是（）。<br>A: 坚持党的领导，为脱贫攻坚提供坚强政治和组织保证<br>B: 坚持以人民为中心的发展思想，坚定不移走共同富裕道路<br>C: 坚持粗放扶贫方略，仅用捐助物资的办法缓解贫困现象<br>D: 坚持调动广大贫困群众积极性主动性创造性，激发脱贫内生动力<br>正确答案: C</p>
<p>（），习近平在天安门城楼上庄严宣告，经过全党全国各族人民接续奋斗，我们实现了第一个百年奋斗目标。<br>A: 2019年10月1日<br>B: 2020年9月3日<br>C: 2020年10月23日<br>D: 2021年7月1日<br>正确答案: D</p>
<p>关于中国式现代化，下列理解中错误的是（）。<br>A: 中国式现代化开辟了后发国家走向现代化的崭新道路<br>B: 中国式现代化完全遵循了资本主义现代化模式<br>C: 中国式现代化提供了现代化的全新选择<br>D: 我国用几十年的时间，在发展的很多方面走过了西方发达国家上百年甚至数百年的发展历程<br>正确答案: B</p>
<p>新时代，围绕如何全面建设社会主义现代化国家这一重大问题，习近平提出了一系列新思想新观点新要求，在（）上阐明我国现代化的特征。<br>A: 党的十九届二中全会<br>B: 党的十九届三中全会<br>C: 党的十九届四中全会<br>D: 党的十九届五中全会<br>正确答案: D</p>
<p>关于我国的现代化，下列说法中错误的是（）。<br>A: 我国的现代化是人口规模巨大的现代化<br>B: 我国的现代化是全体人民共同富裕的现代化<br>C: 我国的现代化是片面追求物质文明进步的现代化<br>D: 我国的现代化是人与自然和谐共生的现代化<br>正确答案: C</p>
<p>我国的现代化是社会主义现代化，其具体要求不包括（）。<br>A: 坚持以人民为中心的发展思想<br>B: 防止两极分化<br>C: 促进社会公平正义<br>D: 迅速实现全体人民同步富裕<br>正确答案: D</p>
<p>我国的现代化是物质文明和精神文明相协调的现代化，其具体要求不包括（）。<br>A: 坚持社会主义核心价值观<br>B: 加强理想信念教育<br>C: 弘扬中华优秀传统文化<br>D: 为了物的全面丰富而舍弃人的全面发展<br>正确答案: D</p>
<p>我国的现代化是人与自然和谐共生的现代化，其具体要求不包括（）。<br>A: 同步推进物质文明建设和生态文明建设<br>B: 走生产发展生活富裕生态良好的文明发展道路<br>C: 想要满足人民日益增长的美好生活需要，只需创造更多物质财富<br>D: 提供更多优质生态产品以满足人民日益增长的优美生态环境需要<br>正确答案: C</p>
<p>（）就改革作出了自改革开放以来最为系统全面的顶层设计，开启了全面深化改革系统整体设计推进改革的新时代。<br>A: 党的十八届二中全会<br>B: 党的十八届三中全会<br>C: 党的十八届四中全会<br>D: 党的十八届五中全会<br>正确答案: B</p>
<p>党的十八届三中全会作出了（）的决定，把“完善和发展中国特色社会主义制度推进国家治理体系和治理能力现代化”确定为全面深化改革的总目标，围绕这个总目标<br>A: 全面建设社会主义现代化国家<br>B: 全面深化改革<br>C: 全面依法治国<br>D: 全面从严治党<br>正确答案: B</p>
<p>（）提出，到2035年“各方面制度更加完善，国家治理体系和治理能力现代化基本实现”；到本世纪中叶“实现国家治理体系和治理能力现代化”。<br>A: 党的十九大<br>B: 党的十八大<br>C: 党的十七大<br>D: 党的十六大<br>正确答案: A</p>
<p>（）强调到新中国成立一百年时，全面实现国家治理体系和治理能力现代化，使中国特色社会主义制度更加巩固优越性充分展现。<br>A: 党的十九届二中全会<br>B: 党的十九届三中全会<br>C: 党的十九届四中全会<br>D: 党的十九届五中全会<br>正确答案: C</p>
<p>全面深化改革要始终坚持和完善中国特色社会主义制度，坚持以（）为中心的改革价值取向，坚持党对改革的集中统一领导。<br>A: 人民<br>B: 经济<br>C: 文化<br>D: 生态<br>正确答案: A</p>
<p>关于从实际岀发，走自己的法治道路，下列理解中错误的是（）。<br>A: 从国情实际出发<br>B: 关起门来搞法治<br>C: 坚持以我为主为我所用<br>D: 认真鉴别合理吸收世界上优秀的法治文明成果<br>正确答案: B</p>
<p>加快建设中国特色社会主义法治体系，就要完善以（）为统帅的中国特色社会主义法律体系，把国家各项事业和各项工作纳入法制轨道。<br>A: 宪法<br>B: 民法<br>C: 刑法<br>D: 行政法<br>正确答案: A</p>
<p>全面推进依法治国需要全社会共同参与，其对社会成员的要求不包括（）。<br>A: 办事依法<br>B: 遇事找法<br>C: 只用自己的思路来理解法<br>D: 解决问题靠法<br>正确答案: C</p>
<p>推进科学立法，关键是完善立法体制，深入推进科学立法民主立法，抓住（）这个关键。<br>A: 提高立法数量<br>B: 提高立法质量<br>C: 提高立法频率<br>D: 提高立法强度<br>正确答案: B</p>
<p>中国共产党有自我革命的勇气，其体现不包括（）。<br>A: 不掩饰缺点<br>B: 有缺点克服缺点<br>C: 有问题回避问题<br>D: 有错误承认并纠正错误<br>正确答案: C</p>
<p>（）把“坚持党对一切工作的领导”纳入基本方略的主要内容之一，这是在新时代对马克思主义政党建设理论的继承和发展。<br>A: 党的十六大报告<br>B: 党的十七大报告<br>C: 党的十八大报告<br>D: 党的十九大报告<br>正确答案: D</p>
<p>新时代党的建设总体布局强调（）的统领作用，更加注重党的建设的整体性和系统性。<br>A: 党的思想建设<br>B: 党的政治建设<br>C: 党的组织建设<br>D: 党的作风建设<br>正确答案: B</p>
<p>党的十九大强调“把（）摆在首位”，凸显其极端重要性，这是党的建设理论和实践的重大创新。<br>A: 党的组织建设<br>B: 党的纪律建设<br>C: 党的政治建设<br>D: 党的思想建设<br>正确答案: C</p>
<p>把全面从严治党引向深入，要把党的政治建设摆在首位，其所要坚决防止和反对的不包括（）。<br>A: 宗派主义<br>B: 圈子文化<br>C: 码头文化<br>D: 廉洁文化<br>正确答案: D</p>
<p>党的作风建设的核心是（）。<br>A: 保持党同人民群众的血肉联系<br>B: 艰苦奋斗崇尚实干<br>C: 勤俭节约崇尚清廉<br>D: 求真务实埋头苦干<br>正确答案: A</p>
<p>打赢作风建设持久战就要发扬钉钉子精神，一锤接着一锤敲，其具体要求不包括（）。<br>A: 不让享乐主义和奢靡之风卷土重来<br>B: 追求形式主义和官僚主义<br>C: 秉持艰苦奋斗崇尚实干的工作作风<br>D: 秉持勤俭节约崇尚清廉的家风<br>正确答案: B</p>
<h3 id="多选题-11"><a href="#多选题-11" class="headerlink" title="多选题"></a>多选题</h3><p>全面小康是“五位一体”全面进步的小康，要求（）生态文明建设全面推进。<br>A: 经济建设<br>B: 政治建设<br>C: 文化建设<br>D: 社会建设<br>正确答案: ABCD</p>
<p>我国的现代化是全体人民共同富裕的现代化，必须坚持以人民为中心的发展思想，自觉主动解决（）。<br>A: 地区差距<br>B: 城乡差距<br>C: 收入分配差距<br>D: 分工差别<br>正确答案: ABC</p>
<p>改革开放极大改变了（）的面貌，是当代中国发展进步的活力之源。<br>A: 中国<br>B: 中华民族<br>C: 中国人民<br>D: 中国共产党<br>正确答案: ABCD</p>
<p>随着改革进入攻坚期和深水区，继续推进改革的（）前所未有。<br>A: 复杂性<br>B: 敏感性<br>C: 联动性<br>D: 简单性<br>正确答案: ABC</p>
<p>党的十八届三中全会合理布局了全面深化改革的（）和时间表路线图，取得了改革理论和政策的一系列新的重大突破。<br>A: 战略重点<br>B: 主攻方向<br>C: 工作机制<br>D: 推进方式<br>正确答案: ABCD</p>
<p>新时代的全面深化改革对改革项层设计的要求更高，对改革（）要求更强。<br>A: 系统性<br>B: 整体性<br>C: 片面性<br>D: 协同性<br>正确答案: ABD</p>
<p>全面深化改革必须始终坚持（）。<br>A: 方向不变<br>B: 立场不移<br>C: 原则不改<br>D: 重点不调<br>正确答案: ABC</p>
<p>中国特色社会主义制度和国家治理体系是（）的制度和治理体系。<br>A: 以马克思主义为指导<br>B: 植根中国大地<br>C: 具有深厚中华文化根基<br>D: 深得人民拥护<br>正确答案: ABCD</p>
<p>在推进全面深化改革中，要不断提高党（）的能力和定力，为全面深化改革纵深推进提供根本保证。<br>A: 把方向<br>B: 谋大局<br>C: 定政策<br>D: 促改革<br>正确答案: ABCD</p>
<p>坚持和完善中国特色社会主义制度推进国家治理体系和治理能力现代化，就要着力（）。<br>A: 固根基<br>B: 扬优势<br>C: 补短板<br>D: 强弱项<br>正确答案: ABCD</p>
<p>坚持和完善中国特色社会主义制度推进国家治理体系和治理能力现代化，就要构建（）的制度体系。<br>A: 系统完备<br>B: 灵活随意<br>C: 科学规范<br>D: 运行有效<br>正确答案: ACD</p>
<p>坚持和完善中国特色社会主义制度推进国家治理体系和治理能力现代化，就要加强（），把我国制度优势更好转化为国家治理效能。<br>A: 系统治理<br>B: 依法治理<br>C: 综合治理<br>D: 源头治理<br>正确答案: ABCD</p>
<p>推进国家治理体系和治理能力现代化，就是要使各方面制度更加科学更加完善，实现党国家社会各项事务治理（）。<br>A: 制度化<br>B: 规范化<br>C: 程序化<br>D: 无序化<br>正确答案: ABC</p>
<p>党的十八大以来，以习近平同志为核心的党中央从坚持和发展中国特色社会主义的全局和战略高度（），把全面依法治国纳入“四个全面”战略布局。<br>A: 定位法治<br>B: 布局法治<br>C: 聚焦人治<br>D: 厉行法治<br>正确答案: ABD</p>
<p>坚持以人民为中心，就要把（）落实到全面依法治国各领域全过程。<br>A: 体现人民利益<br>B: 反映人民愿望<br>C: 维护人民权益<br>D: 增进人民福祉<br>正确答案: ABCD</p>
<p>（），都必须以宪法为根本的活动准则，都负有维护宪法尊严保证宪法实施的职责。<br>A: 全国各族人民<br>B: 一切国家机关和武装力量<br>C: 各政党和各社会团体<br>D: 各企业事业组织<br>正确答案: ABCD</p>
<p>只有全面依法治国才能有效保障国家治理体系的（），才能最大限度凝聚社会共识。<br>A: 系统性<br>B: 随意性<br>C: 规范性<br>D: 协调性<br>正确答案: ACD</p>
<p>坚持在法治轨道上推进国家治理体系和治理能力现代化就要更好发挥法治固根本稳预期利长远的重要作用，坚持（）。<br>A: 依法应对重大挑战<br>B: 依法抵御重大风险<br>C: 依法克服重大阻力<br>D: 依法解决重大矛盾<br>正确答案: ABCD</p>
<p>坚持建设中国特色社会主义法治体系，就要加快形成（），形成完善的党内法规体系。<br>A: 完备的法律规范体系<br>B: 高效的法治实施体系<br>C: 严密的法治监督体系<br>D: 有力的法治保障体系<br>正确答案: ABCD</p>
<p>习近平法治思想指出，要继续推进法治领域改革，解决好（）等领域的突出矛盾和问题。<br>A: 立法<br>B: 执法<br>C: 司法<br>D: 守法<br>正确答案: ABCD</p>
<p>习近平法治思想指出，要坚持建设德才兼备的高素质法治工作队伍，推进法治专门队伍（）。<br>A: 革命化<br>B: 正规化<br>C: 专业化<br>D: 职业化<br>正确答案: ABCD</p>
<p>习近平法治思想指出，各级领导干部要不断提高运用法治思维和法治方式深化改革（）的能力，做尊法学法守法用法的模范。<br>A: 推动发展<br>B: 化解矛盾<br>C: 维护稳定<br>D: 应对风险<br>正确答案: ABCD</p>
<p>加快形成高效的法治实施体系，就要做到（），确保法律的全面有效实施。<br>A: 有法必依<br>B: 执法必严<br>C: 违法必究<br>D: 执法必重<br>正确答案: ABC</p>
<p>加快形成严密的法治监督体系，就要加强（）监察监督司法监督审计监督社会监督舆论监督制度建设。<br>A: 党内监督<br>B: 人大监督<br>C: 民主监督<br>D: 行政监督<br>正确答案: ABCD</p>
<p>加快形成有力的法治保障体系，就要着力建设一支（）的社会主义法治工作队伍。<br>A: 忠于党<br>B: 忠于国家<br>C: 忠于人民<br>D: 忠于法律<br>正确答案: ABCD</p>
<p>深化依法治国实践，就要准确把握全面推进依法治国重点任务，着力推进（）。<br>A: 科学立法<br>B: 严格执法<br>C: 公正司法<br>D: 全民守法<br>正确答案: ABCD</p>
<p>推进严格执法，重点是解决执法（）以及不作为乱作为等突出问题。<br>A: 不规范<br>B: 不严格<br>C: 不透明<br>D: 不文明<br>正确答案: ABCD</p>
<p>推进公正司法，要以优化司法职权配置为重点，健全司法权力（）的制度安排。<br>A: 分工负责<br>B: 相互配合<br>C: 相互制约<br>D: 相互掣肘<br>正确答案: ABC</p>
<p>全面从严治党，要求增强（）。<br>A: 系统性<br>B: 预见性<br>C: 创造性<br>D: 实效性<br>正确答案: ABCD</p>
<p>加强长期执政能力建设，对党的建设提出了更高标准，长期执政，意味着（）。<br>A: 在各个方面要经受长期的考验<br>B: 在世情国情不断变化的条件下始终能应对各种风险挑战<br>C: 要始终保持不忘初心牢记使命，意味着<br>D: 要始终具有先进性和纯洁性<br>正确答案: ABCD</p>
<p>新时代党的建设的目标是建设（）朝气蓬勃的马克思主义执政党。<br>A: 始终走在时代前列<br>B: 人民衷心拥护<br>C: 勇于自我革命<br>D: 经得起各种风浪考验<br>正确答案: ABCD</p>
<p>全党要坚定执行党的政治路线，严格遵守政治纪律和政治规矩，在（）上同党中央保持高度一致。<br>A: 政治立场<br>B: 政治方向<br>C: 政治原则<br>D: 政治道路<br>正确答案: ABCD</p>
<p>要尊崇党章，严格执行新形势下党内政治生活若干准则，增强党内政治生活的（）。<br>A: 政治性<br>B: 时代性<br>C: 原则性<br>D: 战斗性<br>正确答案: ABCD</p>
<p>把全面从严治党引向深入，要把党的政治建设摆在首位，弘扬（）等价值观。<br>A: 忠诚老实<br>B: 公道正派<br>C: 实事求是<br>D: 清正廉洁<br>正确答案: ABCD</p>
<p>把全面从严治党引向深入，要把党的政治建设摆在首位，坚决防止和反对个人主义（）。<br>A: 分散主义<br>B: 自由主义<br>C: 本位主义<br>D: 好人主义<br>正确答案: ABCD</p>
<p>全党同志要加强党性锻炼，不断提高政治觉悟和政治能力，把（）作为根本政治担当，永葆共产党人政治本色。<br>A: 对党忠诚<br>B: 为党分忧<br>C: 为党尽职<br>D: 为民造福<br>正确答案: ABCD</p>
<p>理想指引人生方向，信念决定事业成败，理想信念不坚定，就可能导致（）。<br>A: 政治上变质<br>B: 经济上贪婪<br>C: 道德上堕落<br>D: 生活上腐化<br>正确答案: ABCD</p>
<p>加强党的组织建设，就要坚持（），为坚持和加强党的全面领导坚持和发展中国特色社会主义提供坚强组织保证。<br>A: 德才兼备<br>B: 以德为先<br>C: 唯才是举<br>D: 任人唯贤<br>正确答案: ABD</p>
<p>如果党的政治纪律成了摆设，就会形成“破窗效应”，使党的（）丧失严肃性和权威性。<br>A: 章程<br>B: 原则<br>C: 制度<br>D: 部署<br>正确答案: ABCD</p>
<p>加强党的纪律建设，要在重点强化政治纪律和组织纪律的同时，带动（）严起来。<br>A: 廉洁纪律<br>B: 群众纪律<br>C: 工作纪律<br>D: 生活纪律<br>正确答案: ABCD</p>
<p>制度问题带有（），加强制度建设是全面从严治党的长远之策根本之策。<br>A: 根本性<br>B: 全局性<br>C: 稳定性<br>D: 长期性<br>正确答案: ABCD</p>
<p>加强党内制度建设，就要形成（）的党内法规制度体系。<br>A: 内容科学<br>B: 程序严密<br>C: 配套完备<br>D: 运行有效<br>正确答案: ABCD</p>
<h3 id="判断题-11"><a href="#判断题-11" class="headerlink" title="判断题"></a>判断题</h3><p>“四个全面”战略布局，是我们党站在新的历史起点上把握我国发展新特征确定的治国理政新方略。<br>正确答案: 对</p>
<p>“四个全面”战略布局，是新的时代条件下推进改革开放和社会主义现代化建设坚持和发展中国特色社会主义的战略抉择。<br>正确答案: 对</p>
<p>全面小康是城乡区域共同发展的小康。<br>正确答案: 对</p>
<p>中国共产党成立百年来，团结带领中国人民进行的—切奋斗就是为了把我国建设成为现代化强国，实现中华民族伟大复兴。<br>正确答案: 对</p>
<p>世界上的所有现代化都必须建立在对外殖民血腥掠夺对内残酷剥削人民的原始积累基础上。<br>正确答案: 错</p>
<p>我们要后来居上，决定了我国发展必然是一个“串联式”的过程，工业化城镇化农业现代化信息化顺序发展。<br>正确答案: 错</p>
<p>西方资本主义的现代化奠定了放之四海而皆准的现代化标准。<br>正确答案: 错</p>
<p>改革开放是我们党的一次伟大觉醒，正是这个伟大觉醒孕育了我们党从理论到实践的伟大创造。<br>正确答案: 对</p>
<p>改革开放是坚持和发展中国特色社会主义的必由之路。<br>正确答案: 对</p>
<p>新时代的全面深化改革中，制度建设分量更重，改革更多面对的是深层次体制机制问题。<br>正确答案: 对</p>
<p>改革开放是决定当代中国命运的关键一招，也是决定实现“两个一百年”奋斗目标实现中华民族伟大复兴的关键一招.<br>正确答案: 对</p>
<p>制度优势是一个国家的最大优势，制度竞争是国家间根本的竞争。<br>正确答案: 对</p>
<p>我们党干革命搞建设抓改革，都是为了让人民过上幸福生活。<br>正确答案: 对</p>
<p>全面深化改革能否顺利推进，关键取决于国际形势。<br>正确答案: 错</p>
<p>只有有了好的制度，才有可能实现治理体系和治理能力的现代化。<br>正确答案: 对</p>
<p>优越的制度可以脱离治理体系和治理能力来发挥作用。<br>正确答案: 错</p>
<p>全面依法治国是中国特色社会主义的本质要求和重要保障。<br>正确答案: 对</p>
<p>全面依法治国最广泛最深厚的基础是人民。<br>正确答案: 对</p>
<p>中国特色社会主义法治道路本质上是中国特色社会主义道路在法治领域的具体体现。<br>正确答案: 对</p>
<p>公平正义是司法的灵魂和生命。<br>正确答案: 对</p>
<p>中国特色社会主义法治道路是社会主义法治建设成就和经验的集中体现，是建设社会主义法治国家的唯一正确道路。<br>正确答案: 对</p>
<p>走中国特色社会主义法治道路，是历史的必然结论，是由我国社会主义国家性质所决定的，是立足我国基本国情的必然选择。<br>正确答案: 对</p>
<p>始终坚持依法治国和以德治国相结合是中国特色社会主义法治道路的一个鲜明特点。<br>正确答案: 对</p>
<p>中国特色社会主义法治道路的核心要义，就是坚持党的领导，坚持中国特色社会主义制度，贯彻中国特色社会主义法治理论。<br>正确答案: 对</p>
<p>能不能做到依法治国，关键在于能不能尽可能提高立法数量。<br>正确答案: 错</p>
<p>办好中国的事情，关键在党，关键在坚持党要管党全面从严治党。<br>正确答案: 对</p>
<p>在进行社会革命的同时不断进行自我革命，是我们党区别于其他政党最显著的标志。<br>正确答案: 对</p>
<p>中国共产党没有任何自己特殊的利益，从来不代表任何利益集团任何权势团体任何特权阶层的利益。<br>正确答案: 对</p>
<p>治国必先治党，治党务必宽松。<br>正确答案: 错</p>
<p>全面从严治党，核心是加强党的领导。<br>正确答案: 对</p>
<p>党的领导可以是片面的部分的。<br>正确答案: 错</p>
<p>如果管党不力治党不严，党就不可避免被历史淘汰，党所肩负的历史使命就无法实现。<br>正确答案: 对</p>
<p>照搬苏联模式是中国共产党的最大政治优势。<br>正确答案: 错</p>
<p>经得起各种风浪考验，是党必须具备的政治智慧和执政能力。<br>正确答案: 对</p>
<p>新时代党的建设总要求，丰富和发展了马克思主义建党学说，标志着对执政党建设规律的认识达到新的高度。<br>正确答案: 对</p>
<p>保证全党服从中央，坚持党中央权威和集中统一领导，是党的政治建设的首要任务。<br>正确答案: 对</p>
<p>深入学习领会习近平新时代中国特色社会主义思想，用党的创新理论武装全党指导实践推动工作，是全党的重大政治任务。<br>正确答案: 对</p>
<p>党风问题党同人民群众联系问题是关系党生死存亡的问题。<br>正确答案: 对</p>
<p>中国共产党是靠铁的纪律组织起来的马克思主义政党。<br>正确答案: 对</p>
<p>纪律严明是中国共产党的光荣传统和独特优势。<br>正确答案: 对</p>
<p>如果没有铁的纪律，就没有党的团结统一，党的凝聚力和战斗力就会大大削弱，党的领导能力和执政能力就会大大削弱。<br>正确答案: 对</p>
<h2 id="第十二章"><a href="#第十二章" class="headerlink" title="第十二章"></a>第十二章</h2><h3 id="单选题-12"><a href="#单选题-12" class="headerlink" title="单选题"></a>单选题</h3><p>关于坚持总体国家安全观的意义，下列说法中错误的是（）。<br>A: 适应了进行具有许多新的历史特点的伟大斗争的新要求<br>B: 回应了人民对国家安全的新期待<br>C: 顺应了世界发展变化的新趋势<br>D: 利于在和平发展大势的逆转中处于不败之地<br>正确答案: D</p>
<p>坚持总体国家安全观，必须以（）为宗旨。<br>A: 文化安全<br>B: 太空安全<br>C: 网络安全<br>D: 人民安全<br>正确答案: D</p>
<p>坚持总体国家安全观，必须以（）为根本。<br>A: 经济安全<br>B: 科技安全<br>C: 政治安全<br>D: 生态安全<br>正确答案: C</p>
<p>“（）”事件指的是非常难以预测，但突然发生时会引起连锁反应带来巨大负面影响的小概率事件。<br>A: 黑天鹅<br>B: 灰犀牛<br>C: 黑乌鸦<br>D: 白蝙蝠<br>正确答案: A</p>
<p>“（）”事件指的是太过于常见以至于人们习以为常的风险，比喻大概率且影响巨大的潜在危机。<br>A: 白蝙蝠<br>B: 黑乌鸦<br>C: 灰犀牛<br>D: 黑天鹅<br>正确答案: C</p>
<p>着力防范化解重大风险既要打好防范和抵御风险的有准备之战，也要打好化险为夷转危为机的战略主动战，其具体要求不包括（）。<br>A: 让经济风险演化为社会政治风险<br>B: 决不让局部风险演化为区域性或系统性风险<br>C: 决不让个别风险演化为综合风险<br>D: 决不让国际风险演化为国内风险<br>正确答案: A</p>
<p>党在新时代的强军目标必须同国家现代化进程相一致，力争到（）基本实现国防和军队现代化。<br>A: 2025年<br>B: 2035年<br>C: 本世纪中叶<br>D: 本世纪末<br>正确答案: B</p>
<p>党在新时代的强军目标必须同国家现代化进程相一致，力争到（）把人民军队全面建成世界一流军队。<br>A: 本世纪末<br>B: 本世纪中叶<br>C: 2035年<br>D: 2025年<br>正确答案: B</p>
<p>党对军队绝对领导的制度不包括（）。<br>A: 坚持军队最高领导权和指挥权属于党中央中央军委，中央军委实行主席负责制<br>B: 实行党委制政治委员制政治机关制<br>C: 实行党委(支部)统一的集体领导下的首长分工负责制<br>D: 实行支部建在师上<br>正确答案: D</p>
<p>党对军队绝对领导的根本原则和制度，发端于（）。<br>A: 南昌起义<br>B: 秋收起义<br>C: 广州起义<br>D: 黄麻起义<br>正确答案: A</p>
<p>党对军队绝对领导的根本原则和制度，奠基于（）。<br>A: 省港罢工<br>B: 五卅运动<br>C: 三湾改编<br>D: 四渡赤水<br>正确答案: C</p>
<p>党对军队绝对领导的根本原则和制度，定型于（）。<br>A: 八七会议<br>B: 古田会议<br>C: 扎西会议<br>D: 遵义会议<br>正确答案: B</p>
<p>全军必须扭住能打仗打胜仗这个强军之要，牢固树立（）这个唯一的根本的标准，全面提高新时代备战打仗能力。<br>A: 武器装备<br>B: 战斗力<br>C: 军事理论<br>D: 文化氛围<br>正确答案: B</p>
<p>“一国两制”实践取得了举世公认的成功，其具体体现不包括（）。<br>A: 香港澳门经济发展陷入停滞<br>B: 香港澳门对外交往日益活跃<br>C: 香港澳门各项事业取得全面进步<br>D: 香港澳门同祖国内地的联系越来越紧密<br>正确答案: A</p>
<p>关于“一国”和“两制”的关系，下列理解中错误的是（）。<br>A: “一国”是实行“两制”的前提和基础，“两制”从属和派生于“一国”，并统一于“一国”之内<br>B: 必须牢固树立“一国”意识，坚守“一国”原则，正确处理特别行政区同中央的关系<br>C: 在“一国”的基础之上，“两制”的关系应该也完全可以做到和谐相处相互促进<br>D: “一国两制”的提出是为了让香港澳门最终也实行社会主义制度<br>正确答案: D</p>
<p>2016年11月，（）第二十四次会议通过关于香港特别行政区基本法第一百零四条的解释，维护了基本法的权威和香港法治，顺应了包括香港同胞在内的全体中国人民的共同愿望。<br>A: 十届全国人大常委会<br>B: 十一届全国人大常委会<br>C: 十二届全国人大常委会<br>D: 十三届全国人大常委会<br>正确答案: C</p>
<p>为了维护国家主权安全发展利益，坚持和完善“一国两制”制度体系，维护香港长期繁荣稳定，保障香港居民合法权益，2020年5月，（）通过《全国人民代表大会关于建立健全香港特别行政区维护国家安全的法律制度和执行机制的决定》。<br>A: 十三届全国人大一次会议<br>B: 十三届全国人大二次会议<br>C: 十三届全国人大三次会议<br>D: 十三届全国人大四次会议<br>正确答案: C</p>
<p>2020年6月，（）第二十次会议通过《中华人民共和国香港特别行政区维护国家安全法》，并将其列入香港基本法附件三，香港国安法的颁布实施，是“一国两制”事业的重要里程碑。<br>A: 十三届全国人大常委会<br>B: 十二届全国人大常委会<br>C: 十一届全国人大常委会<br>D: 十届全国人大常委会<br>正确答案: A</p>
<p>关于香港的地位，下列描述中错误的是（）。<br>A: 国际金融中心<br>B: 国际制造中心<br>C: 国际贸易中心<br>D: 国际航运中心<br>正确答案: B</p>
<h3 id="多选题-12"><a href="#多选题-12" class="headerlink" title="多选题"></a>多选题</h3><p>中华民族伟大复兴绝不是轻轻松松敲锣打鼓就能实现的，必然会面对各种（）。<br>A: 重大挑战<br>B: 重大风险<br>C: 重大阻力<br>D: 重大矛盾<br>正确答案: ABCD</p>
<p>坚持总体国家安全观，回应了人民对国家安全的新期待，具体包括（）。<br>A: 希望国家更加强大，更有力地维护国家统一和民族团结<br>B: 希望着力解决空气水土壤污染等突出问题<br>C: 希望着力解决农产品食品药品安全等突出问题<br>D: 希望更有效地保护生命财产安全<br>正确答案: ABCD</p>
<p>当今世界百年未有之大变局正加速演进，只有坚持总体国家安全观，才能实现共享（）。<br>A: 正义尊严<br>B: 发展成果<br>C: 安全保障<br>D: 军事信息<br>正确答案: ABC</p>
<p>以人民安全为宗旨，就是国家安全一切为了人民一切依靠人民，充分发挥广大人民群众（）。<br>A: 积极性<br>B: 主动性<br>C: 被动性<br>D: 创造性<br>正确答案: ABD</p>
<p>维护国家安全，要立足国际秩序大变局来把握规律，立足我国发展重要战略机遇期大背景来谋划，保持（），把战略主动权牢牢掌握在自己手中。<br>A: 战略定力<br>B: 战略自信<br>C: 战略耐心<br>D: 战略冒进<br>正确答案: ABC</p>
<p>坚持走中国特色国家安全道路，就要统筹外部安全和内部安全，对内求发展求变革求稳定，建设平安中国；对外（），积极塑造外部安全环境。<br>A: 求和平<br>B: 求对抗<br>C: 求合作<br>D: 求共赢<br>正确答案: ACD</p>
<p>加强战略预判和风险预警，要力争把风险化解在源头，防止各种风险（）。<br>A: 传导<br>B: 叠加<br>C: 演变<br>D: 升级<br>正确答案: ABCD</p>
<p>完善风险防控机制，要建立健全（），主动加强协调配合。<br>A: 风险研判机制<br>B: 决策风险评估机制<br>C: 风险防控协同机制<br>D: 风险防控责任机制<br>正确答案: ABCD</p>
<p>党在新时代的强军目标是建设一支（）的人民军队。<br>A: 听党指挥<br>B: 能打胜仗<br>C: 作风优良<br>D: 我行我素<br>正确答案: ABC</p>
<p>必须全面贯彻党领导军队的一系列根本原则和制度，确保部队（）。<br>A: 绝对忠诚<br>B: 绝对纯洁<br>C: 绝对自由<br>D: 绝对可靠<br>正确答案: ABD</p>
<p>军队是要准备打仗的，要全面提高新时代备战打仗能力，有效（）。<br>A: 塑造态势<br>B: 管控危机<br>C: 遏制战争<br>D: 打赢战争<br>正确答案: ABCD</p>
<p>推进强军事业必须坚持政治建军（），全面提高革命化现代化正规化水平。<br>A: 改革强军<br>B: 科技强军<br>C: 人才强军<br>D: 依法治军<br>正确答案: ABCD</p>
<p>推进强军事业必须更加注重（）军民融合，全面提高革命化现代化正规化水平。<br>A: 聚焦实战<br>B: 创新驱动<br>C: 体系建设<br>D: 集约高效<br>正确答案: ABCD</p>
<p>必须坚持向科技创新要战斗力，统筹推进军事理论（）等各方面创新，建设创新型人民军队。<br>A: 技术<br>B: 组织<br>C: 管理<br>D: 文化<br>正确答案: ABCD</p>
<p>必须坚持发展和安全兼顾富国和强军统一，形成（）军民融合深度发展格局，构建一体化的国家战略体系和能力。<br>A: 全要素<br>B: 多领域<br>C: 高效益<br>D: 单方面<br>正确答案: ABC</p>
<p>党的十八大以来，人民军队（）重树作风形象，在中国特色强军之路上迈出了坚实步伐。<br>A: 重振政治纲纪<br>B: 重塑组织形态<br>C: 重整斗争格局<br>D: 重构建设布局<br>正确答案: ABCD</p>
<p>把作风建设作为军队一项基础性长期性工作抓紧抓实，就要抵御（）的侵蚀。<br>A: 拜金主义<br>B: 享乐主义<br>C: 个人主义<br>D: 集体主义<br>正确答案: ABC</p>
<p>构建一体化的国家战略体系和能力，就要把国防和军队建设有机融入经济社会发展大体系，逐步实现国家各领域（）。<br>A: 战略布局一体融合<br>B: 战略资源一体整合<br>C: 战略力量一体运用<br>D: 战略目标一体套用<br>正确答案: ABC</p>
<p>构建一体化的国家战略体系和能力，是一个系统工程，涉及（）。<br>A: 领域宽<br>B: 范围广<br>C: 内容多<br>D: 布局窄<br>正确答案: ABC</p>
<p>构建一体化的国家战略体系和能力，必须努力形成（）的组织管理体系。<br>A: 统一领导<br>B: 军地协调<br>C: 顺畅高效<br>D: 军地分离<br>正确答案: ABC</p>
<p>构建一体化的国家战略体系和能力，必须努力形成（）相统一的工作运行体系。<br>A: 国家主导<br>B: 需求牵引<br>C: 资本掌控<br>D: 市场运作<br>正确答案: ABD</p>
<p>构建一体化的国家战略体系和能力，必须努力形成（）的政策制度体系。<br>A: 系统完备<br>B: 漫灌刺激<br>C: 街接配套<br>D: 有效激励<br>正确答案: ACD</p>
<p>构建一体化的国家战略体系和能力，就要向重点领域聚焦用力，在（）军队保障社会化等领域，盘活用好存量资源，优化配置增量资源。<br>A: 基础设施建设<br>B: 国防科技工业<br>C: 武器装备采购<br>D: 人才培养<br>正确答案: ABCD</p>
<p>要加强国防教育，增强全民国防观念，使（）成为全社会的思想共识和自觉行动。<br>A: 关心国防<br>B: 热爱国防<br>C: 建设国防<br>D: 保卫国防<br>正确答案: ABCD</p>
<p>继续推动香港澳门各项事业向前发展，要全面准确理解和贯彻（）的方针。<br>A: “一国两制”<br>B: “港人治港”<br>C: “澳人治澳”<br>D: 高度自治<br>正确答案: ABCD</p>
<p>推动港澳融入国家发展大局，就要支持香港澳门更加积极主动（），实现新发展，作出新贡献。<br>A: 助力国家全面开放<br>B: 融入国家发展大局<br>C: 参与国家治理实践<br>D: 促进国际人文交流<br>正确答案: ABCD</p>
<p>2021年3月，（）先后通过，为全面准确贯彻“一国两制”方针，落实“爱国者治港”原则，确保香港长治久安和长期繁荣稳定提供了坚实的制度保障。<br>A: 《中华人民共和国香港特别行政区基本法》<br>B: 《全国人民代表大会关于完善香港特别行政区选举制度的决定》<br>C: 新修订的《中华人民共和国香港特别行政区基本法附件一香港特别行政区行政长官的产生办法》<br>D: 新修订的《中华人民共和国香港特别行政区基本法附件二香港特别行政区立法会的产生办法和表决程序》<br>正确答案: BCD</p>
<p>国家坚决反对任何外国和境外势力以任何方式干预香港特别行政区事务，采取必要措施予以反制，依法防范制止和惩治外国和境外势力利用香港进行（）活动。<br>A: 分裂<br>B: 颠覆<br>C: 渗透<br>D: 破坏<br>正确答案: ABCD</p>
<p>只有争取早日解决政治对立，实现台海持久和平，达成国家统一愿景，才能让两岸子孙后代在（）的共同家园中生活成长。<br>A: 祥和<br>B: 安宁<br>C: 繁荣<br>D: 尊严<br>正确答案: ABCD</p>
<h3 id="判断题-12"><a href="#判断题-12" class="headerlink" title="判断题"></a>判断题</h3><p>总体国家安全观关键在“总体”，突出的是“大安全”理念。<br>正确答案: 对</p>
<p>总体国家安全观为破解我国国家安全面临的难题推进新时代国家安全工作提供了基本遵循。<br>正确答案: 对</p>
<p>总体国家安全观科学回答了中国这样一个发展中的社会主义大国如何维护和塑造国家安全的一系列基本问题。<br>正确答案: 对</p>
<p>国家安全是人民幸福安康的基本要求，是安邦定国的重要基石。<br>正确答案: 对</p>
<p>维护国家安全是全国各族人民的根本利益所在。<br>正确答案: 对</p>
<p>坚持总体国家安全观，归根到底是为了更好维护我国发展的历史机遇期，确保中华民族伟大复兴进程不被迟滞或打断。<br>正确答案: 对</p>
<p>坚持党对国家安全工作的绝对领导，是做好国家安全工作的根本原则，是维护国家安全和社会安定的根本保证。<br>正确答案: 对</p>
<p>当前，我国正处于一个大有可为的战略机遇期，在发展中不会再遇到重大风险。<br>正确答案: 错</p>
<p>我国必须坚持把防范化解国家安全风险摆在突出位置，力争把可能带来重大风险的隐患发现和处置于萌芽状态。<br>正确答案: 对</p>
<p>预判风险所在是防范风险的前提，把握风险走向是谋求战略主动的关键。<br>正确答案: 对</p>
<p>巩固国防和强大人民军队是新时代坚持和发展中国特色社会主义实现中华民族伟大复兴的战略支撑。<br>正确答案: 对</p>
<p>党对军队的绝对领导是人民军队建军之本强军之魂。<br>正确答案: 对</p>
<p>作风优良是我军鲜明特色和政治优势。<br>正确答案: 对</p>
<p>改革是强军的必由之路。<br>正确答案: 对</p>
<p>军民融合发展是兴国之举强军之策。<br>正确答案: 对</p>
<p>人民军队是保卫红色江山维护民族尊严的坚强柱石，也是维护地区和世界和平的强大力量。<br>正确答案: 对</p>
<p>强军事业取得的历史性成就和历史性变革，根本在于习近平强军思想的科学指引。<br>正确答案: 对</p>
<p>听党指挥决定军队建设的政治方向。<br>正确答案: 对</p>
<p>党对军队绝对领导的根本原则和制度是人民军队完全区别于一切旧军队的政治特质和根本优势。<br>正确答案: 对</p>
<p>坚持党指挥枪建设自己的人民军队，是党在血与火的斗争中得出的颠扑不破的真理。<br>正确答案: 对</p>
<p>能打胜仗反映军队的根本职能和军队建设的根本指向。<br>正确答案: 对</p>
<p>能打仗打胜仗是党和人民对军队的根本要求，是军队使命职责之所在军队存在的根本价值之所在。<br>正确答案: 对</p>
<p>我军要强起来，作风必须过硬。<br>正确答案: 对</p>
<p>能否保持我党我军的光荣传统和优良作风，关系军队生死存亡，关系党和国家事业兴衰成败，关系社会主义红色江山会不会改变颜色。<br>正确答案: 对</p>
<p>构建一体化的国家战略体系和能力是实现发展和安全兼顾富国和强军统一的必然选择。<br>正确答案: 对</p>
<p>军政军民团结是实现富国和强军相统一的重要政治保障，是我党我军特有的政治优势。<br>正确答案: 对</p>
<p>“一国两制”是中国为国际社会解决类似问题提供的一个新思路新方案，是中华民族为世界和平与发展作出的新贡献。<br>正确答案: 对</p>
<p>“一国两制”是解决历史遗留的香港澳门问题的最佳方案，也是香港澳门回归后保持长期繁荣稳定的最佳制度。<br>正确答案: 对</p>
<p>国家主体坚持实行社会主义制度，是香港澳门实行资本主义制度保持繁荣稳定的前提和保障。<br>正确答案: 对</p>
<p>香港澳门依照基本法实行“港人治港”“澳人治澳”高度自治，必须充分尊重国家主体实行的社会主义制度。<br>正确答案: 对</p>
<p>任何危害国家主权安全，挑战中央权力和特别行政区基本法权威，利用香港澳门对内地进行渗透破坏的活动，都是对底线的触碰，都是绝不能允许的。<br>正确答案: 对</p>
<p>香港澳门回归祖国后，处理这两个特别行政区的事务完全是中国内政，用不着任何外部势力指手画脚。<br>正确答案: 对</p>
<p>发展是香港澳门的立身之本，也是保持香港澳门国际地位和解决香港澳门各种问题的金钥匙。<br>正确答案: 对</p>
<p>要发展壮大爱国爱港爱澳力量，增强香港澳门同胞的国家意识和爱国精神，使爱国爱港爱澳光荣传统薪火相传。<br>正确答案: 对</p>
<p>作为一项前无古人的开创性事业，“一国两制”实践过程注定一帆风顺，不会遭遇任何阻碍。<br>正确答案: 错</p>
<p>香港国安法的颁布实施，为香港特别行政区行政立法司法机关依法防范制止和惩治危害国家安全的行为和活动提供了有力制度保障。<br>正确答案: 对</p>
<p>维护国家主权统一和领土完整是香港特别行政区的宪制责任。<br>正确答案: 对</p>
<p>香港特别行政区行政长官应当就香港特别行政区履行维护国家安全职责开展国家安全教育依法禁止危害国家安全的行为和活动等情况，定期向中央人民政府提交报告。<br>正确答案: 对</p>
<p>从制定实施香港国安法到完善香港选举制度，顺应了香港社会盼望良政善治长治久安的主流民意，体现了包括香港同胞在内的全国人民的共同心愿。<br>正确答案: 对</p>
<p>解决台湾问题实现祖国完全统一，是中国共产党矢志不渝的历史任务，是全体中华儿女的共同愿望，是中华民族根本利益所在。<br>正确答案: 对</p>
<p>民族复兴国家统一是大势所趋大义所在民心所向。<br>正确答案: 对</p>
<p>祖国必须统一，也必然统一。<br>正确答案: 对</p>
<p>推动两岸关系和平发展，最根本的是坚持一个中国原则。<br>正确答案: 对</p>
<p>两岸同属一个国家两岸同胞同属一个民族，这一历史事实和法理基础从未改变，也不可能改变。<br>正确答案: 对</p>
<p>“九二共识”表明大陆与台湾同属一个中国，两岸关系不是国与国关系。<br>正确答案: 对</p>
<p>“一国两制”在台湾的具体实现形式会充分考虑台湾现实情况，会充分吸收两岸各界意见和建议，会充分照顾到台湾同胞利益和感情。<br>正确答案: 对</p>
<p>“台独”分裂势力及其活动损害国家主权和领土完整，是两岸关系和平发展的最大障碍，是台海和平稳定的最大威胁。<br>正确答案: 对</p>
<p>任何人都不要低估中国人民捍卫国家主权和领土完整的坚强决心坚定意志强大能力。<br>正确答案: 对</p>
<p>台湾问题是中国的内政，事关中国核心利益和中国人民民族感情，不容任何外来干涉。<br>正确答案: 对</p>
<p>台湾问题因民族弱乱而产生，必将随着民族复兴而终结。<br>正确答案: 对</p>
<h2 id="第十三章"><a href="#第十三章" class="headerlink" title="第十三章"></a>第十三章</h2><h3 id="单选题-13"><a href="#单选题-13" class="headerlink" title="单选题"></a>单选题</h3><p>中国坚持以相互尊重合作共赢为基础走和平发展道路，下列各项中，不符合中国的国际定位的是（）。<br>A: 世界和平的建设者<br>B: 全球发展的贡献者<br>C: 国际秩序的维护者<br>D: 国际秩序的挑战者<br>正确答案: D</p>
<p>中国坚持以深化外交布局为依托打造全球伙伴关系，致力于同（）发展新时代全面战略协作伙伴关系。<br>A: 俄罗斯<br>B: 印度<br>C: 美国<br>D: 日本<br>正确答案: A</p>
<p>世界上的事情越来越需要各国共同商量着办，下列各项中，不属于多数国家的共识的是（）。<br>A: 打破国际惯例<br>B: 遵守国际规则<br>C: 建立国际机制<br>D: 追求国际正义<br>正确答案: A</p>
<p>为了共同维护国际公平正义，在国际关系中所要弘扬的精神不包括（）。<br>A: 平等互信<br>B: 包容互鉴<br>C: 合作共赢<br>D: 孤立保守<br>正确答案: D</p>
<p>习近平外交思想在涉及国家主权和领土完整的重大问题上划出红线亮明底线，传承发扬了新中国的正义立场，其中不包括（）。<br>A: 反对多元主义<br>B: 反对霸权主义<br>C: 反对殖民主义<br>D: 反对强权政治<br>正确答案: A</p>
<p>习近平外交思想展现出鲜明的理论创新品格，其具体体现不包括（）。<br>A: 实现了历史使命与时代潮流的高度统一<br>B: 实现了民族精神与国际主义的高度统一<br>C: 实现了唯心主义与形而上学的高度统一<br>D: 实现了中国气派与世界情怀的高度统一<br>正确答案: C</p>
<p>中国坚定不移地奉行独立自主的和平外交政策，坚持和平共处五项原则，其中不包括（）。<br>A: 互相尊重主权和领土完整<br>B: 互不侵犯<br>C: 互相介入内政<br>D: 平等互利<br>正确答案: C</p>
<p>下列各项中，不符合独立自主和平外交政策的是（）。<br>A: 主张和平解决国际争端和热点问题<br>B: 主张动辄诉诸武力或以武力相威胁<br>C: 反对颠覆别国合法政权<br>D: 反对一切形式的恐怖主义<br>正确答案: B</p>
<p>关于中国所坚持走的和平发展道路，下列各项中理解错误的是（）。<br>A: 积极争取和平的国际环境发展自己<br>B: 以自身发展促进世界和平<br>C: 尽可能独占全球发展机遇<br>D: 促进中国和世界各国良性互动互利共赢<br>正确答案: C</p>
<p>推动建设新型国际关系，是立足时代发展潮流和我国根本利益作出的战略选择，反映了中国人民和世界人民的共同心愿，其内涵不包括（）。<br>A: 相互尊重<br>B: 零和博弈<br>C: 公平正义<br>D: 合作共赢<br>正确答案: B</p>
<p>中国这头狮子已经醒了，其特点不包括（）。<br>A: 和平<br>B: 可亲<br>C: 文明<br>D: 暴躁<br>正确答案: D</p>
<p>推动建设新型国际关系，就要怎样坚决维护国家核心利益，其具体举措不包括（）。<br>A: 稳妥应对涉及我国领土主权和海洋权益争端<br>B: 坚决在国际上遏制一切分裂势力的破坏活动<br>C: 防范国际暴力恐怖活动向境内渗透<br>D: 以牺牲别国利益为代价来发展自己<br>正确答案: D</p>
<p>推动建设新型国际关系就要坚决维护国家核心利益，下列各项中，不符合中国主张的是（）。<br>A: 把自己的意志强加于人<br>B: 反对以强凌弱<br>C: 反对以大欺小<br>D: 反对干涉别国内政<br>正确答案: A</p>
<p>推动建设新型国际关系，就要在和平共处五项原则基础上发展同世界各国的友好合作，其具体举措不包括（）。<br>A: 重视各大国的地位和作用，推进大国协调和合作<br>B: 深化同周边国家关系，努力使自身发展更好惠及周边国家<br>C: 坚持只把发达国家作为对外政策的基础<br>D: 永远做发展中国家的可靠朋友和真诚伙伴<br>正确答案: C</p>
<p>推动建设新型国际关系，就要积极参与全球治理体系改革和建设，其具体举措不包括（）。<br>A: 支持扩大发展中国家在国际事务中的代表性和发言权<br>B: 开展同各国政党和政治组织的友好往来<br>C: 推动国际秩序和国际体系朝着炮舰外交的方向发展<br>D: 加强人大政协地方民间团体的对外交流<br>正确答案: C</p>
<p>推动建设新型国际关系，就要加强涉外法律工作，完善涉外法律法规体系，其具体举措不包括（）。<br>A: 积极参与国际规则制定<br>B: 满足我国公民法人在海外的所有诉求<br>C: 深化司法领域国际合作<br>D: 加强反腐败国际合作<br>正确答案: B</p>
<p>2015年9月，习近平在纽约联合国总部出席第70届联合国大会一般性辩论时发表题为（）的重要讲话，指出我们要继承和弘扬联合国宪章的宗旨和原则，构建以合作共赢为核心的新型国际关系，打造人类命运共同体。<br>A: 《携手构建合作共赢公平合理的气候变化治理机制》<br>B: 《携手构建合作共赢新伙伴 同心打造人类命运共同体》<br>C: 《谋共同永续发展 做合作共赢伙伴》<br>D: 《新时代 共享未来》<br>正确答案: B</p>
<p>2017年1月，习近平在联合国日内瓦总部发表（）的主旨演讲，提出世界怎么了我们怎么办?这是整个世界都在思考的问题。<br>A: 《共同构建人类命运共同体》<br>B: 《坚定信心 共克时艰 共建更加美好的世界》<br>C: 《携手抗疫 共克时艰》<br>D: 《与世界相交 与时代相通 在可持续发展道路上阔步前行》<br>正确答案: A</p>
<p>当前，国际安全形势动荡复杂，各国应树立的全球安全观不包括（）。<br>A: 共同<br>B: 自保<br>C: 合作<br>D: 可持续<br>正确答案: B</p>
<p>建设共同繁荣的世界，就要支持以（）为核心的开放透明包容非歧视性的多边贸易体制，推动建设开放型世界经济。<br>A: 亚太经济合作组织<br>B: 世界贸易组织<br>C: 石油输出国组织<br>D: 二十国集团<br>正确答案: B</p>
<p>构建人类命运共同体，建设开放包容的世界，就要在文化上尊重世界文明多样性，其具体要求不包括（）。<br>A: 促进文明交流<br>B: 加强文明互鉴<br>C: 激化文明冲突<br>D: 实现文明共存<br>正确答案: C</p>
<p>“一带一路”贯穿亚欧非大陆，其重点畅通的区域不包括（）。<br>A: 中国经中亚俄罗斯至欧洲(波罗的海)<br>B: 中国经中亚西亚至波斯湾地中海<br>C: 中国至东南亚南亚印度洋<br>D: 中国经俄罗斯白令海峡至加拿大美国<br>正确答案: D</p>
<p>下列各项中，不属于共建“一带一路”倡议的核心内涵的是（）。<br>A: 促进基础设施建设和互联互通<br>B: 加强经济政策协调和发展战略对接<br>C: 共同研发高科技军事武器<br>D: 促进协同联动发展<br>正确答案: C</p>
<p>古丝绸之路绵亘万里，延续千年，积淀了丝绸之路精神，其核心内涵不包括（）。<br>A: 和平合作<br>B: 开放包容<br>C: 互利共赢<br>D: 敝帚自珍<br>正确答案: D</p>
<p>把“一带一路”建成和平之路，对各国的具体要求不包括（）。<br>A: 热衷输出自己的社会制度<br>B: 尊重彼此发展道路<br>C: 尊重彼此主权尊严领土完整<br>D: 尊重彼此核心利益和重大关切<br>正确答案: A</p>
<p>各国要聚焦发展这个根本性问题，释放发展潜力，把“一带一路”建成繁荣之路，其具体目标不包括（）。<br>A: 实现资源大垄断<br>B: 实现发展大联动<br>C: 实现经济大融合<br>D: 实现成果大共享<br>正确答案: A</p>
<p>促进“一带一路”国际合作，各国要把“一带一路”建成文明之路，其具体要求不包括（）。<br>A: 以文明交流超越文明隔阂<br>B: 以文明互鉴超越文明冲突<br>C: 以文明共存超越文明优越<br>D: 以文明冲突超越文明竞争<br>正确答案: D</p>
<p>关于共建“一带一路”倡议，下列理解中错误的是（）。<br>A: 共建“一带一路”是经济合作倡议<br>B: 共建“一带一路”是要关起门来搞“中国俱乐部”<br>C: 共建“一带一路”不以意识形态划界，不搞零和游戏<br>D: 共建“一带一路”是中国同世界共享机遇共谋发展的阳光大道<br>正确答案: B</p>
<h3 id="多选题-13"><a href="#多选题-13" class="headerlink" title="多选题"></a>多选题</h3><p>党的十八大以来，以习近平同志为核心的党中央，旗帜鲜明地回答了（）等一系列重大理论和实践问题，形成了习近平外交思想。<br>A: 新时代中国应当推动建设什么样的世界<br>B: 新时代中国应当推动构建什么样的国际关系<br>C: 中国需要什么样的外交<br>D: 中国怎样办好新时代外交<br>正确答案: ABCD</p>
<p>习近平外交思想，明确了新时代我国对外工作的（）体制机制，是一个科学系统内涵丰富的思想体系。<br>A: 形势任务<br>B: 目标原则<br>C: 路径手段<br>D: 战略策略<br>正确答案: ABCD</p>
<p>对外工作是一个系统工程，（）军队地方民间等要强化统筹协调，各有侧重，相互配合。<br>A: 政党<br>B: 政府<br>C: 人大<br>D: 政协<br>正确答案: ABCD</p>
<p>中国坚持以深化外交布局为依托打造全球伙伴关系，致力于同美国发展（）的关系。<br>A: 不冲突不对抗<br>B: 相互尊重<br>C: 合作共贏<br>D: 虚与委蛇<br>正确答案: ABC</p>
<p>中国坚持以深化外交布局为依托打造全球伙伴关系，致力于同欧洲发展（）的伙伴关系。<br>A: 和平<br>B: 增长<br>C: 改革<br>D: 文明<br>正确答案: ABCD</p>
<p>各国都要遵循联合国宪章宗旨和原则，共同推动国际关系（），努力使全球治理体系更加平衡地反映大多数国家意愿和利益。<br>A: 民主化<br>B: 法治化<br>C: 无序化<br>D: 合理化<br>正确答案: ABD</p>
<p>中国外交（），在国际上磊落坦荡。<br>A: 有原则<br>B: 重情谊<br>C: 讲道义<br>D: 谋公正<br>正确答案: ABCD</p>
<p>习近平外交思想为（）等传统理念赋予更加鲜明的时代精神，将其上升到人类命运共同体新型国际关系全球治理体系变革的历史新高度。<br>A: 独立自主的和平外交方针<br>B: 和平共处五项原则<br>C: 推动建立国际政治经济新秩序<br>D: 积极结盟对抗的冷战思维<br>正确答案: ABC</p>
<p>习近平外交思想充分汲取中华优秀传统文化的丰富营养，在人类命运共同体理念中，蕴含着“（）”的美好愿景。<br>A: 天下为公<br>B: 明哲保身<br>C: 世界大同<br>D: 唯我独尊<br>正确答案: AC</p>
<p>习近平外交思想充分汲取中华优秀传统文化的丰富营养，在周边外交方针的阐发中，体现着（）的历史传承。<br>A: 以邻为壑<br>B: 亲仁善邻<br>C: 兼爱非攻<br>D: 祸水东引<br>正确答案: BC</p>
<p>习近平外交思想充分汲取中华优秀传统文化的丰富营养，在全球治理的改革诉求中，借重了（）的传统智慧。<br>A: 和衷共济<br>B: 合纵连横<br>C: 远交近攻<br>D: 协和万邦<br>正确答案: AD</p>
<p>习近平外交思想充分汲取中华优秀传统文化的丰富营养，在构建全球伙伴关系的过程中，秉持了（）的和谐理念。<br>A: 同而不和<br>B: 和而不同<br>C: 立己达人<br>D: 虚伪诡诈<br>正确答案: BC</p>
<p>习近平外交思想充分汲取中华优秀传统文化的丰富营养，在正确义利观的价值取向里，彰显了（）的道德操守。<br>A: 趋利避害<br>B: 弘义融利<br>C: 急功近利<br>D: 扶危济困<br>正确答案: BD</p>
<p>习近平外交思想蕴含的（）正确义利观等新型理念，反映了世界各国追求发展进步的共同愿望。<br>A: 全球治理观<br>B: 全球安全观<br>C: 全球发展观<br>D: 全球文明观<br>正确答案: ABCD</p>
<p>和平发展是中国基于（）作出的战略抉择，必须始终坚持。<br>A: 自身国情<br>B: 社会制度<br>C: 文化传统<br>D: 苏联模式<br>正确答案: ABC</p>
<p>推动建设新型国际关系，就要重视各大国的地位和作用，推进大国协调和合作，构建（）的大国关系框架，致力于同各大国发展全方位合作关系。<br>A: 针锋相对<br>B: 总体稳定<br>C: 均衡发展<br>D: 互相结盟<br>正确答案: BC</p>
<p>中国积极倡导和践行多边主义，支持（）等发挥积极作用，推动国际秩序和国际体系朝着公正合理的方向发展。<br>A: 二十国集团<br>B: 亚太经合组织<br>C: 上海合作组织<br>D: 金砖国家<br>正确答案: ABCD</p>
<p>中国扎实推进公共外交和人文交流，加强（）的对外交流，夯实国家关系发展的社会基础。<br>A: 人大<br>B: 政协<br>C: 地方<br>D: 民间团体<br>正确答案: ABCD</p>
<p>中国积极参与执法安全国际合作，共同打击（）。<br>A: 暴力恐怖势力<br>B: 民族分裂势力<br>C: 宗教极端势力<br>D: 贩毒走私跨国有组织犯罪<br>正确答案: ABCD</p>
<p>中国持续张开双臂拥抱世界，把相互尊重公平正义合作共赢理念体现到（）等对外合作的方方面面，推动构建人类命运共同体。<br>A: 政治<br>B: 经济<br>C: 安全<br>D: 文化<br>正确答案: ABCD</p>
<p>2013年3月，习近平在莫斯科国际关系学院发表演讲时指出，这个世界越来越成为你中有我我中有你的命运共同体，（）成为时代潮流。<br>A: 和平<br>B: 发展<br>C: 合作<br>D: 共赢<br>正确答案: ABCD</p>
<p>2019年5月，习近平在亚洲文明对话大会开幕式上发表题为《深化文明交流互鉴 共建亚洲命运共同体》的主旨演讲，希望各国秉持开放精神，推进（）民心相通，共同构建亚洲命运共同体人类命运共同体。<br>A: 政策沟通<br>B: 设施联通<br>C: 贸易畅通<br>D: 资金融通<br>正确答案: ABCD</p>
<p>2020年9月，习近平在第75届联合国大会一般性辩论上发表重要讲话，强调坚守（）民主自由的全人类共同价值，推动构建新型国际关系，推动构建人类命运共同体，共同创造世界更加美好的未来。<br>A: 和平<br>B: 发展<br>C: 公平<br>D: 正义<br>正确答案: ABCD</p>
<p>构建人类命运共同体，核心就是建设（）清洁美丽的世界。<br>A: 持久和平<br>B: 普遍安全<br>C: 共同繁荣<br>D: 开放包容<br>正确答案: ABCD</p>
<p>构建人类命运共同体，建设持久和平的世界，就要在政治上坚决摒弃（）。<br>A: 相互尊重<br>B: 冷战思维<br>C: 平等协商<br>D: 强权政治<br>正确答案: BD</p>
<p>建设一个持久和平的世界，根本要义在于国家之间要构建（）的伙伴关系。<br>A: 平等相待<br>B: 冲突对抗<br>C: 互商互谅<br>D: 零和博弈<br>正确答案: AC</p>
<p>构建人类命运共同体，建设普遍安全的世界，就要坚持（）。<br>A: 以对抗解决冲突<br>B: 以结盟缓和矛盾<br>C: 以对话解决争端<br>D: 以协商化解分歧<br>正确答案: CD</p>
<p>国家不论（）社会制度存在多大差异，都要尊重和照顾其合理安全关切。<br>A: 大小<br>B: 强弱<br>C: 贫富<br>D: 历史文化传统<br>正确答案: ABCD</p>
<p>各国都有平等参与地区安全事务的权利，也都有维护地区安全的责任，要以（）的方式解决安全难题。<br>A: 对话协商<br>B: 互利合作<br>C: 只求自保<br>D: 惟赖外援<br>正确答案: AB</p>
<p>构建人类命运共同体，建设共同繁荣的世界，就要推动经济全球化朝着更加开放（）的方向发展。<br>A: 包容<br>B: 普惠<br>C: 平衡<br>D: 共赢<br>正确答案: ABCD</p>
<p>建设开放包容的世界，就要促进（）的文明交流对话，在竞争比较中取长补短，在交流互鉴中共同发展。<br>A: 同而不和<br>B: 各说各话<br>C: 和而不同<br>D: 兼收并蓄<br>正确答案: CD</p>
<p>建设清洁美丽的世界，就要坚持走（）之路，构筑尊崇自然绿色发展的生态体系。<br>A: 绿色发展<br>B: 低碳发展<br>C: 循环发展<br>D: 可持续发展<br>正确答案: ABCD</p>
<p>构建人类命运共同体思想顺应了历史潮流，回应了时代要求，凝聚了各国共识，为人类社会实现（）绘制了蓝图。<br>A: 共同发展<br>B: 持续繁荣<br>C: 长治久安<br>D: 隔阂对抗<br>正确答案: ABC</p>
<p>共建“一带一路”倡议秉持和遵循共商共建共享原则，努力实现（）民心相通，是发展的倡议合作的倡议开放的倡议。<br>A: 政策沟通<br>B: 设施联通<br>C: 贸易畅通<br>D: 资金融通<br>正确答案: ABCD</p>
<p>共建“一带一路”顺应了全球治理体系变革的内在要求，彰显了（）的命运共同体意识，已经成为推动构建人类命运共同体的重要实践平台。<br>A: 同舟共济<br>B: 勾心斗角<br>C: 权责共担<br>D: 过河拆桥<br>正确答案: AC</p>
<h3 id="判断题-13"><a href="#判断题-13" class="headerlink" title="判断题"></a>判断题</h3><p>外交是国家意志的集中体现，必须坚持外交大权在党中央，党中央对对外工作实行集中统一领导。<br>正确答案: 对</p>
<p>面对世界经济的复杂形势和全球性问题，超级大国可以独善其身一枝独秀。<br>正确答案: 错</p>
<p>丝绸之路经济带和21世纪海上丝绸之路倡议能够把快速发展的中国经济同沿线国家的利益结合起来，实现共同繁荣。<br>正确答案: 对</p>
<p>中华民族的血液中没有侵略他人称王称霸的基因。<br>正确答案: 对</p>
<p>中国走的是和平发展道路，对他国对世界决不是挑战和威胁。<br>正确答案: 对</p>
<p>为了走和平发展道路，有时只能放弃正当权益，牺牲国家核心利益。<br>正确答案: 错</p>
<p>中国人民珍爱和平，决不搞侵略扩张，但有战胜一切侵略的信心。<br>正确答案: 对</p>
<p>中国人民从来没有欺负压迫奴役过其他国家人民，过去没有，现在没有，将来也不会有。<br>正确答案: 对</p>
<p>中国人只需要讲爱国主义，不必具有国际视野和国际胸怀。<br>正确答案: 错</p>
<p>中国是一个发展中大国，无需承担国际责任。<br>正确答案: 错</p>
<p>实现中国梦的奋斗目标，必须有和平的国际环境，必须坚持走和平发展道路。<br>正确答案: 对</p>
<p>对于一切国际事务，都要根据最终实际获利预期来决定自己的立场和政策。<br>正确答案: 错</p>
<p>各国的事务应由超级大国主导，世界上的事情应由联合国安全理事会决定。<br>正确答案: 错</p>
<p>维护世界和平促进共同发展，是中国外交政策的宗旨。<br>正确答案: 对</p>
<p>广交朋友，诚待天下，是中华民族的光荣传统。<br>正确答案: 对</p>
<p>无论是应对眼下的危机，还是共创美好的未来，人类都需要同舟共济团结合作。<br>正确答案: 对</p>
<p>任何以邻为壑的做法，任何单打独斗的思路，任何孤芳自赏的傲慢，最终都必然归于失败。<br>正确答案: 对</p>
<p>要和平不要战争只是小国人民的愿望。<br>正确答案: 错</p>
<p>大国对小国可以根据具体情况，搞唯我独尊恃强凌弱的霸道。<br>正确答案: 错</p>
<p>只有各国都走和平发展道路，各国才能共同发展，国与国才能和平相处。<br>正确答案: 对</p>
<p>不同文明凝聚着不同民族的智慧和贡献，但却又有高低之别和优劣之分。<br>正确答案: 错</p>
<p>文明差异作为世界冲突的根源，永远是人类文明进步的阻碍。<br>正确答案: 错</p>
<p>中国共产党将继续同一切爱好和平的国家和人民一道，弘扬和平发展公平正义民主自由的全人类共同价值，推动历史车轮向着光明的目标前进。<br>正确答案: 对</p>
<p>建设生态文明关乎人类未来。<br>正确答案: 对</p>
<p>共建“一带一路”倡议源于中国，机遇和成果只属于亚洲。<br>正确答案: 错</p>
<p>共建“一带一路”只是中国扩大和深化对外开放的需要，与世界各国的需求无关。<br>正确答案: 错</p>
<p>共建“一带一路”符合国际社会的共同利益，彰显人类社会共同理想和美好追求，是国际合作以及全球治理新模式的积极探索。<br>正确答案: 对</p>
<h2 id="第十四章"><a href="#第十四章" class="headerlink" title="第十四章"></a>第十四章</h2><h3 id="单选题-14"><a href="#单选题-14" class="headerlink" title="单选题"></a>单选题</h3><p>在我国国家制度和国家治理体系13个方面显著优势中，居第一位的是（）。<br>A: 坚持党的集中统一领导，坚持党的科学理论，保持政治稳定，确保国家始终沿着社会主义方向前进的显著优势<br>B: 坚持全面依法治国，建设社会主义法治国家，切实保障社会公平正义和人民权利的显著优势<br>C: 坚持共同的理想信念价值理念道德观念，弘扬中华优秀传统文化革命文化社会主义先进文化，促进全体人民在思想上精神上紧紧团结在一起的显著优势<br>D: 坚持德才兼备选贤任能，聚天下英才而用之，培养造就更多更优秀人才的显著优势<br>正确答案: A</p>
<p>中国共产党运用科学民主的办法进行决策，其具体体现不包括（）。<br>A: 独断专行<br>B: 广泛协商<br>C: 广集民智<br>D: 增进共识<br>正确答案: A</p>
<p>（）确立了党对军队的绝对领导这一根本原则，在革命根据地局部执政条件下，形成了党委会统一领导党政军民工作实行党的一元化领导体制。<br>A: 党的一大<br>B: 古田会议<br>C: 黎平会议<br>D: 瓦窑堡会议<br>正确答案: B</p>
<p>（）把“党是领导一切的”写进党章。<br>A: 党的十六大<br>B: 党的十七大<br>C: 党的十八大<br>D: 党的十九大<br>正确答案: D</p>
<p>（）进一步将党的领导制度明确为我国根本领导制度，强调要坚持和完善党的领导制度体系，把党的领导落实到国家治理各领域各方面各环节。<br>A: 党的十九届二中全会<br>B: 党的十九届三中全会<br>C: 党的十九届四中全会<br>D: 党的十九届五中全会<br>正确答案: C</p>
<p>党的重大决策都要严格按照程序办事，充分发扬民主，广泛听取意见和建议，其具体要求不包括（）。<br>A: 科学决策<br>B: 民主决策<br>C: 随意决策<br>D: 依法决策<br>正确答案: C</p>
<p>在充分发扬民主的基础上，要有正确的集中，这对各地方各部门的具体要求不包括（）。<br>A: 不允许自行其是各自为政<br>B: 不允许发挥积极性主动性创造性<br>C: 不允许有令不行有禁不止<br>D: 不允许搞上有政策下有对策<br>正确答案: B</p>
<p>下列各项中，不符合党的民主集中制的基本原则的是（）。<br>A: 党员个人服从党的组织，少数服从多数，下级组织服从上级组织，全党各个组织和全体党员服从党的全国代表大会和中央委员会<br>B: 少数人拥有自由否决权<br>C: 下级组织服从上级组织<br>D: 全党各个组织和全体党员服从党的全国代表大会和中央委员会<br>正确答案: B</p>
<p>下列各项中，不符合党的民主集中制的基本原则的是（）。<br>A: 党的上级组织要经常听取下级组织和党员群众的意见<br>B: 党的上级组织要及时解决下级组织和党员群众提出的问题<br>C: 党的下级组织既要向上级组织请示和报告工作<br>D: 党的下级组织无权独立负责地解决自己职责范围内的问题<br>正确答案: D</p>
<h3 id="多选题-14"><a href="#多选题-14" class="headerlink" title="多选题"></a>多选题</h3><p>中国共产党的领导是做好党和国家各项工作的根本保证，是我国（）的根本点，绝对不能有丝毫动摇。<br>A: 政治稳定<br>B: 经济发展<br>C: 民族团结<br>D: 社会稳定<br>正确答案: ABCD</p>
<p>新时代中国共产党的历史使命，就是统揽（），在全面建成小康社会的基础上全面建设社会主义现代化国家，实现中华民族伟大复兴的中国梦。<br>A: 伟大斗争<br>B: 伟大工程<br>C: 伟大事业<br>D: 伟大梦想<br>正确答案: ABCD</p>
<p>实现伟大梦想，就要更加自觉地坚持党的领导和中国特色社会主义制度，要坚决战胜一切在（）等领域和自然界出现的困难和挑战<br>A: 政治<br>B: 经济<br>C: 文化<br>D: 社会<br>正确答案: ABCD</p>
<p>实现伟大梦想，就要更加自觉地增强（），始终坚持和发展中国特色社会主义。<br>A: 道路自信<br>B: 理论自信<br>C: 制度自信<br>D: 文化自信<br>正确答案: ABCD</p>
<p>不断增强党的（），确保我们党永葆旺盛生命力和强大战斗力。<br>A: 政治领导力<br>B: 思想引领力<br>C: 群众组织力<br>D: 社会号召力<br>正确答案: ABCD</p>
<p>伟大斗争伟大工程伟大事业伟大梦想是一个（）的整体。<br>A: 紧密联系<br>B: 相互贯通<br>C: 相互作用<br>D: 有机统一<br>正确答案: ABCD</p>
<p>中国共产党作为最高政治领导力量，对党和国家实行全面领导，推动构建（）的党和国家机构职能体系。<br>A: 系统完备<br>B: 无序治理<br>C: 科学规范<br>D: 运行高效<br>正确答案: ACD</p>
<p>中国共产党作为最高政治领导力量，对党和国家实行全面领导，推动（）审判机关检察机关人民团体企事业单位社会组织等在党的统一领导下协调行动增强合力。<br>A: 人大<br>B: 政府<br>C: 政协<br>D: 监察机关<br>正确答案: ABCD</p>
<p>中国共产党每前进一步，都离不开（）。<br>A: 科学有效的决策<br>B: 周密的部署<br>C: 照本宣科的教条理论<br>D: 有效的实施<br>正确答案: ABD</p>
<p>中国共产党作为最高政治领导力量所做的决策，关系到党和国家（）问题。<br>A: 方向性<br>B: 全局性<br>C: 战略性<br>D: 根本性<br>正确答案: ABCD</p>
<p>确保党始终总揽全局协调各方，必须增强（），自觉维护党中央权威和集中统一领导，自觉在思想上政治上行动上同党中央保持高度一致。<br>A: 政治意识<br>B: 大局意识<br>C: 核心意识<br>D: 看齐意识<br>正确答案: ABCD</p>
<p>党中央作出的决策部署，（）法院检察院等的党组织要贯彻落实。<br>A: 人大<br>B: 政府<br>C: 政协<br>D: 监察委员会<br>正确答案: ABCD</p>
<p>党的十八大以来，中央政治局常务委员会先后多次召开会议，听取（）最高人民检察院党组工作汇报，这已成为实现党中央集中统一领导的重要制度安排。<br>A: 全国人大常委会<br>B: 国务院<br>C: 全国政协<br>D: 最高人民法院<br>正确答案: ABCD</p>
<p>党中央作出的决策部署，党的（）等部门要贯彻落实，各事业单位人民团体等的党组织也要贯彻落实。<br>A: 组织<br>B: 宣传<br>C: 统战<br>D: 政法<br>正确答案: ABCD</p>
<p>凡属重大问题都要按照（）的原则，由党的委员会集体讨论，作出决定.<br>A: 集体领导<br>B: 民主集中<br>C: 个别酝酿<br>D: 会议决定<br>正确答案: ABCD</p>
<h3 id="判断题-14"><a href="#判断题-14" class="headerlink" title="判断题"></a>判断题</h3><p>坚持和完善党的领导，是党和国家的根本所在命脉所在，是全国各族人民的利益所在幸福所在。<br>正确答案: 对</p>
<p>没有中国共产党，就没有新中国，就没有中华民族伟大复兴。<br>正确答案: 对</p>
<p>中国共产党的领导是中国特色社会主义最本质的特征。<br>正确答案: 对</p>
<p>中国共产党的领导直接关系着中国特色社会主义的性质方向和命运。<br>正确答案: 对</p>
<p>中国共产党是中国特色社会主义事业的坚强领导核心，是这一伟大事业的开创者引领者推动者。<br>正确答案: 对</p>
<p>中国共产党的领导是实现社会主义现代化和民族复兴的最根本保证。<br>正确答案: 对</p>
<p>把新时代中国特色社会主义这篇大文章继续写好写精彩，从根本上要靠党的全面领导，靠党把好方向盘。<br>正确答案: 对</p>
<p>中国制度之所以优越，是因为党的领导在中国特色社会主义制度中是最具统领性决定性的因素。<br>正确答案: 对</p>
<p>没有中国共产党，也就没有中国特色社会主义制度，制度优势就无从谈起。<br>正确答案: 对</p>
<p>中国特色社会主义制度是当代中国发展进步的根本制度保障。<br>正确答案: 对</p>
<p>中国共产党作为长期执政的党，以自身优势引领和锻造了中国特色社会主义的制度优势，保证了中国特色社会主义制度优势的有效发挥。<br>正确答案: 对</p>
<p>实现伟大梦想，最根本的是必须深入推进党的建设新的伟大工程。<br>正确答案: 对</p>
<p>没有中国共产党的领导，民族复兴必然是空想。<br>正确答案: 对</p>
<p>办好中国的事情关键在党，实现中华民族伟大复兴关键在党。<br>正确答案: 对</p>
<p>党是最高政治领导力量，这是由国家性质所决定的，是由国家宪法所确立的。<br>正确答案: 对</p>
<p>党是最高政治领导力量，这是被中国革命建设改革伟大实践所证明的，是推进伟大事业的根本保证。<br>正确答案: 对</p>
<p>党政军民学，东西南北中，党是领导一切的，是最高的政治领导力量。<br>正确答案: 对</p>
<p>政治方向是党和国家发展的首要问题。<br>正确答案: 对</p>
<p>党的领导制度是我国的根本领导制度，这是由党的领导在我国政治生活中的地位和作用决定的。<br>正确答案: 对</p>
<p>党的领导制度在国家制度体系中的统领地位，是党的核心领导地位的必然反映内在要求。<br>正确答案: 对</p>
<p>把党的领导制度作为我国的根本领导制度，彰显了我们党的高度制度自觉制度自信。<br>正确答案: 对</p>
<p>坚持党总揽全局协调各方的领导核心地位，是党作为最高政治力量在治国理政中的必然要求。<br>正确答案: 对</p>
<p>确保党始终总揽全局协调各方，必须坚持和完善党的领导的体制机制。<br>正确答案: 对</p>
<p>离开民主讲集中，集中就成了个人专权专断。<br>正确答案: 对</p>
<p>离开集中搞民主，就会导致极端民主化和无政府状态。<br>正确答案: 对</p>
<p>坚持民主集中制就必须坚持民主基础上的集中和集中指导下的民主相结合。<br>正确答案: 对</p>
<p>党的最高领导机关，是党的全国代表大会和它所产生的中央委员会。<br>正确答案: 对</p>
<p>执政能力建设是党的根本性建设，关系社会主义事业兴衰成败，关系中华民族前途命运，关系党和国家长治久安。<br>正确答案: 对</p>
<p>坚持党的领导，是党和国家的根本所在命脉所在，是全国各族人民的利益所系命运所系。<br>正确答案: 对</p>
]]></content>
      <categories>
        <category>课程学习</category>
        <category>毛概</category>
      </categories>
      <tags>
        <tag>课程学习</tag>
        <tag>毛概</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试期末复习</title>
    <url>/135xyq.github.io/2022/05/17/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h1 id="软测题库"><a href="#软测题库" class="headerlink" title="软测题库"></a>软测题库</h1><h2 id="第1题-填写代码-判断Delta类的语句覆盖测试-9分"><a href="#第1题-填写代码-判断Delta类的语句覆盖测试-9分" class="headerlink" title="第1题 填写代码.判断Delta类的语句覆盖测试(9分)"></a>第1题 填写代码.判断Delta类的语句覆盖测试(9分)</h2><h3 id="此题的上机步骤是"><a href="#此题的上机步骤是" class="headerlink" title="此题的上机步骤是:"></a>此题的上机步骤是:</h3><ol>
<li>建立一个Java项目,名称可以按题号取名;</li>
<li>建立一个测试类, 类的名称为TestMain。这一点非常重要；</li>
<li>填代码；</li>
<li>提交代码，注意题号要一致。</li>
<li>注意只能修改【代码】之处,不能修改其它地方,否则以0分计</li>
</ol>
<p>针对下面的Delta类, 在后面有一个测试类TestMain。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Delta</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delta</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">double</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b * b - <span class="number">4</span> * a * c &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面TestMain测试程序实现了语句覆盖。请将下面TestMain测试程序中的【代码】替换为Java测试代码，使测试程序运行正确。<br>文件TestMain.java如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</span><br><span class="line">    @【代码<span class="number">1</span>】</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelta1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Delta 【代码<span class="number">2</span>】=<span class="keyword">new</span> Delta();</span><br><span class="line">        assertEquals(<span class="keyword">true</span>,delta.delta(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelta2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Delta delta=<span class="keyword">new</span> Delta();</span><br><span class="line">        assertEquals(【代码<span class="number">3</span>】,delta.delta(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelta1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Delta delta=<span class="keyword">new</span> Delta();</span><br><span class="line">        assertEquals(<span class="keyword">true</span>,delta.delta(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelta2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Delta delta=<span class="keyword">new</span> Delta();</span><br><span class="line">        assertEquals(<span class="keyword">false</span>,delta.delta(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="第2题-填写代码-判断Calculator类加减法的语句覆盖测试-10分"><a href="#第2题-填写代码-判断Calculator类加减法的语句覆盖测试-10分" class="headerlink" title="第2题 填写代码.判断Calculator类加减法的语句覆盖测试(10分)"></a>第2题 填写代码.判断Calculator类加减法的语句覆盖测试(10分)</h2><h3 id="此题的上机步骤是-1"><a href="#此题的上机步骤是-1" class="headerlink" title="此题的上机步骤是:"></a>此题的上机步骤是:</h3><ol>
<li>建立一个Java项目,名称可以按题号取名;</li>
<li>建立一个测试类, 类的名称为TestMain。这一点非常重要；</li>
<li>填代码；</li>
<li>提交代码，注意题号要一致。</li>
<li>注意只能修改【代码】之处,不能修改其它地方,否则以0分计</li>
</ol>
<p>针对下面的Calculator类, 在后面有一个测试类TestMain。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> result; <span class="comment">// 静态变量，用于存储运行结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        result = result + n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">substract</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        result = result - n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;     <span class="comment">// 将结果清零</span></span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面TestMain测试程序实现了语句覆盖。请将下面TestMain测试程序中的【代码】替换为Java测试代码，使测试程序运行正确。<br>文件TestMain.java如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Calculator calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> 【代码1】 Exception </span>&#123;</span><br><span class="line">        calculator.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        calculator.add(<span class="number">2</span>);</span><br><span class="line">        calculator.add(<span class="number">3</span>);</span><br><span class="line">        assertEquals(<span class="number">5</span>, calculator.【代码<span class="number">2</span>】());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSubstract</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        calculator.add(<span class="number">10</span>);</span><br><span class="line">        calculator.substract(<span class="number">2</span>);</span><br><span class="line">        assertEquals(<span class="number">8</span>, 【代码<span class="number">3</span>】.getResult());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="答案-1"><a href="#答案-1" class="headerlink" title="答案"></a>答案</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Calculator calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        calculator.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        calculator.add(<span class="number">2</span>);</span><br><span class="line">        calculator.add(<span class="number">3</span>);</span><br><span class="line">        assertEquals(<span class="number">5</span>, calculator.getResult());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSubstract</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        calculator.add(<span class="number">10</span>);</span><br><span class="line">        calculator.substract(<span class="number">2</span>);</span><br><span class="line">        assertEquals(<span class="number">8</span>, calculator.getResult());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第3题-填写代码-判断NextDate类闰年函数的原子谓词覆盖测试-12分"><a href="#第3题-填写代码-判断NextDate类闰年函数的原子谓词覆盖测试-12分" class="headerlink" title="第3题 填写代码.判断NextDate类闰年函数的原子谓词覆盖测试(12分)"></a>第3题 填写代码.判断NextDate类闰年函数的原子谓词覆盖测试(12分)</h2><h3 id="此题的上机步骤是-2"><a href="#此题的上机步骤是-2" class="headerlink" title="此题的上机步骤是:"></a>此题的上机步骤是:</h3><ol>
<li>建立一个Java项目,名称可以按题号取名;</li>
<li>建立一个测试类, 类的名称为TestMain。这一点非常重要；</li>
<li>填代码；</li>
<li>提交代码，注意题号要一致。</li>
<li>注意只能修改【代码】之处,不能修改其它地方,否则以0分计</li>
</ol>
<p>针对下面的NextDate类, 在后面有一个测试类TestMain。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NextDate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> bool;</span><br><span class="line">    <span class="comment">// 判断某一年是不是闰年的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leapYear</span><span class="params">(<span class="keyword">int</span> year)</span> </span>&#123;</span><br><span class="line">        bool = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> ((year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>) || (year % <span class="number">400</span> == <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="comment">// 是闰年</span></span><br><span class="line">            bool = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> bool;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面TestMain测试程序实现了语句覆盖。请将下面TestMain测试程序中的【代码】替换为Java测试代码，使测试程序运行正确。<br>文件TestMain.java如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> NextDate nextDate;</span><br><span class="line">    @【代码<span class="number">1</span>】</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        nextDate = 【代码<span class="number">2</span>】 NextDate();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testleapYear1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        nextDate.leapYear(<span class="number">400</span>);</span><br><span class="line">        assertEquals(<span class="keyword">true</span>, nextDate.getResult());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testleapYear2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        nextDate.【代码<span class="number">3</span>】(<span class="number">4</span>);</span><br><span class="line">        assertEquals(<span class="keyword">true</span>, nextDate.getResult());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testleapYear3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        nextDate.leapYear(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">assert</span>【代码<span class="number">4</span>】(<span class="keyword">false</span>, nextDate.getResult());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="答案-2"><a href="#答案-2" class="headerlink" title="答案"></a>答案</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> NextDate nextDate;</span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        nextDate = <span class="keyword">new</span> NextDate();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testleapYear1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        nextDate.leapYear(<span class="number">400</span>);</span><br><span class="line">        assertEquals(<span class="keyword">true</span>, nextDate.getResult());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testleapYear2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        nextDate.leapYear(<span class="number">4</span>);</span><br><span class="line">        assertEquals(<span class="keyword">true</span>, nextDate.getResult());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testleapYear3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        nextDate.leapYear(<span class="number">100</span>);</span><br><span class="line">        assertEquals(<span class="keyword">false</span>, nextDate.getResult());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="第4题-填写代码-字符串正则化类的测试-10分"><a href="#第4题-填写代码-字符串正则化类的测试-10分" class="headerlink" title="第4题 填写代码.字符串正则化类的测试(10分)"></a>第4题 填写代码.字符串正则化类的测试(10分)</h2><h3 id="此题的上机步骤是-3"><a href="#此题的上机步骤是-3" class="headerlink" title="此题的上机步骤是:"></a>此题的上机步骤是:</h3><ol>
<li>建立一个Java项目,名称可以按题号取名;</li>
<li>建立一个测试类, 类的名称为TestMain。这一点非常重要；</li>
<li>填代码；</li>
<li>提交代码，注意题号要一致。</li>
<li>注意只能修改【代码】之处,不能修改其它地方,否则以0分计</li>
</ol>
<p>针对下面的StringNormalize类, 在后面有一个测试类TestMain。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringNormalize</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">normalize</span><span class="params">(String in)</span> </span>&#123;</span><br><span class="line">            StringBuilder out = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            String l = in.toLowerCase();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l.length(); ++i) &#123;</span><br><span class="line">                <span class="keyword">char</span> c = l.charAt(i);</span><br><span class="line">                <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span> || c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                    out.append(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> out.toString();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请将下面TestMain测试程序中的【代码】替换为Java测试代码，使测试程序运行正确。<br>文件TestMain.java如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test(timeout = 4000)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test0</span><span class="params">()</span> <span class="keyword">throws</span> 【代码1】 </span>&#123;</span><br><span class="line">        String string0 = StringNormalize.normalize(<span class="string">&quot;#d0::&amp;Ghk\&quot;hS~L&quot;</span>);</span><br><span class="line">        assertEquals(<span class="string">&quot;d0ghkhsl&quot;</span>, string0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test(timeout = 4000)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        String string0 = 【代码<span class="number">2</span>】.normalize(<span class="string">&quot;%P/1Rx&#125;BT~H$R;A+Hg&quot;</span>);</span><br><span class="line">        assertEquals(<span class="string">&quot;p1rxbthrahg&quot;</span>, string0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test(timeout = 4000)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        String string0 = StringNormalize.normalize(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        assertEquals(<span class="string">&quot;&quot;</span>, string0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test(timeout = 4000, 【代码3】 = NullPointerException.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// Undeclared exception!</span></span><br><span class="line">        StringNormalize.normalize((String) <span class="keyword">null</span>);</span><br><span class="line">        fail(<span class="string">&quot;Expecting exception: NullPointerException&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test(【代码4】 = 4000)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        String string0 = StringNormalize.normalize(<span class="string">&quot;&gt; h[1QY#+&#x27;9vWzL1M|h&quot;</span>);</span><br><span class="line">        assertEquals(<span class="string">&quot;h1qy9vwzl1mh&quot;</span>, string0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test(timeout = 4000)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        StringNormalize utils0 = <span class="keyword">new</span> StringNormalize();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="答案-3"><a href="#答案-3" class="headerlink" title="答案"></a>答案</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test(timeout = 4000)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test0</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        String string0 = StringNormalize.normalize(<span class="string">&quot;#d0::&amp;Ghk\&quot;hS~L&quot;</span>);</span><br><span class="line">        assertEquals(<span class="string">&quot;d0ghkhsl&quot;</span>, string0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test(timeout = 4000)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        String string0 = StringNormalize.normalize(<span class="string">&quot;%P/1Rx&#125;BT~H$R;A+Hg&quot;</span>);</span><br><span class="line">        assertEquals(<span class="string">&quot;p1rxbthrahg&quot;</span>, string0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test(timeout = 4000)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        String string0 = StringNormalize.normalize(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        assertEquals(<span class="string">&quot;&quot;</span>, string0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test(timeout = 4000, expected = NullPointerException.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// Undeclared exception!</span></span><br><span class="line">        StringNormalize.normalize((String) <span class="keyword">null</span>);</span><br><span class="line">        fail(<span class="string">&quot;Expecting exception: NullPointerException&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test(timeout = 4000)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        String string0 = StringNormalize.normalize(<span class="string">&quot;&gt; h[1QY#+&#x27;9vWzL1M|h&quot;</span>);</span><br><span class="line">        assertEquals(<span class="string">&quot;h1qy9vwzl1mh&quot;</span>, string0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test(timeout = 4000)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        StringNormalize utils0 = <span class="keyword">new</span> StringNormalize();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第5题-填写代码-Web测试搜索百度-湘潭大学-15分"><a href="#第5题-填写代码-Web测试搜索百度-湘潭大学-15分" class="headerlink" title="第5题 填写代码.Web测试搜索百度-湘潭大学(15分)"></a>第5题 填写代码.Web测试搜索百度-湘潭大学(15分)</h2><h3 id="此题的上机环境是"><a href="#此题的上机环境是" class="headerlink" title="此题的上机环境是:"></a>此题的上机环境是:</h3><ol>
<li>Chrome浏览器安装目录为C:\Program Files\Chrome\Application\chrome.exe<br>如果安装目录不是该文件夹，请复制安装目录下的子文件夹“Chrome”到“C:\Program Files\”。</li>
<li>驱动程序chromedriver.exe放到C:\WebDriver中</li>
</ol>
<h3 id="此题的上机步骤是-4"><a href="#此题的上机步骤是-4" class="headerlink" title="此题的上机步骤是:"></a>此题的上机步骤是:</h3><ol>
<li>建立一个Java项目,名称可以按题号取名;</li>
<li>建立一个测试类, 类的名称为TestMain。这一点非常重要；</li>
<li>填代码；</li>
<li>提交代码，注意题号要一致。</li>
<li>注意只能修改【代码】之处,不能修改其它地方,否则以0分计</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 测试百度的租房搜索功能</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 1. 打开百度网页版http://www.baidu.com</span></span><br><span class="line"><span class="comment">* 2. 搜索框选择“湘潭大学”</span></span><br><span class="line"><span class="comment">* 3. 点击“百度一下”按钮</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>请将下面TestMain测试程序中的【代码】替换为Java测试代码，使测试程序运行正确。<br>文件TestMain.java如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.openqa.selenium.WebElement;</span><br><span class="line"><span class="keyword">import</span> org.openqa.selenium.chrome.ChromeDriver;</span><br><span class="line"><span class="keyword">import</span> org.openqa.selenium.chrome.ChromeOptions;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="comment">// 配置chromedriver的驱动路径</span></span><br><span class="line">        System.setProperty(<span class="string">&quot;webdriver.chrome.driver&quot;</span>, <span class="string">&quot;【代码1】/chromedriver.exe&quot;</span>);</span><br><span class="line">        ChromeOptions options = <span class="keyword">new</span> ChromeOptions();</span><br><span class="line">        <span class="comment">// 设置chrome浏览器的 exe文件路径</span></span><br><span class="line">        【代码<span class="number">2</span>】.setBinary(<span class="string">&quot;C:\\Program Files\\Chrome\\Application\\chrome.exe&quot;</span>);</span><br><span class="line">        ChromeDriver 【代码<span class="number">3</span>】 = <span class="keyword">new</span> ChromeDriver(options);</span><br><span class="line">        <span class="comment">// 隐式等待时间</span></span><br><span class="line">        driver.manage().timeouts().implicitlyWait(<span class="number">5</span>, TimeUnit.SECONDS); <span class="comment">// 每次操作时长</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 运行Chrome浏览器并且打开“百度”网站</span></span><br><span class="line">        driver.get(<span class="string">&quot;http://www.baidu.com&quot;</span>);</span><br><span class="line">        <span class="comment">// 1. “百度”网站搜索内容输入文本框输入文字“湘潭大学”</span></span><br><span class="line">        WebElement e = driver.findElementByXPath(<span class="string">&quot;【代码4】&quot;</span>);<span class="comment">// 定位控件“搜索文本框”</span></span><br><span class="line">        CharSequence []cs=&#123;<span class="string">&quot;湘潭大学&quot;</span>&#125;;<span class="comment">//重点要求</span></span><br><span class="line">        e.【代码<span class="number">5</span>】(cs);<span class="comment">// “搜索文本框”中输入文字“湘潭大学”</span></span><br><span class="line">        <span class="comment">// 2. 单击“百度一下”按钮</span></span><br><span class="line">        e = driver.findElementByXPath(<span class="string">&quot;/html/body/div[1]/div[1]/div[5]/div/div/form/span[2]/input&quot;</span>);<span class="comment">// 定位“百度”</span></span><br><span class="line"></span><br><span class="line">按钮</span><br><span class="line">        e.click();<span class="comment">// 单击</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.cnblogs.com/aaronthon/p/12739437.html">findElementByXPath</a></p>
<h3 id="答案-4"><a href="#答案-4" class="headerlink" title="答案"></a>答案</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.openqa.selenium.WebElement;</span><br><span class="line"><span class="keyword">import</span> org.openqa.selenium.chrome.ChromeDriver;</span><br><span class="line"><span class="keyword">import</span> org.openqa.selenium.chrome.ChromeOptions;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="comment">// 配置chromedriver的驱动路径</span></span><br><span class="line">        System.setProperty(<span class="string">&quot;webdriver.chrome.driver&quot;</span>, <span class="string">&quot;C:/WebDriver/chromedriver.exe&quot;</span>);</span><br><span class="line">        ChromeOptions options = <span class="keyword">new</span> ChromeOptions();</span><br><span class="line">        <span class="comment">// 设置chrome浏览器的 exe文件路径</span></span><br><span class="line">       options.setBinary(<span class="string">&quot;C:\\Program Files\\Chrome\\Application\\chrome.exe&quot;</span>);</span><br><span class="line">        ChromeDriver driver = <span class="keyword">new</span> ChromeDriver(options);</span><br><span class="line">        <span class="comment">// 隐式等待时间</span></span><br><span class="line">        driver.manage().timeouts().implicitlyWait(<span class="number">5</span>, TimeUnit.SECONDS); <span class="comment">// 每次操作时长</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 运行Chrome浏览器并且打开“百度”网站</span></span><br><span class="line">        driver.get(<span class="string">&quot;http://www.baidu.com&quot;</span>);</span><br><span class="line">        <span class="comment">// 1. “百度”网站搜索内容输入文本框输入文字“湘潭大学”</span></span><br><span class="line">        WebElement e = driver.findElementByXPath(<span class="string">&quot;/html/body/div[1]/div[1]/div[5]/div/div/form/span[1]/input&quot;</span>);<span class="comment">// 定位控件“搜索文本框”</span></span><br><span class="line">        CharSequence []cs=&#123;<span class="string">&quot;湘潭大学&quot;</span>&#125;;<span class="comment">//重点要求</span></span><br><span class="line">        e.sendKeys(cs);<span class="comment">// “搜索文本框”中输入文字“湘潭大学”</span></span><br><span class="line">        <span class="comment">// 2. 单击“百度一下”按钮</span></span><br><span class="line">        e = driver.findElementByXPath(<span class="string">&quot;/html/body/div[1]/div[1]/div[5]/div/div/form/span[2]/input&quot;</span>);<span class="comment">// 定位“百度”</span></span><br><span class="line"></span><br><span class="line">        e.click();<span class="comment">// 单击</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="第6题-填写代码-WEB测试安居客的租房功能-21分"><a href="#第6题-填写代码-WEB测试安居客的租房功能-21分" class="headerlink" title="第6题 填写代码.WEB测试安居客的租房功能(21分)"></a>第6题 填写代码.WEB测试安居客的租房功能(21分)</h2><h3 id="此题的上机环境是-1"><a href="#此题的上机环境是-1" class="headerlink" title="此题的上机环境是:"></a>此题的上机环境是:</h3><ol>
<li>Chrome浏览器安装目录为C:\Program Files\Chrome\Application\chrome.exe<br>如果安装目录不是该文件夹，请将安装目录下的子文件夹“Chrome”复制到“C:\Program Files\”</li>
<li>驱动程序chromedriver.exe放到C:\WebDriver中</li>
</ol>
<h3 id="此题的上机步骤是-5"><a href="#此题的上机步骤是-5" class="headerlink" title="此题的上机步骤是:"></a>此题的上机步骤是:</h3><ol>
<li>建立一个Java项目,名称可以按题号取名;</li>
<li>建立一个测试类, 类的名称为TestMain。这一点非常重要；</li>
<li>填代码；</li>
<li>提交代码，注意题号要一致。</li>
<li>注意只能修改【代码】之处,不能修改其它地方,否则以0分计</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试安居客的租房功能</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. 打开安居客网页版，点击租房</span></span><br><span class="line"><span class="comment"> * 2. 地址选择“南京”</span></span><br><span class="line"><span class="comment"> * 3. 点击“地铁找房”</span></span><br><span class="line"><span class="comment"> * 4. 选择“2 号线”</span></span><br><span class="line"><span class="comment"> * 5. 选择“马群”</span></span><br><span class="line"><span class="comment"> * 6. 设置租金为 2600-5200 元，并点击确定</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>请将下面TestMain测试程序中的【代码】替换为Java测试代码，使测试程序运行正确。<br>文件TestMain.java如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> org.openqa.selenium.WebElement;</span><br><span class="line"><span class="keyword">import</span> org.openqa.selenium.chrome.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Sleep</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(a * <span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="comment">// 配置chromedriver的驱动路径</span></span><br><span class="line">        System.setProperty(<span class="string">&quot;webdriver.chrome.driver&quot;</span>, <span class="string">&quot;C:/WebDriver/chromedriver.exe&quot;</span>);</span><br><span class="line">        ChromeOptions options = <span class="keyword">new</span> 【代码<span class="number">1</span>】();</span><br><span class="line">        <span class="comment">// 设置chrome浏览器的 exe文件路径</span></span><br><span class="line">        options.setBinary(<span class="string">&quot;【代码2】\\Chrome\\Application\\chrome.exe&quot;</span>);</span><br><span class="line">        ChromeDriver driver = <span class="keyword">new</span> ChromeDriver(options);</span><br><span class="line">        <span class="comment">// 隐式等待时间</span></span><br><span class="line">        driver.manage().【代码<span class="number">3</span>】().implicitlyWait(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="comment">// 安居客</span></span><br><span class="line">        driver.get(<span class="string">&quot;https://nj.zu.anjuke.com/&quot;</span>);</span><br><span class="line">        <span class="comment">// 1. 点击租房</span></span><br><span class="line">        WebElement e = driver.findElementByXPath(<span class="string">&quot;/html/body/div[2]/div/ul/li[4]/a&quot;</span>);</span><br><span class="line">        e.click();</span><br><span class="line">        <span class="comment">// 2. 地址选择“南京”</span></span><br><span class="line">        e = driver.【代码<span class="number">4</span>】(<span class="string">&quot;/html/body/div[3]/div/div[1]/i&quot;</span>);</span><br><span class="line">        e.click();</span><br><span class="line">        <span class="comment">// 弹出列表</span></span><br><span class="line">        e = driver.findElementByXPath(<span class="string">&quot;/html/body/div[3]/div/div[2]/dl[2]/dd/a[4]&quot;</span>);</span><br><span class="line">        e.click();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 点击“地铁找房”</span></span><br><span class="line">        e = driver.findElementByLinkText(<span class="string">&quot;地铁找房&quot;</span>);</span><br><span class="line">        e.click();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 选择“2 号线”</span></span><br><span class="line">        e = driver.findElementByXPath(<span class="string">&quot;【代码5】&quot;</span>);</span><br><span class="line">        e.click();</span><br><span class="line">        Sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 5. 选择“马群”</span></span><br><span class="line">        e = driver.findElementByXPath(<span class="string">&quot;/html/body/div[5]/div[2]/div[1]/span[2]/div/div/a[20]&quot;</span>);</span><br><span class="line">        e.click();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 设置租金为 2600-5200 元，并点击确定</span></span><br><span class="line">        e = driver.findElementByXPath(<span class="string">&quot;/html/body/div[5]/div[2]/div[2]/span[2]/div/form/input[1]&quot;</span>);</span><br><span class="line">        CharSequence []cs=&#123;<span class="string">&quot;2600&quot;</span>&#125;;<span class="comment">//重点要求</span></span><br><span class="line">        e.sendKeys(cs);<span class="comment">// “搜索框”中输入“2600”</span></span><br><span class="line"></span><br><span class="line">        e = driver.findElementByXPath(<span class="string">&quot;/html/body/div[5]/div[2]/div[2]/span[2]/div/form/input[2]&quot;</span>);</span><br><span class="line">        cs[<span class="number">0</span>]=<span class="string">&quot;5200&quot;</span>;</span><br><span class="line">        e.【代码<span class="number">6</span>】(cs);<span class="comment">//不能直接用字符串</span></span><br><span class="line">        e.【代码<span class="number">7</span>】();</span><br><span class="line"></span><br><span class="line">        e = driver.findElementByXPath(<span class="string">&quot;//*[@id=\&quot;pricerange_search\&quot;]&quot;</span>);</span><br><span class="line">        e.click();</span><br><span class="line"></span><br><span class="line">        driver.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="答案-5"><a href="#答案-5" class="headerlink" title="答案"></a>答案</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> org.openqa.selenium.WebElement;</span><br><span class="line"><span class="keyword">import</span> org.openqa.selenium.chrome.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Sleep</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(a * <span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="comment">// 配置chromedriver的驱动路径</span></span><br><span class="line">        System.setProperty(<span class="string">&quot;webdriver.chrome.driver&quot;</span>, <span class="string">&quot;C:/WebDriver/chromedriver.exe&quot;</span>);</span><br><span class="line">        ChromeOptions options = <span class="keyword">new</span> ChromeOptions();</span><br><span class="line">        <span class="comment">// 设置chrome浏览器的 exe文件路径</span></span><br><span class="line">        options.setBinary(<span class="string">&quot;C:\\Program Files\\Chrome\\Application\\chrome.exe&quot;</span>);</span><br><span class="line">        ChromeDriver driver = <span class="keyword">new</span> ChromeDriver(options);</span><br><span class="line">        <span class="comment">// 隐式等待时间</span></span><br><span class="line">        driver.manage().timeouts().implicitlyWait(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="comment">// 安居客</span></span><br><span class="line">        driver.get(<span class="string">&quot;https://nj.zu.anjuke.com/&quot;</span>);</span><br><span class="line">        <span class="comment">// 1. 点击租房</span></span><br><span class="line">        WebElement e = driver.findElementByXPath(<span class="string">&quot;/html/body/div[2]/div/ul/li[4]/a&quot;</span>);</span><br><span class="line">        e.click();</span><br><span class="line">        <span class="comment">// 2. 地址选择“南京”</span></span><br><span class="line">        e = driver.findElementByXPath(<span class="string">&quot;/html/body/div[3]/div/div[1]/i&quot;</span>);</span><br><span class="line">        e.click();</span><br><span class="line">        <span class="comment">// 弹出列表</span></span><br><span class="line">        e = driver.findElementByXPath(<span class="string">&quot;/html/body/div[3]/div/div[2]/dl[2]/dd/a[4]&quot;</span>);</span><br><span class="line">        e.click();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 点击“地铁找房”</span></span><br><span class="line">        e = driver.findElementByLinkText(<span class="string">&quot;地铁找房&quot;</span>);</span><br><span class="line">        e.click();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 选择“2 号线”</span></span><br><span class="line">        e = driver.findElementByXPath(<span class="string">&quot;/html/body/div[5]/div[2]/div[1]/span[2]/div/a[3]&quot;</span>);</span><br><span class="line">        e.click();</span><br><span class="line">        Sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 5. 选择“马群”</span></span><br><span class="line">        e = driver.findElementByXPath(<span class="string">&quot;/html/body/div[5]/div[2]/div[1]/span[2]/div/div/a[20]&quot;</span>);</span><br><span class="line">        e.click();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 设置租金为 2600-5200 元，并点击确定</span></span><br><span class="line">        e = driver.findElementByXPath(<span class="string">&quot;/html/body/div[5]/div[2]/div[2]/span[2]/div/form/input[1]&quot;</span>);</span><br><span class="line">        CharSequence []cs=&#123;<span class="string">&quot;2600&quot;</span>&#125;;<span class="comment">//重点要求</span></span><br><span class="line">        e.sendKeys(cs);<span class="comment">// “搜索框”中输入“2600”</span></span><br><span class="line"></span><br><span class="line">        e = driver.findElementByXPath(<span class="string">&quot;/html/body/div[5]/div[2]/div[2]/span[2]/div/form/input[2]&quot;</span>);</span><br><span class="line">        cs[<span class="number">0</span>]=<span class="string">&quot;5200&quot;</span>;</span><br><span class="line">        e.sendKeys(cs);<span class="comment">//不能直接用字符串</span></span><br><span class="line">        e.click();</span><br><span class="line"></span><br><span class="line">        e = driver.findElementByXPath(<span class="string">&quot;//*[@id=\&quot;pricerange_search\&quot;]&quot;</span>);</span><br><span class="line">        e.click();</span><br><span class="line"></span><br><span class="line">        driver.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第7题-测试代码编写-HelloWorld类最简单say方法-5分"><a href="#第7题-测试代码编写-HelloWorld类最简单say方法-5分" class="headerlink" title="第7题 测试代码编写.HelloWorld类最简单say方法(5分)"></a>第7题 测试代码编写.HelloWorld类最简单say方法(5分)</h2><h3 id="此题的上机环境和要求"><a href="#此题的上机环境和要求" class="headerlink" title="此题的上机环境和要求:"></a>此题的上机环境和要求:</h3><ol>
<li>Junit4 或者以上。</li>
<li>使用Junit4脚本。</li>
<li>测试类只有一个，名称为TestMain，这一点非常重要。</li>
<li>测试代码不能有输出语句（System…等)，否则以0分计。</li>
<li>如果测试代码不能编译成功则以0分计。</li>
</ol>
<h3 id="此题的上机步骤是-6"><a href="#此题的上机步骤是-6" class="headerlink" title="此题的上机步骤是:"></a>此题的上机步骤是:</h3><ol>
<li>建立一个Java项目，名称可以按题号取名。</li>
<li>建立被测试类和一个测试类(名称为TestMain)。</li>
<li>编写测试代码。</li>
<li>提交测试代码，注意题号要一致。</li>
</ol>
<p>本题被测试类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="答案-6"><a href="#答案-6" class="headerlink" title="答案"></a>答案</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HelloWorld h1 = <span class="keyword">new</span> HelloWorld();</span><br><span class="line">        assertEquals(<span class="string">&quot;Hello World!&quot;</span>,h1.say());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="第8题-测试代码编写-SayYourName类语句覆盖-10分"><a href="#第8题-测试代码编写-SayYourName类语句覆盖-10分" class="headerlink" title="第8题 测试代码编写.SayYourName类语句覆盖(10分)"></a>第8题 测试代码编写.SayYourName类语句覆盖(10分)</h2><h3 id="此题的上机环境和要求-1"><a href="#此题的上机环境和要求-1" class="headerlink" title="此题的上机环境和要求:"></a>此题的上机环境和要求:</h3><ol>
<li>Junit4 或者以上。</li>
<li>使用Junit4脚本。</li>
<li>测试类只有一个，名称为TestMain，这一点非常重要。</li>
<li>测试代码不能有输出语句（System…等)，否则以0分计。</li>
<li>如果测试代码不能编译成功则以0分计。</li>
</ol>
<h3 id="此题的上机步骤是-7"><a href="#此题的上机步骤是-7" class="headerlink" title="此题的上机步骤是:"></a>此题的上机步骤是:</h3><ol>
<li>建立一个Java项目，名称可以按题号取名。</li>
<li>建立被测试类和一个测试类(名称为TestMain)。</li>
<li>编写测试代码。</li>
<li>提交测试代码，注意题号要一致。</li>
</ol>
<p>本题被测试类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SayYourName</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAndSay</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;LiMeiYi&quot;</span>.equals(name)) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="string">&quot;Hi,Teacher&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="string">&quot;Hi,Welcome!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="答案-7"><a href="#答案-7" class="headerlink" title="答案"></a>答案</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SayYourName ayn = <span class="keyword">new</span> SayYourName();</span><br><span class="line">        assertEquals(<span class="string">&quot;Hi,Teacher&quot;</span>,ayn.getAndSay(<span class="string">&quot;LiMeiYi&quot;</span>));</span><br><span class="line">        assertEquals(<span class="string">&quot;Hi,Teacher&quot;</span>,ayn.getAndSay(<span class="string">&quot;xyq&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="第9题-测试代码编写-Calculator类简单语句覆盖-15分"><a href="#第9题-测试代码编写-Calculator类简单语句覆盖-15分" class="headerlink" title="第9题 测试代码编写.Calculator类简单语句覆盖(15分)"></a>第9题 测试代码编写.Calculator类简单语句覆盖(15分)</h2><h3 id="此题的上机环境和要求-2"><a href="#此题的上机环境和要求-2" class="headerlink" title="此题的上机环境和要求:"></a>此题的上机环境和要求:</h3><ol>
<li>Junit4 或者以上。</li>
<li>使用Junit4脚本。</li>
<li>测试类只有一个，名称为TestMain，这一点非常重要。</li>
<li>测试代码不能有输出语句（System…等)，否则以0分计。</li>
<li>如果测试代码不能编译成功则以0分计。</li>
</ol>
<h3 id="此题的上机步骤是-8"><a href="#此题的上机步骤是-8" class="headerlink" title="此题的上机步骤是:"></a>此题的上机步骤是:</h3><ol>
<li>建立一个Java项目，名称可以按题号取名。</li>
<li>建立被测试类和一个测试类(名称为TestMain)。</li>
<li>编写测试代码。</li>
<li>提交测试代码，注意题号要一致。</li>
</ol>
<p>本题被测试类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minus</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == b)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;除数不能为零!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a / b;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="答案-8"><a href="#答案-8" class="headerlink" title="答案"></a>答案</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</span><br><span class="line">    Calculator calulator = <span class="keyword">new</span> Calculator();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertEquals(<span class="number">3</span>,calulator.add(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMinus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertEquals(<span class="number">1</span>,calulator.minus(<span class="number">3</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMultiply</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertEquals(<span class="number">4</span>,calulator.multiply(<span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDivide1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        assertEquals(<span class="number">1</span>,calulator.divide(<span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDivide2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            calulator.divide(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">            fail(<span class="string">&quot;除数不能为零!&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            assertEquals(<span class="string">&quot;除数不能为零!&quot;</span>,e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="第10题-测试代码编写-Triangle类分支覆盖-22分"><a href="#第10题-测试代码编写-Triangle类分支覆盖-22分" class="headerlink" title="第10题 测试代码编写.Triangle类分支覆盖(22分)"></a>第10题 测试代码编写.Triangle类分支覆盖(22分)</h2><h3 id="此题的上机环境和要求-3"><a href="#此题的上机环境和要求-3" class="headerlink" title="此题的上机环境和要求:"></a>此题的上机环境和要求:</h3><p>1）Junit4 或者以上。<br>2) 使用Junit4脚本。<br>3) 测试类只有一个，名称为TestMain，这一点非常重要。<br>3) 测试代码不能有输出语句（System…等)，否则以0分计。<br>4) 如果测试代码不能编译成功则以0分计。</p>
<h3 id="此题的上机步骤是-9"><a href="#此题的上机步骤是-9" class="headerlink" title="此题的上机步骤是:"></a>此题的上机步骤是:</h3><ol>
<li>建立一个Java项目，名称可以按题号取名。</li>
<li>建立被测试类和一个测试类(名称为TestMain)。</li>
<li>编写测试代码。</li>
<li>提交测试代码，注意题号要一致。</li>
</ol>
<p>本题被测试类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义三角形的三边</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">long</span> lborderA = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">long</span> lborderB = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">long</span> lborderC = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Triangle</span><span class="params">(<span class="keyword">long</span> lborderA,<span class="keyword">long</span> lborderB,<span class="keyword">long</span> lborderC)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.lborderA = lborderA;</span><br><span class="line">           <span class="keyword">this</span>.lborderB = lborderB;</span><br><span class="line">           <span class="keyword">this</span>.lborderC = lborderC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否是三角形</span></span><br><span class="line"><span class="comment">     * 是返回true；不是返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTriangle</span><span class="params">(Triangle triangle)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> isTrue = <span class="keyword">false</span>;</span><br><span class="line">       <span class="comment">//判断边界，大于0小于等于100，出界返回false</span></span><br><span class="line">       <span class="keyword">if</span>((triangle.lborderA&gt;<span class="number">0</span>&amp;&amp;triangle.lborderA&lt;=<span class="number">100</span>)</span><br><span class="line">          &amp;&amp;(triangle.lborderB&gt;<span class="number">0</span>&amp;&amp;triangle.lborderB&lt;=<span class="number">100</span>)</span><br><span class="line">          &amp;&amp;(triangle.lborderC&gt;<span class="number">0</span>&amp;&amp;triangle.lborderC&lt;=<span class="number">100</span>))</span><br><span class="line">       &#123;</span><br><span class="line">            <span class="comment">//判断两边之和大于第三边</span></span><br><span class="line">            <span class="keyword">if</span>((triangle.lborderA&lt;(triangle.lborderB+triangle.lborderC))</span><br><span class="line">             &amp;&amp;(triangle.lborderB&lt;(triangle.lborderA+triangle.lborderC))</span><br><span class="line">             &amp;&amp;(triangle.lborderC&lt;(triangle.lborderA+triangle.lborderB)))</span><br><span class="line">            isTrue = <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">            <span class="keyword">return</span> isTrue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 判断三角形类型</span></span><br><span class="line"><span class="comment">      * 等腰三角形返回字符串“等腰三角形”；</span></span><br><span class="line"><span class="comment">      * 等边三角形返回字符串“等边三角形”；</span></span><br><span class="line"><span class="comment">      * 其它三角形返回字符串“不等边三角形”；</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">isType</span><span class="params">(Triangle triangle)</span></span>&#123;</span><br><span class="line">        String strType = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">// 判断是否是三角形            </span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.isTriangle(triangle))&#123;</span><br><span class="line">            <span class="comment">//判断是否是等边三角形                  </span></span><br><span class="line">            <span class="keyword">if</span>(triangle.lborderA==triangle.lborderB&amp;&amp;triangle.lborderB==triangle.lborderC)</span><br><span class="line">                strType = <span class="string">&quot;等边三角形&quot;</span>;</span><br><span class="line">                <span class="comment">//判断是否是不等边三角形</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((triangle.lborderA!=triangle.lborderB)&amp;&amp;</span><br><span class="line">               (triangle.lborderB!=triangle.lborderC)&amp;&amp;</span><br><span class="line">               (triangle.lborderA!=triangle.lborderC))</span><br><span class="line">                strType = <span class="string">&quot;不等边三角形&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                strType=<span class="string">&quot;等腰三角形&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> strType;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO 自动生成方法存根</span></span><br><span class="line">        Triangle aTriangle;</span><br><span class="line">        aTriangle=<span class="keyword">new</span> Triangle(-<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span>(!aTriangle.isTriangle(aTriangle))</span><br><span class="line">        System.out.println(<span class="string">&quot;不是三角形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="答案-9"><a href="#答案-9" class="headerlink" title="答案"></a>答案</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.BeforeClass;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIsTriangle1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Triangle triangle = <span class="keyword">new</span> Triangle(<span class="number">101</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">        assertEquals(<span class="keyword">false</span>,triangle.isTriangle(triangle));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIsTriangle2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Triangle triangle = <span class="keyword">new</span> Triangle(<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">        assertEquals(<span class="keyword">true</span>,triangle.isTriangle(triangle));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIsTriangle3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Triangle triangle = <span class="keyword">new</span> Triangle(<span class="number">5</span>,<span class="number">3</span>,<span class="number">10</span>);</span><br><span class="line">        assertEquals(<span class="keyword">false</span>,triangle.isTriangle(triangle));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIsType1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Triangle triangle = <span class="keyword">new</span> Triangle(<span class="number">12</span>,<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">        assertEquals(<span class="string">&quot;&quot;</span>,triangle.isType(triangle));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIsType2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Triangle triangle = <span class="keyword">new</span> Triangle(<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">        assertEquals(<span class="string">&quot;等边三角形&quot;</span>,triangle.isType(triangle));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIsType3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Triangle triangle = <span class="keyword">new</span> Triangle(<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line">        assertEquals(<span class="string">&quot;等腰三角形&quot;</span>,triangle.isType(triangle));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIsType4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Triangle triangle = <span class="keyword">new</span> Triangle(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">        assertEquals(<span class="string">&quot;不等边三角形&quot;</span>,triangle.isType(triangle));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIsType5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Triangle triangle = <span class="keyword">new</span> Triangle(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">        assertEquals(<span class="string">&quot;不等边三角形&quot;</span>,triangle.isType(triangle));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIsType6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Triangle.main(<span class="keyword">new</span> String[]&#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="第11题-单选题-16分）"><a href="#第11题-单选题-16分）" class="headerlink" title="第11题  单选题(16分）"></a>第11题  单选题(16分）</h2><ol>
<li>软件生命周期由若干个阶段组成，下列（  ）阶段，如果在此阶段发现软件缺陷，则修复费用是最低的。<br>（A）需求分析（编制产品说明书）<br>（B）设计<br>（C）编码<br>（D）产品发布</li>
<li>下列各项中（   ）不是一个测试计划所应包含的内容。<br>（A）测试资源、进度安排<br>（B）测试预期输出<br>（C）测试范围<br>（D）测试策略</li>
<li>软件测试的目的是（  ）。<br>（A）试验性运行软件<br>（B）发现软件错误<br>（C）证明软件正确<br>（D）找出软件中全部错误</li>
<li>软件测试是采用（   ）执行软件的活动。<br>（A）测试用例<br>（B）输入数据<br>（C）测试环境<br>（D）输入条件</li>
<li>与设计测试用例无关的文档是（  ）。<br>（A）项目开发计划<br>（B）需求规格说明书<br>（C）设计说明书<br>（D）源程序</li>
<li>下列项目中不属于测试文档的是（   ）<br>（A）测试计划<br>（B）测试用例<br>（C）程序流程图<br>（D）测试报告</li>
<li>软件测试用例主要由输入数据和（  ）两部分组成。<br>（A）测试计划<br>（B）测试规则<br>（C）预期输出结果<br>（D）以往测试记录分析</li>
<li>经验表明，在程序测试中，某模块与其他模块相比，若该模块已发现并改正的错误较多，<br>则该模块中残存的错误数目与其他模块相比，通常应该（  ）。<br>（A）较少<br>（B）较多<br>（C）相似<br>（D）不确定</li>
</ol>
<h3 id="答案-10"><a href="#答案-10" class="headerlink" title="答案"></a>答案</h3><ol>
<li>A</li>
<li>B</li>
<li>B</li>
<li>A</li>
<li>A </li>
<li>C</li>
<li>C</li>
<li>B</li>
</ol>
<h2 id="第12题-计算题-软件可靠性基本参数”有效度”计算-10分"><a href="#第12题-计算题-软件可靠性基本参数”有效度”计算-10分" class="headerlink" title="第12题 计算题.软件可靠性基本参数”有效度”计算(10分)"></a>第12题 计算题.软件可靠性基本参数”有效度”计算(10分)</h2><h3 id="此题的步骤和要求"><a href="#此题的步骤和要求" class="headerlink" title="此题的步骤和要求:"></a>此题的步骤和要求:</h3><ol>
<li>按题目要求做计算。;</li>
<li>提交计算结果，注意题号要一致。</li>
<li>计算结果如果有小数的话，保留两位小数，第三位小数四舍五入，如果有特殊说明例外。<br>如果不足两位小数请补0，例如如果计算是4.1，则提交的是4.10。</li>
</ol>
<h3 id="内容："><a href="#内容：" class="headerlink" title="内容："></a>内容：</h3><p>假设系统S投入测试或运行，工作一段时间t1后，软件出现错误，系统被停止并进行修复，经过T1时间后，故障被排除；又投入测试或运行，工作一段时间t2后，软件出现错误，系统被停止并进行修复，经过T2时间后，故障被排除。如此进行下去。<br>假设t1，t2，…，tn是系统正常的工作时间，T1，T2，…，Tn是维护时间，其数据分别如下：</p>
<table>
<thead>
<tr>
<th align="center">运行时间</th>
<th align="center">t1</th>
<th align="center">t2</th>
<th align="center">t3</th>
<th align="center">t4</th>
<th align="center">t5</th>
<th align="center">t6</th>
<th align="center">t7</th>
</tr>
</thead>
<tbody><tr>
<td align="center">小时</td>
<td align="center">12</td>
<td align="center">20</td>
<td align="center">40</td>
<td align="center">70</td>
<td align="center">110</td>
<td align="center">60</td>
<td align="center">120</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">维护时间</th>
<th align="center">t1</th>
<th align="center">t2</th>
<th align="center">t3</th>
<th align="center">t4</th>
<th align="center">t5</th>
<th align="center">t6</th>
<th align="center">t7</th>
</tr>
</thead>
<tbody><tr>
<td align="center">小时</td>
<td align="center">12</td>
<td align="center">8</td>
<td align="center">5</td>
<td align="center">5</td>
<td align="center">2</td>
<td align="center">9</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p>请计算“有效度A”。</p>
<h3 id="答案-11"><a href="#答案-11" class="headerlink" title="答案"></a>答案</h3><p>0.91</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>MTBF = (12 + 20 + 40 + 70 + 110 + 60 + 120) / 7<br>MTTR = (12 + 8 + 5 + 5 + 2 + 9 + 1) / 7<br>$$<br>A = \frac{MTBF}{MTBF + MTTR} = \frac{432}{474}<br>$$</p>
<h2 id="第13题-计算题-软件可靠性基本参数”故障率”计算-10分"><a href="#第13题-计算题-软件可靠性基本参数”故障率”计算-10分" class="headerlink" title="第13题 计算题.软件可靠性基本参数”故障率”计算(10分)"></a>第13题 计算题.软件可靠性基本参数”故障率”计算(10分)</h2><h3 id="此题的步骤和要求-1"><a href="#此题的步骤和要求-1" class="headerlink" title="此题的步骤和要求:"></a>此题的步骤和要求:</h3><ol>
<li>按题目要求做计算。;</li>
<li>提交计算结果，注意题号要一致。</li>
<li>计算结果如果有小数的话，保留四位小数，第五位小数四舍五入，如果有特殊说明例外。<br>如果不足四位小数请补0，例如如果计算是4.145，则提交的是4.1450。</li>
</ol>
<h3 id="内容：-1"><a href="#内容：-1" class="headerlink" title="内容："></a>内容：</h3><p>假设系统S投入测试或运行，工作一段时间t1后，软件出现错误，系统被停止并进行修复，经过T1时间后，故障被排除；又投入测试或运行，工作一段时间t2后，软件出现错误，系统被停止并进行修复，经过T2时间后，故障被排除。如此进行下去。<br>假设t1，t2，…，tn是系统正常的工作时间，T1，T2，…，Tn是维护时间，其数据分别如下：</p>
<table>
<thead>
<tr>
<th align="center">运行时间</th>
<th align="center">t1</th>
<th align="center">t2</th>
<th align="center">t3</th>
<th align="center">t4</th>
<th align="center">t5</th>
<th align="center">t6</th>
<th align="center">t7</th>
</tr>
</thead>
<tbody><tr>
<td align="center">小时</td>
<td align="center">12</td>
<td align="center">20</td>
<td align="center">40</td>
<td align="center">70</td>
<td align="center">110</td>
<td align="center">60</td>
<td align="center">120</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">维护时间</th>
<th align="center">t1</th>
<th align="center">t2</th>
<th align="center">t3</th>
<th align="center">t4</th>
<th align="center">t5</th>
<th align="center">t6</th>
<th align="center">t7</th>
</tr>
</thead>
<tbody><tr>
<td align="center">小时</td>
<td align="center">12</td>
<td align="center">8</td>
<td align="center">5</td>
<td align="center">5</td>
<td align="center">2</td>
<td align="center">9</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p>请计算“故障率（风险函数）”。<br>请保留四位小数，第五位小数四舍五入<br>注意：<strong>故障率（风险函数）结果不需要使用单位FIT</strong>。</p>
<h3 id="答案-12"><a href="#答案-12" class="headerlink" title="答案"></a>答案</h3><p>0.0162</p>
<h3 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h3><p>$$<br>故障率 = \frac{总失效次数}{总工作时间} = \frac{n}{\sum_{i=1}^{n}t_i} = \frac{7}{(12 + 20 + 40 + 70 + 110 + 60 + 120)} = \frac{7}{432}<br>$$</p>
<h2 id="第14题-计算题-软件可靠性”按使用剖面测试小时”计算-10分"><a href="#第14题-计算题-软件可靠性”按使用剖面测试小时”计算-10分" class="headerlink" title="第14题 计算题.软件可靠性”按使用剖面测试小时”计算(10分)"></a>第14题 计算题.软件可靠性”按使用剖面测试小时”计算(10分)</h2><h3 id="此题的步骤和要求-2"><a href="#此题的步骤和要求-2" class="headerlink" title="此题的步骤和要求:"></a>此题的步骤和要求:</h3><ol>
<li>按题目要求做计算。;</li>
<li>提交计算结果，注意题号要一致。</li>
<li>计算结果如果有小数的话，保留两位小数，第三位小数四舍五入，如果有特殊说明例外.</li>
</ol>
<p>如果不足两位小数请补0，例如如果计算是4.1，则提交的是4.10。</p>
<h3 id="内容：-2"><a href="#内容：-2" class="headerlink" title="内容："></a>内容：</h3><p>假设某软件有7个模块，实际使用时每个模块被执行的概率分别为p1，p2，…，p7，</p>
<p>其数据如下:</p>
<table>
<thead>
<tr>
<th align="center">模块概率</th>
<th align="center">p1</th>
<th align="center">p2</th>
<th align="center">p3</th>
<th align="center">p4</th>
<th align="center">p5</th>
<th align="center">p6</th>
<th align="center">p7</th>
</tr>
</thead>
<tbody><tr>
<td align="center">概率取值</td>
<td align="center">0.12</td>
<td align="center">0.2</td>
<td align="center">0.17</td>
<td align="center">0.02</td>
<td align="center">0.3</td>
<td align="center">0.1</td>
<td align="center">0.09</td>
</tr>
</tbody></table>
<p>请问均匀分布测试M=100小时，相当于按使用剖面测试了多少小时?</p>
<h3 id="答案-不知道为啥错"><a href="#答案-不知道为啥错" class="headerlink" title="答案(不知道为啥错)"></a>答案(不知道为啥错)</h3><p>75.86</p>
<h3 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h3><p>$$<br>100 \times \sum_{ i=1 }^{ 7 } min{ { p_i,\frac{1}{7} }}<br>=100 \times (0.12 + 1/7 + 1 /7 + 0.02 + 1/7+0.1+0.09)<br>= 100 \times (3 / 7 + 0.33)<br>$$</p>
<h2 id="第15题-计算题-软件可靠性”被执行概率已知时使用剖面测试时间”计算-10分"><a href="#第15题-计算题-软件可靠性”被执行概率已知时使用剖面测试时间”计算-10分" class="headerlink" title="第15题 计算题.软件可靠性”被执行概率已知时使用剖面测试时间”计算(10分)"></a>第15题 计算题.软件可靠性”被执行概率已知时使用剖面测试时间”计算(10分)</h2><h3 id="此题的步骤和要求-3"><a href="#此题的步骤和要求-3" class="headerlink" title="此题的步骤和要求:"></a>此题的步骤和要求:</h3><ol>
<li>按题目要求做计算。;</li>
<li>提交计算结果，注意题号要一致。</li>
<li>计算结果如果有小数的话，保留两位小数，第三位小数四舍五入，如果有特殊说明例外。</li>
</ol>
<p>如果不足两位小数请补0，例如如果计算是4.1，则提交的是4.10。</p>
<h3 id="内容：-3"><a href="#内容：-3" class="headerlink" title="内容："></a>内容：</h3><p>某系统有6个模块，在均匀分布假设下，每个模块被执行的概率为1/6。假设系统总共的测试时间为120H，则每个模块的测试时间为20H。根据对用户使用剖面的分析，6个模块被执行的概率分别近似为：0.14, 0.23, 0.26, 0.20, 0.07, 0.1。对同样的120H，6个模块实际的执行时间分别为16.8, 27.6, 31.2, 24.0, 8.4, 12.0。请计算相当于按使用剖面的测试时间是多少小时？</p>
<h3 id="答案："><a href="#答案：" class="headerlink" title="答案："></a>答案：</h3><p>97.20</p>
<h3 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h3><p>时间：min{120 * 0.14,20} + min{120 * 0.23 , 20} + min{120 * 0.26,20} + min{120 * 0.20,20} + min{120 * 0.07 ,20} + {120 * 0.1,20}<br>= 16.8 + 20 + 20 + 20 + 8.4 + 12.0<br>97.20</p>
<h2 id="第16题-判断题-8分"><a href="#第16题-判断题-8分" class="headerlink" title="第16题  判断题(8分)"></a>第16题  判断题(8分)</h2><ol>
<li>白盒测试不仅与程序内部结构有关，还要考虑程序的功能要求。（   ）</li>
<li>白盒测试的“原子谓词覆盖”标准强于“路径覆盖”。（   ）</li>
<li>白盒测试仅与程序的内部结构有关，完全可以不考虑程序的功能要求。（   ）</li>
<li>白盒测试是从用户观点出发的测试。（   ）</li>
<li>测试按照测试层次可以划分成为单元测试、集成测试和系统测试。（   ）</li>
<li>测试是调试的一个部分。（   ）</li>
<li>测试是可以穷尽的。（   ）</li>
<li>测试是提高产品质量根本手段。（   ）</li>
</ol>
<h3 id="答案-13"><a href="#答案-13" class="headerlink" title="答案"></a>答案</h3><ol>
<li>√</li>
<li>×</li>
<li>√</li>
<li>×</li>
<li>√</li>
<li>×</li>
<li>×</li>
<li>×</li>
</ol>
<h2 id="第17题-工具软件的掌握-selenium工具的环境配置-5分"><a href="#第17题-工具软件的掌握-selenium工具的环境配置-5分" class="headerlink" title="第17题 工具软件的掌握. selenium工具的环境配置(5分)"></a>第17题 工具软件的掌握. selenium工具的环境配置(5分)</h2><h3 id="此题的上机环境是-2"><a href="#此题的上机环境是-2" class="headerlink" title="此题的上机环境是:"></a>此题的上机环境是:</h3><ol>
<li>Chrome浏览器安装目录为C:\Program Files\Chrome\Application\chrome.exe<br>如果安装目录不是该文件夹，请复制安装目录下的子文件夹“Chrome”到“C:\Program Files\”。</li>
<li>驱动程序chromedriver.exe放到C:\WebDriver中</li>
</ol>
<h3 id="此题的步骤和要求是"><a href="#此题的步骤和要求是" class="headerlink" title="此题的步骤和要求是:"></a>此题的步骤和要求是:</h3><ol>
<li>建立一个Java项目,名称务必按题号取名。这一点非常重要；</li>
<li>建立一个测试类, 类的名称为TestMain。这一点非常重要；</li>
<li>按下面TestMain.java代码的要求编写测试代码；</li>
<li>按要求进行配置，保证内容正确。</li>
<li>截图（包含了右下角时间），截图存储为jpg文件。<br>截图内容:要能够看到工程名称、TestMain.java代码和右下角时间。</li>
<li>文件名称要求: 学号-姓名.jpg<br>例如学号为 201055152702,姓名为张三富的同学,文件名称为:<br>201055152702-张三富.jpg<br>请务必提交jpg文件或者JPG文件!<br>文件大小限定1Mb。</li>
</ol>
<p>关于”截图”方法,可以按键盘上的屏幕截图按钮”PrtSc”键,然后打开”附件”中的”画图”应用程序,粘贴,再存储为jpg格式文件.</p>
<p>文件TestMain.java做Web功能测试的要求如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试乐居网的搜索功能</span></span><br><span class="line"><span class="comment"> * 乐居网: http://www.leju12.com/</span></span><br><span class="line"><span class="comment"> * 1. 打开安居客网页版</span></span><br><span class="line"><span class="comment"> * 2. 搜索框输入“蜂蜜”</span></span><br><span class="line"><span class="comment"> * 3. 点击“搜索”按钮    </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>


<h3 id="答案-乐居网-http-www-leju12-com-在维护"><a href="#答案-乐居网-http-www-leju12-com-在维护" class="headerlink" title="答案(乐居网: http://www.leju12.com/在维护)"></a>答案(乐居网: <a href="http://www.leju12.com/%E5%9C%A8%E7%BB%B4%E6%8A%A4">http://www.leju12.com/在维护</a>)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.openqa.selenium.WebElement;</span><br><span class="line"><span class="keyword">import</span> org.openqa.selenium.chrome.ChromeDriver;</span><br><span class="line"><span class="keyword">import</span> org.openqa.selenium.chrome.ChromeOptions;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.setProperty(<span class="string">&quot;webdriver.chrome.driver&quot;</span>, <span class="string">&quot;C:\\WebDriver\\chromedriver.exe&quot;</span>);</span><br><span class="line"><span class="comment">//      System.setProperty(&quot;webdriver.chrome.driver&quot;, &quot;D:\\学习\\课程学习\\软件测试\\考试题/chromedriver.exe&quot;);</span></span><br><span class="line">        ChromeOptions options = <span class="keyword">new</span> ChromeOptions();</span><br><span class="line">        <span class="comment">// options.setBinary(&quot;C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe&quot;);</span></span><br><span class="line">        options.setBinary(<span class="string">&quot;C:\\Program Files\\Chrome\\Application\\chrome.exe&quot;</span>);</span><br><span class="line">        ChromeDriver driver = <span class="keyword">new</span> ChromeDriver(options);</span><br><span class="line">        <span class="comment">// 隐式等待时间</span></span><br><span class="line">        driver.manage().timeouts().implicitlyWait(<span class="number">5</span>, TimeUnit.SECONDS); <span class="comment">// 每次操作时长</span></span><br><span class="line">        driver.get(<span class="string">&quot;http://www.baidu.com/&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        WebElement text = driver.findElementByXPath(<span class="string">&quot;/html/body/div[1]/div[1]/div[5]/div[1]/div/form/span[1]/input&quot;</span>)</span><br><span class="line">;</span><br><span class="line">        text.sendKeys(<span class="string">&quot;蜜蜂&quot;</span>);</span><br><span class="line">        WebElement button = driver.findElementByXPath(<span class="string">&quot;/html/body/div[1]/div[1]/div[5]/div[2]/div/form/span[2]/input&quot;</span>);</span><br><span class="line">        button.click();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第18题-测试代码编写-一元二次方程类语句覆盖-10分"><a href="#第18题-测试代码编写-一元二次方程类语句覆盖-10分" class="headerlink" title="第18题 测试代码编写.一元二次方程类语句覆盖(10分)"></a>第18题 测试代码编写.一元二次方程类语句覆盖(10分)</h2><h3 id="此题的上机环境和要求-4"><a href="#此题的上机环境和要求-4" class="headerlink" title="此题的上机环境和要求:"></a>此题的上机环境和要求:</h3><ol>
<li>Junit4 或者以上。</li>
<li>使用Junit4脚本。</li>
<li>测试类只有一个，名称为TestMain，这一点非常重要。</li>
<li>测试代码不能有输出语句（System…等)，否则以0分计。</li>
<li>如果测试代码不能编译成功则以0分计。</li>
</ol>
<h3 id="此题的上机步骤是-10"><a href="#此题的上机步骤是-10" class="headerlink" title="此题的上机步骤是:"></a>此题的上机步骤是:</h3><ol>
<li>建立一个Java项目，名称可以按题号取名。</li>
<li>建立被测试类和一个测试类(名称为TestMain)。</li>
<li>编写测试代码。</li>
<li>提交测试代码，注意题号要一致。</li>
</ol>
<p>本题被测试类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalcRootClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> x1, x2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">CalcFun</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">double</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> mid = <span class="number">0</span>;</span><br><span class="line">        String st = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="number">0</span>) &#123;</span><br><span class="line">            mid = b * b - <span class="number">4</span> * a * c;</span><br><span class="line">            <span class="keyword">if</span> (mid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                x1 = (-b + Math.sqrt(mid)) / (<span class="number">2</span> * a);</span><br><span class="line">                x2 = (-b - Math.sqrt(mid)) / (<span class="number">2</span> * a);</span><br><span class="line">                st += (<span class="string">&quot;二个实根\n&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (mid == <span class="number">0</span>) &#123;</span><br><span class="line">                    x1 = -b / (<span class="number">2</span> * a);</span><br><span class="line">                    x2=x1;</span><br><span class="line">                    st += (<span class="string">&quot;一个二重实根\n&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    x1 = -b / (<span class="number">2</span> * a);</span><br><span class="line">                    x2 = Math.sqrt(-mid) / (<span class="number">2</span> * a);</span><br><span class="line">                    st += (<span class="string">&quot;二个复根,实部和虚部分别为\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            st = st + <span class="string">&quot;x1=&quot;</span> + x1 + <span class="string">&quot;,x2=&quot;</span> + x2 + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="答案-14"><a href="#答案-14" class="headerlink" title="答案"></a>答案</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.assertEquals;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</span><br><span class="line">    CalcRootClass crc;</span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        crc = <span class="keyword">new</span> CalcRootClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertEquals(<span class="string">&quot;&quot;</span>,crc.CalcFun(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">        assertEquals(<span class="string">&quot;二个实根\nx1=3.0,x2=1.0\n&quot;</span>,crc.CalcFun(<span class="number">1</span>,-<span class="number">4</span>,<span class="number">3</span>));</span><br><span class="line">        assertEquals(<span class="string">&quot;一个二重实根\nx1=-1.0,x2=-1.0\n&quot;</span>,crc.CalcFun(<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>));</span><br><span class="line">        assertEquals(<span class="string">&quot;二个复根,实部和虚部分别为\nx1=-0.4,x2=0.2\n&quot;</span>,crc.CalcFun(<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.assertEquals;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</span><br><span class="line">    CalcRootClass crc;</span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        crc = <span class="keyword">new</span> CalcRootClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertEquals(<span class="string">&quot;&quot;</span>,crc.CalcFun(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertEquals(<span class="string">&quot;二个实根\nx1=3.0,x2=1.0\n&quot;</span>,crc.CalcFun(<span class="number">1</span>,-<span class="number">4</span>,<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertEquals(<span class="string">&quot;一个二重实根\nx1=-1.0,x2=-1.0\n&quot;</span>,crc.CalcFun(<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertEquals(<span class="string">&quot;二个复根,实部和虚部分别为\nx1=-0.4,x2=0.2\n&quot;</span>,crc.CalcFun(<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="第19题-测试代码编写-一元二次方程分支覆盖-10分"><a href="#第19题-测试代码编写-一元二次方程分支覆盖-10分" class="headerlink" title="第19题 测试代码编写.一元二次方程分支覆盖(10分)"></a>第19题 测试代码编写.一元二次方程分支覆盖(10分)</h2><h3 id="此题的上机环境和要求-5"><a href="#此题的上机环境和要求-5" class="headerlink" title="此题的上机环境和要求:"></a>此题的上机环境和要求:</h3><ol>
<li>Junit4 或者以上。</li>
<li>使用Junit4脚本。</li>
<li>测试类只有一个，名称为TestMain，这一点非常重要。</li>
<li>测试代码不能有输出语句（System…等)，否则以0分计。</li>
<li>如果测试代码不能编译成功则以0分计。</li>
</ol>
<h3 id="此题的上机步骤是-11"><a href="#此题的上机步骤是-11" class="headerlink" title="此题的上机步骤是:"></a>此题的上机步骤是:</h3><ol>
<li>建立一个Java项目，名称可以按题号取名。</li>
<li>建立被测试类和一个测试类(名称为TestMain)。</li>
<li>编写测试代码。</li>
<li>提交测试代码，注意题号要一致。</li>
</ol>
<p>本题被测试类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalcRootClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> x1, x2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">CalcFun</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">double</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> mid = <span class="number">0</span>;</span><br><span class="line">        String st = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="number">0</span>) &#123;</span><br><span class="line">            mid = b * b - <span class="number">4</span> * a * c;</span><br><span class="line">            <span class="keyword">if</span> (mid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                x1 = (-b + Math.sqrt(mid)) / (<span class="number">2</span> * a);</span><br><span class="line">                x2 = (-b - Math.sqrt(mid)) / (<span class="number">2</span> * a);</span><br><span class="line">                st += (<span class="string">&quot;二个实根\n&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (mid == <span class="number">0</span>) &#123;</span><br><span class="line">                    x1 = -b / (<span class="number">2</span> * a);</span><br><span class="line">                    x2=x1;</span><br><span class="line">                    st += (<span class="string">&quot;一个二重实根\n&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    x1 = -b / (<span class="number">2</span> * a);</span><br><span class="line">                    x2 = Math.sqrt(-mid) / (<span class="number">2</span> * a);</span><br><span class="line">                    st += (<span class="string">&quot;二个复根,实部和虚部分别为\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            st = st + <span class="string">&quot;x1=&quot;</span> + x1 + <span class="string">&quot;,x2=&quot;</span> + x2 + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="答案-15"><a href="#答案-15" class="headerlink" title="答案"></a>答案</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.assertEquals;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</span><br><span class="line">    CalcRootClass crc;</span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        crc = <span class="keyword">new</span> CalcRootClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertEquals(<span class="string">&quot;&quot;</span>,crc.CalcFun(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertEquals(<span class="string">&quot;二个实根\nx1=3.0,x2=1.0\n&quot;</span>,crc.CalcFun(<span class="number">1</span>,-<span class="number">4</span>,<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertEquals(<span class="string">&quot;一个二重实根\nx1=-1.0,x2=-1.0\n&quot;</span>,crc.CalcFun(<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertEquals(<span class="string">&quot;二个复根,实部和虚部分别为\nx1=-0.4,x2=0.2\n&quot;</span>,crc.CalcFun(<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="附加作业-1-购物车WEB测试"><a href="#附加作业-1-购物车WEB测试" class="headerlink" title="附加作业(1)-购物车WEB测试"></a>附加作业(1)-购物车WEB测试</h2><p>测试类名称是TestMain。</p>
<p>测试网站：</p>
<p><a href="https://sahitest.com/demo/training/login.htm">https://sahitest.com/demo/training/login.htm</a></p>
<ol>
<li>用下列用户登录</li>
</ol>
<p>用户名：test</p>
<p>密码：secret</p>
<ol start="2">
<li><p>单击 “login”按钮，出现”All available books”表单界面</p>
</li>
<li><p>请对界面的每个控件都进行一次测试。</p>
</li>
</ol>
<h3 id="答案-16"><a href="#答案-16" class="headerlink" title="答案"></a>答案</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.openqa.selenium.WebElement;</span><br><span class="line"><span class="keyword">import</span> org.openqa.selenium.chrome.ChromeDriver;</span><br><span class="line"><span class="keyword">import</span> org.openqa.selenium.chrome.ChromeOptions;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.setProperty(<span class="string">&quot;webdriver.chrome.driver&quot;</span>, <span class="string">&quot;D:\\学习\\课程学习\\软件测试\\考试题\\chromedriver.exe&quot;</span>);</span><br><span class="line">        ChromeOptions options = <span class="keyword">new</span> ChromeOptions();</span><br><span class="line">        options.setBinary(<span class="string">&quot;C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe&quot;</span>);</span><br><span class="line">        ChromeDriver driver = <span class="keyword">new</span> ChromeDriver(options);</span><br><span class="line">        driver.manage().timeouts().implicitlyWait(<span class="number">5</span>,TimeUnit.SECONDS);</span><br><span class="line">        driver.get(<span class="string">&quot;https://sahitest.com/demo/training/login.htm&quot;</span>);</span><br><span class="line">        CharSequence username[] = &#123;<span class="string">&quot;test&quot;</span>&#125;;</span><br><span class="line">        CharSequence password[] = &#123;<span class="string">&quot;secret&quot;</span>&#125;;</span><br><span class="line">        CharSequence coreJava1[] = &#123;<span class="string">&quot;9&quot;</span>&#125;;</span><br><span class="line">        CharSequence ruby1[] = &#123;<span class="string">&quot;999&quot;</span>&#125;;</span><br><span class="line">        CharSequence python1[] = &#123;<span class="string">&quot;99&quot;</span>&#125;;</span><br><span class="line">        CharSequence total1[] = &#123;<span class="string">&quot;123456789&quot;</span>&#125;;</span><br><span class="line">        WebElement user = driver.findElementByXPath(<span class="string">&quot;/html/body/center/div/form/table/tbody/tr[1]/td[2]/input&quot;</span>);</span><br><span class="line">        user.sendKeys(username);</span><br><span class="line">        WebElement pwd = driver.findElementByXPath(<span class="string">&quot;/html/body/center/div/form/table/tbody/tr[2]/td[2]/input&quot;</span>);</span><br><span class="line">        pwd.sendKeys(password);</span><br><span class="line">        WebElement login = driver.findElementByCssSelector(<span class="string">&quot;.test .button&quot;</span>);</span><br><span class="line">        login.click();</span><br><span class="line">        WebElement coreJava = driver.findElementByXPath(<span class="string">&quot;/html/body/center/form/div/table/tbody/tr[2]/td[4]/input&quot;</span>);</span><br><span class="line">        coreJava.sendKeys(coreJava1);</span><br><span class="line">        WebElement ruby = driver.findElementByXPath(<span class="string">&quot;/html/body/center/form/div/table/tbody/tr[2]/td[4]/input&quot;</span>);</span><br><span class="line">        ruby.sendKeys(ruby1);</span><br><span class="line">        WebElement python = driver.findElementByXPath(<span class="string">&quot;//*[@id=\&quot;listing\&quot;]/tbody/tr[3]/td[4]/input&quot;</span>);</span><br><span class="line">        python.sendKeys(python1);</span><br><span class="line">        WebElement addBtn = driver.findElementByXPath(<span class="string">&quot;//*[@id=\&quot;listing\&quot;]/tbody/tr[4]/td[4]/input&quot;</span>);</span><br><span class="line">        addBtn.click();</span><br><span class="line">        WebElement total = driver.findElementByXPath(<span class="string">&quot;//*[@id=\&quot;total\&quot;]&quot;</span>);</span><br><span class="line">        total.sendKeys(total1);</span><br><span class="line">        WebElement clearBtn = driver.findElementByXPath(<span class="string">&quot;/html/body/center/form/div/input[2]&quot;</span>);</span><br><span class="line">        clearBtn.sendKeys(total1);</span><br><span class="line">        WebElement logout = driver.findElementByXPath(<span class="string">&quot;/html/body/center/form/div/input[3]&quot;</span>);</span><br><span class="line">        logout.click();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="附加作业-2-用户注册WEB测试"><a href="#附加作业-2-用户注册WEB测试" class="headerlink" title="附加作业(2)-用户注册WEB测试"></a>附加作业(2)-用户注册WEB测试</h2><p>测试类名称是TestMain。</p>
<p>测试网站：</p>
<p><a href="https://sahitest.com/demo/training/register.htm">https://sahitest.com/demo/training/register.htm</a></p>
<ol>
<li><p>进入用户注册。</p>
</li>
<li><p>请对此用户注册界面的每个控件都进行一次测试，包括“提示”信息的测试。</p>
</li>
</ol>
<h3 id="答案-17"><a href="#答案-17" class="headerlink" title="答案"></a>答案</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.openqa.selenium.Alert;</span><br><span class="line"><span class="keyword">import</span> org.openqa.selenium.WebElement;</span><br><span class="line"><span class="keyword">import</span> org.openqa.selenium.chrome.ChromeDriver;</span><br><span class="line"><span class="keyword">import</span> org.openqa.selenium.chrome.ChromeOptions;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.setProperty(<span class="string">&quot;webdriver.chrome.driver&quot;</span>, <span class="string">&quot;D:\\学习\\课程学习\\软件测试\\考试题\\chromedriver.exe&quot;</span>);</span><br><span class="line">        ChromeOptions options = <span class="keyword">new</span> ChromeOptions();</span><br><span class="line">        options.setBinary(<span class="string">&quot;C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe&quot;</span>);</span><br><span class="line">        ChromeDriver driver = <span class="keyword">new</span> ChromeDriver(options);</span><br><span class="line">        driver.manage().timeouts().implicitlyWait(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">        driver.get(<span class="string">&quot;https://sahitest.com/demo/training/register.htm&quot;</span>);</span><br><span class="line">        CharSequence username[] = &#123;<span class="string">&quot;xyq&quot;</span>&#125;;</span><br><span class="line">        CharSequence password[] = &#123;<span class="string">&quot;666&quot;</span>&#125;;</span><br><span class="line">        CharSequence repeatPassword[] = &#123;<span class="string">&quot;666&quot;</span>&#125;;</span><br><span class="line">        CharSequence address[] = &#123;<span class="string">&quot;湘潭大学&quot;</span>&#125;;</span><br><span class="line">        CharSequence billingAddress[] = &#123;<span class="string">&quot;湘潭大学&quot;</span>&#125;;</span><br><span class="line">        WebElement username1 = driver.findElementByXPath(<span class="string">&quot;/html/body/center/div/form/div/table/tbody/tr[1]/td[2]/input&quot;</span>);</span><br><span class="line">        username1.sendKeys(username);</span><br><span class="line">        WebElement password1 = driver.findElementByXPath(<span class="string">&quot;/html/body/center/div/form/div/table/tbody/tr[2]/td[2]/input&quot;</span>);</span><br><span class="line">        password1.sendKeys(password);</span><br><span class="line">        WebElement repeatPassword1 = driver.findElementByXPath(<span class="string">&quot;/html/body/center/div/form/div/table/tbody/tr[3]/td[2]/input&quot;</span>);</span><br><span class="line">        repeatPassword1.sendKeys(repeatPassword);</span><br><span class="line">        WebElement gender1 = driver.findElementByXPath(<span class="string">&quot;/html/body/center/div/form/div/table/tbody/tr[4]/td[2]/input[1]&quot;</span>);</span><br><span class="line">        gender1.click();</span><br><span class="line">        WebElement address1 = driver.findElementByXPath(<span class="string">&quot;/html/body/center/div/form/div/table/tbody/tr[5]/td[2]/textarea&quot;</span>);</span><br><span class="line">        address1.sendKeys(address);</span><br><span class="line">        WebElement billingAddress1 = driver.findElementByXPath(<span class="string">&quot;/html/body/center/div/form/div/table/tbody/tr[6]/td[2]/textarea&quot;</span>);</span><br><span class="line">        billingAddress1.sendKeys(billingAddress);</span><br><span class="line">        WebElement select = driver.findElementByXPath(<span class="string">&quot;/html/body/center/div/form/div/table/tbody/tr[7]/td[2]/select/option[2]&quot;</span>);</span><br><span class="line">        select.click();</span><br><span class="line">        WebElement agree = driver.findElementByXPath(<span class="string">&quot;/html/body/center/div/form/input[1]&quot;</span>);</span><br><span class="line">        agree.click();</span><br><span class="line">        WebElement register = driver.findElementByXPath(<span class="string">&quot;/html/body/center/div/form/input[2]&quot;</span>);</span><br><span class="line">        register.click();</span><br><span class="line">        Alert alert =driver.switchTo().alert();</span><br><span class="line">        alert.accept();</span><br><span class="line">        WebElement cancel = driver.findElementByXPath(<span class="string">&quot;/html/body/center/div/form/input[3]&quot;</span>);</span><br><span class="line">        cancel.click();</span><br><span class="line">        alert.dismiss();</span><br><span class="line">        cancel.click();</span><br><span class="line">        alert.accept();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="学习通练习"><a href="#学习通练习" class="headerlink" title="学习通练习"></a>学习通练习</h2><h3 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h3><h4 id="1-单选题-软件生命周期由若干个阶段组成，下列（-）阶段，如果发生软件缺陷，则修复费用是最低的。"><a href="#1-单选题-软件生命周期由若干个阶段组成，下列（-）阶段，如果发生软件缺陷，则修复费用是最低的。" class="headerlink" title="1. (单选题)软件生命周期由若干个阶段组成，下列（   ）阶段，如果发生软件缺陷，则修复费用是最低的。"></a>1. (单选题)软件生命周期由若干个阶段组成，下列（   ）阶段，如果发生软件缺陷，则修复费用是最低的。</h4><p>A. 编码<br>B. 需求分析（编制产品说明书）<br>C. 设计<br>D. 产品发布</p>
<p>正确答案：B</p>
<h4 id="2-单选题-软件测试是采用（-）执行软件的活动。"><a href="#2-单选题-软件测试是采用（-）执行软件的活动。" class="headerlink" title="2. (单选题)软件测试是采用（    ）执行软件的活动。"></a>2. (单选题)软件测试是采用（    ）执行软件的活动。</h4><p>A. 输入数据<br>B. 测试用例<br>C. 测试环境<br>D. 输入条件</p>
<p>正确答案: B</p>
<h4 id="3-单选题-下面说法正确的是（-）。"><a href="#3-单选题-下面说法正确的是（-）。" class="headerlink" title="3. (单选题)下面说法正确的是（   ）。"></a>3. (单选题)下面说法正确的是（   ）。</h4><p>A. 成功的测试是发现了迄今尚未发现的错误的测试<br>B. 经过测试没有发现错误说明程序正确<br>C. 测试的目标是为了证明程序没有错误<br>D. 成功的测试是没有发现错误的测试</p>
<p>正确答案: A</p>
<h4 id="4-单选题-下列可以作为软件测试对象的是（-）。"><a href="#4-单选题-下列可以作为软件测试对象的是（-）。" class="headerlink" title="4. (单选题)下列可以作为软件测试对象的是（   ）。"></a>4. (单选题)下列可以作为软件测试对象的是（   ）。</h4><p>A. 源程序<br>B. 软件设计规格说明<br>C. 需求规格说明书<br>D. 以上全部</p>
<p>正确答案: D</p>
<ol start="5">
<li>(单选题)以下那一种选项不属于软件缺陷（ ）.</li>
</ol>
<p>A. 软件实现了产品规格没有提到的功能<br>B. 软件实现了产品规格说明所要求的功能但因受性能限制而未考虑可移植性问题<br>C. 软件中出现了产品规格说明不应该出现的功能<br>D. 软件没有实现产品规格说明所要求的功能</p>
<p>正确答案: B</p>
<h4 id="6-单选题-在边界值分析中，下列数据通常不用来做数据测试的是（-）"><a href="#6-单选题-在边界值分析中，下列数据通常不用来做数据测试的是（-）" class="headerlink" title="6. (单选题)在边界值分析中，下列数据通常不用来做数据测试的是（   ）"></a>6. (单选题)在边界值分析中，下列数据通常不用来做数据测试的是（   ）</h4><p>A. 等价类中的等价值<br>B. 正好等于边界的值<br>C. 刚刚大于边界的值<br>D. 刚刚小于边界的值</p>
<p>正确答案: A</p>
<h4 id="7-单选题-测试ATM取款功能，已知取款数只能输入正整数，每次取款数要求是100的倍数且不能大于500，下面（-）是正确的无效等价类"><a href="#7-单选题-测试ATM取款功能，已知取款数只能输入正整数，每次取款数要求是100的倍数且不能大于500，下面（-）是正确的无效等价类" class="headerlink" title="7. (单选题)测试ATM取款功能，已知取款数只能输入正整数，每次取款数要求是100的倍数且不能大于500，下面（  ）是正确的无效等价类"></a>7. (单选题)测试ATM取款功能，已知取款数只能输入正整数，每次取款数要求是100的倍数且不能大于500，下面（  ）是正确的无效等价类</h4><p>A. （0，100）、（100，200）、（200，300）、（300，400）、（400，500）、（500，+∞）<br>B. （500，+∞）<br>C. （-∞，100）、（100，200）、（200，300）、（300，400）、（400，500）、（500，+∞）<br>D. （500，+∞）、任意大于0小于500的非100倍数的整数</p>
<p>正确答案: D</p>
<h4 id="8-单选题-在某大学学籍管理信息系统中，假设学生年龄的输入范围为-16—40，则根据黑盒测试中的等价类划分技术，下面划分正确的是（-）。"><a href="#8-单选题-在某大学学籍管理信息系统中，假设学生年龄的输入范围为-16—40，则根据黑盒测试中的等价类划分技术，下面划分正确的是（-）。" class="headerlink" title="8. (单选题)在某大学学籍管理信息系统中，假设学生年龄的输入范围为 16—40，则根据黑盒测试中的等价类划分技术，下面划分正确的是（  ）。"></a>8. (单选题)在某大学学籍管理信息系统中，假设学生年龄的输入范围为 16—40，则根据黑盒测试中的等价类划分技术，下面划分正确的是（  ）。</h4><p>A. 可划分为1个有效等价类，2个无效等价类<br>B. 可划分为 2 个有效等价类，2 个无效等价类<br>C. 可划分为 2 个有效等价类，1 个无效等价类<br>D. 可划分为 1 个有效等价类，1 个无效等价类</p>
<p>正确答案: A</p>
<h4 id="9-单选题-单元测试中用来模拟被测模块调用者的模块称之为（-）"><a href="#9-单选题-单元测试中用来模拟被测模块调用者的模块称之为（-）" class="headerlink" title="9. (单选题)单元测试中用来模拟被测模块调用者的模块称之为（      ）"></a>9. (单选题)单元测试中用来模拟被测模块调用者的模块称之为（      ）</h4><p>A. 驱动模块<br>B. 桩模块<br>C. 父模块<br>D. 子模块</p>
<p>正确答案: A</p>
<h4 id="10-单选题-不属于单元测试内容的是（-）"><a href="#10-单选题-不属于单元测试内容的是（-）" class="headerlink" title="10. (单选题)不属于单元测试内容的是（     ）"></a>10. (单选题)不属于单元测试内容的是（     ）</h4><p>A. 模块接口测试<br>B. 局部数据结构测试<br>C. 独立路径测试<br>D. 用户界面测试</p>
<p>正确答案: D</p>
<h4 id="11-单选题-单元测试中设计测试用例的依据是（-）"><a href="#11-单选题-单元测试中设计测试用例的依据是（-）" class="headerlink" title="11. (单选题)单元测试中设计测试用例的依据是（   ）"></a>11. (单选题)单元测试中设计测试用例的依据是（   ）</h4><p>A. 概要设计规格说明书<br>B. 详细设计规格说明书<br>C. 项目计划说明书<br>D. 用户需求规格说明书</p>
<p>正确答案: B</p>
<h4 id="12-软件测试是软件质量保证的重要手段，下述（-）是软件测试的最基础环节"><a href="#12-软件测试是软件质量保证的重要手段，下述（-）是软件测试的最基础环节" class="headerlink" title="12.  软件测试是软件质量保证的重要手段，下述（     ）是软件测试的最基础环节"></a>12.  软件测试是软件质量保证的重要手段，下述（     ）是软件测试的最基础环节</h4><p>A. 单元测试<br>B. 结构测试<br>C. 功能测试<br>D. 验收测试</p>
<p>正确答案: A</p>
<h4 id="13-单选题-进行全面的单元测试方法是（-）"><a href="#13-单选题-进行全面的单元测试方法是（-）" class="headerlink" title="13. (单选题)进行全面的单元测试方法是（      ）"></a>13. (单选题)进行全面的单元测试方法是（      ）</h4><p>A. 采用黑盒测试，辅之以白盒测试<br>B. 采用白盒测试，辅之以黑盒测试<br>C. 只使用黑盒测试<br>D. 只使用白盒测试</p>
<p>正确答案: B</p>
<h4 id="14-单选题-下列各项中（-）不是一个测试计划所应包含的内容。"><a href="#14-单选题-下列各项中（-）不是一个测试计划所应包含的内容。" class="headerlink" title="14. (单选题)下列各项中（    ）不是一个测试计划所应包含的内容。"></a>14. (单选题)下列各项中（    ）不是一个测试计划所应包含的内容。</h4><p>A. 测试资源、进度安排<br>B. 测试范围<br>C. 测试策略<br>D. 测试预期输出</p>
<p>正确答案: D</p>
<h4 id="15-单选题-软件测试过程中的集成测试主要是为了发现（-）阶段的错误。"><a href="#15-单选题-软件测试过程中的集成测试主要是为了发现（-）阶段的错误。" class="headerlink" title="15. (单选题)软件测试过程中的集成测试主要是为了发现（  ）阶段的错误。"></a>15. (单选题)软件测试过程中的集成测试主要是为了发现（  ）阶段的错误。</h4><p>A. 需求分析<br>B. 概要设计<br>C. 详细设计<br>D. 编码</p>
<p>正确答案: B</p>
<h4 id="16-单选题-集成测试计划应该在（-）阶段末提交。"><a href="#16-单选题-集成测试计划应该在（-）阶段末提交。" class="headerlink" title="16. (单选题)集成测试计划应该在（    ）阶段末提交。"></a>16. (单选题)集成测试计划应该在（    ）阶段末提交。</h4><p>A. 需求分析<br>B. 概要设计<br>C. 详细设计<br>D. 单元测试</p>
<p>正确答案: B</p>
<h4 id="17-单选题-自底向上增量式集成测试中，下面（-）描述是正确的。"><a href="#17-单选题-自底向上增量式集成测试中，下面（-）描述是正确的。" class="headerlink" title="17. (单选题)自底向上增量式集成测试中，下面（    ）描述是正确的。"></a>17. (单选题)自底向上增量式集成测试中，下面（    ）描述是正确的。</h4><p>A. 父单元用测试过的子单元测试<br>B. 测试由桩模块控制<br>C. 最上面的模块最先测试<br>D. 包含树的深度优先或广度优先遍历过程</p>
<p>正确答案: A</p>
<h4 id="18-单选题-方法需要考察模块间的接口和各模块之间的联系。"><a href="#18-单选题-方法需要考察模块间的接口和各模块之间的联系。" class="headerlink" title="18. (单选题)( )方法需要考察模块间的接口和各模块之间的联系。"></a>18. (单选题)( )方法需要考察模块间的接口和各模块之间的联系。</h4><p>A. 确认测试<br>B. 系统测试<br>C. 集成测试<br>D. 单元测试</p>
<p>正确答案: C</p>
<h4 id="19-单选题-集成测试对系统内部的交互以及集成后系统功能检验了（-）质量特性。"><a href="#19-单选题-集成测试对系统内部的交互以及集成后系统功能检验了（-）质量特性。" class="headerlink" title="19.  (单选题)集成测试对系统内部的交互以及集成后系统功能检验了（  ）质量特性。"></a>19.  (单选题)集成测试对系统内部的交互以及集成后系统功能检验了（  ）质量特性。</h4><p>A. 正确性<br>B. 可靠性<br>C. 可用性<br>D. 可维护性</p>
<p>正确答案: A</p>
<h4 id="20-单选题-在自低向上测试中，要编写称为（-）的模块来测验正在测试的模块。"><a href="#20-单选题-在自低向上测试中，要编写称为（-）的模块来测验正在测试的模块。" class="headerlink" title="20. (单选题)在自低向上测试中，要编写称为（   ）的模块来测验正在测试的模块。"></a>20. (单选题)在自低向上测试中，要编写称为（   ）的模块来测验正在测试的模块。</h4><p>A. 测试存根<br>B. 底层模块<br>C. 驱动模块<br>D. 桩模块</p>
<p>正确答案: C</p>
<h4 id="21-单选题-数据流覆盖关注的是程序中某个变量从其声明、赋值到引用的变化情况，它是下列哪一种覆盖的变种（-）。"><a href="#21-单选题-数据流覆盖关注的是程序中某个变量从其声明、赋值到引用的变化情况，它是下列哪一种覆盖的变种（-）。" class="headerlink" title="21. (单选题)数据流覆盖关注的是程序中某个变量从其声明、赋值到引用的变化情况，它是下列哪一种覆盖的变种（  ）。"></a>21. (单选题)数据流覆盖关注的是程序中某个变量从其声明、赋值到引用的变化情况，它是下列哪一种覆盖的变种（  ）。</h4><p>A. 路径覆盖<br>B. 语句覆盖<br>C. 分支覆盖<br>D. 原子谓词覆盖</p>
<p>正确答案: A</p>
<h3 id="判断题"><a href="#判断题" class="headerlink" title="判断题"></a>判断题</h3><h4 id="1-判断题-等价类测试的标准等价类测试不如对应的健壮等价类测试的测试全面。"><a href="#1-判断题-等价类测试的标准等价类测试不如对应的健壮等价类测试的测试全面。" class="headerlink" title="1. (判断题)等价类测试的标准等价类测试不如对应的健壮等价类测试的测试全面。"></a>1. (判断题)等价类测试的标准等价类测试不如对应的健壮等价类测试的测试全面。</h4><p>A. 对<br>B. 错</p>
<p>正确答案: 对</p>
<h4 id="2-判断题-等价类划分方法将所有可能的输入数据划分成若干部分，然后从每一部分中选取少数有代表性的数据作为测试用例。"><a href="#2-判断题-等价类划分方法将所有可能的输入数据划分成若干部分，然后从每一部分中选取少数有代表性的数据作为测试用例。" class="headerlink" title="2. (判断题)等价类划分方法将所有可能的输入数据划分成若干部分，然后从每一部分中选取少数有代表性的数据作为测试用例。"></a>2. (判断题)等价类划分方法将所有可能的输入数据划分成若干部分，然后从每一部分中选取少数有代表性的数据作为测试用例。</h4><p>A. 对<br>B. 错</p>
<p>正确答案: 对</p>
<h4 id="3-判断题-黑盒测试的测试用例是根据应用程序的功能需求设计的。"><a href="#3-判断题-黑盒测试的测试用例是根据应用程序的功能需求设计的。" class="headerlink" title="3. (判断题)黑盒测试的测试用例是根据应用程序的功能需求设计的。"></a>3. (判断题)黑盒测试的测试用例是根据应用程序的功能需求设计的。</h4><p>A. 对<br>B. 错</p>
<p>正确答案: 对</p>
<h4 id="4-判断题-黑盒测试往往会造成测试用例之间可能存在严重的冗余和未测试的功能漏洞。"><a href="#4-判断题-黑盒测试往往会造成测试用例之间可能存在严重的冗余和未测试的功能漏洞。" class="headerlink" title="4. (判断题)黑盒测试往往会造成测试用例之间可能存在严重的冗余和未测试的功能漏洞。"></a>4. (判断题)黑盒测试往往会造成测试用例之间可能存在严重的冗余和未测试的功能漏洞。</h4><p>A. 对<br>B. 错</p>
<p>正确答案: 对</p>
<h4 id="5-判断题-用黑盒法测试时，测试用例是根据程序内部逻辑设计的。"><a href="#5-判断题-用黑盒法测试时，测试用例是根据程序内部逻辑设计的。" class="headerlink" title="5. (判断题)用黑盒法测试时，测试用例是根据程序内部逻辑设计的。"></a>5. (判断题)用黑盒法测试时，测试用例是根据程序内部逻辑设计的。</h4><p>A. 对<br>B. 错</p>
<p>正确答案: 错</p>
<h4 id="6-判断题-有n个变量的函数的边界值分析会产生4n-1个测试用例"><a href="#6-判断题-有n个变量的函数的边界值分析会产生4n-1个测试用例" class="headerlink" title="6. (判断题)有n个变量的函数的边界值分析会产生4n+1个测试用例"></a>6. (判断题)有n个变量的函数的边界值分析会产生4n+1个测试用例</h4><p>A. 对<br>B. 错</p>
<p>正确答案: 对</p>
<h4 id="7-判断题-有n个变量的函数的健壮性测试用例的个数为：5n-1。"><a href="#7-判断题-有n个变量的函数的健壮性测试用例的个数为：5n-1。" class="headerlink" title="7. (判断题)有n个变量的函数的健壮性测试用例的个数为：5n+1。"></a>7. (判断题)有n个变量的函数的健壮性测试用例的个数为：5n+1。</h4><p>A. 对<br>B. 错</p>
<p>正确答案: 错</p>
<h4 id="8-判断题-在所有的黑盒测试方法中，基于决策表的测试是最为严格、最具有逻辑性的测试方法。"><a href="#8-判断题-在所有的黑盒测试方法中，基于决策表的测试是最为严格、最具有逻辑性的测试方法。" class="headerlink" title="8. (判断题)在所有的黑盒测试方法中，基于决策表的测试是最为严格、最具有逻辑性的测试方法。"></a>8. (判断题)在所有的黑盒测试方法中，基于决策表的测试是最为严格、最具有逻辑性的测试方法。</h4><p>A. 对<br>B. 错</p>
<p>正确答案: 对</p>
<h4 id="9-判断题-单元测试多采用白盒测试（结构性测试）技术。"><a href="#9-判断题-单元测试多采用白盒测试（结构性测试）技术。" class="headerlink" title="9.  (判断题)单元测试多采用白盒测试（结构性测试）技术。"></a>9.  (判断题)单元测试多采用白盒测试（结构性测试）技术。</h4><p>A. 对<br>B. 错</p>
<p>正确答案: 对</p>
<h4 id="10-判断题-单元测试能发现约80-的软件缺陷。"><a href="#10-判断题-单元测试能发现约80-的软件缺陷。" class="headerlink" title="10. (判断题)单元测试能发现约80%的软件缺陷。"></a>10. (判断题)单元测试能发现约80%的软件缺陷。</h4><p>A. 对<br>B. 错</p>
<p>正确答案: 对</p>
<h4 id="11-判断题-单元测试又称为模块测试，是针对软件测试的最小单位－程序模块进行正确性检验的测试工作。"><a href="#11-判断题-单元测试又称为模块测试，是针对软件测试的最小单位－程序模块进行正确性检验的测试工作。" class="headerlink" title="11. (判断题)单元测试又称为模块测试，是针对软件测试的最小单位－程序模块进行正确性检验的测试工作。"></a>11. (判断题)单元测试又称为模块测试，是针对软件测试的最小单位－程序模块进行正确性检验的测试工作。</h4><p>A. 对<br>B. 错</p>
<p>正确答案: 对</p>
<h4 id="12-单元测试通常由开发人员进行。"><a href="#12-单元测试通常由开发人员进行。" class="headerlink" title="12. 单元测试通常由开发人员进行。"></a>12. 单元测试通常由开发人员进行。</h4><p>A. 对<br>B. 错</p>
<p>正确答案: 对</p>
<h4 id="13-判断题-集成测试计划在需求分析阶段末提交。"><a href="#13-判断题-集成测试计划在需求分析阶段末提交。" class="headerlink" title="13. (判断题)集成测试计划在需求分析阶段末提交。"></a>13. (判断题)集成测试计划在需求分析阶段末提交。</h4><p>A. 对<br>B. 错</p>
<p>正确答案: 错</p>
<h4 id="14-判断题-集成测试是检验程序单元或部件的接口关系，逐步集成为符合概要设计要求的程序部件或整个系统。"><a href="#14-判断题-集成测试是检验程序单元或部件的接口关系，逐步集成为符合概要设计要求的程序部件或整个系统。" class="headerlink" title="14. (判断题)集成测试是检验程序单元或部件的接口关系，逐步集成为符合概要设计要求的程序部件或整个系统。"></a>14. (判断题)集成测试是检验程序单元或部件的接口关系，逐步集成为符合概要设计要求的程序部件或整个系统。</h4><p>A. 对<br>B. 错</p>
<p>正确答案: 对</p>
<h4 id="15-判断题-集成测试是为确定软件系统是否满足验收标准以及使客户决定是否接受而进行的正式测试。"><a href="#15-判断题-集成测试是为确定软件系统是否满足验收标准以及使客户决定是否接受而进行的正式测试。" class="headerlink" title="15. (判断题)集成测试是为确定软件系统是否满足验收标准以及使客户决定是否接受而进行的正式测试。"></a>15. (判断题)集成测试是为确定软件系统是否满足验收标准以及使客户决定是否接受而进行的正式测试。</h4><p>A. 对<br>B. 错</p>
<p>正确答案: 错</p>
<h4 id="16-判断题-进行自底向上集成测试，需要为所测模块或子系统编制相应的驱动模块。"><a href="#16-判断题-进行自底向上集成测试，需要为所测模块或子系统编制相应的驱动模块。" class="headerlink" title="16.  (判断题)进行自底向上集成测试，需要为所测模块或子系统编制相应的驱动模块。"></a>16.  (判断题)进行自底向上集成测试，需要为所测模块或子系统编制相应的驱动模块。</h4><p>A. 对<br>B. 错</p>
<p>正确答案: 对</p>
<h4 id="17-判断题-进行自顶向下集成测试，需要为所测模块或子系统编制相应的驱动模块。"><a href="#17-判断题-进行自顶向下集成测试，需要为所测模块或子系统编制相应的驱动模块。" class="headerlink" title="17. (判断题)进行自顶向下集成测试，需要为所测模块或子系统编制相应的驱动模块。"></a>17. (判断题)进行自顶向下集成测试，需要为所测模块或子系统编制相应的驱动模块。</h4><p>A. 对<br>B. 错</p>
<p>正确答案: 错</p>
<h4 id="18-判断题-集成测试是对已测试过的模块进行组装，进行集成测试的目的主要在于检验与软件设计相关的程序结构问题。"><a href="#18-判断题-集成测试是对已测试过的模块进行组装，进行集成测试的目的主要在于检验与软件设计相关的程序结构问题。" class="headerlink" title="18.  (判断题)集成测试是对已测试过的模块进行组装，进行集成测试的目的主要在于检验与软件设计相关的程序结构问题。"></a>18.  (判断题)集成测试是对已测试过的模块进行组装，进行集成测试的目的主要在于检验与软件设计相关的程序结构问题。</h4><p>A. 对<br>B. 错</p>
<p>正确答案: 对</p>
<h4 id="19-判断题-集成测试一般通过黑盒测试方法来完成。"><a href="#19-判断题-集成测试一般通过黑盒测试方法来完成。" class="headerlink" title="19. (判断题)集成测试一般通过黑盒测试方法来完成。"></a>19. (判断题)集成测试一般通过黑盒测试方法来完成。</h4><p>A. 对<br>B. 错</p>
<p>正确答案: 对</p>
<h4 id="20-判断题-单元测试是完成集成测试后开始的，它对开发工作初期制定的确认准则进行检验。"><a href="#20-判断题-单元测试是完成集成测试后开始的，它对开发工作初期制定的确认准则进行检验。" class="headerlink" title="20. (判断题)单元测试是完成集成测试后开始的，它对开发工作初期制定的确认准则进行检验。"></a>20. (判断题)单元测试是完成集成测试后开始的，它对开发工作初期制定的确认准则进行检验。</h4><p>A. 对<br>B. 错</p>
<p>正确答案: 错</p>
<h2 id="部分计算公式"><a href="#部分计算公式" class="headerlink" title="部分计算公式"></a>部分计算公式</h2><h3 id="可靠性测试"><a href="#可靠性测试" class="headerlink" title="可靠性测试"></a>可靠性测试</h3><blockquote>
<p>假设系统S投入测试或运行，工作一段时间t1后，软件出现错误，系统被停止并进行修复，经过T1时间后，故障被排除；又投入测试或运行，工作一段时间t2后，软件出现错误，系统被停止并进行修复，经过T2时间后，故障被排除。如此进行下去。<br>假设t1，t2，…，tn是系统正常的工作时间，T1，T2，…，Tn是维护时间</p>
</blockquote>
<h4 id="故障率（风险函数）"><a href="#故障率（风险函数）" class="headerlink" title="故障率（风险函数）"></a>故障率（风险函数）</h4><p>$$<br>\lambda = \frac{总失效次数}{总工作时间} = \frac{n}{\sum_{i=1}^{n}t_i}<br>$$</p>
<p>$\lambda$的单位是 FIT , $1FIT = 10^{-9} /小时$</p>
<h4 id="维修率"><a href="#维修率" class="headerlink" title="维修率"></a>维修率</h4><p>$$<br>u = \frac{ 总失效次数 } { 总维护时间 } = \frac{ n } { \sum_ { i=1 } ^ { n }T_i}<br>$$</p>
<h4 id="平均无故障时间"><a href="#平均无故障时间" class="headerlink" title="平均无故障时间"></a>平均无故障时间</h4><p>$$<br>MTBF = \frac { 总工作时间 } { 总失效次数 } = \frac{ \sum_{ i=1 } ^ { n } t_i }{ n } = \frac{ 1 }{ \lambda }<br>$$</p>
<h4 id="平均维护时间"><a href="#平均维护时间" class="headerlink" title="平均维护时间"></a>平均维护时间</h4><p>$$<br>MTTR = \frac{总维护时间}{总失效次数} = \frac{\sum_{i=1}^{n}T_i}{n} = \frac{1}{u}<br>$$</p>
<h4 id="有效度"><a href="#有效度" class="headerlink" title="有效度"></a>有效度</h4><p>$$<br>A = \frac{ 总工作时间 }{ 总工作时间 + 总失效次数(可能是总维护时间，书上是总失效次数) } = \frac{ MTBF } { MTBF + MTTR } = \frac{ 1(可能是u,书上是1 ) }{ \lambda + u }<br>$$</p>
<h3 id="剖面测试"><a href="#剖面测试" class="headerlink" title="剖面测试"></a>剖面测试</h3><h4 id="相当于按使用剖面测试了多少小时"><a href="#相当于按使用剖面测试了多少小时" class="headerlink" title="相当于按使用剖面测试了多少小时"></a>相当于按使用剖面测试了多少小时</h4><p>假设软件有n功能或模块，实际使用时每个模块被执行的概率分别为p1,p2,…,pn,均匀分布测试M小时，则相当于按使用剖面测试的时间如下(单位为小时):</p>
<p>$$<br>M \sum_{ i=1 } ^ { n } min { { p_i,\frac{ 1 } { n } } }<br>$$</p>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="软件测试过程"><a href="#软件测试过程" class="headerlink" title="软件测试过程"></a>软件测试过程</h3><p>单元测试 -&gt; 集成测试 -&gt; 确认测试 -&gt; 系统测试 -&gt; 验收测试</p>
<p>软件开发是自顶向下逐步细化的过程，软件测试则是自底向上逐步集成的过程。低一级的测试为上一级的测试准备条件。</p>
<p>单元测试：确保每一个模块能正常工作，大多采用白盒测试;<br>集成测试：检测和排除与软件设计相关的程序结构问题，大多采用黑盒测试;<br>确认测试：以规格说明书规定的需求为尺度，检验开发的软件是否满足所有的功能和性能要求;<br>系统测试：软件是否能与系统的其他部分协调工作;<br>验收测试：解决开发的软件产品是否符合预期要求、用户是否接受等问题;</p>
<h3 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h3><p>黑盒测试是一种从软件<strong>外部</strong>对软件实施的测试，也称功能测试或基于规格说明的测试。</p>
<p>使用的唯一信息是软件的规格说明。</p>
<p>黑盒测试是从用户的观点出发的测试。</p>
<h4 id="等价类划分法"><a href="#等价类划分法" class="headerlink" title="等价类划分法"></a>等价类划分法</h4><p>等价类是指输入域的某个互不相交的子集合</p>
<h5 id="等价类划分原则"><a href="#等价类划分原则" class="headerlink" title="等价类划分原则"></a>等价类划分原则</h5><ol>
<li>按区间划分</li>
<li>按数值划分</li>
<li>按数值集合划分</li>
<li>按限制条件或规则划分</li>
<li>细分等价类</li>
</ol>
<h5 id="有效等价类"><a href="#有效等价类" class="headerlink" title="有效等价类"></a>有效等价类</h5><p>有效等价类一指符合程序规格说明书，有意义的、合理的输人数据所所构成的集合。<br>利用有效等价类，可以检验程序是否实现了规格说明预先规定的功能和性能。有效等价类可以是一个，也可以是多个。</p>
<h4 id="无效等价类"><a href="#无效等价类" class="headerlink" title="无效等价类"></a>无效等价类</h4><p>无效等价类一指不符合程序规格说明书，不合理或无意义的输人数据所构成的集合。<br>利用无效等价类，可以检查软件功能和性能的实现是否有不符合规格说明要求的地方。无效等价类至少应有一个，也可能有多个。</p>
<h5 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h5><ol>
<li>规格说明往往没有定义无效测试用例的期望输出应该是什么样的</li>
<li>强类型语言没必要考虑无效输入</li>
</ol>
<h4 id="边界值分析法"><a href="#边界值分析法" class="headerlink" title="边界值分析法"></a>边界值分析法</h4><h5 id="边界值分析测试"><a href="#边界值分析测试" class="headerlink" title="边界值分析测试"></a>边界值分析测试</h5><p>边界值分析利用输入变量的最小值、稍大于最小值、域内任意值、稍小于最大值、最大值来设置测试用例。</p>
<p>对于一个n变量的程序，边界值分析会产生 4n + 1 个测试用例。</p>
<h5 id="健壮性边界值测试"><a href="#健壮性边界值测试" class="headerlink" title="健壮性边界值测试"></a>健壮性边界值测试</h5><p>利用输入变量的最小值、稍大于最小值、略小于最小值、域内任意值、稍小于最大值、最大值、略超过最大值来设置测试用例。</p>
<p>对于一个n变量的程序，健壮性边界值测试会产生 6n + 1 个测试用例。</p>
<h3 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h3><p>分析程序的内部结构。</p>
<h4 id="语句覆盖准则"><a href="#语句覆盖准则" class="headerlink" title="语句覆盖准则"></a>语句覆盖准则</h4><p>程序的每条语句都得到运行。</p>
<h4 id="分支覆盖准则"><a href="#分支覆盖准则" class="headerlink" title="分支覆盖准则"></a>分支覆盖准则</h4><p>每个分支都至少获得一次“真”值和一次“假”值。</p>
<h4 id="谓词测试"><a href="#谓词测试" class="headerlink" title="谓词测试"></a>谓词测试</h4><h5 id="原子谓词覆盖准则"><a href="#原子谓词覆盖准则" class="headerlink" title="原子谓词覆盖准则"></a>原子谓词覆盖准则</h5><p>每个复合谓词所包含的每一个原子谓词都至少获得一次“真”值和一次“假”值。</p>
<h5 id="分支-谓词覆盖准则"><a href="#分支-谓词覆盖准则" class="headerlink" title="分支-谓词覆盖准则"></a>分支-谓词覆盖准则</h5><p>不仅每个复合谓词所包含的每一个原子谓词都至少获得一次“真”值和一次“假”值，而且每个复合谓词本身也至少获得一次“真”值和一次“假”值。</p>
<h5 id="复合谓词覆盖准则"><a href="#复合谓词覆盖准则" class="headerlink" title="复合谓词覆盖准则"></a>复合谓词覆盖准则</h5><p>每个谓词中条件的各种可能都至少出现一次。</p>
<h4 id="路径覆盖准则"><a href="#路径覆盖准则" class="headerlink" title="路径覆盖准则"></a>路径覆盖准则</h4><p>他要求观察程序运行的整个路径，要求程序的运行覆盖所有的完整路径。</p>
<p>路径覆盖准则包含分支覆盖准则。</p>
]]></content>
      <categories>
        <category>课程学习</category>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>课程学习</tag>
        <tag>软件测试</tag>
      </tags>
  </entry>
  <entry>
    <title>软件项目管理题库</title>
    <url>/135xyq.github.io/2022/06/23/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="软件项目管理题库"><a href="#软件项目管理题库" class="headerlink" title="软件项目管理题库"></a>软件项目管理题库</h1><h2 id="填空题"><a href="#填空题" class="headerlink" title="填空题"></a>填空题</h2><ol>
<li>标识风险的方法有（检查单）和（头脑风暴）。</li>
<li>活动网络图中的关键路径（可能有多）条。</li>
<li>标识资源需求时，资源需求列表必须（尽可能全面），宁愿所包含的某些资源在以后不需要时再删除掉也不要忽略某些必需的资源。</li>
<li>项目监督与控制关注的重点是要（确保项目的进展）。这就要求对所发生的事件进行监督，将实际完成情况与进度表进行比较，必要时（修订计划和进度表），以尽可能使项目回到原有的目标。</li>
<li>监督项目时，为收集部分完成活动的信息，对还剩下多少工作进行预测，可采取（局部完成报告）方法和（红黄绿交通灯报告）方法。</li>
<li>监督项目中可视化的方法有（甘特图），（延迟图）和（时间线图）。</li>
<li>使项目返回目标的方法有（缩短关键路径）和（重新考虑优先需求）。</li>
<li>在订立合同时，我们一定需要明确两个问题，第一，客户能不能把软件卖给别人；第二，<br>供应商能不能把软件卖给别人，即，明确（软件的所有权）。</li>
<li>当出现矛盾需要添加或改变合同的条款时，口头证据是不算数的，商定的变更需要很好地（文档化）</li>
<li>工作中产出的软件著作的所有权属于（入职单位），作者有（署名权）。</li>
<li>项目管理中的人员管理主要涉及（人员选择）、（人员发展）、（人员激励）和（在项目过程中不断改善人员的福利）。</li>
<li>人员管理中，提高工作热情的方法有（制定特定的目标），（让员工们参与制订目标），（提供反馈）和（考虑任务合理分工）。</li>
<li>增强任务分工的有效性方法是（扩充工作范畴并执行工作）。</li>
<li>在某些情况下如果有人的行为对其他人造成潜在的危害，即使法律还未明确禁止这些行为，我们也会认为那是不道德的。</li>
<li> 在项目早期，组员需要建立自信和彼此间的信任感，同一时间和地点，通过（会议）来进行沟通是最佳的方式。</li>
<li> 项目中期的设计阶段，项目整体架构被建立起来了，详细设计中的各个组件设计便可以在不同的地域并行地开展，（电视电话会议）来进行沟通是最佳的方案。</li>
<li> 项目的实现阶段，一旦设计被阐述清晰并且每个人都知道其在项目中的角色和职责，实现工作就可以开始了，仅仅利用（电子邮件）的方式就足够了</li>
<li> 软件系统质量的最终判断标准是（系统是否能正确地运行）。</li>
<li>通过合同购买的软件往往是通过做（黑盒测试）来验收。</li>
<li>项目规模和管理成本呈指数型增长，主要是因为（沟通成本呈指数型增长）。</li>
<li>操作系统是（嵌入式系统），因为起主要是用于控制硬件。</li>
<li>根据《著作权法》，逆向工程侵犯了作者的（复制权）。</li>
<li>为了尽快完成任务，我们应该（并行）安排工作。</li>
<li> 通过（模块关系图）可以确定是否要并发开发项目中的模块。</li>
<li> 瀑布模型典型缺点是不能跨步骤返工，改进方法是使用（V 过程模型）。</li>
<li> 采用（增量式）方法，在最终期限时，即使不能交付当初承诺的所有功能，至少也能交付一些功能。</li>
<li> 条形图式的项目计划没有表达清楚（任务/活动的逻辑关系）。</li>
<li> 缩短项目周期的一个有效办法是（并行地执行活动）。</li>
</ol>
<h2 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h2><h3 id="1-处理风险的方法有哪四种，并通俗解释。"><a href="#1-处理风险的方法有哪四种，并通俗解释。" class="headerlink" title="1. 处理风险的方法有哪四种，并通俗解释。"></a>1. 处理风险的方法有哪四种，并通俗解释。</h3><ul>
<li>接受风险——什么也不做</li>
<li>规避风险——不做前置动作</li>
<li>降低和缓解风险——处理</li>
<li>转移风险——另外的人或者公司</li>
</ul>
<h3 id="2-资源调度会创建新活动网络图关键路径，情形有哪两种？因此，计划的改变需要做什么？"><a href="#2-资源调度会创建新活动网络图关键路径，情形有哪两种？因此，计划的改变需要做什么？" class="headerlink" title="2. 资源调度会创建新活动网络图关键路径，情形有哪两种？因此，计划的改变需要做什么？"></a>2. 资源调度会创建新活动网络图关键路径，情形有哪两种？因此，计划的改变需要做什么？</h3><p>a. 因缺少资源而延迟活动的开始，会导致活动在用完缓冲期时变成关键的活动；<br>b. 一个活动完成的延迟，会导致延迟其后续活动所要求的可用资源</p>
<p>不断重新扫描关键路径。</p>
<h3 id="3-Amanda-项目的一名软件开发人员用-Java-语言编写了一个估计需要-500-行代码的程序的前-250-行代码，请问为什么不能说已经完成了-50-的工作量。如何才能合理地估计出近似的完成量是多少？"><a href="#3-Amanda-项目的一名软件开发人员用-Java-语言编写了一个估计需要-500-行代码的程序的前-250-行代码，请问为什么不能说已经完成了-50-的工作量。如何才能合理地估计出近似的完成量是多少？" class="headerlink" title="3. Amanda 项目的一名软件开发人员用 Java 语言编写了一个估计需要 500 行代码的程序的前 250 行代码，请问为什么不能说已经完成了 50%的工作量。如何才能合理地估计出近似的完成量是多少？"></a>3. Amanda 项目的一名软件开发人员用 Java 语言编写了一个估计需要 500 行代码的程序的前 250 行代码，请问为什么不能说已经完成了 50%的工作量。如何才能合理地估计出近似的完成量是多少？</h3><ul>
<li>估计的总代码行数可能不准确。</li>
<li>迄今为止已编写的代码行可能比随后要编写的代码更容易或更难。</li>
<li>程序一般直到经过测试后才认为完成——已编写完了的程序仍然不算完成，除非经过测试。</li>
</ul>
<p>通过更多地了解已经做了什么和还需要完成什么，就可能做出合理的完成估计。把开发任务分解<br>成更小的子任务（如软件设计、编码和单元测试），在此可能有用。</p>
<h3 id="4-在程序规格说明中的一个变更，通常会使程序的设计随之变更，然后变更编码。请问还有其他的产品需要修改吗？"><a href="#4-在程序规格说明中的一个变更，通常会使程序的设计随之变更，然后变更编码。请问还有其他的产品需要修改吗？" class="headerlink" title="4. 在程序规格说明中的一个变更，通常会使程序的设计随之变更，然后变更编码。请问还有其他的产品需要修改吗？"></a>4. 在程序规格说明中的一个变更，通常会使程序的设计随之变更，然后变更编码。请问还有其他的产品需要修改吗？</h3><p>在这些项中，最可能受变更影响的是测试数据、期望结果和用户手册。</p>
<h3 id="5-考虑还有什么其他原因使系统具有范围蠕变的趋势。"><a href="#5-考虑还有什么其他原因使系统具有范围蠕变的趋势。" class="headerlink" title="5. 考虑还有什么其他原因使系统具有范围蠕变的趋势。"></a>5. 考虑还有什么其他原因使系统具有范围蠕变的趋势。</h3><p>除了用户要求增加额外的功能之外，在详细设计阶段开发人员会渐渐明确需要额外的代码来处理特殊<br>情况的需求。为了协调组件可能需要附加的功能。</p>
<h3 id="6-很容易看出，把设备成本加入合同对承包商是有利的。但是-这种合同是否对客户也有好处呢？"><a href="#6-很容易看出，把设备成本加入合同对承包商是有利的。但是-这种合同是否对客户也有好处呢？" class="headerlink" title="6.  很容易看出，把设备成本加入合同对承包商是有利的。但是 这种合同是否对客户也有好处呢？"></a>6.  很容易看出，把设备成本加入合同对承包商是有利的。但是 这种合同是否对客户也有好处呢？</h3><ol>
<li>供应商需要报出一个价格，该价格包括一个差额，以便迎合设备价格的可能增长。</li>
<li>当实际价格没有增长与估计的一样多时，这可能就是实际价格</li>
<li>如果合同规定一个固定费用，再加上材料和设备的实际成本，那么客户在这种情况下<br>就更好。</li>
</ol>
<h3 id="7-如何评估一个提议的下面几个方面？"><a href="#7-如何评估一个提议的下面几个方面？" class="headerlink" title="7. 如何评估一个提议的下面几个方面？"></a>7. 如何评估一个提议的下面几个方面？</h3><p>1）现有的软件应用程序的可用性。<br>2）一个待设计和构建的软件应用程序的可用性。<br>3）需要提供的硬件的维护成本。<br>4）响应软件支持所需要的时间。<br>5）培训。</p>
<ol>
<li>检查用户手册、观察演示和跟踪实际的用户等。</li>
<li>评价开发人员想使用的方法来检查其是否遵循好的接口实践，还可能要检查供应商在使<br>用的接口标准。</li>
<li>仔细检查供应商提供的担保，与介绍方商讨也是有帮助的。</li>
<li>再次担保要由与此有关的供应商来提供，要检查这些担保的特性。</li>
<li>检查培训材料，访问培训的员工并检查他们的 CV，已经使用供应商培训服务的介绍方<br>可以提出他们的看法</li>
</ol>
<h3 id="8-某软件开发部门通过鼓励重用现有软件组件的方法来提高生产率，已经提议通过财务奖励来达到。你认为这种方式可以进行到什么程度？"><a href="#8-某软件开发部门通过鼓励重用现有软件组件的方法来提高生产率，已经提议通过财务奖励来达到。你认为这种方式可以进行到什么程度？" class="headerlink" title="8. 某软件开发部门通过鼓励重用现有软件组件的方法来提高生产率，已经提议通过财务奖励来达到。你认为这种方式可以进行到什么程度？"></a>8. 某软件开发部门通过鼓励重用现有软件组件的方法来提高生产率，已经提议通过财务奖励来达到。你认为这种方式可以进行到什么程度？</h3><p>a. 需要有方法（如功能点分析）来度量要实际交付给用户的功能和特征。<br>b. 还需要有某些办法来度量在应用程序中使用的从别处获得的代码。【可以设置重用代码与<br>新代码的百分比指标，如果满足指标，就奖励员工。】<br>c. 另外，要度量由重用所获得的节省，并实行收益共享方案。【可以通过每次软件构件重用<br>时支付使用费的制度，来鼓励程序员产生和发布可重用构件。】</p>
<h3 id="9-虽然一般认为，组织比个人承担更大的道德责任，因为他们比个人对危害有更大的影响力，尤其在他们实施各种大型开发项目时。然而，也有观点，特别是经济学家-Milton-Friedman指出，那些为商业组织工作的人要按合同去-保护和增加公司股东的财产。这些股东是公司的投资人以及合法的拥有者，他们也可能包括将退休金投资到公司的普通人。公司雇员追求团体的整体利益，而以牺牲股东的利益为代价被认为是不诚实的行为。找出可以组成上述股东商业道德模型的可能异议和评论。"><a href="#9-虽然一般认为，组织比个人承担更大的道德责任，因为他们比个人对危害有更大的影响力，尤其在他们实施各种大型开发项目时。然而，也有观点，特别是经济学家-Milton-Friedman指出，那些为商业组织工作的人要按合同去-保护和增加公司股东的财产。这些股东是公司的投资人以及合法的拥有者，他们也可能包括将退休金投资到公司的普通人。公司雇员追求团体的整体利益，而以牺牲股东的利益为代价被认为是不诚实的行为。找出可以组成上述股东商业道德模型的可能异议和评论。" class="headerlink" title="9. 虽然一般认为，组织比个人承担更大的道德责任，因为他们比个人对危害有更大的影响力，尤其在他们实施各种大型开发项目时。然而，也有观点，特别是经济学家 Milton Friedman指出，那些为商业组织工作的人要按合同去 保护和增加公司股东的财产。这些股东是公司的投资人以及合法的拥有者，他们也可能包括将退休金投资到公司的普通人。公司雇员追求团体的整体利益，而以牺牲股东的利益为代价被认为是不诚实的行为。找出可以组成上述股东商业道德模型的可能异议和评论。"></a>9. 虽然一般认为，组织比个人承担更大的道德责任，因为他们比个人对危害有更大的影响力，尤其在他们实施各种大型开发项目时。然而，也有观点，特别是经济学家 Milton Friedman指出，那些为商业组织工作的人要按合同去 保护和增加公司股东的财产。这些股东是公司的投资人以及合法的拥有者，他们也可能包括将退休金投资到公司的普通人。公司雇员追求团体的整体利益，而以牺牲股东的利益为代价被认为是不诚实的行为。找出可以组成上述股东商业道德模型的可能异议和评论。</h3><p>a. 这个模型隐含的意思是，雇员和客户的存在只是为了最大化股东的利润。这暗示企业的<br>全部目的是产生利润。<br>b. 如果商业组织只关注产生利润，而危害到其他利益相关者，那么企业的公共所有权就会<br>受到质疑。<br>c. 如果我们认为每个个体作个体是有社会责任感，有道德的，那么当这些人也是股东时，我<br>们可以认为他们也一样有社会责任感。<br>d. 以有社会责任感的方式行动，建立社会声誉，赢得商业机会，最终会 增加股东的收益。</p>
<h3 id="10-请谈一谈你对-996-的看法。"><a href="#10-请谈一谈你对-996-的看法。" class="headerlink" title="10. 请谈一谈你对 996 的看法。"></a>10. 请谈一谈你对 996 的看法。</h3><p>a. 公司希望软件开发者能够无偿地加班工作；<br>b. 员工一旦超过了一定的压力负荷，工作的质量就会下降，健康就会受到影响；<br>c. 好的项目管理人员能通过对需要的工作量和消耗的时间进行更实际的估计来减少对加班<br>的需要。</p>
<h3 id="11-集体不稳定是学生在完成组作业的过程中经常碰到的问题。参与者可以用什么方法来鼓励组员合理地分担任务？"><a href="#11-集体不稳定是学生在完成组作业的过程中经常碰到的问题。参与者可以用什么方法来鼓励组员合理地分担任务？" class="headerlink" title="11. 集体不稳定是学生在完成组作业的过程中经常碰到的问题。参与者可以用什么方法来鼓励组员合理地分担任务？"></a>11. 集体不稳定是学生在完成组作业的过程中经常碰到的问题。参与者可以用什么方法来鼓励组员合理地分担任务？</h3><ol>
<li>使每个执行者的工作能独立地加以标识。</li>
<li>使小组成员专心和关注小组工作的成果。</li>
<li>奖励对小组工作做出贡献的个人</li>
</ol>
<h3 id="12-下面的人具有什么样的权力-上面所定义的那些-？"><a href="#12-下面的人具有什么样的权力-上面所定义的那些-？" class="headerlink" title="12. 下面的人具有什么样的权力(上面所定义的那些)？"></a>12. 下面的人具有什么样的权力(上面所定义的那些)？</h3><p>(a) Brightmouth 学院的管理工资系统的内部审计员。<br>(b) 请来的咨询师，为提高 IOE 公司的软件开发生产率给出建议。<br>(c) Brightmouth 学院的院长，他告诉员工如果他们不接受新的合同，就会被<br>解雇。<br>(d) 对学院工资系统的用户负责的 Brigette。<br>(e) 负责项目组中权限管理的 Amanda。</p>
<p>在每种情况中，可以包括多种类型的权力:<br>(a)这里包含一些专家权，但对于从事审计的人来讲，主要的权力类型是联络权，<br>【因为审计员要产生报告提交给更高层的管理人员。外部审计员通常有强制权。】<br>(b)这里的权力主要是基于专家的和基于信息的，但由于咨询师要向高层管理人<br>员报告，因此也存在联络权。.<br>(c)这是强制权。<br>(d) Brigette 有些联络权。在她工作中包含的技术专长，意味着她有些专家权。【她<br>很少有或没有强制权，因为她不是有关员工的管理人员。基于“你给我帮忙，我<br>给你好处”的非正式约定，她可施加一些奖励权。】<br>(e) Amanda 有一些奖励权。因为她能接触更高层的管理人员，所以也有联络权。<br>她能访问用户意味着她有通知权。如果她给项目带来特殊的技术专长(如分析技<br>能)，那么她可以有某些专家权。由于起着其他项目组成员可能要模仿的模范作<br>用，她甚至展示出示范权!</p>
<h3 id="13-在与下面这些人员打交道时，你认为哪种管理方式最合适？"><a href="#13-在与下面这些人员打交道时，你认为哪种管理方式最合适？" class="headerlink" title="13. 在与下面这些人员打交道时，你认为哪种管理方式最合适？"></a>13. 在与下面这些人员打交道时，你认为哪种管理方式最合适？</h3><p>(a) 在 Brightmouth 学院，学院雇用了一个有多年处理学院工资经验的地方<br>当局的前办事员来建立并管理新的工资部门。<br>(b) 在 IOE, 一个刚刚加入 Amanda 组的新的程序分析员。<br>(c) 在 IOE, 一个 40 多岁的非常有经验的程序分析员，公司前段时间把 他<br>从会计部门调到软件开发部门，他一直从事账户维护系统的系统支持工作。</p>
<p>(a)当办事员在新的环境中工作并建立新关系时，刚开始可能需要大量面向人员的<br>管理和支持。<br>(b)接受训练的人同时需要面向任务和面向人员的管理。<br>(c)有经验的维护程序员可能在过去已经拥有了相当大的自主权。系统的扩充可能<br>对这个人的工作有相当复杂的影响。在短期内，可能需要增加面向任务的管理，<br>以便做出非常仔细的判断。</p>
<h3 id="14-团队的发展分为哪五个阶段，并简要说明。"><a href="#14-团队的发展分为哪五个阶段，并简要说明。" class="headerlink" title="14. 团队的发展分为哪五个阶段，并简要说明。"></a>14. 团队的发展分为哪五个阶段，并简要说明。</h3><p>a. 形成时期：团队内的成员开始相互认识，并且制定一些基本的行为规范。<br>b. 混乱时期：因为不同的组员争夺领导权而使组内产生了矛盾，这也是组工作<br>方式即将建立之时。<br>c. 规范时期：解决了大量矛盾，工作组一致性开始形成。<br>d. 执行时期：重点开始关注要着手的任务。<br>e. 中止时期：工作组解散。</p>
<h3 id="15-分散团队好处有哪六点？"><a href="#15-分散团队好处有哪六点？" class="headerlink" title="15. 分散团队好处有哪六点？"></a>15. 分散团队好处有哪六点？</h3><p>a. 通过雇佣薪水较低地区的劳动力来减少人力成本。<br>b. 通过网络协同办公来减少住宿开支、社会安全开支以及培训费用。<br>c. 灵活的雇佣机制——不需要某些工作时，某些员工也不需要被雇佣。<br>d. 生产率可能会提升。<br>e. 用特定的员工去做特定的工作（而不是一般的项目组员），这样可以提 升质<br>量。<br>f. 可以通过安排不同时区段的人员的任务分工来减少任务的持续时间。</p>
<h3 id="17-分散的工作方式的挑战有哪七点？"><a href="#17-分散的工作方式的挑战有哪七点？" class="headerlink" title="17. 分散的工作方式的挑战有哪七点？"></a>17. 分散的工作方式的挑战有哪七点？</h3><p>a. 被拆分给合约员工的需求要非常的明确。<br>b. 所遵循的流程必须要被正式传递，前面的活动也许要通过观察和模拟合作方<br>式来良好的衔接。<br>c. 协调分散的员工也许会很难。<br>d. 付费方式可能需要调整为按件付费。<br>e. 远程或者素不相识的协作者间也许缺乏信任感。<br>f. 对交付物的质量评估要非常彻底。<br>g. 不同的时区协作可能会导致沟通和协作的问题。</p>
<h3 id="18-在-Brightmouth-学院，Brigette-需要为学院选择最好的商用工资单的软件。她应该如何进行选择呢？"><a href="#18-在-Brightmouth-学院，Brigette-需要为学院选择最好的商用工资单的软件。她应该如何进行选择呢？" class="headerlink" title="18. 在 Brightmouth 学院，Brigette 需要为学院选择最好的商用工资单的软件。她应该如何进行选择呢？"></a>18. 在 Brightmouth 学院，Brigette 需要为学院选择最好的商用工资单的软件。她应该如何进行选择呢？</h3><p>a. 进行调查研究来了解用户的真正需求是什么。<br>b. 将需求组织成与单独的质量和属性相关的组。<br>c. 在这些需求中，有些需求具有绝对的特性。<br>d. 在其他情况下，需求是相对的。有些相对需求比其他需求更重要。<br>e. 需要标识一组可能的候选软件。<br>f. 必须设计出度量软件期望质量的实用方法。<br>g. 很可能有些软件在某些方面有缺陷，但这可通过其他质量来弥补。</p>
<h3 id="19-建议为文字处理软件提供质量规格说明，特别要注意说明这-些质量属性是如何进行测量的。"><a href="#19-建议为文字处理软件提供质量规格说明，特别要注意说明这-些质量属性是如何进行测量的。" class="headerlink" title="19. 建议为文字处理软件提供质量规格说明，特别要注意说明这 些质量属性是如何进行测量的。"></a>19. 建议为文字处理软件提供质量规格说明，特别要注意说明这 些质量属性是如何进行测量的。</h3><p>可以定义许多质量规格说明，下面只给出两个例子。要强调的一点是， 软件可能最佳地分<br>解成许多不同的功能域，每一个功能域可以单独评价，如 文档准备、陈述和邮件合并等。</p>
<h3 id="20-什么情况下一个活动的入口条件和它之前的那个活动的出口条件有所不同？"><a href="#20-什么情况下一个活动的入口条件和它之前的那个活动的出口条件有所不同？" class="headerlink" title="20.  什么情况下一个活动的入口条件和它之前的那个活动的出口条件有所不同？"></a>20.  什么情况下一个活动的入口条件和它之前的那个活动的出口条件有所不同？</h3><ol>
<li>一个活动可能在它的直接前驱活动全部完成之前开始。在这种情况下， 尽管前驱活动的<br>出口需求还没有满足，但后继活动的入口需求已经满足了。【 例如，尽管还有些与屏幕布局<br>有关的缺陷，但是软件模块可以用来对硬件平 台进行性能测试。】</li>
<li>后继活动的入口需求不同于前驱活动的出口需求的另一种情况是，前驱 活动在等待获得<br>某个特定的资源。</li>
</ol>
<h3 id="21-开发软件所涉及的过程之一，是系统测试和随后遇到缺陷后-对应用程序所进行的修改。如果软件开发组织想要符合-BS-EN-ISO-9001-2000-会对软件的系统测试产生什么影响？"><a href="#21-开发软件所涉及的过程之一，是系统测试和随后遇到缺陷后-对应用程序所进行的修改。如果软件开发组织想要符合-BS-EN-ISO-9001-2000-会对软件的系统测试产生什么影响？" class="headerlink" title="21.  开发软件所涉及的过程之一，是系统测试和随后遇到缺陷后 对应用程序所进行的修改。如果软件开发组织想要符合 BS EN ISO 9001 : 2000,会对软件的系统测试产生什么影响？"></a>21.  开发软件所涉及的过程之一，是系统测试和随后遇到缺陷后 对应用程序所进行的修改。如果软件开发组织想要符合 BS EN ISO 9001 : 2000,会对软件的系统测试产生什么影响？</h3><p>a. 需要文档化的规程来控制系统测试。<br>b. 可以将系统测试的质量目标定义为确保软件符合用户规格说明书中所列的需求。<br>c. 确保这一点的过程包括：将测试用例对规格说明书中有关章节的交叉引用文档化，执行测<br>试用例的结果需要记录，而且需要记录随后对任何缺陷的修改。</p>
<h3 id="22-牢记前面提及对-BS-EN-ISO-9001-的批评，在将质量要求非常-高的某些工作承包给具有BS-EN-ISO-9001-证书的供应商时，项目经理应该采-取什么防范措施？"><a href="#22-牢记前面提及对-BS-EN-ISO-9001-的批评，在将质量要求非常-高的某些工作承包给具有BS-EN-ISO-9001-证书的供应商时，项目经理应该采-取什么防范措施？" class="headerlink" title="22. 牢记前面提及对 BS EN ISO 9001 的批评，在将质量要求非常 高的某些工作承包给具有BS EN ISO 9001 证书的供应商时，项目经理应该采 取什么防范措施？"></a>22. 牢记前面提及对 BS EN ISO 9001 的批评，在将质量要求非常 高的某些工作承包给具有BS EN ISO 9001 证书的供应商时，项目经理应该采 取什么防范措施？</h3><p>项目经理可检查谁实际执行了认证。他们还可以发现 BS EN ISO 9001 认 证的实施范围。例<br>如，认证可能只应用于创建确定产品的过程，而不应用于 其他过程。也许最重要的一点是，<br>项目经理需要再次确保指导承包商工作的规格说 明书充分反映了客户组织的需求。</p>
<h3 id="23-质量循环和评审小组之间的主要区别是什么？"><a href="#23-质量循环和评审小组之间的主要区别是什么？" class="headerlink" title="23.  质量循环和评审小组之间的主要区别是什么？"></a>23.  质量循环和评审小组之间的主要区别是什么？</h3><p>a. 一般来讲，质量循环是检查过程，而评审小组是检查产品的特定实例。<br>b. 单独使用评审小组可能效率不高，因为评审小组会重复地删除同类型的缺陷，而不是像<br>质量循环那样处理缺陷。<br>c. 质量循环的任务是找到缺陷的根源，并防止缺陷的再次出现。</p>
<h3 id="24-项目策划和执行的每一个阶段都需要考虑质量，但在迭代过程中的哪五个步骤要特别重视软件质量？"><a href="#24-项目策划和执行的每一个阶段都需要考虑质量，但在迭代过程中的哪五个步骤要特别重视软件质量？" class="headerlink" title="24. 项目策划和执行的每一个阶段都需要考虑质量，但在迭代过程中的哪五个步骤要特别重视软件质量？"></a>24. 项目策划和执行的每一个阶段都需要考虑质量，但在迭代过程中的哪五个步骤要特别重视软件质量？</h3><p>a. 标识项目的范围和目标<br>b. 标识项目的基础设施<br>c. 分析项目的特征<br>d. 标识项目的产品和活动<br>e. 评审/发布计划</p>
<h3 id="25-软件产品质量特性最少包含哪-6-项，并简要解释。"><a href="#25-软件产品质量特性最少包含哪-6-项，并简要解释。" class="headerlink" title="25. 软件产品质量特性最少包含哪 6 项，并简要解释。"></a>25. 软件产品质量特性最少包含哪 6 项，并简要解释。</h3><p>a. 定义/描述：定义质量特性。<br>b. 刻度：测量的单位。<br>c. 测试：质量属性存在程度的实际测试。<br>d. 最小的可接受值：低于此值的产品可能会被拒绝。<br>e. 目标值：值的范围，计划的质量测量值在该范围内。<br>f. 现值：目前具有的值。</p>
<h3 id="26-在有助于提高软件质量的技术中，每完成一项工作的时候，要把工作的副本分发给合作者，让他们检查工作中的缺陷。然后，开会讨论工作并产生需要返工的缺陷列表。其作用是哪四点？"><a href="#26-在有助于提高软件质量的技术中，每完成一项工作的时候，要把工作的副本分发给合作者，让他们检查工作中的缺陷。然后，开会讨论工作并产生需要返工的缺陷列表。其作用是哪四点？" class="headerlink" title="26.  在有助于提高软件质量的技术中，每完成一项工作的时候，要把工作的副本分发给合作者，让他们检查工作中的缺陷。然后，开会讨论工作并产生需要返工的缺陷列表。其作用是哪四点？"></a>26.  在有助于提高软件质量的技术中，每完成一项工作的时候，要把工作的副本分发给合作者，让他们检查工作中的缺陷。然后，开会讨论工作并产生需要返工的缺陷列表。其作用是哪四点？</h3><p>a. 在去除表面缺陷时，审查是非常有效的方法。<br>b. 鼓励开发人员产生结构更好的、不需要加以说明的软件，因为如果不 这样做，他们知道<br>其他人会对此提出批评。<br>c. 能促进优秀编程实践的传播，因为参与者会讨论每一份代码的优缺点。<br>d. 能加强团队精神。</p>
<h3 id="27-考虑下列问题："><a href="#27-考虑下列问题：" class="headerlink" title="27. 考虑下列问题："></a>27. 考虑下列问题：</h3><p>a. 编辑一版报纸。<br>b. 发射火星生命探测仪。<br>c. 准备结婚。<br>d. 改进财务计算机系统以处理欧元问题。<br>e. 开发人机界面的研究项目。<br>f. 对用户使用计算机系统时出现问题的原因进行调查。<br>g. 为计算机专业的学生分配第二年的编程任务。<br>h. 为新计算机编写操作系统。<br>i. 在组织中安装新版本的字处理软件包。<br>其中有些问题看上去更符合项目的定义。按照你对项目定义的理解将以 上问题进行排<br>序，越符合“项目”的概念，越靠前。并指出每个问题与其前面 问题在作为项目上的不同之<br>处。</p>
<p>b, h, d, i, f, c, e, a, g</p>
<h3 id="28-计算机操作系统是信息系统还是嵌入式系统？"><a href="#28-计算机操作系统是信息系统还是嵌入式系统？" class="headerlink" title="28. 计算机操作系统是信息系统还是嵌入式系统？"></a>28. 计算机操作系统是信息系统还是嵌入式系统？</h3><p>操作系统的是嵌入式系统，因为许多从事基于计算机的信息系统的大型组织都有专家来负责<br>操作系统的维护。不过，由于操作系统主要考虑的是驱动硬件，因此可以认为它更像我们曾<br>经描述的嵌入式系统。</p>
<h3 id="29-Brightmouth-学院是一个高等教育研完机构，过去由当地政府-管辖，现在改为自主管理。该学院的工资仍由当地政府管理，其工资单和其他支出由当地政府的计算中心给出，政府要收取这项服务的费用。学院管理方的意见是，如购买一个工资软件包商用产品，并由自己来处理工资，可能要经济一些。请问-Brightmouth-学院实现独立的工资发放系统的项目是目标驱动项目还是产品驱动项目？"><a href="#29-Brightmouth-学院是一个高等教育研完机构，过去由当地政府-管辖，现在改为自主管理。该学院的工资仍由当地政府管理，其工资单和其他支出由当地政府的计算中心给出，政府要收取这项服务的费用。学院管理方的意见是，如购买一个工资软件包商用产品，并由自己来处理工资，可能要经济一些。请问-Brightmouth-学院实现独立的工资发放系统的项目是目标驱动项目还是产品驱动项目？" class="headerlink" title="29. Brightmouth 学院是一个高等教育研完机构，过去由当地政府 管辖，现在改为自主管理。该学院的工资仍由当地政府管理，其工资单和其他支出由当地政府的计算中心给出，政府要收取这项服务的费用。学院管理方的意见是，如购买一个工资软件包商用产品，并由自己来处理工资，可能要经济一些。请问 Brightmouth 学院实现独立的工资发放系统的项目是目标驱动项目还是产品驱动项目？"></a>29. Brightmouth 学院是一个高等教育研完机构，过去由当地政府 管辖，现在改为自主管理。该学院的工资仍由当地政府管理，其工资单和其他支出由当地政府的计算中心给出，政府要收取这项服务的费用。学院管理方的意见是，如购买一个工资软件包商用产品，并由自己来处理工资，可能要经济一些。请问 Brightmouth 学院实现独立的工资发放系统的项目是目标驱动项目还是产品驱动项目？</h3><p>Brightmouth 学院工资单：目标驱动的和产品驱动的<br>这个项目实际上是目标驱动的，如果内部的工资单处理产生不了成本效益，那么该项目不应<br>该试图实现这种解决方案。<br>这个项目也可以是产品驱动的，可以考虑满足目标集其他方法，例如，可能把这种处理以更<br>低的成本承包给除地方当局外的某些组织。</p>
<h3 id="30-Brightmouth-学院是一个高等教育研完机构，过去由当地政府-管辖，现在改为自主管理。该学院的工资仍由当地政府管理，其工资单和其他支出由当地政府的计算中心给出，政府要收取这项服务的费用。学院管理方的意见是，如购买一个工资软件包商用产品，并由自己来处理工资，可能要经济一些。请标识-Brightmouth-学院工资单项目的利益相关者。"><a href="#30-Brightmouth-学院是一个高等教育研完机构，过去由当地政府-管辖，现在改为自主管理。该学院的工资仍由当地政府管理，其工资单和其他支出由当地政府的计算中心给出，政府要收取这项服务的费用。学院管理方的意见是，如购买一个工资软件包商用产品，并由自己来处理工资，可能要经济一些。请标识-Brightmouth-学院工资单项目的利益相关者。" class="headerlink" title="30. Brightmouth 学院是一个高等教育研完机构，过去由当地政府 管辖，现在改为自主管理。该学院的工资仍由当地政府管理，其工资单和其他支出由当地政府的计算中心给出，政府要收取这项服务的费用。学院管理方的意见是，如购买一个工资软件包商用产品，并由自己来处理工资，可能要经济一些。请标识 Brightmouth 学院工资单项目的利益相关者。"></a>30. Brightmouth 学院是一个高等教育研完机构，过去由当地政府 管辖，现在改为自主管理。该学院的工资仍由当地政府管理，其工资单和其他支出由当地政府的计算中心给出，政府要收取这项服务的费用。学院管理方的意见是，如购买一个工资软件包商用产品，并由自己来处理工资，可能要经济一些。请标识 Brightmouth 学院工资单项目的利益相关者。</h3><p>Brightmouth 学院工资单主要的项目利益相关者可能包括：<br>1）财务部门；<br>2）人事部门，需要提供大部分必要的员工详细信息；<br>3）部门负责人，需要提交兼职员工工作小时的细节；<br>4）全体员工，当然要关心他们的工资得到了正确的支付；<br>5）场所管理人员，新的任务可能意味着办公室布局在物理上必须重新安排；<br>6）软件和硬件销售商。</p>
<h3 id="31-Paul-Duggan-是软件开发部经理。星期二上午-10-00-他和下属-部门领导与集团经理开会，讨论明年的人员需求。Paul-已经起草了一份题目-为“邀请”的人事文件，这是根据他的部门明年的工作计划而作出的。这份文件在会议上进行了讨论。下午-2-00-Paul-和他的高级职员开会，讨论他的部门-正在进行的一个重要项目。该项目有一名程序员出了车祸，将住睨一段时间。-为保证项目的进度，决定将另一组（任务不紧迫的）一名组员调到这个项目，-以临时替代做些不很紧要的工作，但这需要一周的时间来安排。Paul-一方面必-须打电话给人事部门，告诉他们关于人员替补的问题，同时必须打电话给用户，解释项目可能延期的原因并且说明谁在做这件不很紧要的工作。指出在这一天中-Paul-在不同时段所作出的响应，属于八项管理职责中的哪些职责。"><a href="#31-Paul-Duggan-是软件开发部经理。星期二上午-10-00-他和下属-部门领导与集团经理开会，讨论明年的人员需求。Paul-已经起草了一份题目-为“邀请”的人事文件，这是根据他的部门明年的工作计划而作出的。这份文件在会议上进行了讨论。下午-2-00-Paul-和他的高级职员开会，讨论他的部门-正在进行的一个重要项目。该项目有一名程序员出了车祸，将住睨一段时间。-为保证项目的进度，决定将另一组（任务不紧迫的）一名组员调到这个项目，-以临时替代做些不很紧要的工作，但这需要一周的时间来安排。Paul-一方面必-须打电话给人事部门，告诉他们关于人员替补的问题，同时必须打电话给用户，解释项目可能延期的原因并且说明谁在做这件不很紧要的工作。指出在这一天中-Paul-在不同时段所作出的响应，属于八项管理职责中的哪些职责。" class="headerlink" title="31. Paul Duggan 是软件开发部经理。星期二上午 10:00,他和下属 部门领导与集团经理开会，讨论明年的人员需求。Paul 已经起草了一份题目 为“邀请”的人事文件，这是根据他的部门明年的工作计划而作出的。这份文件在会议上进行了讨论。下午 2:00 Paul 和他的高级职员开会，讨论他的部门 正在进行的一个重要项目。该项目有一名程序员出了车祸，将住睨一段时间。 为保证项目的进度，决定将另一组（任务不紧迫的）一名组员调到这个项目， 以临时替代做些不很紧要的工作，但这需要一周的时间来安排。Paul 一方面必 须打电话给人事部门，告诉他们关于人员替补的问题，同时必须打电话给用户，解释项目可能延期的原因并且说明谁在做这件不很紧要的工作。指出在这一天中 Paul 在不同时段所作出的响应，属于八项管理职责中的哪些职责。"></a>31. Paul Duggan 是软件开发部经理。星期二上午 10:00,他和下属 部门领导与集团经理开会，讨论明年的人员需求。Paul 已经起草了一份题目 为“邀请”的人事文件，这是根据他的部门明年的工作计划而作出的。这份文件在会议上进行了讨论。下午 2:00 Paul 和他的高级职员开会，讨论他的部门 正在进行的一个重要项目。该项目有一名程序员出了车祸，将住睨一段时间。 为保证项目的进度，决定将另一组（任务不紧迫的）一名组员调到这个项目， 以临时替代做些不很紧要的工作，但这需要一周的时间来安排。Paul 一方面必 须打电话给人事部门，告诉他们关于人员替补的问题，同时必须打电话给用户，解释项目可能延期的原因并且说明谁在做这件不很紧要的工作。指出在这一天中 Paul 在不同时段所作出的响应，属于八项管理职责中的哪些职责。</h3><p>策划：<br>来年的人员配置需求。<br>控制、革新和指导：<br>确定需要做什么来取得好的进展，不会因临时失去员工而影响进展。<br>人员配置：<br>决定哪名员工需要做什么。<br>与人事部门讨论临时工的要求。<br>策划来年的人员配置。<br>注意：同样的活动可能包括许多不同的职责。</p>
<h3 id="32-—个-ICT-项目意在取消分散存放的纸张文件，代之以集中组织的数据库。许多地理位置分散的办公室人员需要培训，然后使用新的-ICT-系统把人工记录设置在数据库上。直到最后一条记录转移到系统后，该系统-才能正常运行。只有当新的事务处理能在一定时间周期内处理时，才能说新-系统是成功的。请标识你所收集的保证项目执行期间事务将按计划进行的数据。"><a href="#32-—个-ICT-项目意在取消分散存放的纸张文件，代之以集中组织的数据库。许多地理位置分散的办公室人员需要培训，然后使用新的-ICT-系统把人工记录设置在数据库上。直到最后一条记录转移到系统后，该系统-才能正常运行。只有当新的事务处理能在一定时间周期内处理时，才能说新-系统是成功的。请标识你所收集的保证项目执行期间事务将按计划进行的数据。" class="headerlink" title="32. —个 ICT 项目意在取消分散存放的纸张文件，代之以集中组织的数据库。许多地理位置分散的办公室人员需要培训，然后使用新的 ICT 系统把人工记录设置在数据库上。直到最后一条记录转移到系统后，该系统 才能正常运行。只有当新的事务处理能在一定时间周期内处理时，才能说新 系统是成功的。请标识你所收集的保证项目执行期间事务将按计划进行的数据。"></a>32. —个 ICT 项目意在取消分散存放的纸张文件，代之以集中组织的数据库。许多地理位置分散的办公室人员需要培训，然后使用新的 ICT 系统把人工记录设置在数据库上。直到最后一条记录转移到系统后，该系统 才能正常运行。只有当新的事务处理能在一定时间周期内处理时，才能说新 系统是成功的。请标识你所收集的保证项目执行期间事务将按计划进行的数据。</h3><p>该项目似乎有两个主要的组成部分：培训和文档转换。如果要求培训教师到各部门去提供培<br>训，那么需要进度表来指出每个部门何时接受培训。因此，可能要收集以下关于培训进展的<br>信息：</p>
<ol>
<li>已经接受培训的部门数——这可以对照计划做比较。</li>
<li>已经接受培训的员工数一一确保员工参加。</li>
<li>来自员工的关于培训质量的反馈一一例如，通过后续的培训评价表格。<br>至于文档转换方面，通常要收集每个部门以下的信息：</li>
<li>已转换的文档数。</li>
<li>估计仍要转换的文档数。</li>
<li>在转换文档上所花的员工小时数——监督预算和转换生产率。</li>
<li>参与转换的员工数。<br>当所有的文档已经转换时，进行性能测试来检测响应时间是否满足要求。</li>
</ol>
<h3 id="33-2003-年美国-Standish-Group-通过分析-13522-个项目得出结论即只有（）的项目是成功的82-的项目延期-43-的项目超出预算。请问，"><a href="#33-2003-年美国-Standish-Group-通过分析-13522-个项目得出结论即只有（）的项目是成功的82-的项目延期-43-的项目超出预算。请问，" class="headerlink" title="33. 2003 年美国 Standish Group 通过分析 13522 个项目得出结论即只有（）的项目是成功的82%的项目延期 43%的项目超出预算。请问，"></a>33. 2003 年美国 Standish Group 通过分析 13522 个项目得出结论即只有（）的项目是成功的82%的项目延期 43%的项目超出预算。请问，</h3><p>a. （）中应填写什么？<br>b. 这个数据对吗？为什么？</p>
<p>a. 1/3<br>b. 这个数据是对的，从上面数据来看，虽然有些项目延期了，但是最终他可能还是盈利了，<br>所以他是一个成功的项目。</p>
<h3 id="34-以下哪个最可能是项目？-c"><a href="#34-以下哪个最可能是项目？-c" class="headerlink" title="34. 以下哪个最可能是项目？(c)"></a>34. 以下哪个最可能是项目？(c)</h3><p>a. 回宿舍接课本是不是项目？<br>b. 运维是不是项目？<br>c. 老师上课是否是项目？</p>
<h3 id="35-在-IOE-的年度维护合同系统中，IOE-组织外部的项目利益相关者可能考虑的重要问题是什么？"><a href="#35-在-IOE-的年度维护合同系统中，IOE-组织外部的项目利益相关者可能考虑的重要问题是什么？" class="headerlink" title="35. 在 IOE 的年度维护合同系统中，IOE 组织外部的项目利益相关者可能考虑的重要问题是什么？"></a>35. 在 IOE 的年度维护合同系统中，IOE 组织外部的项目利益相关者可能考虑的重要问题是什么？</h3><p>a.考虑主要利益相关者 IOE 客户<br>b. 考虑 IOE 和设备制造商可能还有客户协议<br>c. 考虑由保险公司支付每次维护工作的费用，而 IOE 向保险公司按年支付保费。</p>
<h3 id="36-除了自己编写的一个较小的标准之外，Brigette-没有设置任何标准。Brigette-将使用什么样的质量标准来确认她已经很好地理解了用户需求？"><a href="#36-除了自己编写的一个较小的标准之外，Brigette-没有设置任何标准。Brigette-将使用什么样的质量标准来确认她已经很好地理解了用户需求？" class="headerlink" title="36. 除了自己编写的一个较小的标准之外，Brigette 没有设置任何标准。Brigette 将使用什么样的质量标准来确认她已经很好地理解了用户需求？"></a>36. 除了自己编写的一个较小的标准之外，Brigette 没有设置任何标准。Brigette 将使用什么样的质量标准来确认她已经很好地理解了用户需求？</h3><p>需要阅读和批准系统规格说明</p>
<h3 id="37-对下面的系统进行分类："><a href="#37-对下面的系统进行分类：" class="headerlink" title="37. 对下面的系统进行分类："></a>37. 对下面的系统进行分类：</h3><p>a. 工资单系统是 (面向数据或信息的特定应用领域的系统)。<br>b. 控制装瓶设备的系统是 (包含嵌入式软件的面向过程的系统)。<br>c. 供水给消费者的水厂所用设备的设计图细节的保存系统像一个(大量使用计算机图形的信<br>息系统)。设备本身使用安全性关键的控制软件，但这不是项目要考虑的主题。<br>d. 项目管理软件工具一般划分在 (通用程序包类) 中，它们包含大量的信息系统的基本要素。<br>e. 律师用于获得与公司税收有关的诉讼法的系统可使用一个信息检索程序包，是 (通用的软<br>件程序包) 。它也是基于知识的系统的有力候选者。<br>f. 用于计算管理特殊疾病患者用药量的系统是一个 (基于知识的系统) ，也是安全性关键的系<br>统。<br>g. 用于控制在隧道中通行的火车的系统是一个 (安全性非常关键的嵌入式系统)。</p>
<h3 id="38-Brightmouth-学院的-Brigette-已经将市场上没有合适的工资单程序包的可能性标识为风险。在-Brightmouth-学院工资单项目上还可能有哪些内在的其他风险？"><a href="#38-Brightmouth-学院的-Brigette-已经将市场上没有合适的工资单程序包的可能性标识为风险。在-Brightmouth-学院工资单项目上还可能有哪些内在的其他风险？" class="headerlink" title="38. Brightmouth 学院的 Brigette 已经将市场上没有合适的工资单程序包的可能性标识为风险。在 Brightmouth 学院工资单项目上还可能有哪些内在的其他风险？"></a>38. Brightmouth 学院的 Brigette 已经将市场上没有合适的工资单程序包的可能性标识为风险。在 Brightmouth 学院工资单项目上还可能有哪些内在的其他风险？</h3><p>在 Brightmouth 学院可以标识的风险是:<br>a. 财务部门和人事部门之间观点的冲突；<br>b. 缺少人员(特别是人事人员)对系统的验收；<br>c. 缺少过去执行工资单处理的地方当局的合作；<br>d. 学院缺少运行工资单系统的经验；<br>e. 学院缺少管理计算机的专门技术；<br>f. 选择的硬件可能不够；<br>g. 工资单需求的变更。</p>
<h3 id="39-在系统开发项目的什么阶段-比如可行，性研究、需求分析等-使用原型作为降低不确定性的手段。"><a href="#39-在系统开发项目的什么阶段-比如可行，性研究、需求分析等-使用原型作为降低不确定性的手段。" class="headerlink" title="39. 在系统开发项目的什么阶段(比如可行，性研究、需求分析等) 使用原型作为降低不确定性的手段。"></a>39. 在系统开发项目的什么阶段(比如可行，性研究、需求分析等) 使用原型作为降低不确定性的手段。</h3><p>a. 有项建议是：保险公司的高层经理可通过安装在位于他们桌面上的个人计算机中的主管<br>信息系统来访问管理信息。要建立这样的系统是昂贵的， 而且对于经理是否使用该系统还<br>有些疑问。<br>b. 用于支持销售部员工接听关于汽车保险的公众询问电话并给予报价的计算机系统。<br>c. 保险公司考虑使用 Microsoft Access 支持的系统开发特征来实现电 话销售系统。刚开始<br>他们对能否提供需要的接口没有把握，而且也关心使用 Microsoft Access 开发的系统的可能<br>响应时间。</p>
<p>a. 原型作为可行性研究的一部分是有用的。<br>b. 原型用于辅助设计用户对话。<br>c. 大部分关键的响应事务的原型可在物理设计阶段构建</p>
<h3 id="40-内部开发是指开发者和客户属于同一个组织，然而外包开发是指开发者和客户属于不同的组织。请问，以上两个客户是同一个意思吗？如果不是分别代表什么？"><a href="#40-内部开发是指开发者和客户属于同一个组织，然而外包开发是指开发者和客户属于不同的组织。请问，以上两个客户是同一个意思吗？如果不是分别代表什么？" class="headerlink" title="40. 内部开发是指开发者和客户属于同一个组织，然而外包开发是指开发者和客户属于不同的组织。请问，以上两个客户是同一个意思吗？如果不是分别代表什么？"></a>40. 内部开发是指开发者和客户属于同一个组织，然而外包开发是指开发者和客户属于不同的组织。请问，以上两个客户是同一个意思吗？如果不是分别代表什么？</h3><p>不是同一个意思，前者是公司开发人员，后者是用户。</p>
<h3 id="41-对于建设-Brightmouth-学院工资单系统，购买现货软件缺点有哪-4-个？"><a href="#41-对于建设-Brightmouth-学院工资单系统，购买现货软件缺点有哪-4-个？" class="headerlink" title="41. 对于建设 Brightmouth 学院工资单系统，购买现货软件缺点有哪 4 个？"></a>41. 对于建设 Brightmouth 学院工资单系统，购买现货软件缺点有哪 4 个？</h3><p>a. 【由于其他客户也可以获得同样的系统，所以】获得此系统不会增加竞争力。<br>b. 【现在的现货软件越来越客户化，可以通过配置参数表来设置应用系统的属性，但是】这<br>种灵活性还是有限的，最终可能需要变更工作流程来适应软件系统。<br>c. 无法获得软件源码【，也就无法根据组织和环境的变化而修改软件】。<br>d. 【一旦使用现货软件，】组织将会依赖于此软件，很难再使用其他的应用软件，这会导致<br>许可证费用不断增加。</p>
<h3 id="42-为什么往往开发人员青睐重量级方法，然而，客户更青睐快速应用开发？"><a href="#42-为什么往往开发人员青睐重量级方法，然而，客户更青睐快速应用开发？" class="headerlink" title="42. 为什么往往开发人员青睐重量级方法，然而，客户更青睐快速应用开发？"></a>42. 为什么往往开发人员青睐重量级方法，然而，客户更青睐快速应用开发？</h3><p>开发人员希望明确需求并做出可靠的产品，客户希望快速看到原型并进一步确认需求。</p>
<h3 id="43-低估的项目可能不能及时完成或超出成本，但仍可能比估计过高的项目在更短的时间内实现，请问低估的项目有哪两个危害？"><a href="#43-低估的项目可能不能及时完成或超出成本，但仍可能比估计过高的项目在更短的时间内实现，请问低估的项目有哪两个危害？" class="headerlink" title="43. 低估的项目可能不能及时完成或超出成本，但仍可能比估计过高的项目在更短的时间内实现，请问低估的项目有哪两个危害？"></a>43. 低估的项目可能不能及时完成或超出成本，但仍可能比估计过高的项目在更短的时间内实现，请问低估的项目有哪两个危害？</h3><p>a.影响软件质量。特别是缺乏经验的员工，可能会通过低标准的工作来响应紧迫的交付期。<br>b. 低标准的工作可能只在项目的后期（如测试阶段）才体现出来，此时特别难以控制，而且<br>巨大的返工可能会导致项目延期。</p>
<h3 id="44-由底向上估计方法的步骤有哪四步？适用的场景有哪两个？"><a href="#44-由底向上估计方法的步骤有哪四步？适用的场景有哪两个？" class="headerlink" title="44. 由底向上估计方法的步骤有哪四步？适用的场景有哪两个？"></a>44. 由底向上估计方法的步骤有哪四步？适用的场景有哪两个？</h3><p>a. 将项目分解成构件任务<br>b. 然后估计执行每个任务需要多少工作量。<br>c. 每个子任务能被一个人在一周或两周内完成<br>d. 由底向上部分累加每个活动的已计算的工作量来得到总体的估计<br>场景：<br>a. 适合于后期更详细的项目策划阶段<br>b. 如果一个项目完全是新颖的或者没有可用的历史数据</p>
<h3 id="45-由顶到底估计步骤是哪四步？"><a href="#45-由顶到底估计步骤是哪四步？" class="headerlink" title="45. 由顶到底估计步骤是哪四步？"></a>45. 由顶到底估计步骤是哪四步？</h3><p>设想在最终系统中软件模块的数目和类型<br>估计每个已标识模块的 SLOC<br>估计工作内容，考虑复杂度和技术难度<br>计算工作量</p>
<h3 id="46-网络策划模型中，关键路径的重要性体现在哪两方面？"><a href="#46-网络策划模型中，关键路径的重要性体现在哪两方面？" class="headerlink" title="46. 网络策划模型中，关键路径的重要性体现在哪两方面？"></a>46. 网络策划模型中，关键路径的重要性体现在哪两方面？</h3><p>a. 在管理项目时，应该特别关注对关键路径上活动的监控，以便尽早发 现和纠正任何延迟<br>或资源无法得到的影响。<br>b. 在策划项目时，如果要缩短整个项目的周期，就必须缩短关键路径。</p>
<h2 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h2><ol>
<li>项目预算在下列那个阶段投入最大？ （ B ）<br>A. 项目计划制定阶段<br>B. 项目计划执行阶段<br>C. 总体变更控制阶段<br>D. 项目启动阶段</li>
<li>领导和管理对项目来说都非常重要。关于管理的一种定义认为管理主要是实现项目干系<br>人的主要目标，而领导则是 （ A ）<br>A. 确定管理方向，组织和激励他人努力工作<br>B. 通过他人的工作实现工作目标<br>C. 运用领导权力鼓励他人提高工作效率<br>D. 运用所有适当的权利作为激励手段</li>
<li>对项目来说“临时”的意思是： （ B ）<br>A. 项目的工期短<br>B. 每个项目都有确定的开始和结束点<br>C. 项目未来完成时间未定<br>D. 项目随时可以取消</li>
<li>目标管理不涉及下列哪些内容 （ D ）<br>确定明确和现实的目标<br>定期评估项目目标是否完成<br>促进合作、团队建设和对项目的投入<br>为项目成员建立具体的职业途径</li>
<li>工作结果是 （ A ）<br>A. 为完成项目所进行的各项工作活动的结果<br>B.满足项目成功的标准<br>客户正式验收了项目<br>完成合同的正式验收</li>
<li>一个公司在确定项目选择模式时，最重要的标准是： （B ）<br>A. 功能<br>B. 实用<br>C. 使用简便<br>D. 费用</li>
<li>工作包是： （ A ）<br>A. 一项 WBS 最低层的交付工作<br>B. 一项具有特殊标准的任务<br>C. 一项必要的汇报工作<br>D. 一项可分包给若干单位的任务</li>
<li>选派项目经理的理想时间是： （ A ）<br>A. 在项目的启动阶段<br>B. 在项目的计划阶段<br>C. 在项目生命周期中的概念阶段结束后<br>D. 在项目生命周期中的开始阶段开始之前</li>
<li>在下列那个项目生命周期阶段会发生最严重的不确定性？ （ A ）<br>构思阶段<br>规划阶段<br>执行阶段<br>收尾阶段</li>
<li>项目失败的主要原因是（D）<br>A. 缺乏项目型或强矩阵型的结构，项目范围界定不当，以及缺少项目计划。<br>B. 缺少最高管理层的支持，项目人员缺乏合作，以及项目经理领导不得力。<br>C. 客户需求认识不足或不当，项目人员分布分散，项目进行期间与客户沟通不足。<br>D. 组织方面的不利因素，客户需求认识不足或不当，项目需求识别不当，规划和控制不足<br>或不当。</li>
<li>一项工作最早开始日期为 10 号，最晚开始日期为 19 号，该项工作周期为 4 天，这其<br>中没有休息日。从以上给出的信息，关于该项工作可以得到什么结论？（A）<br>A. 该项工作总时差为 9 天<br>B. 该项工作最早完成日期为 14 号当天结束时<br>C. 该项工作最迟完成的日期为 25 号<br>D. 如果将投入该项工作的资源数量增加一倍的话，该项工作可以在两天内完成</li>
<li>在项目的时间管理中，项目赶工的意思是： （ A）<br>A. 重新界定逻辑关系，以缩短项目周期<br>B. 缩短用于项目进度风险模型分析的计算机网络维修时间<br>C. 给所有的项目工作都增加新的资源<br>D. 根据优先顺序给重要路径上的活动增加资源</li>
<li>趋势分析被用来监控（ D ）<br>A. 错误原因<br>B. 质量管理计划<br>C. 客户满意度<br>D. 技术、成本和进度执行情况</li>
<li>项目 A 按矩阵组织形式进行管理，该项目经理向高级副总裁汇报工作，后者为项目提<br>供直接的支持。在这种情况下，以下哪一种描述最好的说明了项目经理的相对权力：（ D）<br>A. 项目经理很可能不会被项目干系人质疑<br>B. 在强矩阵型结构中，权力向职能经理倾斜<br>C. 在弱矩阵型结构中，权力向项目经理倾斜<br>D. 在强矩阵型结构中，权力向项目经理倾斜</li>
<li>当组织的功能结构需要用来支持多个项目时，主要的困难将会出现，这是由于：（ B ）<br>A. 项目经理的权限造成的<br>B. 不同的项目优先顺序发生矛盾，从而对有限的资源进行竞争<br>C. 项目组成员对他们的专长的关注超过了对项目本身的关注<br>D. 项目经理运用人际技巧来非正式地解决成员之间的冲突</li>
<li>减少项目中冲突的主要方法是（C）。<br>A. 举行定期的小组会议<br>B. 使用小组协调人员<br>C. 进行谨慎仔细的项目规划<br>D. 规定严格的讨论制度</li>
<li>在强和弱矩阵组织结构中，导致冲突的主要原因是： （ D ）<br>A. 沟通障碍<br>B. 相互冲突的利益<br>C. 需要统一意见<br>D. 管辖模糊</li>
<li>责任分配矩阵不被用来说明下列哪一项？ （ C ）<br>A. 谁负责那方面的工作<br>B. 工作单元间哪些关键界面需要管理上的特别协调<br>C. 实现项目目标需要哪些工作因素<br>D. 谁向谁汇报</li>
<li>以下选项中哪项不是开工会议的目标： （ D ）<br>A. 建立工作关系和沟通渠道<br>B. 审查项目计划<br>C. 建立个人和团队的责任<br>D. 讨论有关合同的具体法律问题</li>
<li>要创造易于接受的沟通环境，项目经理应该： （ B ）<br>A. 确保所有的沟通都是清晰并易于理解的<br>B. 以他（她）喜欢的表达方式<br>C. 让整个项目团队准备项目沟通计划<br>D. 确保队伍成员获得他们工作所需要的信息</li>
<li>绩效测量的基线是（ A ）。<br>A. 计划工作预算成本<br>B. 已完成工作预算成本<br>C. 已完成工作实际成本<br>D. 计划工作实际成本</li>
<li>在收尾阶段，许多项目经理都倾向于推迟人员安排，这是因为（A）。<br>A. 他们不想面对在这过程中可能产生的人际关系矛盾<br>B. 他们认为谁都不想离开这个项目<br>C. 职能经理不想队伍成员回去<br>D. 团队成员不想转移到新的任务中去</li>
<li>在项目管理中，当运作环境变成（ ）而且项目任务变得（ ）时，对人员和技术的需求<br>就增加了。 （C）<br>A. 动态的，简单<br>B. 静态的，复杂<br>C. 动态的，复杂<br>D. 静态的，简单</li>
<li>项目在（D）组织中最不被重视。<br>A. 平衡矩阵型<br>B. 强矩阵型<br>C. 项目协调员型<br>D. 职能型</li>
<li>对项目而言，“一次性”指（B）。<br>A. 项目周期短<br>B. 每个项目都有明确的起止时间<br>C. 项目将在未来不能确定的时候完成<br>D. 项目随时可能取消</li>
<li>范围界定的工具是( )。 (A)<br>A. WBS<br>B. 分层法<br>C. PERT<br>D. 流程图法</li>
<li>项目构思是以（ ）为主体。(A)<br>A. 项目的投资者/业主<br>B. 项目的供应商<br>C. 项目的实施组织<br>D. 项目工作团队</li>
<li>下列属于公开招标的采购方式是：（C）<br>A. 询价采购<br>B. 有限国际招标<br>C. 国际竞争性招标和国内竞争性招标<br>D. 直接签合同和自营工程</li>
<li>项目的三要素包括（B）。<br>A.风险、费用和进度<br>B.质量、进度和成本<br>C.质量、进度和时间<br>D.直接成本、间接成本和可用资源</li>
<li>一个公司接受和利用项目管理的程度通常取决于项目的（）和（）。 (C)<br>A.质量要求，劳动力需求<br>B.风险管理，质量管理<br>C.规模，性质<br>D.工业类型，劳动力需求</li>
<li>三点法统计估算公式：期望值= (B)<br>A.（乐观估算+（4X 最可能估算）+悲观估算）X6<br>B.（乐观估算+（4X 最可能估算）+悲观估算）/6<br>C.（乐观估算+（4X 最可能估算）X 悲观估算）/6<br>D.（乐观估算+（4+最可能估算）+悲观估算）/6<br>专业分析：在计划评审技术（PERT）中用到这个公式计算估计工期分布的中值。</li>
<li>在一个确认项目正式存在的初始化文档是（C）<br>A. 范围基线<br>B. 管理计划<br>C. 项目章程<br>D. 配置控制报告<br>分析：项目章程是确认项目正式存在的初始化文档</li>
<li>进度控制与下列哪种因素无关？ (D)<br>A. 对促进项目进度产生变化的影响因素进行管理，保证这些变化是有益的<br>B. 确定项目进度发生变化<br>C. 当变化出现时，对实际发生的变化进行管理<br>D. 根据客户要求改变项目进度<br>分析：根据客户需要更改项目进度是被动的，因而会造成项目执行混乱。控制的目的是降低<br>项目的混乱程度，并采取系统的活动方法使这一变化造成的混乱控制在最小的范围</li>
<li>以下(C)是项目队伍建设的基本原则。<br>A. 进行经常性的执行情况评估<br>B. 确保项目队伍每位成员除了向项目经理汇报之外同时向职能经理汇报<br>C. 尽早进行项目团队建设<br>D. 解决成员间的政治分歧<br>分析：项目中早些开始建立班子对确定正确的风气和防止发生不良习惯和作风是关键的</li>
<li>项目小组衡量风险应对计划实施有效性时，是将计划实施结果与下列哪个因素进行对比<br>(A)<br>A. 可接受的风险承受度<br>B. 风险评分<br>C. 风险的概率/影响评级<br>D. 项目的总体风险评级<br>专业分析：项目所有者、客户或者项目监控方可能对风险表现出不同的承受能力。风险管理<br>计划应该制定出可接受的风险承受度做为项目小组衡量风险应对计划实施有效性的标准。</li>
<li>项目的质量保证部门最近对项目进行了质量审计，得到了一系列发现和建议。其中有一<br>条建议看起来非常关键，应该采纳，因为它能影响到能否向顾客成功地提交项目产品。如果<br>这条建议没有得到采纳的话，产品很可能达不到要求。下一步你应该怎么做 ( D)<br>A. 召开一次项目团队会议，看看应该由谁来负责这个问题<br>B. 重新指定这个问题的负责人<br>C. 马上进行产品的返工<br>D. 发布一项变更申请 以采取必要的纠正措施<br>专业分析：通过质量审计获取的信息可以用于改善质量系统和业绩水平。在大多数情况下，<br>实施质量改善工作需要先准备变更要求。</li>
<li>在与几个项目干系人的会议中，干系人要求项目经理将项目工作范围内容扩大。这个项<br>目经理曾经接触过章程签字前有关项目的来往信函，他记得项目发起人明确地否定了这些项<br>目干系人提到的工作范围。项目经理最恰当的做法是：<br>A. 让项目发起人知道项目干系人的要求。（C）<br>B. 评估增加工作范围的影响<br>C. 告诉项目干系人，范围不能扩大。<br>D. 如果项目进度计划中有可用的时间，就加入该项工作。</li>
<li>项目发起人和你组织中的其他人反复地要求变更。当你努力实施一些变更时，你发现现<br>行的合同并不包括对评估变更的预算。你应该怎样做？ （C）<br>A. 请高级管理层从公司储备中拨更多的钱。<br>B.  告诉发起人项目中没有变更的预算。<br>C. 与发起人协商决定如何补救这个问题。<br>D. 把这件事直接交给合同/法律部门。</li>
<li>你不能确定在可交付成果的集成时你可能遇到什么问题，这对你的项目是一个风险，但<br>是你决定不在这个时间处理它。这是（D）的例子。<br>A. 风险规避<br>B. 风险转移<br>C. 风险减轻<br>D. 风险接受</li>
<li>决策树的最佳用途是（C）：<br>A. 确定风险量与预期值之间的相互作用。<br>B. 概率与事件风险说明的结合。<br>C. 图解说明如何领会决策和相关事件的相互作用。<br>D. 确定风险事件的标准偏差的流程图。</li>
<li>项目风险排序是下述风险管理过程哪部分的一项输入？（D）<br>A. 风险识别<br>B. 风险定性分析<br>C. 风险定量分析<br>D. 风险应对计划过程</li>
<li>在项目执行过程中，你被任命为项目经理。项目各项指标都在基准的容许范围内。但是，<br>客户对项目绩效不满意。你应该做的第一件事情是什么？（D）<br>A. 与项目团队一起讨论。<br>B. 重新计算基准。<br>C. 重新商谈合同。<br>D. 与客户见面。</li>
<li>在项目质量保证阶段，项目经理正与质量专家一起工作。他们正在执行下述（B）活动?<br>A. 质量控制。<br>B. 确定使用的是否是正确的质量标准。<br>C. 确定应该使用什么质量标准。<br>D. 按照标准评估质量。</li>
<li>一项分析显示，项目结束时你的项目将超出预算。你应该采取下面哪项行动？（A）<br>A. 考虑对项目进行赶工和/或快速跟进，然后评估可选方案。<br>B. 先拜见上级领导以寻求增加预算的可能性，然后召开团队会议。<br>C. 拜见客户以寻找避免已同意范围变更的成本。<br>D. 增加项目储备金。<br>赶工通常会增加成本而快速跟进通常会增加风险。风险的增加会导致应急储备的增加，但通<br>过缩短进度可以降低成本。对活动进行赶工通常会增加的这些活动的成本，但你可以通过缩<br>短进度来降低总成本。</li>
<li>假设你有一个项目包括以下五项任务：<br>任务 1 立刻开始，估计工期为 1 天<br>任务 2 在任务 1 完成后开始，估计工期为 4 天<br>任务 3 在任务 2 完成后开始，估计工期为 5 天<br>任务 4 在任务 1 完成后开始，估计工期为 8 天<br>任务 5 在任务 3 和 4 完成后开始，估计工期 1 天<br>在 PDM 中，任务 5 与任务 4 的关系是（D）<br>A. 开始完成关系<br>B. 完成完成关系<br>C. 开始开始关系<br>D. 完成开始关系</li>
<li>估算计划活动持续时间的依据来自于（A）<br>A. 项目团队最熟悉具体计划活动工作内容性质的个人或集体<br>B. 项目经理<br>C. 客户或业主<br>D. 工作分解结构</li>
<li>你的两个小组成员就一个小技术问题发生争执。你与他们会面，希望通过找到共识来解<br>决争端。你将采用哪种冲突解决方法：（B）<br>A. 退让<br>B. 淡化争议<br>C. 分辨对错，解决问题<br>D. 妥协</li>
<li>人力资源管理的主要程序是：（B）<br>A、组织设计，团队建设，资源规划，评优和奖励<br>B、组织规划 ,人员招募,团队发展<br>C、业主管理,团队发展，项目计划编制，项目相关者管理<br>D、员工规划，资源外购，团队发展，业主管理<br>参考答案：B</li>
<li>以下哪一项最能表现某个项目的特征(C)<br>A. 运用进度计划技巧<br>B. 整合范围与成本<br>C. 确定期限<br>D. 利用网络进行跟踪</li>
</ol>
]]></content>
      <categories>
        <category>课程学习</category>
        <category>软件项目管理</category>
      </categories>
      <tags>
        <tag>课程学习</tag>
        <tag>软件项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title>马克思题库</title>
    <url>/135xyq.github.io/2022/01/01/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E9%A9%AC%E5%85%8B%E6%80%9D%E9%A2%98%E5%BA%93/</url>
    <content><![CDATA[<h2 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h2><h3 id="单选"><a href="#单选" class="headerlink" title="单选"></a>单选</h3><ol>
<li><p>在纪念马克思诞辰200周年大会上，习近平指出：“人类社会发生了巨大而深刻的变化，但马克思的名字依然在世界各地受到人们的尊敬，马克思的学说依然闪烁着耀眼的真理光芒！”马克思主义之所以仍然闪耀真理的光芒是因为（）。<br>A. 它完成了对所有客观事物的认识<br>B. 它是检验认识真理性的唯一标准<br>C. 它正确反映了社会发展规律并具有与时俱进的理论品质<br>D. 它是任何条件下都必须全部照搬的<br>正确答案：C</p>
</li>
<li><p>（）标志着现代无产阶级作为独立的政治力量登上了历史舞台。<br>A. 资本主义生产方式在欧洲的普遍确立<br>B. 法国. 英国. 德国工人运动的兴起<br>C. 共产主义者同盟的成立<br>D. 马克思主义的公开问世<br>正确答案：B</p>
</li>
<li><p>（）在斗争中逐渐走向自觉，产生了对科学理论指导的需要，成为马克思主义的阶级基础。<br>A. 无产阶级<br>B. 小资产阶级<br>C. 地主阶级<br>D. 农民阶级<br>正确答案：A</p>
</li>
<li><p>表明马克思. 恩格斯完成从唯心主义向唯物主义. 从革命民主主义向共产主义的转变的是（）。<br>A. 1844年在《德法年鉴》上发表的论文<br>B. 1848年发表的《共产党宣言》<br>C. 1871年写成的《法兰西内战》<br>D. 1878年写成的《反杜林论》<br>正确答案：A</p>
</li>
<li><p>由马克思. 恩格斯合作写作的（）首次系统阐释了历史唯物主义的基本观点。<br>A. 《黑格尔法哲学批判》<br>B. 《德意志意识形态》<br>C. 《资本论》<br>D. 《反杜林论》<br>正确答案：B</p>
</li>
<li><p>马克思. 恩格斯接受国际性工人组织“正义者同盟”的邀请，为其起草了第一个无产阶级政党的党纲（）。<br>A. 《共产党宣言》<br>B. 《论犹太人问题》<br>C. 《政治经济学批判》<br>D. 《英国工人阶级状况》<br>正确答案：A</p>
</li>
<li><p>1876年至1878年，恩格斯写出了（），全面阐述了马克思主义理论体系。<br>A. 《神圣家族》<br>B. 《哥达纲领批判》<br>C. 《反杜林论》<br>D. 《家庭. 私有制和国家的起源》<br>正确答案：C</p>
</li>
<li><p>19世纪末到20世纪初，（）成为帝国主义体系中最薄弱的环节，为无产阶级革命首先在此发生并取得胜利创造了有利条件。<br>A. 美国<br>B. 法国<br>C. 德国<br>D. 俄国<br>正确答案：D</p>
</li>
<li><p>列宁深刻分析了19世纪末20世纪初世界历史条件的变化，认为资本主义发达国家已经发展到（）。<br>A. 自由竞争阶段<br>B. 垄断阶段<br>C. 生产集中阶段<br>D. 帝国主义阶段<br>正确答案：D</p>
</li>
<li><p>在帝国主义阶段，除无产阶级与资产阶级矛盾外，（）成为资本主义世界的又一重大矛盾。<br>A. 农民阶级与地主阶级的矛盾<br>B. 垄断资本家与小商品生产者的矛盾<br>C. 金融资本与实体产业的矛盾<br>D. 帝国主义和殖民地半殖民地国家的民族矛盾<br>正确答案：D</p>
</li>
<li><p>列宁和布尔什维克党领导了（），是社会主义从理想开始变为现实，开创了世界历史的新纪元。<br>A. 二月革命<br>B. 四月政变<br>C. 十月革命<br>D. 雾月政变<br>正确答案：C</p>
</li>
<li><p>列宁在领导俄国革命和建设过程中，把马克思主义与俄国实际相结合，创立了（），把马克思主义发展到一个新的历史阶段。<br>A. 列宁主义<br>B. 伯恩斯坦主义<br>C. 修正主义<br>D. 无政府主义<br>正确答案：A</p>
</li>
<li><p>习近平指出：“马克思创建了唯物史观和剩余价值学说，揭示了人类社会发展的一般规律，揭示了资本主义运行的特殊规律，为人类指明了从必然王国向自由王国飞跃的途径。”这集中体现了马克思主义的（）特征。<br>A. 科学性<br>B. 实践性<br>C. 革命性<br>D. 发展性<br>正确答案：A</p>
</li>
<li><p>恩格斯指出：“马克思的整个世界观不是教义，而是方法。它提供的不是现成的教条，而是进一步研究的出发点和供这种研究使用的方法。”这集中体现了马克思主义的（）特征。<br>A. 人民性<br>B. 发展性<br>C. 革命性<br>D. 科学性<br>正确答案：B</p>
</li>
<li><p>马克思主义的政治立场是（）。<br>A. 人民至上<br>B. 政党至上<br>C. 集团至上<br>D. 利益至上<br>正确答案：A</p>
</li>
<li><p>“江山就是人民. 人民就是江山，打江山. 守江山，守的是人民的心”集中体现了马克思主义的（）特征。<br>A. 人民性<br>B. 科学性<br>C. 革命性<br>D. 发展性<br>正确答案：A</p>
</li>
<li><p>马克思在《关于费尔巴哈的提纲》中提出：“哲学家们只是用不同的方式解释世界，而问题在于改变世界。”这集中体现了马克思主义的（）特征。<br>A. 人民性<br>B. 科学性<br>C. 实践性<br>D. 发展性<br>正确答案：C</p>
</li>
<li><p>（）观点是马克思主义首要的和基本的观点。<br>A. 实践<br>B. 认识<br>C. 物质<br>D. 价值<br>正确答案：A</p>
</li>
<li><p>德国古典哲学是马克思主义哲学的直接理论来源，马克思恩格斯批判地吸取了黑格尔哲学的（）。<br>A. 唯物主义思想<br>B. 辩证法思想<br>C. 劳动价值论<br>D. 唯物史观<br>正确答案：B</p>
</li>
</ol>
<h3 id="多选"><a href="#多选" class="headerlink" title="多选"></a>多选</h3><ol>
<li><p>马克思主义是由马克思和恩格斯创立并为后继者所不断发展的科学理论体系，是（）. 是指引人民创造美好生活的行动指南。<br>A. 关于自然. 社会和人类思维发展一般规律的学说<br>B. 关于社会主义必然代替资本主义. 最终实现共产主义的学说<br>C. 关于无产阶级解放全人类解放和每个人自由而全面发展的学说<br>D. 无产阶级政党和社会主义国家的指导思想<br>正确答案：ABCD</p>
</li>
<li><p>马克思主义的基本观点包括（）等一系列观点。<br>A. 关于世界统一于物质. 物质决定意识的观点<br>B. 关于实践和认识辩证关系的观点<br>C. 关于人与自然和谐共生的观点<br>D. 关于世界历史的观点<br>正确答案：ABCD</p>
</li>
<li><p>习近平指出：“中国共产党根基在人民. 血脉在人民. 力量在人民。”这体现了马克思主义的基本立场，即以无产阶级的解放和全人类的解放为己任. 以人的自由全面发展为美好目标. （）。<br>A. 以人民为中心<br>B. 一切为了人民<br>C. 一切依靠人民<br>D. 全心全意为人民谋幸福<br>正确答案：ABCD</p>
</li>
<li><p>马克思. 恩格斯所生活的时代，资本主义在西欧已经有了相当的发展，资本主义生产方式在促进生产发展的同时造成了（），带来如何说明资本主义这个怪物. 人类的未来在哪里等问题。<br>A. 社会分工向自给自足经济退化<br>B. 社会两极分化<br>C. 经济危机周期性爆发<br>D. 农民对于土地依附关系加强<br>正确答案：BC</p>
</li>
<li><p>19世纪西欧（）三大思潮为马克思主义的创立提供了直接的理论来源。<br>A. 德国古典哲学<br>B. 英国古典政治经济学<br>C. 英法两国的空想社会主义<br>D. 法国理性主义<br>正确答案：ABC</p>
</li>
<li><p>19世纪（）三大科学发现，为马克思主义提供了自然科学前提。<br>A. 作用力与反作用力定律<br>B. 细胞学说<br>C. 能量守恒与转化定律<br>D. 生物进化论<br>正确答案：BCD</p>
</li>
<li><p>列宁指出：“马克思的全部天才正是在于他回答了人类先进思想已经提出的种种问题。他的学说的产生正是哲学. 政治经济学和社会主义极伟大的代表人物的学说的直接继续。”马克思学说直接继续的“代表人物的学说”包括（）。<br>A. 黑格尔的辩证法思想<br>B. 亚当·斯密等人对劳动和价值的分析<br>C. 圣西门等人的社会主义思想<br>D. 孟德斯鸠等人的“三权分立”思想<br>正确答案：ABC</p>
</li>
<li><p>“马克思主义同‘宗派主义’毫无相似之处，它绝不是离开世界文明发展大道而产生的一种固步自封. 僵化不变的学说”，这说明马克思主义（）。<br>A. 是社会发展的产物<br>B. 回应了时代所提出的课题<br>C. 是对人类文明优秀成果的继承<br>D. 随时代发展而不断丰富<br>正确答案：ABCD</p>
</li>
<li><p>（）是马克思一生的两个伟大发现。<br>A. 劳动价值论<br>B. 剩余价值学说<br>C. 唯物主义<br>D. 唯物史观<br>正确答案：BD</p>
</li>
<li><p>中国共产党在革命. 建设. 改革的进程中不断推进马克思主义中国化，产生了毛泽东思想. （）等理论成果，丰富和发展了马克思主义。<br>A. 邓小平理论<br>B. “三个代表”重要思想<br>C. 科学发展观<br>D. 习近平新时代中国特色社会主义思想<br>正确答案：ABCD</p>
</li>
<li><p>马克思主义具有鲜明的（），这些特征体现了马克思主义的本质和使命。<br>A. 科学性<br>B. 人民性<br>C. 实践性<br>D. 发展性<br>正确答案：ABCD</p>
</li>
<li><p>马克思关于哲学. 政治经济学. 科学社会主义的观点，最终升华为马克思主义的根本原因是（）。<br>A. 马克思对所处的时代和世界的深入考察<br>B. 马克思对人类社会发展规律的深刻把握<br>C. 马克思远超前人的才华与天赋<br>D. 马克思丰富的求学经历<br>正确答案：AB</p>
</li>
<li><p>马克思主义具有科学的世界观和方法论基础，即（）。<br>A. 辩证唯物主义<br>B. 历史唯物主义<br>C. 直观唯物主义<br>D. 朴素唯物主义<br>正确答案：AB</p>
</li>
<li><p>人民群众是历史的创造者，是社会主义事业的依靠力量，这要求马克思主义政党必须（）。<br>A. 把人民放在心中最高位置<br>B. 一切奋斗都致力于实现最广大人民的根本利益<br>C. 一切为了人民，一切依靠人民<br>D. 全心全意为人民谋幸福<br>正确答案：ABCD</p>
</li>
<li><p>当前世界正经历百年未有之大变局，必须坚持与时俱进，继续丰富和发展马克思主义，要（）。<br>A. 既坚持马克思主义基本原理，又谱写新的理论篇章<br>B. 既发扬优良传统，又创造新鲜经验<br>C. 在解放思想中统一思想<br>D. 用发展的马克思主义指导新的实践<br>正确答案：ABCD</p>
</li>
<li><p>马克思主义之所以能够作为观察当代世界的认识工具，是因为（）。<br>A. 马克思主义能够站在科学和时代的制高点上观察事物和现象<br>B. 马克思主义掌握了人类社会发展的规律，具有唯物辩证的科学方法<br>C. 马克思主义善于透过现象看本质，能够把握住问题实质<br>D. 能够从运动中看到变化，从变化中看到发展<br>正确答案：ABCD</p>
</li>
<li><p>2019年，英国《泰晤士报》报道说，金融危机使西方人突然重视马克思的《资本论》了，“马克思再一次成为了时髦”。德国马克思故居展览馆馆长曾说“我记不清听到人们这样讲了多少次：‘这个人是对的’”。马克思能够再次成为时髦是因为（）。<br>A. 世界仍处于马克思所指明的从资本主义走向社会主义的大时代<br>B. 马克思所揭示的资本主义基本矛盾仍然存在<br>C. 马克思主义揭示了人类社会发展规律<br>D. 社会主义已经代替了资本主义<br>正确答案：ABC</p>
</li>
<li><p>马克思主义对于人类走向未来具有不可缺少的启示和引领价值，我们要（）。<br>A. 用马克思主义观察时代<br>B. 用马克思主义把握时代<br>C. 用马克思主义引领时代<br>D. 把中国特色社会社会主义和人类进步事业不断推向前进<br>正确答案：ABCD</p>
</li>
<li><p>新时代中国大学生的素质尤其是思想政治素质如何，关系到实现全面建设社会主义现代化强国的宏伟目标，学习马克思主义理论应（）。<br>A. 努力学习和掌握马克思主义的基本立场. 观点. 方法<br>B. 努力学习和掌握马克思主义中国化的理论成果<br>C. 坚持理论联系实际的马克思主义学风<br>D. 自觉将马克思主义内化于心<br>正确答案：ABCD</p>
</li>
</ol>
<h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3><ol>
<li><p>相对于特定历史条件下的个别理论判断，马克思主义基本原理具有普遍的. 根本的和长远的指导意义。<br>对</p>
</li>
<li><p>马克思主义仅仅是马克思和恩格斯两个人的学说的总和。<br>错</p>
</li>
<li><p>马克思主义哲学. 马克思主义政治经济学和科学社会主义构成马克思主义的全部内容。<br>错</p>
</li>
<li><p>马克思主义哲学是对德国古典哲学的完全继承。<br>错</p>
</li>
<li><p>马克思主义就是德国古典哲学. 英国古典政治经济学和空想社会主义的总和。<br>错</p>
</li>
<li><p>19世纪20世纪末，资本主义出现了马克思恩格斯生前不曾有的新特点，经济政治发展的不平衡成为资本主义发展的绝对规律。<br>对</p>
</li>
<li><p>社会主义革命可能在一国或数国首先发生并取得胜利的论断，是列宁在分析帝国主义的经济基础. 深刻矛盾和统治危机基础上提出的。<br>对</p>
</li>
<li><p>习近平新时代中国特色社会主义思想是马克思主义中国化最新理论成果，是全党全国人民为实现中华民族伟大复兴而奋斗的行动指南。<br>对</p>
</li>
<li><p>辩证唯物主义和历史唯物主义是马克思主义的一个突出特征和理论优势。<br>对</p>
</li>
<li><p>无产阶级解放和全人类解放是完全一致的。<br>对</p>
</li>
<li><p>观察当今世界局势和社会发展，不仅要看到现状，更要看到未来，因此需要马克思主义辩证思想的深邃目光。<br>对</p>
</li>
<li><p>中国现代化建设取得的举世瞩目的伟大成就，是马克思主义的现实指导作用和当代价值的最直接. 最可靠的证明。<br>对</p>
</li>
<li><p>为中国人民谋幸福，为中华民族谋复兴的初心和使命是激励中国共产党人不断前进的根本动力。<br>对</p>
</li>
<li><p>当今世界发展日新月异，与马克思所处时代相比已经发生了巨大而深刻的变化，马克思主义已经不再适用。<br>错</p>
</li>
<li><p>学习马克思主义最根本的是要掌握马克思主义的基本立场. 观点. 方法，领会马克思主义的精髓要义。<br>对</p>
</li>
</ol>
<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="单选-1"><a href="#单选-1" class="headerlink" title="单选"></a>单选</h3><ol>
<li><p>对（）问题的不同回答，形成了唯物主义和唯心主义两种根本对立的哲学派别。<br>A. 存在和思维何者为第一性的问题<br>B. 存在和思维是否具有同一性的问题<br>C. 谁是社会历史的创造者问题<br>D. 认识的本质和来源问题<br>正确答案：A</p>
</li>
<li><p>对（）问题的不同回答，形成了可知论和不可知论两种根本对立的哲学派别。<br>A. 存在和思维何者为第一性的问题<br>B. 存在和思维是否具有同一性的问题<br>C. 谁是社会历史的创造者问题<br>D. 认识的本质和来源问题<br>正确答案：B</p>
</li>
<li><p>把世界的本原归结为某种或某几种具体物质形态的观点属于( )。<br>A. 形而上学唯物主义<br>B. 朴素唯物主义<br>C. 唯心主义<br>D. 辩证唯物主义<br>正确答案：B</p>
</li>
<li><p>亚里士多德曾说：“最早的哲学家大都认为万物的唯一原理是物质本性的原理……这类哲学的创始人泰勒斯称该原理是水……”，这种“最早的哲学家”的观点属于（）。<br>A. 主观唯心主义<br>B. 客观唯心主义<br>C. 朴素唯物主义<br>D. 机械唯物主义<br>正确答案：C</p>
</li>
<li><p>桓谭在《新论·祛蔽》中说:“精神居形体，犹火之燃烛矣。……烛无，火亦不能独行于空虚。”这种认为精神没有了形体就不能存在的观点属于（）。<br>A. 唯物主义<br>B. 唯心主义<br>C. 可知论<br>D. 不可知论<br>正确答案：A</p>
</li>
<li><p>贝克莱曾说：“只要闭上眼睛，世界上就没有什么悬崖”，这种观点属于（）。<br>A. 唯物主义<br>B. 唯心主义<br>C. 可知论<br>D. 不可知论<br>正确答案：B</p>
</li>
<li><p>古希腊哲学家皮浪认为：“感觉是我们认知外在世界的唯一通道，但感觉又是不真实的。因为感觉并不能告诉我们什么是真理，什么是错误。我们一点也不能相信它们。”这种观点属于（）。<br>A. 唯物主义<br>B. 唯心主义<br>C. 可知论<br>D. 不可知论<br>正确答案：D</p>
</li>
<li><p>“鹅湖之会”是中国哲学史上著名的辩论，朱熹同陆氏兄弟围绕“教人之法”展开激烈辩论。朱熹主张格物致知，穷尽事物之理，陆九渊则主张心即理，发明本心。从哲学角度看，这场辩论的实际上是（）。<br>A. 可知论和不可知论之争<br>B. 朴素唯物主义和辩证唯物主义之争<br>C. 客观唯心主义同主观唯心主义之争<br>D. 机械唯物主义同朴素唯物主义之争<br>正确答案：C</p>
</li>
<li><p>1803年英国化学家约翰·道尔顿发表“原子说”，提出所有物质都是由原子构成。 随着科学发展，原子的存在进一步被证实。受此影响，近代部分哲学家认为物质的本质就是原子，这种观点的局限是（）。<br>A. 不能正确认识物质和意识何者为第一性的问题<br>B. 不能正确认识意识能否正确反映存在的问题<br>C. 不能正确理解哲学的物质概念与自然科学物质概念之间共性与个性的关系<br>D. 不能正确理解社会存在和社会意识的关系<br>正确答案：C</p>
</li>
<li><p>马克思主义的物质范畴从现实存在着的自然存在与社会存在中抽象出其共同特性，即（）。<br>A. 客观实在性<br>B. 主观能动性<br>C. 形式统一性<br>D. 相对独立性<br>正确答案：A</p>
</li>
<li><p>马赫主义主张世界第一性的东西既不是物质也不是精神，而是感觉经验，强调一切科学理论都不过是假说，不存在真实的外部世界。马赫主义的观点从根本上否认了物质世界的（）。<br>A. 主观能动性<br>B. 统一性<br>C. 多样性<br>D. 客观实在性<br>正确答案：D</p>
</li>
<li><p>费尔巴哈主张感觉能够给人揭示客观真理，认为“我的感觉是主观的，可是它的基础是客观的”，这说明物质（）。<br>A. 能够被感觉所复写<br>B. 和感觉完全同一<br>C. 不能被感觉所认识<br>D. 是感觉的派生物<br>正确答案：A</p>
</li>
<li><p>《坛经》中记载：“时有风吹幡动。一僧曰风动，一僧曰幡动。议论不已。惠能进曰：‘非风动，非幡动，仁者心动。’” 从辩证唯物主义来看，这种观点的局限性在于（）。<br>A. 认为世界不能被感知<br>B. 认为世界依赖于感觉而存在<br>C. 认为客观精神是世界的本源<br>D. 认为存在绝对静止<br>正确答案：B</p>
</li>
<li><p>马克思主义的物质范畴对物质作出了全面的科学规定，这一范畴（）。<br>A. 是对费尔巴哈的完全继承<br>B. 是一切人在生动的人类实践中作出的<br>C. 是对旧唯物主义的完全继承<br>D. 是对自然界的直观复写<br>正确答案：B</p>
</li>
<li><p>物质的根本属性是（）。<br>A. 运动<br>B. 静止<br>C. 时间<br>D. 空间<br>正确答案：A</p>
</li>
<li><p>列宁认为：“世界上除了运动着的物质之外，什么也没有”，这种观点属于（）。<br>A. 否认意识能动性的直观唯物主义<br>B. 否认世界可知性的经验批判主义<br>C. 认为运动是物质的根本属性的辩证唯物主义<br>D. 认为世界运转永恒不变的机械唯物主义<br>正确答案：C</p>
</li>
<li><p>运动就其作为哲学范畴而言，标志着（）。<br>A. 单纯空间位置的变动<br>B. 理论思维的发展过程<br>C. 时间的发展延伸<br>D. 一切事物和现象的变化及其过程<br>正确答案：D</p>
</li>
<li><p>毛泽东曾说：“人的认识物质，就是认识物质的运动形式”，这是因为（）。<br>A. 物质的静止状态不可认识<br>B. 物质本身不可认识<br>C. 物质和运动不可分离<br>D. 意识和运动直接同一<br>正确答案：C</p>
</li>
<li><p>马克思指出：“物体. 存在. 实体是同一种实在的观念。决不可以把思维同那思维着的物质分开。物质是一切变化的主体。”这说明（）。<br>A. 运动是物质的运动<br>B. 思维并不存在<br>C. 运动就是思维的运动<br>D. 物质依赖于思维而存在<br>正确答案：A</p>
</li>
<li><p>“风定花犹落，鸟鸣山更幽”形象地表达了动和静的辩证关系是（）。<br>A. 静不是动，动不是静<br>B. 动是必然的，静是偶然的<br>C. 运动和静止相互依赖. 相互渗透. 相互包含<br>D. 动是静的原因，静是动的结果<br>正确答案：C</p>
</li>
<li><p>明代诗人曾写道：“空手把锄头，步行骑水牛。人在桥上走，桥流水不流。”从辩证唯物主义来理解，“水不流”体现的是（）。<br>A. 物质运动的变动性<br>B. 物质运动的稳定性<br>C. 物质运动的一维性<br>D. 物质运动的三维性<br>正确答案：B</p>
</li>
<li><p>内稳态是生物学的一个定义，属于稳态的一种，表示生物通过神经-体液-免疫系统协同工作而维持的一种自身内部相对稳定的状态。内稳态的存在体现了（）。<br>A. 物质世界的运动是相对的<br>B. 物质运动过程中存在相对静止<br>C. 存在着不运动的物质<br>D. 相对静止的无条件性<br>正确答案：B</p>
</li>
<li><p>钱钟书在《管锥编》中写道：“寂静之幽深者，每以得声音衬托而愈觉其深”。以下各项中，与这句话体现的道理相同的是（）。<br>A. 物方生方死<br>B. 人一次也不能踏进同一条河流<br>C. 蝉噪林逾静，鸟鸣山更幽<br>D. 沉舟侧畔千帆过，病树前头万木春<br>正确答案：C</p>
</li>
<li><p>王安石对诗句“蝉噪林逾静，鸟鸣山更幽”十分喜爱，并在自己的《钟山绝句》将其改为“茅檐相对坐终日，一鸟不鸣山更幽”。黄庭坚评价他的这一改动为“点金成铁”，从哲学的角度看，这是因为（）。<br>A. 忽视了物质和运动不可分割的关系<br>B. 忽视了物质运动的无条件性<br>C. 忽视了运动与静止的对立统一关系<br>D. 忽视了物质运动与时空的紧密关联<br>正确答案：C</p>
</li>
<li><p>2021年6月17日，神舟十二号载人飞船成功对接于天和核心舱前向端口。在对接中，宇宙飞船首先以相同的速度与空间站同步移动，同步后，与其对接端口相连，这主要利用了（）。<br>A. 物质运动中空间的相对位置暂时不变<br>B. 事物的根本性质暂时不变<br>C. 静止的绝对性<br>D. 静止的无条件性<br>正确答案：A</p>
</li>
<li><p>时间是物质运动的持续性. 顺序性，特点是（）。<br>A. 一维性<br>B. 相对性<br>C. 主观性<br>D. 能动性<br>正确答案：A</p>
</li>
<li><p>空间是指物质运动的广延性，特点是（）。<br>A. 三维性<br>B. 多元性<br>C. 独立性<br>D. 主观性<br>正确答案：A</p>
</li>
<li><p>“盛年不再来，一日难再晨”体现的是（）。<br>A. 空间的三维性<br>B. 时间的一维性<br>C. 运动的相对性<br>D. 意识的主观性<br>正确答案：B</p>
</li>
<li><p>牛顿主张绝对的时空观，他曾提出“时间. 空间是一切事物的储藏所”，这种观点的局限性在于（）。<br>A. 否认了物质与运动的不可分割<br>B. 否认了时空与物质运动的不可分割<br>C. 否认了时间与空间的不可分割<br>D. 否认了运动与静止的不可分割<br>正确答案：B</p>
</li>
<li><p>诗人文嘉在《明日歌》中写道：“世人皆被明日累，明日无穷老将至。”“明日无穷老将至”所蕴含的哲学原理是（）。<br>A. 具体物质形态时空的有限性<br>B. 静止的无条件性<br>C. 空间的一维性<br>D. 整个物质世界时空的有限性<br>正确答案：A</p>
</li>
<li><p>经典力学中有一种观点认为时间是“永远均匀流动的，它不依赖于任何外界事物。”这观点属于（）。<br>A. 主观唯心主义<br>B. 朴素唯物主义<br>C. 辩证唯物主义<br>D. 机械唯物主义<br>正确答案：D</p>
</li>
<li><p>医学科学证明，如果人的大脑皮层受损，就会丧失思维能力，没有意识，这说明（）。<br>A. 人脑是意识内容的唯一来源<br>B. 人脑健康自然会有正确的意识<br>C. 人脑是意识的物质器官<br>D. 意识是对外界事物的正确反映<br>正确答案：C</p>
</li>
<li><p>“意识在任何时候都只能是被意识到了的存在，而人们的存在就是他们现实生活的过程”说明（）。<br>A. 意识本质上是客观世界的映像<br>B. 意识在形式和内容上都是客观的<br>C. 意识就是人们的现实生活<br>D. 意识是对现实生活的正确反映<br>正确答案：A</p>
</li>
<li><p>随着分工的发展，“意识才能现实地想象：它是和现存实践的意识不同的某种东西”，这说明（）。<br>A. 分工是意识的唯一来源<br>B. 社会实践特别是劳动，在意识发展中起着决定作用<br>C. 意识是分工条件下的特殊存在<br>D. 分工条件下意识摆脱现实获得完全独立性<br>正确答案：B</p>
</li>
<li><p>马克思. 恩格斯指出：“语言是一种实践的. 既为别人存在因而也为我自身而存在的. 现实的意识。”以下关于语言的说法中，错误的是（）。<br>A. 劳动和交往的需要是语言产生的基础<br>B. 语言的产生促进了意识的发展<br>C. 语言是意识的本体和来源<br>D. 语言的产生促进了生产和交往的发展<br>正确答案：C</p>
</li>
<li><p>中国古代提到月亮往往想到广寒宫等神话形象，而如今即使是小朋友们，也知道月亮是围绕地球旋转的一颗卫星。对月亮认知的变化来自于（）。<br>A. 社会实践的发展<br>B. 科学家的主观设想<br>C. 对月亮理念的回忆<br>D. 意识自身的进化<br>正确答案：A</p>
</li>
<li><p>马克思在批判费尔巴哈时指出：“樱桃树被移植到这个地区，才有对于樱桃树的“感性确定性”，这说明（）。<br>A. 意识是客观世界的主观映象<br>B. 感性认识是对世界的正确认识<br>C. 人的认识只能来自于直接经验<br>D. 物质和意识完全同一<br>正确答案：A</p>
</li>
<li><p>1920年10月，一位印度传教士在印度加尔各答的丛林中发现两个狼哺育的女孩，这两个女孩被人称为“狼孩”。在大脑结构上，狼孩和同龄人没多大差别，但智力缺不足同龄人的十分之一。这说明（）。<br>A. 意识是人的本质<br>B. 意识来源于人脑<br>C. 社会实践在意识发展中具有决定作用<br>D. 意识形式上是客观的<br>正确答案：C</p>
</li>
<li><p>马克思指出，人在“劳动过程结束时得到的结果，在这个过程开始时就已经在劳动者的表象中存在着，即已经观念地存在着”，这体现了（）。<br>A. 意识活动具有目的性和计划性<br>B. 意识活动具有创造性<br>C. 意识活动能够调控人的行为和生理活动<br>D. 意识活动具有客观性<br>正确答案：A</p>
</li>
<li><p>麒麟是中国传统瑞兽，融合了狮头. 麋身. 牛尾. 马蹄，麒麟的形象塑造体现了（）。<br>A. 意识是人脑的机能和属性<br>B. 意识是客观世界的直观反映<br>C. 意识活动具有目的性和计划性<br>D. 意识活动具有创造性<br>正确答案：D</p>
</li>
<li><p>听乐队合奏时，听觉注意力能够集中到某件乐器的声音上，此时其它乐器演奏的声音虽然也会被耳朵接收，却会被大脑皮层抑制，其信号也就被弱化和边缘化了。这说明（）。<br>A. 意识能够根据一定的目的和要求确定反映什么. 不反映什么<br>B. 意识能够摆脱物质的纠缠自主创造内容<br>C. 大脑皮层是意识的内容来源<br>D. 意识能够在思维中构造出一个现实中没有的世界<br>正确答案：A</p>
</li>
<li><p>2021年3月11日，十三届全国人大四次会议表决通过了《关于国民经济和社会发展第十四个五年规划和2035年远景目标纲要的决议》。制定五年规划对我国经济社会发展具有重要意义，五年规划的制定说明意识（）。<br>A. 具有目的性和计划性<br>B. 能够直观反映现实<br>C. 在内容上是主观的<br>D. 能够任意对感性材料加工创造<br>正确答案：A</p>
</li>
<li><p>我国古典小说《三国演义》写诸葛亮用木马车送粮，而不是用汽车；《西游记》中的孙悟空能做到七十二变，可就是变不出计算机。这说明（）。<br>A. 人们的立场不同，所以认识就不同<br>B. 意识的内容来自客观事物<br>C. 古代文学家思想保守，不善于联想，想象力不够<br>D. 人们的思想认识被局限于现实，不能有丝毫逾越<br>正确答案：B</p>
</li>
<li><p>鲁迅在评价《红楼梦》时曾说：“就因读者的眼光而有种种：经学家看见《易》，道学家看见淫， 才子看见缠绵，革命家看见排满，流言家看见宫闱秘事……。”这说明（）。<br>A. 意识对现实的反映具有主体选择性<br>B. 间接经验不能带来新的认识<br>C. 人所见的现实不过是自身意识的重现<br>D. 文学作品不是客观实在<br>正确答案：A</p>
</li>
<li><p>2021年10月14日，“羲和号”卫星升空，中国正式进入探日时代。太阳与地球相伴亿万年，或许人类从诞生之日起，就对太阳产生了浓厚的兴趣，面对太阳产生无限遐想，中国古代就有“夸父追日”“后羿射日”等神话传说。这些传说的产生所体现的意识的能动作用是（）。<br>A. 现实性<br>B. 选择性<br>C. 创造性<br>D. 直观性<br>正确答案：C</p>
</li>
<li><p>2021中国科幻大会推出沉浸式科幻产业展，其时空语境建立在多年以后，以“科幻共同体”为主题，打造在一艘太空飞船一日生活的沉浸式科幻体验场景。对多年以后时空语境的设想体现了（）。<br>A. 意识是客观世界的客观映像<br>B. 意识能够在思维中构造一个现实中没有的观念世界<br>C. 意识能够脱离现实自由畅想<br>D. 时空可以在现实物质运动之外被感知<br>正确答案：B</p>
</li>
<li><p>“羲和号”开启了中国的探日时代，然而在此之前，许多中国科幻小说中已经有了对太阳的“详尽”描述，这体现了意识的（）。<br>A. 反映特性<br>B. 能动作用<br>C. 现实性<br>D. 客观性<br>正确答案：B</p>
</li>
<li><p>孙中山曾说：“吾心信其可行，则移山填海之难，终有成功之日”，这说明（）。<br>A. 所有的设想都能变为现实<br>B. 意识坚定程度决定了未来的现实<br>C. 意识具有调控人的行为. 影响实践结果的作用<br>D. 决心是目标实现的根本原因<br>正确答案：C</p>
</li>
<li><p>马克思曾指出：“通过实践创造对象世界，即改造无机界，人证明自己是有意识的类存在物”，这说明（）。<br>A. 意识的具有改造客观世界的能动作用<br>B. 意识能够直接创造现实<br>C. 意识是第一性的，无机界是派生的<br>D. 意识是实践的源泉<br>正确答案：A</p>
</li>
<li><p>俗话说“笑一笑，十年少”，苏东坡曾言“百年须笑三万六千场”，现代医学也证明由衷的笑有益于身心健康。从哲学上看，笑的作用体现了（）。<br>A. 意识的反映特性<br>B. 意识形式上的客观性<br>C. 意识活动能够调控人的行为和生理活动<br>D. 意识具有目的性和计划性<br>正确答案：C</p>
</li>
<li><p>一项医学研究表明乐观有助改善新陈代谢. 减轻炎症反应等，乐观者与悲观者相比，全因死亡风险低14%。这说明（）。<br>A. 心态决定着寿命的长短<br>B. 只有乐观的意识能够改造世界<br>C. 乐观的意识能够影响人的生理活动<br>D. 乐观的意识是对世界的正确反映<br>正确答案：C</p>
</li>
<li><p>列宁指出：“世界不会满足人，人决心以自己的行动来改变世界。”这种观点属于（）。<br>A. 将意识与物质相割裂的二元论<br>B. 认为意识具有第一性的唯心主义<br>C. 承认意识能动作用的辩证唯物主义<br>D. 认为环境决定人的机械唯物主义<br>正确答案：C</p>
</li>
<li><p>“人有多大胆，地有多大产”的观点的错误在于（）。<br>A. 夸大了矛盾的特殊性<br>B. 夸大了运动的绝对性<br>C. 夸大了真正的相对性<br>D. 夸大了意识的能动性<br>正确答案：D</p>
</li>
<li><p>“巧妇难为无米之炊”说明（）。<br>A. 发挥主观能动性必须以尊重客观规律为前提<br>B. 意识无法影响现实<br>C. 物质材料是发挥主观能动性的根本途径<br>D. 客观规律不可认识<br>正确答案：A</p>
</li>
<li><p>早在公元前1200年，人类就已经有了关于“永动机”的设想，不同时代. 不同国家的科学家们都曾为此付出探索，但“永动机”一直没有实现。“永动机”无法被制造说明（）。<br>A. 人类在客观规律面前无能为力<br>B. 主观能动性必须以客观规律为前提<br>C. 人类实践不能改造世界<br>D. 物质运动并不是绝对的<br>正确答案：B</p>
</li>
<li><p>马克思认为：“物质的力量只能用物质力量来摧毁；但是理论一经掌握群众，也会变成物质力量”，这说明（）。<br>A. 物质力量来源于意识<br>B. 意识活动具有创造性<br>C. 物质力量与意识力量二元对立<br>D. 通过实践，正确的认识能够变为物质力量<br>正确答案：D</p>
</li>
<li><p>2021世界人工智能大会在上海拉开帷幕，会场内，嘉宾与全球首个火星车数字人“祝融号”相谈甚欢，虚拟主持人“泠鸢”和大会主持人一起为观众来了一场“脱口秀”，人工智能的智能在本质上是（）。<br>A. 机器的自主意识<br>B. 机器在实践中形成的对现实的反映<br>C. 人的部分智能活动的机器化<br>D. 机器主观能动性的体现<br>正确答案：C</p>
</li>
<li><p>由谷歌开发的人工智能围棋软件AlphaGo连续打败世界围棋冠军，AlphaGo既可以结合树状图的长远推断，又可像人类的大脑一样自发学习进行直觉训练，这说明（）。<br>A. 人工智能已经能够取代人类智能<br>B. 智能机器具备了人类意识<br>C. 智能机器实质上是对的思维机制的模仿<br>D. 智能机器能够进行实践活动<br>正确答案：C</p>
</li>
<li><p>随着人工智能的兴起，互联网上掀起一场“你会和人工智能谈恋爱吗”的讨论。从哲学意识观角度看，这场讨论的根源是人们意识到人工智能很难具备（）。<br>A. 人类的外表<br>B. 人类的计算能力<br>C. 人类的语言<br>D. 人类的情感<br>正确答案：D</p>
</li>
<li><p>商场的导引机器人或者是餐饮行业所使用的服务机器人，或者是智能手机配备的智能语音机器人都能和人类进行简单的沟通，这说明（）。<br>A. 机器人完全具备理解自然语言的能力<br>B. 人工智能以人类语言为基础<br>C. 机器人能够对人类语言进行物化模仿<br>D. 机器人基本自主交往实践能力<br>正确答案：C</p>
</li>
<li><p>2021年9月25日，中国《新一代人工智能伦理规范》发布，为人工智能特定活动制定了伦理规范，这说明（）。<br>A. 人工智能发展不利于社会应及时终止<br>B. 在利用人工智能的同时要加强风险研判和防范<br>C. 人工智能和人类一样是自主的社会伦理主体<br>D. 人工智能具备行为后果意识和自律意识<br>正确答案：B</p>
</li>
<li><p>客观世界的万事万物都处于普遍联系之中，这属于（）的观点。<br>A. 形而上学唯物主义<br>B. 唯物辩证法<br>C. 形而上学唯心主义<br>D. 唯心主义历史观<br>正确答案：B</p>
</li>
<li><p>恩格斯指出：“当我们通过思维来考察自然界或人类历史或我们自己的精神活动的时候，首先呈现在我们眼前的，是一幅由种种联系和相互作用无穷无尽地交织起来的画面。”这说明（）。<br>A. 思维不能彻底认识世界<br>B. 整个世界是普遍联系的<br>C. 世界联系性是思维的产物<br>D. 联系只在思维逻辑中存在<br>正确答案：B</p>
</li>
<li><p>以下各项中，所反映出的辩证法原理，与“城门失火，殃及池鱼”相同的是（）。<br>A. 揠苗助长<br>B. 刮目相看<br>C. 唇亡齿寒<br>D. 刻舟求剑<br>正确答案：C</p>
</li>
<li><p>恩格斯指出，15世纪的自然科学“把自然界分解为各个部分，把各种自然过程分成一定门类……这种做法给我们留下一个习惯：把各种自然和自然过程孤立起来”。这种自然科学的局限是（）。<br>A. 忽略了事物自身的运动<br>B. 割裂了世界的普遍联系<br>C. 否定了物质的第一性<br>D. 排斥了意识的能动作用<br>正确答案：B</p>
</li>
<li><p>“任何一个有机体，在每一个瞬间都既是它本身又不是它本身；在每一瞬间它消化着外界供给的物质，并排泄出其他物质”，这种观点（）。<br>A. 否认相对静止的诡辩论<br>B. 承认联系与发展的唯物辩证法<br>C. 否认认识世界可能性的不可知论<br>D. 承认物质永恒不变的形而上学<br>正确答案：B</p>
</li>
<li><p>“联系是逻辑思维给世界打上的烙印”，这种观点的错误在于否认了联系的（）。<br>A. 客观性<br>B. 普遍性<br>C. 条件性<br>D. 多样性<br>正确答案：A</p>
</li>
<li><p>庄子在《逍遥游》中提出了“无所待”的境界，主张无所依赖的绝对自由。从辩证法的角度看，这种自由无法实现的原因是（）。<br>A. 每一种事物都处在普遍联系之中<br>B. 事物的发展经历两次否定<br>C. 发展具有曲折性<br>D. 联系具有多样性<br>正确答案：A</p>
</li>
<li><p>社会上总会流传一种“不祥年”的说法，认为每逢这样的年份就会有天灾人祸发生。这种说法的错误在于（）。<br>A. 主观臆想了事物的联系<br>B. 割裂了事物的普遍发展<br>C. 忽视了事物发展的外因<br>D. 否定了和谐状态的存在<br>正确答案：A</p>
</li>
<li><p>一些地方的人们掠夺性地滥挖草原上的甘草，虽获得了一定的经济利益，却破坏了草原植被，造成土地荒漠化，一遇大风，沙尘暴铺天盖地而至，给人们带来了巨大灾难。这些人的做法忽视了（）。<br>A. 矛盾的同一性的观点<br>B. 世界的物质统一性观点<br>C. 事物普遍联系的观点<br>D. 必然性和偶然性统一的观点<br>正确答案：C</p>
</li>
<li><p>铁人王进喜曾说：“有条件要上，没条件创造条件也要上”，王进喜对条件的认识体现了（）。<br>A. 人可以完全超越条件的限制<br>B. 人可以任意创造有利条件<br>C. 要善于利用条件又要善于化不利条件为有利条件<br>D. 条件对事物的发展只有支持作用<br>正确答案：C</p>
</li>
<li><p>“揠苗助长”的错误在于（）。<br>A. 没有发挥主观能动性<br>B. 没有看到否定在发展中的作用<br>C. 强行改变事物存在发展的条件<br>D. 只关注主要矛盾忽视次要矛盾<br>正确答案：C</p>
</li>
<li><p>在第二届联合国全球可持续交通大会上，中国移动5G智慧港口展区展出了无人货车有条不紊地在码头上穿梭装卸货物，5G港机远控. 5G岸桥远控正从大型远洋运输船上把集装箱卸下等智慧港口视频画面。5G网络的发展带来了万物互联的时代，体现了（）。<br>A. 联系具有普遍性，世界是一个整体<br>B. 联系具有主观性，人为世界创造了联系<br>C. 联系具有条件性，人能够任意改变事物发展的条件<br>D. 联系具有多样性，人只能把握事物的直接联系<br>正确答案：A</p>
</li>
<li><p>习近平指出：“从古丝绸之路的驼铃帆影，到航海时代的劈波斩浪，再到现代交通网络的四通八达，交通推动经济融通. 人文交流，使世界成了紧密相连的‘地球村’”。从哲学上看，交通的发展体现了（）。<br>A. 人为孤立的世界创造了联系<br>B. 整个世界是相互联系的整体<br>C. 世界联系的偶然性<br>D. 联系的条件是不能改变的<br>正确答案：B</p>
</li>
<li><p>“小河有水大河满，大河无水小河干”体现了（）。<br>A. 世界是普遍联系的<br>B. 事物发展要经过两次否定<br>C. 质变和量变的统一<br>D. 意识对物质具有反作用<br>正确答案：A</p>
</li>
<li><p>从条件的观点来看，“人有多大胆，地有多大产”属于（）。<br>A. 唯心主义无条件论<br>B. 机械唯物主义唯条件论<br>C. 辩证唯物主义无条件论<br>D. 古代朴素唯物主义唯条件论<br>正确答案：A</p>
</li>
<li><p>变化泛指事物发生的一切改变，（）则是事物变化中前进的. 上升的运动。<br>A. 发展<br>B. 联系<br>C. 运动<br>D. 静止<br>正确答案：A</p>
</li>
<li><p>“沉舟侧畔千帆过，病树前头万木春”表现了诗人刘禹锡昂扬进取的精神，也蕴含着（）的哲理。<br>A. 永恒真理能够被认识<br>B. 新事物必然战胜旧事物<br>C. 事物的发展是偶然的<br>D. 主观能动性决定着事物的发展<br>正确答案：B</p>
</li>
<li><p>“凡是在人类历史领域中是现实的，随着时间的推移，都会成为不合理的”，这种观点属于（）。<br>A. 认为“物方生方死”的诡辩论<br>B. 承认事物发展的辩证法<br>C. 在社会历史领领域坚持唯心的旧唯物主义<br>D. 追求永恒真理的形而上学<br>正确答案：B</p>
</li>
<li><p>随着2G、 3G用户加速向4G迁移，截至2019年7月，我国4G用户数达12.4亿，2G、3G逐渐成为历史，而随着5G技术的成熟，4G也终将成为历史，这说明（）。<br>A. 世界是相互联系的整体<br>B. 世界统一于意识<br>C. 世界是变化发展的<br>D. 人创造了事物的发展<br>正确答案：C</p>
</li>
<li><p>在近代推翻封建统治的民主革命过程中，曾发生过多次复辟现象，例如法国波旁王朝路易十八复辟，这些复辟最终又一次被民主革命的浪潮推翻。从哲学上看这是因为（）。<br>A. 复辟王朝作为后出现的新事物在初期不够强大<br>B. 民主革命作为先出现的旧事物力量强大<br>C. 民主革命作为符合历史前进方向的新事物必然战胜旧事物<br>D. 复辟王朝保留了旧的形式，因而是旧事物<br>正确答案：C</p>
</li>
<li><p>习近平指出：“实施创新驱动发展战略，是应对发展环境变化. 把握发展自主权. 提高核心竞争力的必然选择。”从哲学上看这是因为（）。<br>A. 新事物必然战胜旧事物<br>B. 运动是相对的，静止是绝对的<br>C. 事物的发展是偶然的<br>D. 人只能被动的适应环境变化<br>正确答案：A</p>
</li>
<li><p>抓住“风口”对于企业来说极其重要，把握住“风口”往往能够事半功倍。由此发展出一种观点，认为只要站在“风口”上，无论如何都能取得成功。这种观点的错误属于（）。<br>A. 唯条件论<br>B. 无条件论<br>C. 辩证唯物主义<br>D. 主观唯心主义<br>正确答案：A</p>
</li>
<li><p>（）回答了事物为什么会发展的问题。<br>A. 对立统一规律<br>B. 价值规律<br>C. 剩余价值规律<br>D. 社会基本矛盾运动规律<br>正确答案：A</p>
</li>
<li><p>“祸兮福之所倚，福兮祸之所伏”体现了（）。<br>A. 矛盾的同一性<br>B. 矛盾的斗争性<br>C. 矛盾的特殊性<br>D. 矛盾的普遍性<br>正确答案：A</p>
</li>
<li><p>“有无相生，难易相成，长短相形，高下相倾，音声相和，前后相随”体现了（）。<br>A. 矛盾双方相互依存. 相互贯通<br>B. 矛盾双方相互斗争. 相互排斥<br>C. 矛盾双方有主次之分<br>D. 矛盾双方存在和谐的状态<br>正确答案：A</p>
</li>
<li><p>“狡兔死，良狗烹；飞鸟尽，良弓藏；敌国破，谋臣亡”体现了（）。<br>A. 矛盾双方的斗争促进双方力量变化<br>B. 矛盾双方中一方以另一方为前提<br>C. 矛盾双方的斗争性是有条件的<br>D. 矛盾双方的同一性是无条件的<br>正确答案：B</p>
</li>
<li><p>“万物各得其和以生，各得其养以成”，人与自然应和谐共生。和谐是（）。<br>A. 事物发展的根本动力<br>B. 矛盾的普遍形式<br>C. 矛盾的绝对同一<br>D. 矛盾的特殊表现形式<br>正确答案：D</p>
</li>
<li><p>在纪念辛亥革命110周年大会上的讲话中，习近平指出：“今天，经过长期奋斗，实现中华民族伟大复兴具备了更为完善的制度保证. 更为坚实的物质基础. 更为主动的精神力量。前景光明辽阔，但前路不会平坦。”强调“前路不会平坦”体现了（）。<br>A. 矛盾具有同一性<br>B. 和谐是矛盾的特殊形式<br>C. 矛盾具有普遍性<br>D. 矛盾具有特殊性<br>正确答案：C</p>
</li>
<li><p>“世界没有永动机，也没有一劳永逸自动解决所有问题的制度”，从矛盾的观点看，这是因为（）。<br>A. 矛盾的同一性是绝对的<br>B. 矛盾的斗争性是相对的<br>C. 矛盾无处不在无时不有<br>D. 矛盾的重点是和谐<br>正确答案：C</p>
</li>
<li><p>辛亥革命虽然没有完成实现民族独立. 人民解放的历史任务，但辛亥革命“永远是中华民族伟大复兴征程上一座巍然屹立的里程碑”，从矛盾的观点看，这体现了（）。<br>A. 矛盾的普遍性决定了事物的不同性质<br>B. 事物的性质具有主观性<br>C. 次要矛盾的次要方面决定事物的性质<br>D. 主要矛盾的主要方面决定事物的性质<br>正确答案：D</p>
</li>
<li><p>坚持把马克思主义同中国具体实际. 同中华优秀传统文化相结合的哲学基础是坚持（）。<br>A. 矛盾的共性与个性的有机统一<br>B. 矛盾的同一性和斗争性的有机统一<br>C. 主要矛盾和次要矛盾的有机统一<br>D. 主要方面和次要方面的有机统一<br>正确答案：A</p>
</li>
<li><p>古希腊学者欧布里德曾经提出一个悖论，其大意是：一粒谷粒不能成为谷堆，再加上一粒也不能成为谷堆； 所以如果现有的谷粒数不成为谷堆，那么在这个基础上每次只加一粒谷粒，则谷堆一直不能形成，这个悖论被称为“谷堆悖论”。“谷堆悖论”的错误在于（）。<br>A. 只看到了主要矛盾，忽略了次要矛盾<br>B. 只看到了共性，忽略了个性<br>C. 只看到了量变，忽视了质变<br>D. 只看到了偶然性，忽视了必然性<br>正确答案：C</p>
</li>
<li><p>“山积而高，泽积而长”体现了（）。<br>A. 共性与个性的统一<br>B. 同一性与斗争性的统一<br>C. 客观性与主观性的统一<br>D. 量变和质变的统一<br>正确答案：D</p>
</li>
<li><p>当前，全民健身理念逐步成为一种社会主流认识，然而在全民健身的热潮中存在着一些认知偏差，比如朋友圈病态追求“瘦身”. 盲目打卡高难度动作等。从哲学上看，这些行为违反了（）。<br>A. 两点论与重点论相统一<br>B. 共性与个性相统一<br>C. 世界的物质统一性原理<br>D. 适度原则<br>正确答案：D</p>
</li>
<li><p>在实际工作中，要注意掌握分寸，防止“过”或“不及”，其关键在于（）。<br>A. 抓住事物的主要矛盾<br>B. 确定事物的质<br>C. 认识事物的量<br>D. 把握事物的度<br>正确答案：D</p>
</li>
<li><p>《孙子兵法》：“投入亡地然后存，陷于死地而后生。”韩信据此背水一战，打败赵军；马谡据此屯兵山下，痛失街亭。同是根据兵法，造成的结果却不同，这说明（）。<br>A. 矛盾具有普遍性，两者没有共性<br>B. 具体问题具体分析是解决矛盾的关键<br>C. 兵法本身有正确和错误之分<br>D. 矛盾双方是既对立又统一的<br>正确答案：B</p>
</li>
<li><p>鲁迅在评《三国演义》时说：“至于写人，亦颇有失，以致欲显刘备之长厚而似伪，状诸葛之多智而近妖。”这一评述所蕴含的哲理是（）。<br>A. 矛盾双方会相互转化<br>B. 要把握事物的度<br>C. 对事物既要肯定又要否定<br>D. 要把事物看作一个整体<br>正确答案：B</p>
</li>
<li><p>杜甫诗曰：“挽弓当挽强，用箭当用长，射人先射马，擒贼先擒王。”这首诗蕴含的哲理是（）。<br>A. 量变引起质变<br>B. 承认矛盾客观性，正确对待矛盾<br>C. 既要看到矛盾主要方面，又要看到矛盾次要方面<br>D. 抓主要矛盾，抓中心，抓关键<br>正确答案：D</p>
</li>
<li><p>事物的发展是通过其内在矛盾运动以（）的方式而实现的。<br>A. 自我否定<br>B. 外部否定<br>C. 绝对否定<br>D. 他物否定<br>正确答案：A</p>
</li>
<li><p>恩格斯指出：“小生产只能同生产和社会狭隘的. 自然生产的界限相容，因而它发展到一定程度就产生消灭它自身的手段”。这说明否定（）。<br>A. 是矛盾运动的原因<br>B. 是外部自然的产物<br>C. 是事物自身的否定<br>D. 是一次完成的<br>正确答案：C</p>
</li>
<li><p>有许多观众认为黄梅戏唱腔比较柔美，不适合演绎荡气回肠的故事，但黄梅戏《江姐》导演吴琼则指出，只要声腔设计从人物出发，黄梅戏也能够唱出激昂旋律。导演的回答体现了（）。<br>A. 内容决定形式<br>B. 形式决定内容<br>C. 现实决定可能<br>D. 可能决定现实<br>正确答案：A</p>
</li>
<li><p>经典黄梅戏剧目《女驸马》同名国风连载漫画作品以韩再芬版舞台剧《女驸马》为蓝本，将黄梅戏的种子植入年轻人的“二次元”世界。从哲学角度看，这体现了（）。<br>A. 内容决定形式，有什么样的内容就有什么样的形式<br>B. 形式具有相对独立性，同一内容可以通过多种形式来展现<br>C. 原因决定结果，有什么样的原因就有什么样的结果<br>D. 结果具有相对独立性，同一原因可能导致多种结果<br>正确答案：B</p>
</li>
<li><p>探测行星大气中的氧气一直以来都是寻找地外生命的一个标准，恒星的紫外辐射也会导致行星上产生氧气分子，形成虚假生命信号。从哲学上看，“虚假生命信号”体现了（）。<br>A. 存在不表现本质的现象<br>B. 存在不表现为现象的本质<br>C. 本质深藏在现象背后不可认识<br>D. 现象可以区分为真象和假象<br>正确答案：D</p>
</li>
<li><p>利用光伏板收集太阳能是开发绿色新能源的重要举措。但由于光板的遮挡，不少草地因此杂草疯长，影响光板的使用效果，也易造成火灾，而人工除草费时费力。中国某光伏园区，通过牧羊成功解决了这一难题。牧羊和难题的解决体现了（）。<br>A. 现象与本质的辩证关系<br>B. 必然性与偶然性的辩证关系<br>C. 现实与可能的辩证关系<br>D. 原因与结果的辩证关系<br>正确答案：D</p>
</li>
<li><p>下列选项中，属于因果联系的是（）。<br>A. 风来雨至<br>B. 摩擦生热<br>C. 冬去春来<br>D. 电闪雷鸣<br>正确答案：B</p>
</li>
<li><p>马克思指出：“辩证法对每一种既成的形式都是从不断的运动中，因而也是从它的暂时性方面去理解”，这说明辩证法（）。<br>A. 不承认相对静止<br>B. 不承认和谐状态的存在<br>C. 不能把握事物的本质<br>D. 不承认永恒不变的绝对真理<br>正确答案：D</p>
</li>
<li><p>马克思主义物质观认为客观实在性是物质的唯一特性，从个性中看到了个性，从相对中找到绝对，从暂时中发现永恒。这体现了（）。<br>A. 唯物主义和唯心主义的统一<br>B. 可知论和不可之论的统一<br>C. 唯物论和辩证法的统一<br>D. 认识论和历史观的统一<br>正确答案：C</p>
</li>
<li><p>恩格斯指出：“所谓的主观辩证法，不过是在自然中到处发生作用的. 对立中的运动的反映。”这表明（）。<br>A. 主观辩证法不具备能动性<br>B. 主观辩证法与客观辩证法完全一致<br>C. 主观辩证法与客观辩证法本质上是统一的<br>D. 客观辩证法不能被认识<br>正确答案：C</p>
</li>
<li><p>马克思的辩证法同黑格尔的辩证法截然相反，正如马克思所说，“在黑格尔看来，思维过程……是现实事物的创造主，而现实事物只是思维过程的外部表现。”这体现了两种辩证法的相反之处在于（）。<br>A. 关于普遍性与特殊性关系认识上<br>B. 关于必然与偶然关系认识上<br>C. 关于否定-肯定-否定认识上<br>D. 关于主观辩证法与客观辩证法关系的认识上<br>正确答案：D</p>
</li>
<li><p>习近平强调，改革要“扭住关键”，“突出问题导向，体现了（）在改革和发展问题上的运用。<br>A. 抽象推理法<br>B. 直观分析法<br>C. 唯心辩证法<br>D. 矛盾分析法<br>正确答案：D</p>
</li>
<li><p>从个别事实中概括出一般性结论，由个别前提过渡到一般性结论的推理形式是（）。<br>A. 归纳<br>B. 演绎<br>C. 分析<br>D. 具体<br>正确答案：A</p>
</li>
<li><p>由一般性原则推导出个别结论的推理形式是（）。<br>A. 归纳<br>B. 演绎<br>C. 抽象<br>D. 分析<br>正确答案：B</p>
</li>
<li><p>在发现澳大利亚的黑天鹅之前，17世纪之前的欧洲人认为天鹅都是白色的，但随着第一只黑天鹅的出现，这个不可动摇的信念崩溃了。这说明（）。<br>A. 人类不可能认识事物的本质<br>B. 归纳所得结论还不充分可靠<br>C. 经验对认识真理没有任何帮助<br>D. 存在脱离共性的个性<br>正确答案：B</p>
</li>
<li><p>在思维中把认识对象分解为各个部分. 方面. 要素的思维方法是（）。<br>A. 分析<br>B. 抽象<br>C. 归纳<br>D. 历史<br>正确答案：A</p>
</li>
<li><p>在庆祝中国共产党成立100周年大会上，习近平强调要以史为鉴. 开创未来，这是（）的体现。<br>A. 理念思维能力<br>B. 系统思维能力<br>C. 历史思维能力<br>D. 底线思维能力<br>正确答案：C</p>
</li>
<li><p>系统思维以确认事物的（）为前提，进而具体把握事物的系统存在. 系统联系与系统规律。<br>A. 特殊的个性存在<br>B. 普遍有机联系<br>C. 外在的否定<br>D. 前进上升的运动<br>正确答案：B</p>
</li>
<li><p>习近平指出：“生物多样性使地球充满生机，也是人类生存和发展的基础。保护生物多样性有助于维护地球家园，促进人类可持续发展。”保护生态. 保护生物多样性是（）的具体体现。<br>A. 理念思维能力<br>B. 历史思维能力<br>C. 系统思维能力<br>D. 底线思维能力<br>正确答案：C</p>
</li>
<li><p>“凡事从坏处准备，努力争取最好的结果，这样才能有备无患. 遇事不慌，牢牢把握主动权”强调的是（）。<br>A. 系统思维能力<br>B. 底线思维能力<br>C. 历史思维能力<br>D. 创新思维能力<br>正确答案：B</p>
</li>
<li><p>底线思维能力体现了对（）的深刻认识和把握。<br>A. 适度原则<br>B. 共性与个性的关系<br>C. 否定是事物自身的否定<br>D. 具体问题具体分析<br>正确答案：A</p>
</li>
</ol>
<h3 id="多选-1"><a href="#多选-1" class="headerlink" title="多选"></a>多选</h3><ol>
<li><p>哲学基本问题主要包括两方面内容，即（）。<br>A. 存在和思维何者为第一性的问题<br>B. 存在和思维是否具有同一性的问题<br>C. 真理和价值的关系问题<br>D. 真理的绝对性和相对性关系问题<br>正确答案：AB</p>
</li>
<li><p>马克思主义物质概念的重大变革在于（）。<br>A. 通过实践的发现揭示了社会存在<br>B. 克服了旧唯物主义将物质概念局限在自然领域的缺陷<br>C. 把唯心主义从社会历史领域彻底驱除出去<br>D. 找到了物的具体形态并将之作为世界本源<br>正确答案：ABC</p>
</li>
<li><p>马克思主义的物质范畴具有丰富而深刻的理论意义，包括（）。<br>A. 坚持了唯物主义一元论，同唯心主义一元论和二元论划清了界限<br>B. 坚持了能动的反映论和可知论，批判了不可知论<br>C. 体现了唯物论和辩证法的统一，克服了形而上学唯物主义的缺陷<br>D. 体现了唯物主义自然观与历史唯物主义历史观的统一<br>正确答案：ABCD</p>
</li>
<li><p>2013年11月，习近平到湖南湘西考察时首次作出了“实事求是. 因地制宜. 分类指导. 精准扶贫”的重要指示。“精准扶贫”所蕴含的哲学方法论是（）。<br>A. 想问题. 办事情都要以时间. 地点. 条件为转移<br>B. 充分发挥主观能动性创造自然规律<br>C. 努力把握矛盾的普遍性，以共性掩盖个性<br>D. 具体问题具体分析<br>正确答案：AD</p>
</li>
<li><p>席勒说：“时间的步伐有三种：未来姗姗来迟，现在像箭一样飞逝，过去永远静立不动”，这体现了时间具有（）。<br>A. 持续性<br>B. 顺序性<br>C. 一维性<br>D. 广延性<br>正确答案：ABC</p>
</li>
<li><p>古人对龙的描述有九似，“角似鹿. 头似驼. 眼似兔. 项似蛇. 腹似蜃. 鳞似鱼. 爪似鹰. 掌似虎. 耳似牛”，龙的“九似”说明意识（）。<br>A. 是对现实的直观反映<br>B. 是对现实的能动反映<br>C. 能够创造出现实不存在的客观物质<br>D. 能够构建实现没有的观念世界<br>正确答案：BD</p>
</li>
<li><p>意识的能动作用主要表现在意识具有（）。<br>A. 目的性和计划性<br>B. 创造性<br>C. 指导实践改造客观世界的作用<br>D. 调控人的行为和生理活动的作用<br>正确答案：ABCD</p>
</li>
<li><p>意识具有指导实践改造世界的作用，改造世界意味着（）。<br>A. 强化客观世界的变化过程<br>B. 创造出世界上原来没有的东西<br>C. 创造和改变客观规律<br>D. 改变物质的根本属性和存在形式<br>正确答案：AB</p>
</li>
<li><p>鲁迅说过：“描神画鬼，毫无对证，本可以专靠神思，所谓‘天马行空’地挥写了。然而他们写出来的却是三只眼. 长脖子，也就是在正常的人体身上增加了眼睛一只，拉长了颈子二三尺而已。”这段话说明，人们头脑中的鬼神观念是（）。<br>A. 头脑中主观自生的<br>B. 人脑对客观世界的歪曲反映<br>C. 人脑对鬼神的虚幻反映<br>D. 可以从人世间找到它的原型<br>正确答案：BD</p>
</li>
<li><p>“先有计划，后做工作；先有图纸，后造房子”，这说明（）。<br>A. 意识决定物质，思维决定存在<br>B. 物质存在形态的多样性<br>C. 意识对物质的能动作用<br>D. 意识活动的目的性计划性<br>正确答案：CD</p>
</li>
<li><p>正确发挥人的主观能动性所需要的前提和条件有（）。<br>A. 从实际出发<br>B. 实践<br>C. 一定的物质条件<br>D. 天赋观念<br>正确答案：ABC</p>
</li>
<li><p>在庆祝中国共产党成立100周年大会上，习近平指出，要“坚持实事求是，从中国实际出发，洞察时代大势，把握历史主动，进行艰辛探索，不断推进马克思主义中国化时代化，指导中国人民不断推进伟大社会革命”。从哲学角度看，这是因为（）。<br>A. 尊重客观规律是正确发挥主观能动性的前提<br>B. 只有从实际出发，才能获得正确的认识进而形成正确的行动<br>C. 遵循历史规律和进程，才能适应时代发展<br>D. 把握时代脉搏和契机，才能真正成为历史的主人<br>正确答案：ABCD</p>
</li>
<li><p>习近平总书记在庆祝中国共产党成立100周年大会上指出：“一百年来，中国共产党弘扬伟大建党精神，在长期奋斗中构建起中国共产党人的精神谱系，锤炼出鲜明的政治品格。”从物质和意识的辩证关系来看，弘扬伟大建党精神的原因有（）。<br>A. 意识对物质就有能动的反作用<br>B. 意识具有调控人的行为和生理活动的作用<br>C. 意识具有指导实践改造客观世界的作用<br>D. 只有充分发挥主观能动性才能正确认识和改造世界<br>正确答案：AB</p>
</li>
<li><p>即使是目前最强大. 最先进的智能机器，也不能达到人类智能的层级，这是因为（）。<br>A. 人工智能不具备情感. 信念. 意志等人类意识形式<br>B. 人工智能不具备人类的社会属性<br>C. 人工智能难以具备理解自然语言真实意义的能力<br>D. 人工智能的计算能力远低于人类<br>正确答案：ABC</p>
</li>
<li><p>世界的物质统一性体现在（）。<br>A. 自然界是物质的<br>B. 人类社会本质上是物质的<br>C. 人的意识统一于物质<br>D. 物质是道与理念的现实投射<br>正确答案：ABC</p>
</li>
<li><p>联系是指事物内部各要素之间和事物之间（）的关系。<br>A. 相互影响<br>B. 相互制约<br>C. 相互作用<br>D. 相互割裂<br>正确答案：ABC</p>
</li>
<li><p>世界上的万事万物既作为个体事物存在，又作为联系中的事物存在，事物之间的联系具有（）的特点。<br>A. 客观性<br>B. 普遍性<br>C. 多样性<br>D. 条件性<br>正确答案：ABCD</p>
</li>
<li><p>联系具有客观性和普遍性，其中联系的普遍性的含义包括（）。<br>A. 任何事物都具有内在的结构性<br>B. 任何事物都不能孤立存在<br>C. 整个世界是相互联系的统一整体<br>D. 事物皆在理念之中<br>正确答案：ABC</p>
</li>
<li><p>在第二届联合国全球可持续交通大会上，习近平指出：“要大力发展智慧交通和智慧物流，推动大数据. 互联网. 人工智能. 区块链等新技术与交通行业深度融合，使人享其行. 物畅其流。”下列关于智慧交通的说法中，正确的有（）。<br>A. 说明事物的联系是人为创造的<br>B. 智慧交通的智慧之处在于具备真正的自主. 自觉的社会活动<br>C. 说明人可以利用和改变条件推动事物的发展<br>D. 体现了世界的普遍联系<br>正确答案：CD</p>
</li>
<li><p>联系具有多样性，事物联系的主要方式包括（）。<br>A. 直接联系与间接联系<br>B. 内部联系与外部联系<br>C. 本质联系与非本质联系<br>D. 必然联系与偶然联系<br>正确答案：ABCD</p>
</li>
<li><p>联系具有条件性，唯物辩证地看待条件要求我们（）。<br>A. 善于充分利用有利条件<br>B. 善于化不利条件为有利条件<br>C. 唯条件至上. 万事等待条件成熟<br>D. 超越客观规律创造条件<br>正确答案：AB</p>
</li>
<li><p>在新陈代谢的发展过程中，新事物是不可战胜的，这是因为（）。<br>A. 新事物的要素和功能适应了新的环境和条件<br>B. 旧事物的要素和功能不适应环境和客观条件<br>C. 新事物在旧事物的“母体”中孕育成熟<br>D. 在社会历史领域，新事物从根本上符合人民群众的利益和要求<br>正确答案：ABCD</p>
</li>
<li><p>唯物辩证法揭示了事物发展变化的一般规律，包括（）。<br>A. 对立统一关系规律<br>B. 量变质变规律<br>C. 否定之否定规律<br>D. 永恒轮回规律<br>正确答案：ABC</p>
</li>
<li><p>“有了开放就有竞争，有了竞争才有学习，有了学习才有发展。”从对立统一规律的角度看，这是因为（）。<br>A. 矛盾双方不存在和谐状态<br>B. 矛盾双方只存在对抗形式的斗争<br>C. 同一性使矛盾双方相互吸取有利于自身的因素，在相互作用中得到发展<br>D. 矛盾双方的斗争性促进矛盾双方力量的变化<br>正确答案：CD</p>
</li>
<li><p>矛盾的特殊性是指（）。<br>A. 每个具体事物的矛盾各有特点<br>B. 每一矛盾的各个方面各有不同<br>C. 同一矛盾的不同阶段有不同特点<br>D. 矛盾无时不在<br>正确答案：ABC</p>
</li>
<li><p>关于矛盾的共性与个性，下列说法中正确的是（）。<br>A. 矛盾的共性是有条件的. 相对的<br>B. 矛盾的个性是无条件的. 绝对的<br>C. 没有离开个性的共性<br>D. 没有离开共性的个性<br>正确答案：CD</p>
</li>
<li><p>“不积跬步，无以至千里；不积小流，无以成江海”体现了（）。<br>A. 量变是质变的必要准备<br>B. 质变是量变的必要准备<br>C. 量变是质变的必然结果<br>D. 质变是量变的必然结果<br>正确答案：AD</p>
</li>
<li><p>唯物辩证法的否定观所揭示的否定的科学内涵包括（）。<br>A. 否定是事物的自我否定<br>B. 否定是事物发展的环节<br>C. 否定是新旧事物联系的环节<br>D. 辩证否定的实质是“扬弃”<br>正确答案：ABCD</p>
</li>
<li><p>以下各项中，与“麦粒-麦株-麦粒”所反映的哲学原理相同的有（）。<br>A. 团结-批评-团结<br>B. 婴儿-青年-老年<br>C. 否定-肯定-否定<br>D. 自然唯物主义-唯心主义-辩证唯物主义<br>正确答案：ACD</p>
</li>
<li><p>在社会主义条件下，在推进中国特色社会主义事业进程中坚持和发扬唯物辩证法精神就是要（）。<br>A. 坚持解放思想. 实事求是. 与时俱进，用发展着的马克思主义指导新的实践<br>B. 坚持改革开放，不断推进社会主义制度的自我完善<br>C. 推进党的自我革命，始终保持党的先进性和纯洁性<br>D. 提倡创新创造， 反对因循守旧. 墨守成规<br>正确答案：ABCD</p>
</li>
<li><p>归纳和演绎是人们认识世界的重要逻辑方法，以下关于归纳与演绎的关系的说法中，正确的有（）。<br>A. 归纳是演绎的基础<br>B. 演绎为归纳提供理论依据<br>C. 归纳和演绎相互补充<br>D. 归纳和演绎互为前提<br>正确答案：ABCD</p>
</li>
<li><p>马克思认为思想进程不过是历史进程的反映，“这种反映是经过修正的，然而是按照现实的历史过程本身的规律修正的”，这里的“修正”是指（）。<br>A. 抛弃偶然性，抓住必然性<br>B. 抛弃偏差，抓住基本方向和基本线索<br>C. 抛弃历史现实，进行主观创造<br>D. 抛弃历史细节，抓住主流<br>正确答案：ABD</p>
</li>
<li><p>关于逻辑与历史的关系，下列说法中正确的有（）。<br>A. 历史的东西是逻辑的东西的基础<br>B. 逻辑的进程和历史的进程具有内在统一性<br>C. 逻辑的东西能够把握历史的主流<br>D. 逻辑与历史的统一是包含差异的统一<br>正确答案：ABCD</p>
</li>
<li><p>以下各项中，属于现代科学思维方法的有（）。<br>A. 控制方法<br>B. 信息方法<br>C. 系统方法<br>D. 模型方法<br>正确答案：ABCD</p>
</li>
<li><p>辩证思维方法和现代科学思维方法是认识世界的重要方法，关于二者的关系，下列说法中正确的有（）。<br>A. 辩证思维方法是现代科学思维方法的方法论前提<br>B. 现代科学思维方法是辩证思维方法的方法论前提<br>C. 辩证思维方法要自觉以现代科学思维方法为指导<br>D. 现代科学思维方法丰富了辩证思维方法<br>正确答案：AD</p>
</li>
<li><p>创新能力是指破除迷信. （）的能力。<br>A. 超越陈规<br>B. 善于因时制宜<br>C. 知难而进<br>D. 开拓创新<br>正确答案：ABCD</p>
</li>
</ol>
<h3 id="判断-1"><a href="#判断-1" class="headerlink" title="判断"></a>判断</h3><ol>
<li><p>哲学是系统化. 理论化的世界观。<br>对</p>
</li>
<li><p>解决其他一切哲学问题的前提和基础是对哲学基本问题的回答。<br>对</p>
</li>
<li><p>物质世界的运动是相对的，静止是绝对的。<br>错</p>
</li>
<li><p>静止的相对性是物质运动的稳定性. 有条件性的体现。<br>对</p>
</li>
<li><p>运动的绝对性是物质运动的稳定性. 有条件性的体现。<br>错</p>
</li>
<li><p>没有离开运动的时空，只有在物质运动中才能感受到时空，这说明时空只是人们对物质运动的主观感受。<br>错</p>
</li>
<li><p>从哲学上看，世界二重化为主观世界和客观世界，主观世界是实践活动的产物。<br>对</p>
</li>
<li><p>意识是主观世界的客观映像。<br>错</p>
</li>
<li><p>意识是自然界长期发展的产物，也是社会历史发展的产物。<br>对</p>
</li>
<li><p>意识是人脑这样一种特殊物质的机能和属性。<br>对</p>
</li>
<li><p>意识的内容是客观的，形式是主观的。<br>对</p>
</li>
<li><p>物质决定意识，意识对物质具有反作用，这种反作用就是意识的能动作用。<br>对</p>
</li>
<li><p>物质决定意识，这说明人在认识客观世界时，客观世界有什么就只能反映什么，无法进行选择。<br>错</p>
</li>
<li><p>意识具有目的性和计划性，人的整个实践过程就是围绕意识活动所构建的目标进行的，这说明意识决定了人的实践活动。<br>错</p>
</li>
<li><p>意识是对客观世界的反映，鬼神在意识中存在因而也是客观存在的。<br>错</p>
</li>
<li><p>物质是第一性的，意识是派生的，这意味着意识只能在自身范围内活动，不能对物质产生影响。<br>错</p>
</li>
<li><p>观念的东西可以变为客观现实。<br>对</p>
</li>
<li><p>“笑一笑十年少，愁一愁白了头”是主观唯心主义错误思想在心理上的重要体现。<br>错</p>
</li>
<li><p>规律是事物变化发展过程中本身所固有的内在的. 本质的. 必然的联系。<br>对</p>
</li>
<li><p>人在客观世界面前不是无能为力的，人可以创造和改变客观规律以实现自己的目标。<br>错</p>
</li>
<li><p>人是历史的主人，这意味着人可以按照自己的意识，随心所欲的创造历史。<br>错</p>
</li>
<li><p>人只有在掌握客观规律的基础上，才能正确认识世界，有效地改造世界。<br>对</p>
</li>
<li><p>意识是客观世界的反映，遵循感觉即是掌握真理。<br>错</p>
</li>
<li><p>强调规律的客观性即是说人在规律面前是无能为力的。<br>错</p>
</li>
<li><p>正确的认识只有通过实践才能变为物质力量。<br>对</p>
</li>
<li><p>认识只要进行实践就能改变世界。<br>错</p>
</li>
<li><p>人工智能，就是人的部分智能活动机器化。<br>对</p>
</li>
<li><p>人工智能的出现表明人类意识已经能够把意识活动部分地从人脑分离出来。<br>对</p>
</li>
<li><p>人工智能是人的意识的物化，是意识器官功能的延伸。<br>对</p>
</li>
<li><p>社会性是人的意识所固有的本质属性。<br>对</p>
</li>
<li><p>人工智能在一定程度上可以承担某种社会功能。<br>对</p>
</li>
<li><p>随着人工智能的发展，机器人将真正具备自立. 自主. 自觉的社会活动。<br>错</p>
</li>
<li><p>马克思主义认为世界没有所谓共同的本原或本质。<br>错</p>
</li>
<li><p>世界的物质统一性否定了世界的多样性。<br>错</p>
</li>
<li><p>世界的物质统一性是由哲学和自然科学的长期和持续的发展所证明的。<br>对</p>
</li>
<li><p>世界物质统一性原理是辩证唯物主义最基本. 最核心的观点，是马克思主义的基石。<br>对</p>
</li>
<li><p>联系和发展的观点集中体现了唯物辩证法的总特征。<br>对</p>
</li>
<li><p>世界上的万事万物既作为个体事物存在，又作为联系中的事物存在。<br>对</p>
</li>
<li><p>事物的联系是事物本身所固有的。<br>对</p>
</li>
<li><p>在联系的观点上坚持唯物论就是要坚持联系的客观性。<br>对</p>
</li>
<li><p>世界上的事物是多样的，事物之间的联系也是多样的。<br>对</p>
</li>
<li><p>条件往往对人的实践起到支持或制约作用，条件是可以改变和创造的。<br>对</p>
</li>
<li><p>条件是对事物存在和发展发生作用的诸要素的总和。<br>对</p>
</li>
<li><p>条件对事物发展和人的活动只具有支持和促进作用。<br>错</p>
</li>
<li><p>世界是发展变化的，尽管在变化过程中有种种倒退，但前进的发展终究会实现。<br>对</p>
</li>
<li><p>物质世界的发展特别是人类社会的发展，其实质是新事物的产生和旧事物的灭亡。<br>对</p>
</li>
<li><p>判断一个事物是新事物还是旧事物的标准是出现时间的先后。<br>错</p>
</li>
<li><p>新事物是指合乎历史前进方向. 具有远大前途的东西。<br>对</p>
</li>
<li><p>新事物战胜旧事物必然采取革命的形式。<br>错</p>
</li>
<li><p>旧事物就是从来都不符合历史发展要求的事物。<br>错</p>
</li>
<li><p>在社会历史领域，新事物是社会上先进的. 富有创造力的人们创造性活动的产物，能够得到人民群众的拥护，因而必然战胜旧事物。<br>对</p>
</li>
<li><p>对立统一规律是事物发展的根本规律。<br>对</p>
</li>
<li><p>矛盾着的双方相互依存. 相互贯通的性质和趋势即是矛盾的同一性。<br>对</p>
</li>
<li><p>矛盾着的对立面相互排斥. 相互分离的性质和趋势即是矛盾的斗争性。<br>对</p>
</li>
<li><p>矛盾的双方是相互贯通的，在一定条件下可以相互转化。<br>对</p>
</li>
<li><p>矛盾的同一性是有条件的. 相对的。<br>对</p>
</li>
<li><p>矛盾的斗争性是有条件的. 相对的。<br>错</p>
</li>
<li><p>没有矛盾的同一性就没有矛盾的斗争性，没有矛盾的斗争性就没有矛盾的同一性。<br>对</p>
</li>
<li><p>对抗性矛盾和非对抗性矛盾是矛盾斗争的两种基本形式。<br>对</p>
</li>
<li><p>矛盾的斗争性寓于同一性之中，同一性通过斗争性来体现。<br>对</p>
</li>
<li><p>矛盾同一性是事物存在和发展的前提。<br>对</p>
</li>
<li><p>矛盾的同一性规定着事物转化的可能和发展的趋势。<br>对</p>
</li>
<li><p>事物之所以能够转化是因为事物外部矛盾双方具有相互贯通的关系。<br>错</p>
</li>
<li><p>事物的发展方向是有规律地向自己的对立面转化。<br>对</p>
</li>
<li><p>运用矛盾的同一性和斗争性原理指导实践，还要正确认识和谐对事物发展的作用，和谐是相对的. 有条件的。<br>对</p>
</li>
<li><p>社会和谐. 人与自然的和谐，都是在不断解决矛盾的过程中实现的。<br>对</p>
</li>
<li><p>事物的性质是由主要矛盾的主要方面所决定的。<br>对</p>
</li>
<li><p>矛盾的共性和个性. 绝对和相对的道理，是关于事物矛盾问题的精髓，是正确理解矛盾学说的关键。<br>对</p>
</li>
<li><p>质变体现了事物发展的渐变性和连续性。<br>错</p>
</li>
<li><p>量变质变规律是事物发展渐进性和飞跃性统一的体现。<br>对</p>
</li>
<li><p>否定之否定规律揭示了事物自己发展自己的完整过程和本质。<br>对</p>
</li>
<li><p>否定因素是事物内部促使现存事物灭亡的因素。<br>对</p>
</li>
<li><p>事物的自我发展要经历两次否定. 三个阶段。<br>对</p>
</li>
<li><p>事物经过两次否定完成是矛盾得到根本解决，达到事物发展的最终终点。<br>错</p>
</li>
<li><p>内容是构成事物的一切要素的总和。<br>对</p>
</li>
<li><p>形式是指把诸要素统一起来的结构或表现内容的方式。<br>对</p>
</li>
<li><p>内容是事物存在的基础，对形式具有决定作用。<br>对</p>
</li>
<li><p>本质是事物的根本性质，是构成事物的诸要素之间的内在联系。<br>对</p>
</li>
<li><p>现象是事物的外部联系和表面特征，是事物本质的外在表现。<br>对</p>
</li>
<li><p>事物的本质深藏于事物的内部，只能通过感性来感知。<br>错</p>
</li>
<li><p>假象是不表现本质的现象。<br>错</p>
</li>
<li><p>原因和结果的区分既是确定的又是不确定的。<br>对</p>
</li>
<li><p>现实事物的发展可以只表现为纯粹必然的情况。<br>错</p>
</li>
<li><p>偶然性之所以为偶然性，是因为它脱离了必然性。<br>错</p>
</li>
<li><p>现实是相互联系着的实际存在的事物的综合。<br>对</p>
</li>
<li><p>可能是指包含在事物中的预示事物发展前途的种种趋势。<br>对</p>
</li>
<li><p>发展就是现实与可能相互转化的过程。<br>对</p>
</li>
<li><p>唯物辩证法是马克思主义世界观和方法论的核心内容，为人们认识世界和改造世界提供了根本方法。<br>对</p>
</li>
<li><p>唯物辩证法在本质上是批判的和革命的。<br>对</p>
</li>
<li><p>客观辩证法是指人从客观条件出发认识事物所用的思维方法。<br>错</p>
</li>
<li><p>客观辩证法与主观辩证法在形式上是统一的，在本质上是不同的。<br>错</p>
</li>
<li><p>唯物辩证法既是科学的世界观，也是我们认识世界和改造世界的基本方法论。<br>对</p>
</li>
<li><p>矛盾分析法的核心要求是善于分析矛盾的特殊性，做到具体问题具体分析。<br>对</p>
</li>
<li><p>马克思主义的活的灵魂就在于具体地分析具体的情况。<br>对</p>
</li>
<li><p>同分析与综合相比，归纳与演绎是一种更为深刻的思维方法。<br>错</p>
</li>
<li><p>综合就是在分析的基础上，再把各个因素机械拼凑起来。<br>错</p>
</li>
<li><p>分析和综合的实质，就是建立在调查研究基础上的矛盾分析法。<br>对</p>
</li>
<li><p>分析是综合的基础，综合是分析的完成。<br>对</p>
</li>
<li><p>辩证思维能力是科学思维能力的根本要求和集中体现。<br>对</p>
</li>
<li><p>辩证思维能力就是以唯物辩证法为指导，发现矛盾. 分析矛盾. 解决矛盾，把握本质. 遵循规律. 推动工作的能力。<br>对</p>
</li>
<li><p>战略思维能力之所以重要，是因为它是一种充分发挥人的主观能动性. 积极性和创造性的思维活动。<br>对</p>
</li>
<li><p>当今世界，创新已经成为社会进步的主导力量和重要源泉。<br>对</p>
</li>
<li><p>“要胸怀两个大局，一个是中华民族伟大复兴的战略全局，一个是世界百年未有之大变局”是系统思维能力运用的光辉典范。<br>对</p>
</li>
</ol>
<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="单选-2"><a href="#单选-2" class="headerlink" title="单选"></a>单选</h3><ol>
<li><p>（）的观点是马克思主义的基本观点。<br>A. 实践<br>B. 真理<br>C. 价值<br>D. 意识<br>正确答案：A</p>
</li>
<li><p>在（）中，马克思系统论述了实践的观点，揭示了科学实践观的基本内容。<br>A. 《黑格尔法哲学批判》<br>B. 《论犹太人问题》<br>C. 《关于费尔巴哈的提纲》<br>D. 《反杜林论》<br>正确答案：C</p>
</li>
<li><p>马克思指出：“哲学家们只是用不同的方式解释世界，而问题在于改变世界。”这凸显了（）的重要性。<br>A. 物质<br>B. 意识<br>C. 真理<br>D. 实践<br>正确答案：D</p>
</li>
<li><p>实践是“主观见之于客观的东西”，这属于（）的观点。<br>A. 主观唯心主义实践观<br>B. 机械唯物主义实践观<br>C. 直观唯物主义实践观<br>D. 辩证唯物主义实践观<br>正确答案：D</p>
</li>
<li><p>实践的（）特征把它和主观认识活动区分开来。<br>A. 自觉能动性<br>B. 客观实在性<br>C. 社会历史性<br>D. 创造性<br>正确答案：B</p>
</li>
<li><p>“任何历史记载都应当从这些自然基础以及它们在历史进程中由于人们的活动而发生的变更出发”，这说明（）。<br>A. 实践能够引起客观世界的变化<br>B. 历史是人的主观创造<br>C. 自然环境对人具有决定作用<br>D. 人的改变了自然的运行规律<br>正确答案：A</p>
</li>
<li><p>“环境的改变和人的活动的一致，只能被看做是并合理地理解为变革的实践”，这说明实践具有（）。<br>A. 自觉能动性<br>B. 客观实在性<br>C. 社会性<br>D. 历史性<br>正确答案：B</p>
</li>
<li><p>马克思指出：“动物只是按照它所属的那个种的尺度和需要来建造，而人却懂得按照任何一个种的尺度来进行生产，并且懂得怎样处处都把内在的尺度运用到对象上去。”这说明相比于动物，人的实践具有（）。<br>A. 客观实在性<br>B. 社会性<br>C. 自觉能动性<br>D. 历史性<br>正确答案：C</p>
</li>
<li><p>“在曼彻斯特只看见一些工厂和机器，而100年前在那里只能看见一些脚踏纺车和织布机。”从脚踏纺车到机器工厂的发展说明实践活动具有（）。<br>A. 主观性<br>B. 社会历史性<br>C. 反映性<br>D. 特殊性<br>正确答案：B</p>
</li>
<li><p>相传万户是中国第一个试图利用火箭飞行的人，他设想利用火箭的推力，加上风筝的力量飞起，但火箭在实验过程中爆炸，万户也为此献出了生命。从哲学角度看，万户的失败体现了（）。<br>A. 实践不具备改造世界的能力<br>B. 实践的目的正确与否决定实践的成败<br>C. 实践受到社会历史条件的制约<br>D. 实践是人不断摆脱客观规律的活动<br>正确答案：C</p>
</li>
<li><p>2021年6月，广西首个5G+无人驾驶集装箱卡车作业港口项目在北部湾港北海港区启动。无人驾驶集装箱卡车的出现说明（）。<br>A. 机器成为实践的主体<br>B. 人工智能取代人类意识<br>C. 人能够通过工具延伸自己的肢体功能<br>D. 实践不具备能动性<br>正确答案：C</p>
</li>
<li><p>（）实践是人类最基本的实践活动。<br>A. 物质生产<br>B. 科学实验<br>C. 社会政治<br>D. 文化传播<br>正确答案：A</p>
</li>
<li><p>《孙子兵法》指出：“谋定而后动，知止而有得”，从哲学角度看，这说明（）。<br>A. “谋”是“动”的根本目的<br>B. “谋”是“动”的根本来源<br>C. 人的“动”具有自觉能动性<br>D. 人的“谋”是世界的本源<br>正确答案：C</p>
</li>
<li><p>联结人与自然的中介是（）。<br>A. 社会关系<br>B. 社会意识<br>C. 实践<br>D. 地理环境<br>正确答案：C</p>
</li>
<li><p>把科学的实践观第一次引入认识论是（）。<br>A. 费尔巴哈哲学的功绩<br>B. 黑格尔哲学的功绩<br>C. 马克思主义哲学的功绩<br>D. 法国唯物主义哲学的功绩<br>正确答案：C</p>
</li>
<li><p>一种活动能否被称为实践活动关键是看它（）。<br>A. 是否有正确意识的指导<br>B. 是否有合适的中介<br>C. 是否以自然界为客体<br>D. 是否超出了纯粹意识活动<br>正确答案：D</p>
</li>
<li><p>（）构成全部社会生活的基础。<br>A. 社会政治实践<br>B. 科学文化实践<br>C. 物质生产实践<br>D. 纯粹意识活动<br>正确答案：C</p>
</li>
<li><p>马克思. 恩格斯指出：“如果在全部意识形态中，人们和他们的关系就像在照相机中一样是倒立成像的，那么这种现象也是从人们生活的历史过程中产生的”，这说明（）。<br>A. 意识只能歪曲地认识世界<br>B. 意识是实践的基础<br>C. 实践是意识的基础<br>D. 实践不能产生正确的认识<br>正确答案：C</p>
</li>
<li><p>列宁曾说：“我的朋友，理论是灰色的，而生活之树是常青的”，这说明（）。<br>A. 理论不能指导实践<br>B. 理论一旦形成就没有任何变化<br>C. 实践是认识的基础和来源<br>D. 生活瞬息万变不可把握<br>正确答案：C</p>
</li>
<li><p>习近平指出：“我们党现阶段提出和实施的理论和路线方针政策，之所以正确，就是因为它们都是以我国现时代的社会存在为基础的。”这说明（）。<br>A. 实践是认识的来源<br>B. 来自实践的认识都是正确的<br>C. 间接经验不能带来任何知识<br>D. 只有正确的认识具有能动性<br>正确答案：A</p>
</li>
<li><p>杜甫的诗句“读书破万卷，下笔如有神”体现了（）。<br>A. 书本是真知的源头<br>B. 人可以通过书本获得知识<br>C. 认识世界只是需要间接经验<br>D. 书本是知识的直接经验部分<br>正确答案：B</p>
</li>
<li><p>黑格尔说过，对于同一句格言，出自饱经风霜的老年人之口与出自缺乏阅历的青少年之口，其内涵是不同的。这句话说明（ ）。<br>A. 实践是认识的源头活水<br>B. 年龄是检验认识真理性的标准<br>C. 认识与世界不具备统一性<br>D. 语言不能充当实践的中介<br>正确答案：A</p>
</li>
<li><p>恩格斯说：“社会一旦有技术上的需要，这种需要就会比十所大学更能把科学推向前进。”这说明（）。<br>A. 实践的需要推动认识的产生和发展<br>B. 大学不能推动科技前进<br>C. 社会意识决定社会需要的产生<br>D. 间接经验不能推动科学发展<br>正确答案：A</p>
</li>
<li><p>古代水利工程. 建筑. 航海战争的需要催生了古代天文学. 数学和力学；生态环境保护的需要推动了生态文明理论的发展。这说明（）。<br>A. 科学文化实践是决定着社会的基本性质和面貌<br>B. 社会政治实践是人类最基本的实践活动<br>C. 实践的需要是推动认识发展之根本<br>D. 认识是实践的根本目的<br>正确答案：C</p>
</li>
<li><p>随着“羲和号”成功入轨，我国太空探测迎来“探日时代”，将进一步提升对太阳的认识。从哲学的角度来看，这说明（）。<br>A. 实践需要推动认识的产生和发展<br>B. 认识是实践的根本目的<br>C. 认识是检验实践的唯一标准<br>D. 实践为认识的发展提供了手段和条件<br>正确答案：D</p>
</li>
<li><p>柏拉图认为，人在出生之前，其灵魂已经分有了普遍的理念，知识就是对这些理念的回忆。这属于（）。<br>A. 唯心主义认识路线<br>B. 旧唯物主义反映论<br>C. 辩证唯物主义认识论<br>D. 机械唯物主义认识论<br>正确答案：A</p>
</li>
<li><p>有一种观点认为既然意识是物质的反映，那么关于鬼神是否存在就要看是否有人见到过或听到过鬼神，从认识论的角度看，这属于（）<br>A. 先验论<br>B. 理念论<br>C. 直观反映论<br>D. 能动反映论<br>正确答案：C</p>
</li>
<li><p>杭州五年级的学生发现了《西游记》的漏洞：从东土大唐到西域，吃的似乎都是江淮美食，而吴承恩正是淮安人，从认识论的角度看，这个漏洞说明（）。<br>A. 认识必然要以客观事物为原型和摹本<br>B. 认识只能受现实束缚而不能有丝毫逾越<br>C. 个人喜好是认识的根本来源<br>D. 认识是具有创造性的活动<br>正确答案：A</p>
</li>
<li><p>近年来人工智能快速发展，从“智能服务员”到无人港口，人工智能正在改变人的生活，而实际上在人工智能还没有成为现实的时候，关于人工智能的思想与模型就已经出现在科幻小说的场景中和科学家的论文里，这说明（）。<br>A. 意识是实践的基础<br>B. 认识是理念的重现<br>C. 认识改变世界而不是反映世界<br>D. 认识具有能动性和创造性<br>正确答案：D</p>
</li>
<li><p>认识运动的第一次飞跃指的是（）。<br>A. 从理念到自我意识<br>B. 从意识到现实<br>C. 从感性认识到理性认识<br>D. 从非理性因素到理性因素<br>正确答案：C</p>
</li>
<li><p>列宁称感性认识为“生动的直观”，这体现了感性认识的突出特点为（）。<br>A. 创造性<br>B. 能动性<br>C. 直接性<br>D. 正确性<br>正确答案：C</p>
</li>
<li><p>我们在意识中把通过眼. 耳. 鼻. 舌. 身各种感官感觉到一个梨子的各种属性联系起来形成了关于这个梨子的感性形象，这种意识形式属于感性认识中的（）。<br>A. 感觉<br>B. 抽象<br>C. 知觉<br>D. 分析<br>正确答案：C</p>
</li>
<li><p>“感觉到了的东西，我们不能立即理解它，只有理解了的东西，才能更深刻地感觉它。”这一观点说明（）。<br>A. 感性认识对人认识事物本质没有实际意义<br>B. 感性认识是整个认识的起点<br>C. 感性认识是认识的初级阶段，理性认识是认识的高级阶段<br>D. 感性认识的局限性<br>正确答案：C</p>
</li>
<li><p>在实际工作中，片面夸大感性经验的作用，轻视理论，把局部经验当作普遍真理到处搬用，这倾向属于（）。<br>A. 本本主义<br>B. 经验主义<br>C. 教条主义<br>D. 人本主义<br>正确答案：B</p>
</li>
<li><p>恩格斯说：“鹰比人看得远得多，但是人的眼睛识别的东西远胜于鹰。”人的感官的识别能力高于动物，除了人脑及感官发育得更完善之外，还因为（）。<br>A. 人不仅有理性还有非理性<br>B. 人不仅有感觉还有思维<br>C. 人不仅有直觉还有想象<br>D. 人不仅有生理机能还有心理活动<br>正确答案：B</p>
</li>
<li><p>恩格斯说：“人的智力是按照人如何学会改造自然界而发展的。”这说明（）。<br>A. 自然界是认识发展的动力<br>B. 实践是认识发展的动力<br>C. 意识是对世界的直观反映<br>D. 自然界是认识与实践的唯一客体<br>正确答案：B</p>
</li>
<li><p>人们所从事的政治活动. 社会改革. 社会革命都属于（）。<br>A. 物质生产实践<br>B. 意识活动实践<br>C. 社会政治实践<br>D. 科学文化实践<br>正确答案：C</p>
</li>
<li><p>有人认为只有写到书本上的理论才是真实可靠的，便不顾实际情况，生搬硬套书本上的理论，这犯了（）的错误。<br>A. 经验主义<br>B. 直观被动反映论<br>C. 唯心主义先验论<br>D. 教条主义<br>正确答案：D</p>
</li>
<li><p>改革开放以来，大约有上千条新词汇产生，比如外资企业. 知识经济. 电子邮件. 信用卡. 再就业等等。从哲学上看，这一事实说明（）。<br>A. 理性认识依赖于感性认识<br>B. 科学理论对实践具有指导作用<br>C. 意识是人脑的机能<br>D. 意识是客观存在的反映<br>正确答案：D</p>
</li>
<li><p>真理观中的首要问题是（）。<br>A. 真理是不是绝对的<br>B. 真理是不是与价值相统一<br>C. 真理是不是客观的<br>D. 真理能不能被认识<br>正确答案：C</p>
</li>
<li><p>认为真理是“观念与主体感觉相符合”的观点的局限性在于（）。<br>A. 否认了真理的相对性<br>B. 否认了真理的主观形式<br>C. 否认了真理的客观性<br>D. 否认了真理的绝对性<br>正确答案：C</p>
</li>
<li><p>认为“真理是‘绝对理念’的自我显现”的真理观属于（）。<br>A. 客观唯心主义真理观<br>B. 主观唯心主义真理观<br>C. 机械唯物主义真理观<br>D. 辩证唯物主义真理观<br>正确答案：A</p>
</li>
<li><p>马克思主义真理观与旧唯物主义真理观的不同之处在于，它认为真理与客观事物之间的符合关系是建立在（）的基础上的<br>A. 意识<br>B. 理念<br>C. 自然界<br>D. 实践<br>正确答案：D</p>
</li>
<li><p>认识成为真理的先决条件在于（）。<br>A. 是否采取理性判断的形式<br>B. 是否能形成自圆其说的推理<br>C. 是否有感性认识作支撑<br>D. 是否正确反映对象的本质和规律<br>正确答案：D</p>
</li>
<li><p>列宁指出：“主观主义和辩证法的区别在于：在（客观的）辩证法中，相对和绝对的差别也是相对的。”从真理的角度看，这说明（）。<br>A. 真理都是相对主体而言的<br>B. 真理在本质上不具备绝对性<br>C. 真理是绝对性与相对性的统一<br>D. 真理不可认识<br>正确答案：C</p>
</li>
<li><p>列宁指出：“在唯物主义者看来，人类实践的成功证明着我们的表象和我们所感知的客观事物的客观本性相符合。”这说明真理是（）。<br>A. 对客观事物及其规律的正确反映<br>B. 客观实在<br>C. 感性认识<br>D. 主观内容与客观形式的统一<br>正确答案：A</p>
</li>
<li><p>“‘成功’是我在实践中所需要的一切”这种观点的局限在于（）。<br>A. 混淆了“真理”和“有用”<br>B. 忽视了真理的主观形式<br>C. 把实践当做检验真理的唯一标准<br>D. 承认真理的客观性<br>正确答案：A</p>
</li>
<li><p>不同的主体对同一事物往往有不同的认识和判断，往往出现“此亦一是非，彼亦一是非”的情况，这是因为（）。<br>A. 真理是多元的<br>B. 认识是多元的<br>C. 真理不具有客观性<br>D. 认识不能正确反映世界<br>正确答案：B</p>
</li>
<li><p>承认了世界的可知性，承认人能够获得关于无限发展着的物质世界的正确认识，也就是承认了（）。<br>A. 认识的本源性<br>B. 静止的绝对性<br>C. 矛盾的特殊性<br>D. 真理的绝对性<br>正确答案：D</p>
</li>
<li><p>列宁指出：“人不能完全地把握——反映——描绘整个自然界. 它的‘直接的总体’，人只能通过创立抽象. 概念. 规律. 科学的世界图景等等永远地接近于这一点。”这说明（）。<br>A. 真理不具有绝对性<br>B. 世界是不可知的<br>C. 真理具有相对性<br>D. 真理的内容是主观的<br>正确答案：C</p>
</li>
<li><p>在实际工作中的教条主义. 思想僵化，追求某种一成不变的公式，是（）的表现。<br>A. 绝对主义<br>B. 相对主义<br>C. 辩证法<br>D. 唯物主义<br>正确答案：A</p>
</li>
<li><p>所谓马克思主义“过时论”属于（）。<br>A. 只承认真理绝对性的独断论<br>B. 只承认真理相对性的相对主义<br>C. 只承认真理客观性的唯物主义<br>D. 只承认真理主观性的实用主义<br>正确答案：B</p>
</li>
<li><p>“真理和谬误的对立，只是在非常有限的范围内才有意义”是（）。<br>A. 形而上学的观点<br>B. 唯物辩证法的观点<br>C. 诡辩论的观点<br>D. 相对主义的观点<br>正确答案：B</p>
</li>
<li><p>列宁指出：“任何真理，如果把它说得‘过火’……加以夸大，把它运用到实际使用的范围之外，便可以弄到荒谬绝伦的地步。”这说明（）。<br>A. 真理和谬误的对立是绝对的<br>B. 真理和谬误在一定条件下相互转化<br>C. 真理不具有绝对性<br>D. 从整体上看世界是不可知的<br>正确答案：B</p>
</li>
<li><p>平面条件下三角形的内角和为180度，这是广为人知的定理，但是到了曲面条件下，三角形的内角和就会大于或小于180度。这说明（）。<br>A. 真理都是在一定条件下才能成立<br>B. 数学知识不具备真理性<br>C. 真理与谬误的对立是绝对的<br>D. 人不能认识曲面条件下的几何知识<br>正确答案：A</p>
</li>
<li><p>在现实中，反面案例. 反面教材往往能起到警示人的教育作用，这说明（）。<br>A. 谬误就是真理. 真理就是谬误<br>B. 谬误是真理的来源<br>C. 在批判谬误中可以发展真理<br>D. 任何谬误都会转化为真理<br>正确答案：C</p>
</li>
<li><p>以多数人的意见为真理的标准和强调有用即真理的实用主义，在真理标准问题上的共同错误是（）。<br>A. 用认识检验认识<br>B. 认为真理具有客观性<br>C. 用实践检验认识<br>D. 认为真理是绝对的<br>正确答案：A</p>
</li>
<li><p>真理的本性在于（）。<br>A. 客观实在<br>B. 主观意识<br>C. 主观和客观相符合<br>D. 对主体的有用性<br>正确答案：C</p>
</li>
<li><p>“人们达到了思想中所预想的结果时，人们的认识才被证实了”说明（）。<br>A. 目的的正确性是检验真理的标准<br>B. 真理是主观见之于主观的认识活动<br>C. 实践是检验认识真理性的唯一标准<br>D. 认识是第一位的，实践是第二位的<br>正确答案：C</p>
</li>
<li><p>列宁指出：“实践标准决不能完全地证实或驳倒人类的任何表象。”这说明（）。<br>A. 实践不是检验认识真理性的标准<br>B. 实践标准具有不确定性<br>C. 表象是不可认知的<br>D. 实践标准不具有确定性<br>正确答案：B</p>
</li>
<li><p>列宁指出：“必须把人的全部实践——作为真理的标准，也作为事物同人所需要它的那一点的联系的实际确定者——包括到事物的完整的‘定义’中去。”这说明（）。<br>A. 具体的实践不能检验真理<br>B. 实践标准不具有客观性<br>C. 实践检验是一次完成的<br>D. 实践检验真理是一个永无止境的过程<br>正确答案：D</p>
</li>
<li><p>以前在农村，秸秆对农民来说几乎是一个毫无价值的东西，往往通过焚烧来处理，而随着新能源研究的推进，秸秆作为发电和制沼的原料，其价值在某种程度上甚至超过了粮食。这说明（）。<br>A. 客体的价值不具有确定性<br>B. 不同主体的评价创造了不同价值<br>C. 价值是实践基础上确立的主体与客体之间一种创造性关系<br>D. 价值随主体变化，而变化与客体本身无关<br>正确答案：C</p>
</li>
<li><p>同一块钻石，对不同的人而言，具有不同的价值，这说明（）。<br>A. 价值具有主体性与客体无关<br>B. 价值是运动变化的不能不能认识<br>C. 价值的客体性依赖于主体性<br>D. 价值具有多维性<br>正确答案：D</p>
</li>
<li><p>从家用热水器到发电厂的光伏板，今天人们已经充分认识了太阳能的巨大价值。太阳能的发现和利用体现了（）。<br>A. 价值具有社会历史性<br>B. 价值是一维的<br>C. 人的认识和评价创造了价值<br>D. 价值不具有确定性<br>正确答案：A</p>
</li>
<li><p>我国科学家屠呦呦用科学实验方法探寻疟疾的新疗法，体现了（）。<br>A. 真理的确定性和不确定性的统一<br>B. 价值的多维性和一维性的统一<br>C. 真理与价值的对立性<br>D. 真理尺度与价值尺度的统一<br>正确答案：D</p>
</li>
<li><p>1978年关于真理标准大讨论是一场新的思想解放运动，实践之所以成为检验真理的唯一标准是由（）。<br>A. 真理的主观性和实践的客观性所要求的<br>B. 真理的相对性和实践的决定性所预设的<br>C. 真理的绝对性和实践的功能所规定的<br>D. 真理的本性和实践的特点所决定的<br>正确答案：D</p>
</li>
<li><p>列宁指出：“没有抽象的真理，真理都是具体的。”这句话的含义是（）。<br>A. 真理有其适用的范围和条件<br>B. 真理的形成不需要进行抽象的概括<br>C. 真理是抽象不变的公式<br>D. 真理本身没有任何抽象因素<br>正确答案：A</p>
</li>
<li><p>辩证法与形而上学在真理观上的对立在于是否承认（）。<br>A. 真理具有绝对性<br>B. 真理具有客观性<br>C. 真理具有主观性<br>D. 真理具有相对性<br>正确答案：D</p>
</li>
<li><p>既承认实践是检验真理的唯一标准，又承认逻辑证明在认识和探索真理中的作用，就是认为（）。<br>A. 检验真理的标准是多元的<br>B. 逻辑证明可以取代实践标准<br>C. 逻辑证明可以最终证实或驳倒真理<br>D. 被逻辑证明和证伪了的认识最终还要靠实践的检验<br>正确答案：D</p>
</li>
<li><p>16世纪末，伽利略通过在比萨斜塔所做的自由落体实验，推翻了亚里士多德关于物体的降落速度与物体的重量成正比的说法。这件事说明（）。<br>A. 感性认识只有上升到理性认识才能把握事物的本质<br>B. 实践是检验认识真理性的唯一标准<br>C. 实践是认识发展的动力<br>D. 真理是对事物及其发展规律的正确反映<br>正确答案：B</p>
</li>
<li><p>“追求真理比占有真理更宝贵”这一命题所包含的哲理是（）。<br>A. 认识经历着从感性认识到理性认识的发展<br>B. 认识的根本任务是通过现象认识本质<br>C. 认识不能停滞，而应该不断扩展和深化<br>D. 改造世界比认识世界更重要<br>正确答案：C</p>
</li>
<li><p>价值评价是主体对客体价值以及价值大小所作的评判或判断，价值评价是（）。<br>A. 一种纯主观的认识活动<br>B. 没有任何客观标准的评价<br>C. 没有正确与错误区分的评价<br>D. 有肯定与否定之分的评价<br>正确答案：D</p>
</li>
<li><p>人类认识和实践活动中的基本矛盾是（）。<br>A. 普遍性与特殊性的矛盾<br>B. 绝对性与相对性的矛盾<br>C. 主观与客观的矛盾<br>D. 个人和社会的矛盾<br>正确答案：C</p>
</li>
<li><p>（）是人类认识世界和改造世界的根本动力。<br>A. 真理与价值的矛盾<br>B. 经济基础和上层建筑的矛盾<br>C. 本质与现象的矛盾<br>D. 主观与客观的矛盾<br>正确答案：D</p>
</li>
<li><p>马克思在《关于费尔巴哈的提纲》中指出：“环境的改变和人的活动或自我改变是一致的。”这体现了（）。<br>A. 改造客观世界与改造主观世界的统一<br>B. 认识的真理性和价值性的统一<br>C. 环境的客观实在性和主观能动性的统一<br>D. 人的活动的有限性和无限性的统一<br>正确答案：A</p>
</li>
<li><p>自由就是“由自”，这种观点（）。<br>A. 属于宿命论<br>B. 属于唯意志论<br>C. 强调消极顺应自然<br>D. 抹杀了人类自由的可能性<br>正确答案：B</p>
</li>
<li><p>恩格斯指出：“自由不在于幻想中摆脱自然规律而独立，而在于认识这些规律，从而能够有计划地使自然规律为一定目的服务”，这说明（）。<br>A. 人的实践只具有合目的尺度<br>B. 人能够改造和利用自然规律<br>C. 自由既要认识必然又要利用必然<br>D. 人只能消极的顺应自然<br>正确答案：C</p>
</li>
<li><p>习近平指出：“我国正处于并将长期处于社会主义初级阶段，我们不能做超越阶段的事情……而是要根据现有条件把能做的事情尽量做起来”，从自由观的角度看，这说明（）。<br>A. 自由是具体的历史的<br>B. 人只能被动的受社会历史限制<br>C. 实践条件是自由的唯一条件<br>D. 自由是一劳永逸的事情<br>正确答案：A</p>
</li>
<li><p>一切从（）出发，是马克思主义认识论的根本要求和具体体现。<br>A. 实际<br>B. 认识<br>C. 权威<br>D. 书本<br>正确答案：A</p>
</li>
<li><p>马克思. 恩格斯认为：“共产党人的原理……不过是现存的阶级. 我们眼前的历史运动的真实关系的一般表述。”这说明（）。<br>A. 马克思主义基本原理没有把握人类社会发展规律<br>B. 马克思主义只在当时的历史条件有效<br>C. 运用马克思主义必须从实际出发<br>D. 马克思主义不能指导实践<br>正确答案：C</p>
</li>
</ol>
<h3 id="多选-2"><a href="#多选-2" class="headerlink" title="多选"></a>多选</h3><ol>
<li><p>科学实践观创立和发展的意义包括（）。<br>A. 克服了旧唯物主义的根本缺陷，为辩证唯物主义奠定了科学的理论基础<br>B. 建立了科学的. 能动的. 革命的反映论，实现了人类认识史上的变革<br>C. 在人类思想史上第一次揭示了社会生活的实践本质，为创建科学的历史观奠定了理论基础<br>D. 为人们能动地认识世界和改造世界提供了基本的思想方法和工作方法<br>正确答案：ABCD</p>
</li>
<li><p>实践是人能动改造客观世界的物质性活动，具有（）等基本特征。<br>A. 客观实在性<br>B. 自觉能动性<br>C. 社会历史性<br>D. 不可认识性<br>正确答案：ABC</p>
</li>
<li><p>实践在本质上是客观的. 物质的活动，这是因为（）。<br>A. 实践的主体和客体都是客观实在<br>B. 实践的中介是物质的<br>C. 实践的水平. 广度. 深度和发展过程都受客观条件制约<br>D. 实践能引起客观世界的变化<br>正确答案：ABCD</p>
</li>
<li><p>实践的基本要素包括（）。<br>A. 实践的主体<br>B. 实践的客体<br>C. 实践的中介<br>D. 实践的结果<br>正确答案：ABC</p>
</li>
<li><p>以下各项中，属于实践中介的有（）。<br>A. 耕牛<br>B. 电脑<br>C. 无人机<br>D. 语言<br>正确答案：ABCD</p>
</li>
<li><p>以下各项中，属于体现客体主体化的现象的有（）。<br>A. 万户设想了通过火箭升空的场景<br>B. 设计师设计制作了一款新型手机<br>C. 商人乘坐飞机飞往大洋彼岸<br>D. 大学生在课堂上学习知识<br>正确答案：BC</p>
</li>
<li><p>一位科学家说：“我们今天生活着的世界，与其说是自然世界，还不如说是人造或人为的世界。在我们的周围，几乎每样东西都刻有人的技能的痕迹。”这段话应理解为（）。<br>A. 人造的或人为的世界是惟一存在的世界<br>B. 现实世界是人类精神的创造物<br>C. 人类世界是人的实践活动对象化的结果<br>D. 科学技术越来越成为人类改造世界的伟大力量<br>正确答案：CD</p>
</li>
<li><p>马克思指出：“费尔巴哈把宗教的本质归结于人的本质。但是人的本质不是单个人所固有的抽象物，在其现实性上，它是一切社会关系的总和。”这说明相对于费尔巴哈的旧唯物主义，马克思主义的科学之处在于（）。<br>A. 从实践出发把握现实世界<br>B. 从实践出发认识人及其与世界的关系<br>C. 在实践基础上实现了唯物论和辩证法的统一<br>D. 克服了旧唯物主义不懂实践在社会生活中的决定意义的局限<br>正确答案：ABCD</p>
</li>
<li><p>马克思指出：“人的认识是否具有客观的真理性，这不是一个理论的问题，而是一个实践的问题。”马克思主义科学实践观的意义在于（）。<br>A. 揭示了实践的观点是辩证唯物主义认识论首要的和基本的观点。<br>B. 找到了检验认识真理性的唯一标准<br>C. 批判了唯心主义先验论和不可知论<br>D. 克服了旧唯物主义直观反映论的缺陷<br>正确答案：ABCD</p>
</li>
<li><p>马克思. 恩格斯在《德意志意识形态》中写道：“以一定的方式进行生产活动的一定的个人，发生一定的社会关系和政治关系。”马克思的科学实践观的科学之处在于（）。<br>A. 揭示了社会生活的实践本质<br>B. 指出了物质生产实践在社会生活中的重要作用和地位<br>C. 实现了唯物主义自然观和历史观的统一<br>D. 找到了人类历史“真正的发源地”<br>正确答案：ABCD</p>
</li>
<li><p>马克思. 恩格斯指出：“对实践的唯物主义者即共产主义者来说，全部问题在于使现存世界革命化，实际地反对并改变现存的事物。”马克思主义科学实践观的意义在于（）。<br>A. 强调改变世界的重要性<br>B. 强调理论应转化为物质力量<br>C. 为人能动地改造世界提供了基本的思想方法和工作方法<br>D. 是人们认识世界和改造世界的锐利武器<br>正确答案：ABCD</p>
</li>
<li><p>人类的实践活动是不断发展的，它的发展有自身的特点和规律。实践的发展过程是（）。<br>A. 范围不断扩大. 程度不断加深. 效果不断提升的过程<br>B. 从低级到高级. 从简单到复杂. 从自发到自觉的过程<br>C. 改造客观世界和改造主观世界相互促进的过程<br>D. 逐步走向真善美相统一. 最终实现人的自由而全面的发展的过程<br>正确答案：ABCD</p>
</li>
<li><p>实践对认识的决定作用表现在（）。<br>A. 实践是认识的来源<br>B. 实践是认识发展的动力<br>C. 实践是认识的目的<br>D. 实践是检验认识真理性的唯一标准<br>正确答案：ABCD</p>
</li>
<li><p>实践是认识发展的动力，这表现在（）。<br>A. 实践的需要推动认识的产生和发展<br>B. 实践为认识发展提供了手段和条件<br>C. 实践改造了人的主观世界<br>D. 实践锻炼和提高了人的认识能力<br>正确答案：ABCD</p>
</li>
<li><p>习近平说：“你脑子里装着问题了，想解决问题了，想把问题解决好了，就会去学习，就会自觉去学习。”这体现了（）。<br>A. 实践需要推动认识的产生和发展<br>B. 学习间接经验是解决问题的根本途径<br>C. 主观意愿是获得知识的根本动力<br>D. 实践推动人提高认识能力改造主观世界<br>正确答案：AD</p>
</li>
<li><p>习近平指出：“历史表明，社会大变革的时代，一定是哲学社会科学大发展的时代。”从马克思主义哲学角度来看，这是因为（）。<br>A. 认识是实践的基础<br>B. 认识是实践的归宿<br>C. 实践是认识的来源<br>D. 实践是认识发展的动力<br>正确答案：CD</p>
</li>
<li><p>马克思在《关于费尔巴哈的提纲》中提出：“关于思维——离开实践的思维——的现实性或非现实性的争论，是一个纯粹经院哲学的问题。”这说明（）。<br>A. 思维不具备现实性<br>B. 思维是否具有真理性不能从自身得到证实<br>C. 实践是检验认识真理性的唯一标准<br>D. 认识的真理性只有在实践中才能得到验证<br>正确答案：BCD</p>
</li>
<li><p>“求之而后得，为之而后成”，这属于（）。<br>A. 唯物主义认识路线<br>B. 唯心主义认识路线<br>C. 反映论<br>D. 天赋观念论<br>正确答案：AC</p>
</li>
<li><p>旧唯物主义认识论的缺陷包括（）。<br>A. 认为认识是理念的产物<br>B. 认为认识是无本之木<br>C. 离开实践考察认识问题<br>D. 不了解认识的辩证本性<br>正确答案：CD</p>
</li>
<li><p>辩证唯物主义认识论的突出特点有（）。<br>A. 把实践的观点引入认识论<br>B. 把辩证法应用于反映论考察认识的发展过程<br>C. 坚持意识对物质的决定作用<br>D. 认识到意识自身的不动性和永恒性<br>正确答案：AB</p>
</li>
<li><p>理性认识是认识的高级阶段，具有（）的特点。<br>A. 抽象性<br>B. 具体性<br>C. 间接性<br>D. 直接性<br>正确答案：AC</p>
</li>
<li><p>感觉. 知觉. 表象的依次发展，初步显现出（）。<br>A. 认识的发展是不断进行质的飞跃的趋势<br>B. 认识发展从部分到全体的发展趋势<br>C. 认识发展从直接到间接的发展趋势<br>D. 认识发展从感性认识到理性认识发展的趋势<br>正确答案：BCD</p>
</li>
<li><p>认识的第二次飞跃是更为重要的飞跃，其重要性在于（）。<br>A. “生动的直观”是认识过程的起始环节<br>B. 认识世界的目的是改造世界<br>C. 认识的真理性只有在实践中才能得到检验<br>D. 理性认识以事物本质为内容<br>正确答案：BC</p>
</li>
<li><p>习近平指出：“科学理论是我们推动工作. 解决问题的‘金钥匙’”，这句话强调（）。<br>A. 做好认识的第一次飞跃的重要性<br>B. 做好认识的第二次飞跃的重要性<br>C. 科学理论是认识的最终目的<br>D. 科学理论对于实践具有指导作用<br>正确答案：AD</p>
</li>
<li><p>习近平指出：“实践没有止境，理论创新也没有止境。”这是（）。<br>A. 针对当前具体事物. 现实而言的<br>B. 针对实践和认识运动过程向前推移向前发展而言的<br>C. 看到了客观世界的发展变化<br>D. 体现了实践认识的辩证发展过程<br>正确答案：BCD</p>
</li>
<li><p>一个正确的思想，往往需要经历由实践到认识，由认识到实践的多次反复才能形成，这是因为（）。<br>A. 认识主体存在着自身的局限性<br>B. 事物本质的暴露是一个过程<br>C. 人的认识受社会历史条件的限制<br>D. 认识是一个过程<br>正确答案：ABCD</p>
</li>
<li><p>列宁在十月革命胜利后指出：“对俄国来说，根据书本争论社会主义纲领的时代已经过去了，我深信已经一去不复返了。今天只能根据经验来谈社会主义。”对这句话的正确理解有（）。<br>A. 应该在实践中不断丰富发展社会主义理论<br>B. 社会主义建设不需要任何纲领<br>C. 必须由实践来检验社会主义理论<br>D. 对社会主义的认识应该由经验代替理论<br>正确答案：AC</p>
</li>
<li><p>“按图索骥”就是指照图上画的样子去寻求好马，这种方法的错误在于（）。<br>A. 理论脱离实际<br>B. 教条主义<br>C. 经验论<br>D. 唯理论<br>正确答案：ABD</p>
</li>
<li><p>割裂感性认识和理性认识的统一会导致（）。<br>A. 诡辩论<br>B. 唯理论<br>C. 经验论<br>D. 反映论<br>正确答案：BC</p>
</li>
<li><p>下列各项中，能正确说明感性认识和理性认识的联系的有（）。<br>A. 理性认识依赖于感性认识<br>B. 感性认识可以自然而然地上升到理性认识<br>C. 感性认识有待于发展到理性认识<br>D. 理性认识是在感性认识指导下进行的<br>正确答案：AC</p>
</li>
<li><p>同一棵大树，木匠看到的是木材，画家看到的是色彩和色调，植物学家看到的是它的形态特征，这是由于（）。<br>A. 人的感觉受理性指导<br>B. 人的认识具有能动性<br>C. 理性认识是感性认识的基础<br>D. 已有的认识影响感觉活动<br>正确答案：ABD</p>
</li>
<li><p>孙中山先生指出，认识过程是“以行而求知，因知以进行”“行其所不知以致其所知”“因其已知而更进于行”。其中所表达的思想有（）。<br>A. 知行相互促进<br>B. 行先知后<br>C. 知行不可分割<br>D. 知行合一<br>正确答案：ABCD</p>
</li>
<li><p>毛泽东强调：“一个正确的认识，往往需要经过由物质到精神，由精神到物质，即由实践到认识，由认识到实践这样多次的反复，才能够完成。”这说明实践. 认识的辩证运动过程也就是（）。<br>A. 通过实践发现真理的过程<br>B. 通过实践证实真理的过程<br>C. 通过实践发展真理的过程<br>D. 通过实践走向最高理念的过程<br>正确答案：ABC</p>
</li>
<li><p>强调“有用即是真理”的实用主义真理观的局限在于（）。<br>A. 夸大了真理的主观性<br>B. 夸大了真理的客观性<br>C. 夸大了真理的相对性<br>D. 夸大了真理的绝对性<br>正确答案：AC</p>
</li>
<li><p>“一个观念是真的，只要它能帮助我们和我们经验别的部分，得到圆满的关系”，这种真理观（）。<br>A. 属于辩证唯物主义真理观<br>B. 属于实用主义真理观<br>C. 忽视了真理的客观性<br>D. 忽视了真理的主观性<br>正确答案：BC</p>
</li>
<li><p>“认为我们的感觉是外部世界的映像；承认客观真理；坚持唯物主义认识论的观点——这都是一回事”，这说明（）。<br>A. 坚持真理的客观性是真理问题上的唯物论<br>B. 真理的客观性是唯物主义反映论在真理问题上的贯彻<br>C. 辩证唯物主义和旧唯物主义真理观没有区别<br>D. 承认真理的客观性就是否认真理的主观性<br>正确答案：AB</p>
</li>
<li><p>真理的绝对性的含义是指（）。<br>A. 任何真理都标志着主观与客观相符合<br>B. 人类认识能够正确认识无限发展的物质世界<br>C. 真理都是有用的<br>D. 真理永恒不变<br>正确答案：AB</p>
</li>
<li><p>“对自然界的一切真实的认识，都是对永恒的东西. 无限的东西的认识”，这说明（）。<br>A. 真理具有相对性<br>B. 真理具有绝对性<br>C. 世界是可知的<br>D. 世界是不可知的<br>正确答案：BC</p>
</li>
<li><p>真理的相对性的含义是指（）。<br>A. 人不能正确认识无限发展着的世界<br>B. 任何真理都只是对客观世界的某一阶段. 某一部分的正确认识<br>C. 任何真理都只是对客观对象一定方面. 一定层次和一定程度的正确认识<br>D. 世界一直发展变化不存在相对静止<br>正确答案：BC</p>
</li>
<li><p>真理在一定条件下会转化为谬误，这是因为（）。<br>A. 真理本身不具备客观性<br>B. 真理只是相对真理<br>C. 真理是一定条件下的真理<br>D. 真理是同其他原理联系在一起的真理<br>正确答案：CD</p>
</li>
<li><p>“失败常常是成功之母”说明（）。<br>A. 谬误在一定条件下能够向真理转化<br>B. 谬误必然转化为真理<br>C. 真理与谬误的对立是相对的<br>D. 真理与谬误的对立是绝对的<br>正确答案：AC</p>
</li>
<li><p>认识自身不能作为检验真理的标准是因为（）。<br>A. 检验真理是检验主观同客观的符合程度<br>B. 认识检验认识始终实在主观范围内兜圈子<br>C. 已经被证明为正确的理论的适用范围仍需被实践检验<br>D. 真理不具备主观性<br>正确答案：ABC</p>
</li>
<li><p>逻辑证明不能成为检验真理的标准是因为（）。<br>A. 逻辑证明不能回答结论是不是符合实际的问题<br>B. 逻辑证明了的东西还必须经过实践检验<br>C. 逻辑证明对获得正确认识没有帮助<br>D. 逻辑证明作为感性认识不能认识本质<br>正确答案：AB</p>
</li>
<li><p>实践的相对性是指（）。<br>A. 实践受主客观条件制约，不可能完全证实一切认识<br>B. 实践是社会的历史的<br>C. 具体实践往往只能总体上证实认识的真理性<br>D. 实践不能最终检验认识是否具有真理性<br>正确答案：ABC</p>
</li>
<li><p>坚持实践是检验真理的唯一标准，就要（）。<br>A. 看到实践标准的确定性<br>B. 反对唯心主义. 怀疑主义. 相对主义<br>C. 看到实践标准的不确定性<br>D. 反对教条主义和独断论<br>正确答案：ABCD</p>
</li>
<li><p>价值的主体性是指（）。<br>A. 价值直接与主体相联系<br>B. 价值关系的形成依赖于主体的存在<br>C. 价值关系的形成依赖于主体的创造<br>D. 价值始终以主体为中心<br>正确答案：ABCD</p>
</li>
<li><p>价值的客观性是指（）。<br>A. 在一定条件下客体对于主体的意义不依赖主体的主观意识而存在<br>B. 主体的存在和需要是客观的<br>C. 客体的存在. 属性及作用是客观的<br>D. 客体能否满足主体需要是由客体客观存在的性质属性等决定的<br>正确答案：ABCD</p>
</li>
<li><p>正确的价值评价要（）。<br>A. 以真理为根据<br>B. 与社会历史发展的客观规律相一致<br>C. 以最广大人民的需要和利益为根本<br>D. 超越客体进行价值创造<br>正确答案：ABC</p>
</li>
<li><p>价值评价的特点是（）。<br>A. 以主客体的价值关系为认识对象<br>B. 评价结果与评价主体直接相关<br>C. 评价结果的正确与否依赖于对客体状况和主体需要的认识<br>D. 有科学与非科学之分<br>正确答案：ABCD</p>
</li>
<li><p>具有同样的化学知识，有的人为人类造福，有的人制造毒品危害社会，这说明（）。<br>A. 知识对人的行为没有影响<br>B. 科学知识不能保证行为正确<br>C. 价值观有正确错误之分<br>D. 知识与价值观之间没有联系<br>正确答案：BC</p>
</li>
<li><p>马克思主义价值观以（）为标准。<br>A. 是否满足绝大多数人的利益<br>B. 社会的进步<br>C. 人类的彻底解放<br>D. 集团政治利益<br>正确答案：ABC</p>
</li>
<li><p>社会主义核心价值观科学回答了（）等重大问题。<br>A. 建设什么样的国家<br>B. 建设什么样的社会<br>C. 培育什么样的公民<br>D. 如何实现共产主义<br>正确答案：ABC</p>
</li>
<li><p>尽管历史上罗马教廷把哥白尼的“日心说”当作“异端邪说”加以打击，但这既不能改变地球绕太阳运转的规律，也不能阻止人们接受“日心说”。这一事实说明（）。<br>A. 客观规律不以人的意志为转移<br>B. 规律是客观的<br>C. 人在客观规律面前无能为力<br>D. 真理中包含着不依赖于人的客观内容<br>正确答案：ABD</p>
</li>
<li><p>人类创造历史的两种基本活动是（）。<br>A. 认识世界<br>B. 改造世界<br>C. 创造规律<br>D. 摆脱客观世界束缚<br>正确答案：AB</p>
</li>
<li><p>改造世界包括（）。<br>A. 改造世界运行规律<br>B. 改造物质的根本属性<br>C. 改造主观世界<br>D. 改造客观世界<br>正确答案：CD</p>
</li>
<li><p>以下关于客观世界与主观世界关系的说法中，正确的有（）。<br>A. 客观世界与主观世界具有不同的存在方式<br>B. 客观世界与主观世界发展具有不完全同步性<br>C. 主观世界与客观世界的运动规律具有同一性<br>D. 在一定条件下二者可以相互转化<br>正确答案：ABCD</p>
</li>
<li><p>马克思主义关于在改造客观世界的同时改造主观世界的观点的重要意义有（）。<br>A. 有助于提高认识世界的能力<br>B. 有助于更好地处理主观世界与客观世界的关系<br>C. 有助于提高思想修养和精神境界<br>D. 有助于在改造外部世界的同时重视并努力实现人自身的改造<br>正确答案：ABCD</p>
</li>
<li><p>自觉的实现自我改造需要（）。<br>A. 勇于以自我革命的精神打造和锻炼自己<br>B. 增强自我净化. 自我完善的能力<br>C. 增强自我革命. 自我提高的能力<br>D. 完全专注于主观世界<br>正确答案：ABC</p>
</li>
<li><p>任性不是自由，无知不能获得自由，自由是有条件的。自由的条件包括（）。<br>A. 对客观事物的正确认识<br>B. 能够将获得的规律性认识运用于指导实践<br>C. 摆脱客观必然性<br>D. 完全顺从客观必然性<br>正确答案：AB</p>
</li>
<li><p>实现自由的三重含义包括（）。<br>A. 人与自然关系中的自由<br>B. 人与社会关系中的自由<br>C. 人与自身关系中的自由<br>D. 人在创造规律中自由<br>正确答案：ABC</p>
</li>
<li><p>实现人与自然关系中的自由，就要（）。<br>A. 尊重和把握自然规律<br>B. 实现人与自然和谐统一<br>C. 被动地顺应自然<br>D. 完全摆脱自然的束缚<br>正确答案：AB</p>
</li>
<li><p>实现人与社会关系中的自由，就要（）。<br>A. 把握社会规律<br>B. 以真理为根据<br>C. 以最广大人民的需要和利益为根本<br>D. 实现人与社会的和谐统一<br>正确答案：ABCD</p>
</li>
<li><p>实现人与自身关系中的自由，就要（）。<br>A. 自觉摆脱人的自我束缚<br>B. 追求更高境界的精神解放<br>C. 实现身心和谐统一<br>D. 发明本心，认识到“吾心即是宇宙”<br>正确答案：ABC</p>
</li>
<li><p>人类认识世界和改造世界的根本目标是（）。<br>A. 发明本心<br>B. 达到最高理念<br>C. 认识必然<br>D. 争取自由<br>正确答案：CD</p>
</li>
<li><p>从实际出发就是（）。<br>A. 从变化发展着的客观实际出发<br>B. 从特定的社会历史条件出发<br>C. 按照世界的本来面目认识世界<br>D. 从客观事物存在和发展的规律出发<br>正确答案：ABCD</p>
</li>
<li><p>中国共产党人在领导人民进行革命. 建设. 改革的长期实践中所确立的思想路线的内涵包括（）。<br>A. 一切从实际出发<br>B. 理论联系实际<br>C. 实事求是<br>D. 在实践中检验和发展真理<br>正确答案：ABCD</p>
</li>
<li><p>习近平指出：“时代课题是理论创新的驱动力。马克思. 恩格斯. 列宁等都是通过思考和回答时代课题来推进理论创新的。”这说明（）。<br>A. 理论创新决定了实践创新<br>B. 马克思主义已经过时<br>C. “问题倒逼”是不断进行理论创新的助推器<br>D. 时代的变化和实践发展是理论创新的源头活水<br>正确答案：CD</p>
</li>
<li><p>“实践发展永无止境，解放思想永无止境”。坚持马克思主义就是要（）。<br>A. 坚持马克思主义的科学原理和科学精神. 创新精神<br>B. 善于根据客观情况的变化不断从人民群众实践中汲取营养<br>C. 不断丰富和发展马克思主义<br>D. 运用理论指导实践<br>正确答案：ABCD</p>
</li>
</ol>
<h3 id="判断-2"><a href="#判断-2" class="headerlink" title="判断"></a>判断</h3><ol>
<li><p>目的性是实践能动性的主要表现。<br>对</p>
</li>
<li><p>实践的社会性决定了它的历史性。<br>对</p>
</li>
<li><p>在自然经济占主导的时期，生产以满足自身需要为目的，这一时期的实践不具有社会性。<br>错</p>
</li>
<li><p>人脑中观念的存在变为现实的存在是通过实践实现的。<br>对</p>
</li>
<li><p>人在实践中的结果，在实践开始时就在头脑中以观念的形式存在着，这说明实践是主观的. 观念的活动。<br>错</p>
</li>
<li><p>知识性因素是实践主体的首要的能力。<br>对</p>
</li>
<li><p>实践主体是指所有的自然人。<br>错</p>
</li>
<li><p>实践客体是指自然界。<br>错</p>
</li>
<li><p>客观实在性特征将实践活动和认识活动区分开来，使实践主体和客体. 认识主体和客体产生本质上的区别。<br>错</p>
</li>
<li><p>人类一切实践活动的结果都是主体客体化的结果。<br>对</p>
</li>
<li><p>人类实践活动就是主体客体化。<br>错</p>
</li>
<li><p>物质生产实践解决的是人与自然的矛盾，决定着社会的基本性质和面貌。<br>对</p>
</li>
<li><p>社会政治实践就是指社会革命。<br>错</p>
</li>
<li><p>社会政治实践决定了人的物质生产实践。<br>错</p>
</li>
<li><p>精神文化的生产是一个纯粹的意识过程。<br>错</p>
</li>
<li><p>教育活动之所以是一种实践活动，是因为通过教育实际地改变了受教育者的存在状态。<br>对</p>
</li>
<li><p>人在网络世界的活动因其虚拟性而不是一种人类实践。<br>错</p>
</li>
<li><p>虚拟实践的实质是主体与客体通过数字化中介系统在虚拟空间进行的双向对象化活动。<br>对</p>
</li>
<li><p>一切真知都是从直接经验发源的。<br>对</p>
</li>
<li><p>认识的最终目的是为实践服务。<br>对</p>
</li>
<li><p>认识是否具有真理性可以从认识本身和认识对象中得到回答。<br>错</p>
</li>
<li><p>直观反映论的局限性，最根本的是它看不到主观和客观之间的矛盾及其相互作用。<br>对</p>
</li>
<li><p>人的认识不论表现形式多么抽象和复杂，归根结底是对客观对象的反映，这表明这种反映具有客观性。<br>对</p>
</li>
<li><p>辩证唯物主义认为，认识就是主观对客观的照镜子式的原物映现。<br>错</p>
</li>
<li><p>人类所创造的众多科技成果，都彰显了认识的创造性的重大意义，体现了创造性是人类认识基本规定性的地位。<br>错</p>
</li>
<li><p>人认识一定事物的过程是从实践到认识，再从认识到实践的过程。<br>对</p>
</li>
<li><p>知觉是整个认识过程的起始环节。<br>错</p>
</li>
<li><p>感性认识以事物现象的内部联系为内容，深入到对事物本质的认识。<br>错</p>
</li>
<li><p>理性认识以反映事物的本质为内容，因而是深刻的。<br>对</p>
</li>
<li><p>认识的第二次能动飞跃是指从认识到实践的飞跃。<br>对</p>
</li>
<li><p>认识的第一次飞跃解决了认识是否正确的问题。<br>错</p>
</li>
<li><p>认识到实践的最后一个环节，是对人民群众进行组织宣传让理论为群众所掌握。<br>对</p>
</li>
<li><p>人们只要参加社会实践，就一定能获得对客观事物及其规律的正确认识。<br>错</p>
</li>
<li><p>在实践与认识的辩证运动中，主观必须统一于客观，认识必须统一于实践。<br>对</p>
</li>
<li><p>真理是通过人的能动的反映活动而实现的，并且必然随着人类实践的发展而拓展和深化。<br>对</p>
</li>
<li><p>真理的客观性指的是真理的内容对客观事物及其规律的正确反映。<br>对</p>
</li>
<li><p>真理之所以称之为真理，就在于其内容和形式都是客观的。<br>错</p>
</li>
<li><p>真理的客观性决定了真理的一元性。<br>对</p>
</li>
<li><p>真理的一元性是指就整个世界而言，真理性认识只有一个。<br>错</p>
</li>
<li><p>真理是内容上的一元性与形式上的多样性的统一。<br>对</p>
</li>
<li><p>任何真理都是绝对性与相对性的统一。<br>对</p>
</li>
<li><p>真理的相对性是指人们在一定条件下对客观事物及其本质和发展规律的正确认识总是有限度的。<br>对</p>
</li>
<li><p>任何真理的相对性之中都包含着真理的绝对性。<br>对</p>
</li>
<li><p>真理的绝对性和相对性根源于人类认识世界能力的无限性和有限性. 绝对性与相对性的矛盾。<br>对</p>
</li>
<li><p>马克思主义作为客观真理是绝对性和相对性的统一。<br>对</p>
</li>
<li><p>谬误是同客观事物及其发展规律相违背的认识，不是对客观世界的反映。<br>错</p>
</li>
<li><p>认识的发展与真理的获得，正是在对谬误的不断纠正中实现的。<br>对</p>
</li>
<li><p>在确定条件下，一种认识可以既是真理又是谬误。<br>错</p>
</li>
<li><p>在根本意义上，实践是检验真理的标准，此外还有诸多特定标准。<br>错</p>
</li>
<li><p>真理是对客观事物的正确反映，因此客观事物本身是检验真理的标准。<br>错</p>
</li>
<li><p>只有能够把主观和客观联系起来加以比较对照的东西，才能充当检验真理的标准，具有这种特性的东西，只能是社会实践。<br>对</p>
</li>
<li><p>实践的直接现实性品格是实践能够成为检验真理唯一标准的主要根据。<br>对</p>
</li>
<li><p>实践是检验认识真理性的唯一标准，所以逻辑推理在检验真理过程中毫无作用。<br>错</p>
</li>
<li><p>实践标准的绝对性是由实践标准的客观性和唯一性所决定的。<br>对</p>
</li>
<li><p>实践是检验认识真理性的唯一标准，这种检验是一次完成的。<br>错</p>
</li>
<li><p>价值是客体对个人. 群体乃至整个社会的生活和活动所具有的积极意义。<br>对</p>
</li>
<li><p>价值是主体的欲望. 情趣和兴趣，与客体无关。<br>错</p>
</li>
<li><p>价值具有客观性，是一种客观存在，始终以客体为中心。<br>错</p>
</li>
<li><p>主客体之间的价值关系是一种自然的现成关系。<br>错</p>
</li>
<li><p>价值的主体性以价值的客观性为前提。<br>对</p>
</li>
<li><p>价值是一种客观存在，独立于人们对它的认识和评价。<br>对</p>
</li>
<li><p>价值是一种客观存在，因此价值评价能够避免主体间的差异性。<br>错</p>
</li>
<li><p>正确反映和把握价值关系，需要对“主体”进行区分，需要处理好个体评价标准和社会评价标准之间的关系。<br>对</p>
</li>
<li><p>能否做出正确的价值判断，取决于人对客体和主体的双重认识。<br>对</p>
</li>
<li><p>对民族与国家来说，最持久. 最深层的力量是全社会共同认可的核心价值观。<br>对</p>
</li>
<li><p>核心价值观是一个国家的重要稳定器。<br>对</p>
</li>
<li><p>实践的真理尺度体现了人的活动的目的性。<br>错</p>
</li>
<li><p>人的活动是具有目的性的活动，因而真理尺度必须以价值尺度为前提。<br>错</p>
</li>
<li><p>脱离了价值尺度，真理就缺失了主体意义。<br>对</p>
</li>
<li><p>坚持主观与客观. 认识与实践的统一，归根到底是要将认识世界和改造世界密切结合起来。<br>对</p>
</li>
<li><p>正确的认识世界是改造世界的必要前提。<br>对</p>
</li>
<li><p>人的自由限度是在认识必然性的基础上自由活动。<br>对</p>
</li>
<li><p>认识了客观必然性就达到了自由。<br>错</p>
</li>
<li><p>从实际出发，关键是要注重事实，从事实出发。<br>对</p>
</li>
<li><p>只有理论. 思想才可以成为研究问题和作决策. 办事情的出发点。<br>错</p>
</li>
<li><p>坚持实事求是，最基础的工作在于搞清楚“实事”，关键在于“求是”。<br>对</p>
</li>
<li><p>当前我国，一切从实际出发，就是一切要从中国特色社会主义进入了新时代这个我国发展新的历史方位出发。<br>对</p>
</li>
<li><p>在理论创新与实践创新的相互关系中，实践创新具有基础性的意义。<br>对</p>
</li>
</ol>
<h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><h3 id="单选-3"><a href="#单选-3" class="headerlink" title="单选"></a>单选</h3><ol>
<li><p>社会历史观的基本问题是（）。<br>A. 社会存在和社会意识的关系问题<br>B. 生产力和生产关系的关系问题<br>C. 物质与意识的关系问题<br>D. 真理与价值的关系问题<br>正确答案：A</p>
</li>
<li><p>社会存在是社会生活的物质方面，其中的（）提供了社会生活和生产资料的来源。<br>A. 自然地理环境<br>B. 人口因素<br>C. 社会心理<br>D. 意识形态<br>正确答案：A</p>
</li>
<li><p>之所以坚持人与自然和谐共生，建设生态文明，从唯物史观的角度来看，是因为（）。<br>A. 人在自然面前是无能为力的<br>B. 自然地理环境是社会存在和发展的决定力量<br>C. 自然生态平衡对社会生活起着重要作用<br>D. 自然地理环境决定社会结构和面貌<br>正确答案：C</p>
</li>
<li><p>为调整我国人口结构，提高人口质量，2021年我国出台了三孩政策。从唯物史观的视角看，这体现了（）。<br>A. 人口是社会生活的决定力量<br>B. 人口数量越大对社会发展作用越大<br>C. 人口提供了社会生活和生产资料的来源<br>D. 人口的数量. 质量和结构对生产发展和社会进步起加速或延缓作用<br>正确答案：D</p>
</li>
<li><p>“任何一个民族，如果停止劳动，不用说一年，就是几个星期，也要灭亡……”，这说明（）。<br>A. 自然地理环境对社会存在与发展的重要性<br>B. 人口因素对社会存在发展的重要性<br>C. 物质生产方式对社会存在发展的重要性<br>D. 资本主义雇佣劳动对社会存在发展的重要性<br>正确答案：C</p>
</li>
<li><p>（）是最直接. 最集中地反映经济基础的意识形态，在意识形态中居于核心地位，发挥主导作用。<br>A. 政治法律思想<br>B. 社会心理<br>C. 人口因素<br>D. 自然地理环境<br>正确答案：A</p>
</li>
<li><p>《新时代公民道德建设实施纲要》倡导自觉传承中华传统美德，从唯物史观角度看，这体现了（）。<br>A. 道德是永恒不变的<br>B. 道德具有继承性<br>C. 道德是独立发展的，不反映经济基础<br>D. 不同时代具有相同的道德<br>正确答案：B</p>
</li>
<li><p>“在原始社会，人们只有朴素的公有观念，不知‘私有’为何物。随着以生产资料私有制为基础的生产方式的出现和原始社会的瓦解，私有观念才得以产生。”这说明（）。<br>A. 社会意识是历史的具体的<br>B. 社会意识消极地受制于社会存在<br>C. 社会意识决定社会存在<br>D. 社会意识具有相对独立性<br>正确答案：A</p>
</li>
<li><p>马克思指出：“正像古代各民族是在想象中. 在神话中经历了自己的史前时期一样，我们德国人在思想中. 在哲学中经历了自己的未来的历史”，这说明（）。<br>A. 社会意识受制于社会存在<br>B. 社会意识能够摆脱社会存在<br>C. 社会意识具有相对独立性<br>D. 社会意识决定社会存在<br>正确答案：C</p>
</li>
<li><p>“法国人的浪漫. 德国人的严谨。不同民族有其不同的思维特点和习惯”，这说明（）。<br>A. 自然地理环境决定社会意识<br>B. 社会意识决定社会发展方式<br>C. 共同的社会意识是民族形成的基础<br>D. 社会意识具有历史继承性<br>正确答案：D</p>
</li>
<li><p>“在中国，‘让’是一种传统美德，文明出行的道德基础，就是‘礼让’。”传统的“让”作为现代文明出行的道德基础，体现了（）。<br>A. 道德的永恒性<br>B. 道德具有继承性<br>C. 道德在社会意识中居于核心<br>D. 道德水平决定社会发展<br>正确答案：B</p>
</li>
<li><p>马克思指出：“理论一经掌握群众，也会变成物质力量。”从唯物史观角度看，这说明（）。<br>A. 社会意识对社会存在具有反作用<br>B. 社会意识决定社会存在<br>C. 群体意识是意识形态的主导<br>D. 哲学理论不具有阶级性<br>正确答案：A</p>
</li>
<li><p>马克思指出：“思想本身根本不能实现什么东西。思想得到实现，就要有使用实践力量的人。”这说明（）。<br>A. 社会意识对社会存在没有影响<br>B. 社会意识不能转化为物质力量<br>C. 社会意识的能动作用是通过指导人们的实践活动实现的<br>D. 人口因素是社会意识产生发展的决定力量<br>正确答案：C</p>
</li>
<li><p>唯物史观和唯心史观的根本分野是（）。<br>A. 对社会存在社会意识关系问题的不同回答<br>B. 对意识和物质关系的不同回答<br>C. 对真理与价值关系的不同回答<br>D. 对认识来源问题的不同回答<br>正确答案：A</p>
</li>
<li><p>在人类思想史上第一次正确回答了社会历史观的基本问题，宣告唯心史观的彻底破产的是（）。<br>A. 费尔巴哈的唯物主义历史观<br>B. 黑格尔的唯心主义历史观<br>C. 马克思主义历史观<br>D. 机械唯物主义历史观<br>正确答案：C</p>
</li>
<li><p>习近平指出：“中华民族从来不是一帆风顺的，遇到了无数艰难困苦，但我们都挺过来. 走过来了，其中一个很重要的原因就是世世代代的中华儿女培育和发展了独具特色. 博大精深的中华文化。”这说明（）。<br>A. 文化是社会发展的决定力量<br>B. 文化为社会发展提供精神动力<br>C. 文化决定其他一切社会关系<br>D. 文化都具有积极作用<br>正确答案：B</p>
</li>
<li><p>科学技术突飞猛进，人工智能和生物技术加速发展，人类社会正进入一个前所未有的历史性变化，在这场技术驱动的大变局中，出现了哲学“无用”的哲学终结论。这种观点的局限性在于（）。<br>A. 弱化了社会存在的决定力量<br>B. 夸大了社会意识的相对独立性<br>C. 忽视了社会意识的能动作用<br>D. 割裂了社会意识的历史继承性<br>正确答案：C</p>
</li>
<li><p>马克思指出：“一旦人开始生产自己的生活资料，即迈出由他们的肉体组织所决定的这一步的时候，人本身就开始把自己和动物区别开来。”这说明（）。<br>A. 人的肉体组织是人类历史的物质基础<br>B. 生产力是人类生活和历史的物质基础<br>C. 人与动物分别是生产的目的<br>D. 人与动物的生产是同的<br>正确答案：B</p>
</li>
<li><p>劳动资料也称劳动手段，是人们在劳动过程中所运用的物质资料或物质条件，其中最重要的是（）。<br>A. 生产工具<br>B. 劳动技能<br>C. 劳动意识<br>D. 科学知识<br>正确答案：A</p>
</li>
<li><p>在生产力的基本要素中，（）是生产力中最活跃的因素。<br>A. 劳动者<br>B. 生产工具<br>C. 劳动对象<br>D. 劳动产品<br>正确答案：A</p>
</li>
<li><p>利用无人机作业喷药防控与常规喷雾. 烟雾防治相比较，可提高喷药速度. 减少人工成本，提高防治效果. 减少农药使用量，极大地提高了农业植保效率。这说明（）。<br>A. 科学知识是生产力中最活跃的因素<br>B. 科学技术是社会发展的基础和决定力量<br>C. 科学技术是第一生产力<br>D. 科学技术一定有利于人类社会发展<br>正确答案：C</p>
</li>
<li><p>人们解决社会同自然矛盾的实际能力如何主要取决于（）。<br>A. 主观意志的坚定与否<br>B. 理论思维的发展程度<br>C. 生产工具的质量和数量<br>D. 自然界的发展阶段<br>正确答案：C</p>
</li>
<li><p>区分不同生产方式. 判定社会经济结构性质的客观依据是（）。<br>A. 生产工具的性质<br>B. 生产资料所有制<br>C. 劳动者发展程度<br>D. 科学技术水平<br>正确答案：B</p>
</li>
<li><p>马克思在《政治经济学批判》中指出：“经济学研究的不是物，而是人和人之间的关系”，这说明生产关系（）。<br>A. 不具有客观实在性<br>B. 属于社会意识领域<br>C. 是人在物质生产过程中所形成的联系和关系<br>D. 以人的意志为转移<br>正确答案：C</p>
</li>
<li><p>马克思曾说：“手推磨产生的是封建社会，蒸汽磨产生的是工业资本家的社会。”这说明（）。<br>A. 生产工具是生产力中最活跃的因素<br>B. 生产工具的性质是区分不同社会形态的标志<br>C. 生产力状况决定生产关系的性质<br>D. 科学技术的发展是社会形态更替的主要标志<br>正确答案：C</p>
</li>
<li><p>马克思曾说：“（人们）在行会制度及各种规则的保护下积累了资本，发展了海上贸易，建立了殖民地，而人们如果想把这些果实赖以成熟起来的那些形式保存下去，他们就会失去这一切果实。”这说明（）。<br>A. 生产力的发展决定生产关系的变化<br>B. 生产关系不能促进生产力的发展<br>C. 社会制度是社会关系中最基本的关系<br>D. 生产关系的作用只在资本原始积累阶段发生<br>正确答案：A</p>
</li>
<li><p>在生产力与生产关系的矛盾运动中内在的. 本质的. 必然的联系，就是（）。<br>A. 生产关系决定生产力定律<br>B. 上层建筑决定经济基础规律<br>C. 意识决定物质规律<br>D. 生产关系一定要适合生产力状况的规律<br>正确答案：D</p>
</li>
<li><p>（）是政治上层建筑的核心。<br>A. 经济体制<br>B. 国家政权<br>C. 政治法律思想<br>D. 劳动者<br>正确答案：B</p>
</li>
<li><p>马克思认为国家是社会矛盾不可调和的产物，国家的实质是（）。<br>A. 生产力的主要标志<br>B. 绝对理念的伦理实体<br>C. 阶级统治的工具<br>D. 社会发展的最高形式<br>正确答案：C</p>
</li>
<li><p>恩格斯指出：“不管是在波斯和印度兴起和衰落的专制政府有多少，每一个专制政府都十分清楚地知道它们首先是河谷灌溉的总管。”这说明（）。<br>A. 地理环境决定上层建筑<br>B. 国家是为经济基础所服务的<br>C. 专制制度没有适应过生产力发展<br>D. 农业只能在专制制度下存在<br>正确答案：B</p>
</li>
<li><p>指明社会各阶级在国家中的地位，表明国家政权掌握在哪个阶级手里的是（）。<br>A. 政体<br>B. 法律<br>C. 国体<br>D. 宗教<br>正确答案：C</p>
</li>
<li><p>马克思. 恩格斯指出：“某一个地域创造出来的生产力，特别是发明，在往后的发展中是否会失传，完全取决于交往拓展的情况。”这说明（）。<br>A. 交往决定社会形态<br>B. 交往是科学技术发展的基础<br>C. 交往决定生产力的发展水平<br>D. 交往有益于生产力成果的保存<br>正确答案：D</p>
</li>
<li><p>马克思. 恩格斯指出：“一个人的发展取决于和他直接或间接进行交往的其他一切人的发展”，这说明（）。<br>A. 交往能够促进人的全面发展<br>B. 交往是社会关系中最基本的关系<br>C. 交往是人的本质<br>D. 个人被动地受制于社会<br>正确答案：A</p>
</li>
<li><p>唯物史观视域中的“世界历史”是指（）。<br>A. 自然界迄今为止的运动变化过程<br>B. 人类文明迄今为止的运动变化过程<br>C. 绝对精神的辩证运动过程<br>D. 各民族. 国家通过普遍交往，打破孤立隔绝的状态，进入相互依存. 相互联系的世界整体化的历史<br>正确答案：D</p>
</li>
<li><p>世界历史形成和发展的基础是（）。<br>A. 人类理性的觉醒<br>B. 生产方式的发展变革<br>C. 民主制度的大力推行<br>D. 法律的普及程度<br>正确答案：B</p>
</li>
<li><p>世界历史的基本特征是（）。<br>A. 理性至上<br>B. 国家消亡<br>C. 普遍交往<br>D. 实现共产主义<br>正确答案：C</p>
</li>
<li><p>社会形态包括经济形态. 政治形态和意识形态，其中（）是社会形态的基础。<br>A. 经济形态<br>B. 政治形态<br>C. 意识形态<br>D. 社会心理<br>正确答案：A</p>
</li>
<li><p>社会形态更替的统一性与多样性，根源于（）。<br>A. 经济基础和上层建筑的矛盾<br>B. 生产力和生产关系的矛盾<br>C. 社会形态和社会制度的矛盾<br>D. 社会发展的客观必然性和人的历史选择性相统一的过程<br>正确答案：D</p>
</li>
<li><p>社会形态更替的过程归根结底是社会基本矛盾运动的结果，其中（）的发展具有最终决定意义。<br>A. 经济基础<br>B. 自然地理环境<br>C. 生产力<br>D. 上层建筑<br>正确答案：C</p>
</li>
<li><p>资本主义制度在欧洲而并非在封建制度高度发展完善的中国等东方国家首先取得胜利，这说明（）。<br>A. 社会形态更替具有顺序性<br>B. 社会形态更替具有统一性<br>C. 社会形态更替与旧制度发展程度无关<br>D. 社会形态更替具有跨越性<br>正确答案：D</p>
</li>
<li><p>我国农村推广多种形式的承包责任制之所以促进了生产力的发展，在于它遵循了（）。<br>A. 生产关系适合生产力状况的规律<br>B. 上层建筑适合经济基础的规律<br>C. 社会存在决定社会意识的规律<br>D. 阶级斗争推动阶级社会发展的规律<br>正确答案：A</p>
</li>
<li><p>在现代化建设的新时期，党和国家进行社会主义核心价值观教育，形成了强大的凝聚力，这在哲学上的依据是（）。<br>A. 生产力对生产关系的决定作用原理<br>B. 社会意识对社会存在的能动反作用原理<br>C. 经济基础决定上层建筑的原理<br>D. 社会意识决定社会存在原理<br>正确答案：B</p>
</li>
<li><p>“许多事情我们可以讲一千个理由. 一万个理由，但老百姓吃不上饭，就没有理由。‘民以食为天’”。这段话表明（）。<br>A. 人们首先必须吃. 喝. 住. 穿，然后才能从事政治. 科技. 艺术. 宗教等等活动<br>B. 人的生理需求是历史的基础<br>C. 人的自然属性决定着人的本质<br>D. 人的物质欲望是社会发展的根本动力<br>正确答案：A</p>
</li>
<li><p>人类社会发展和进步的最终决定力量是（）。<br>A. 自我意识<br>B. 绝对精神<br>C. 经济基础<br>D. 生产力<br>正确答案：D</p>
</li>
<li><p>恩格斯指出：“17世纪和18世纪从事制造蒸汽机的人们也没有料到，他们制作的工具，比其他任何东西都能更使全世界的社会状态发生革命。”这说明（）。<br>A. 生产工具是生产力中最活跃的因素<br>B. 生产力决定世界发展的历史进程<br>C. 人不能认识生产力和生产关系的运动规律<br>D. 社会革命只能由生产工具更替引起<br>正确答案：B</p>
</li>
<li><p>衡量社会进步的根本尺度是（）。<br>A. 社会的道德文明程度<br>B. 人的理智发展程度<br>C. 经济制度的完善程度<br>D. 生产力的发展程度<br>正确答案：D</p>
</li>
<li><p>在人的物质生产中存在着双重关系，其中生产关系中所体现的是（）。<br>A. 人与自然的关系<br>B. 人与人的关系<br>C. 意识与意识的关系<br>D. 共性与个性的关系<br>正确答案：B</p>
</li>
<li><p>社会物质文明发展的基本内容是（）。<br>A. 人的理智发展<br>B. 人的体力的发展<br>C. 生产力的发展<br>D. 普遍交往的发展<br>正确答案：C</p>
</li>
<li><p>以下社会矛盾中，更为基本的矛盾是（）。<br>A. 经济基础与上层建筑之间的矛盾<br>B. 生产力与生产关系之间的矛盾<br>C. 社会形态更替的统一性与多样性之间的矛盾<br>D. 资产阶级与无产阶级之间的矛盾<br>正确答案：B</p>
</li>
<li><p>马克思. 恩格斯指出：“一切历史冲突都根源于生产力和交往形式之间的矛盾”，这说明（）。<br>A. 生产力和生产关系决定着其他矛盾的存在和发展<br>B. 经济基础和上层建筑的矛盾在社会基本矛盾中更为基本<br>C. 由于基本矛盾的存在社会形态更替必然采取社会革命的形式<br>D. 交往形式是衡量社会进步的根本尺度<br>正确答案：A</p>
</li>
<li><p>在同一社会形态的发展中，社会基本矛盾通常是通过（）的方式来解决的。<br>A. 革命<br>B. 冲突<br>C. 改革<br>D. 妥协<br>正确答案：C</p>
</li>
<li><p>恩格斯指出：“为了达到伟大的目标和团结，为此所必需的千百万大军应当时刻记住主要的东西，不因那些无畏的吹毛求疵而迷失方向。”这句话旨在强调要（）。<br>A. 抓住社会基本矛盾<br>B. 抓住社会主要矛盾<br>C. 认识社会非主要矛盾<br>D. 避免社会矛盾<br>正确答案：B</p>
</li>
<li><p>（）是阶级社会发展的直接动力。<br>A. 科学技术<br>B. 社会改革<br>C. 制度改良<br>D. 阶级斗争<br>正确答案：D</p>
</li>
<li><p>阶级斗争根源于阶级之间（）的根本对立。<br>A. 意识形态<br>B. 政治制度<br>C. 物质利益<br>D. 社会心理<br>正确答案：C</p>
</li>
<li><p>马克思. 恩格斯在《共产党宣言》中指出：“至今一切社会的历史都是阶级斗争的历史”，这说明（）。<br>A. 阶级矛盾是社会基本矛盾<br>B. 阶级斗争永远存在<br>C. 阶级斗争是阶级社会发展的直接动力<br>D. 阶级斗争是历史的创造者<br>正确答案：C</p>
</li>
<li><p>（）是最有前途. 最富有革命彻底性的阶级。<br>A. 资产阶级<br>B. 地主阶级<br>C. 农民阶级<br>D. 无产阶级<br>正确答案：D</p>
</li>
<li><p>列宁指出：“马克思主义提供了一条指导性线索，是我们能在这种看来扑朔迷离. 一团混乱的状态中发现规律性。……只有研究某一社会或某几个社会的全体成员的意向的总和，才能科学地确定这些意向的结果。”这条“线索”是指（）。<br>A. 辩证法理论<br>B. 劳动价值论<br>C. 唯物反映论<br>D. 阶级斗争理论<br>正确答案：D</p>
</li>
<li><p>（）是实现社会形态变革的首要. 基本的标志。<br>A. 国家意识形态采取新的形式<br>B. 社会经济体制发生变革<br>C. 社会基本矛盾彻底解决<br>D. 国家政权转移到革命阶级手里<br>正确答案：D</p>
</li>
<li><p>社会革命根源于（）。<br>A. 社会意识形态对立的极端化<br>B. 社会基本矛盾的尖锐化<br>C. 社会主要矛盾的转化<br>D. 国家政体的变化<br>正确答案：B</p>
</li>
<li><p>马克思指出：“于是这些关系便由生产力的发展形式变成生产力的桎梏。那时社会革命的时代就到来了。”这说明（）。<br>A. 只有在生产关系不适合生产力发展时，社会基本矛盾才起作用<br>B. 只要社会基本矛盾存在就一定发生革命<br>C. 社会革命根源于社会基本矛盾的尖锐化<br>D. 生产力的发展只能通过革命的手段<br>正确答案：C</p>
</li>
<li><p>马克思指出：“革命是历史的火车头”，这说明（）。<br>A. 社会革命是历史的创造者<br>B. 社会革命是历史发展的根本动力<br>C. 改良对社会发展毫无作用<br>D. 社会革命是社会进步的强大推力<br>正确答案：D</p>
</li>
<li><p>（）是指对自然. 社会和人类思维的正确认识，是反映客观事实和客观规律的知识体系及其相关的活动。<br>A. 技术<br>B. 实践<br>C. 意识<br>D. 科学<br>正确答案：D</p>
</li>
<li><p>马克思指出科学是“最明显的字面意义而言的革命力量”，这说明（）。<br>A. 科学是社会革命的集中表现<br>B. 科学是社会形态更替的决定性环节<br>C. 科学具有推动社会发展的强大力量<br>D. 科学发展是社会革命的根源<br>正确答案：C</p>
</li>
<li><p>随着北京再次申奥成功，冰雪运动成为中国人民关注的热点，在此次冰雪运动热潮中，大批网络滑雪小组. 论坛涌现，通过网络“寻友组队”成为大部分滑雪爱好者的第一需求。从唯物史观角度看，这体现了（）。<br>A. 虚拟交往是交往的主要形式<br>B. 现代信息技术革命对生活方式产生巨大影响<br>C. 精神交往是物质交往的基础<br>D. 科学技术革命改变生产方式<br>正确答案：B</p>
</li>
<li><p>正确认识和运用科学技术，首要的就是有（）。<br>A. 高度发达的科技水平<br>B. 大批科研工作者<br>C. 合理的社会制度<br>D. 哲学等意识形态的辅助<br>正确答案：C</p>
</li>
<li><p>人们自己创造自己的历史，因此历史发展的方向是由人自觉选定的，这是（）。<br>A. 历史唯物主义的观点<br>B. 宿命论观点<br>C. 唯意志论观点<br>D. 机械唯物主义观点<br>正确答案：C</p>
</li>
<li><p>群众追随英雄创造历史，这是（）。<br>A. 辩证唯物主义的观点<br>B. 历史唯心主义的观点<br>C. 机械决定论的观点<br>D. 二元论的观点<br>正确答案：B</p>
</li>
<li><p>坚持无产阶级政党的群众观点，就是坚信（）。<br>A. 人民群众的意见全都是正确的<br>B. 人民群众自己解放自己<br>C. 人民群众都有高度的共产主义觉悟<br>D. 人民群众永远能天然地认识历史发展规律<br>正确答案：B</p>
</li>
<li><p>唯物史观和唯心史观在谁是历史创造者问题上的根本对立在于是否承认（）。<br>A. 人的意识在历史活动中有能动作用<br>B. 人民群众是历史的创造者<br>C. 杰出人物在历史上的突出作用<br>D. 知识分子在历史上起决定作用<br>正确答案：B</p>
</li>
<li><p>马克思主义揭示人的本质的出发点是（）。<br>A. 人的自身需要<br>B. 人类的共同利益<br>C. 人的社会关系<br>D. 人的自然属性<br>正确答案：C</p>
</li>
<li><p>人民群众创造历史的活动，首先是（）。<br>A. 政治活动<br>B. 科学活动<br>C. 生产活动<br>D. 艺术活动<br>正确答案：C</p>
</li>
<li><p>（）是社会革命的主力军，他们在社会形态更替的过程中发挥了巨大作用。<br>A. 人民群众<br>B. 资产阶级<br>C. 思想家<br>D. 统治阶级<br>正确答案：A</p>
</li>
<li><p>历史人物在历史上的作用表现为（）。<br>A. 改变历史发展的方向<br>B. 改变历史发展的规律<br>C. 决定历史时代的根本特点<br>D. 加速或延缓历史的发展<br>正确答案：D</p>
</li>
<li><p>人民群众对历史的创造作用总是受到社会历史条件的制约，其根本的条件是指（）。<br>A. 人们的生活水平<br>B. 人们头脑中的意识<br>C. 科学文化水平<br>D. 生产力和生产关系的状况<br>正确答案：D</p>
</li>
<li><p>英雄人物的活动是理解历史发展的基本线索，这种观点是（）。<br>A. 辩证主义的观点<br>B. 唯物史观的观点<br>C. 历史主义的观点<br>D. 历史唯心主义<br>正确答案：D</p>
</li>
<li><p>社会精神财富的源泉是（）。<br>A. 人民群众的社会实践<br>B. 脑力劳动者的集体智慧<br>C. 思想家们的创造性思维<br>D. 客观的物质世界<br>正确答案：A</p>
</li>
<li><p>马克思主义认为，人的本质在其现实性上是（）。<br>A. 一切社会关系的总和<br>B. 政治关系的总和<br>C. 一切思想关系的总和<br>D. 自然属性和社会属性的总和<br>正确答案：A</p>
</li>
<li><p>（）第一次科学回答了谁是历史的创造者. 怎样看待人民群众和个人的历史作用等问题。<br>A. 黑格尔辩证法的历史观<br>B. 费尔巴哈唯物主义的历史观<br>C. 马克思主义唯物史观<br>D. 现代自然科学历史观<br>正确答案：C</p>
</li>
<li><p>从认识根源看，英雄史观之所以产生，主要是因为（）。<br>A. 认识不能正确反映世界<br>B. 认识只能是对自然的认识<br>C. 人们的认识停留在历史现象的表面<br>D. 人们的认识对历史进行了抽象把握<br>正确答案：C</p>
</li>
<li><p>（）最终决定历史发展的结局。<br>A. 自然地理环境的发展限度<br>B. 人类理性的觉醒程度<br>C. 国家体制的完善程度<br>D. 人民群众的社会实践<br>正确答案：D</p>
</li>
<li><p>一切精神财富. 精神产品形成和发展的源泉是（）。<br>A. 绝对理念的实体化<br>B. 意识形态家的理性创造<br>C. 人民群众的生活. 实践<br>D. 情感等非理性因素<br>正确答案：C</p>
</li>
<li><p>在诸多阶级组织中，最集中. 最严密. 最高级的形式是（）。<br>A. 集团<br>B. 行会<br>C. 政党<br>D. 同盟<br>正确答案：C</p>
</li>
<li><p>马克思曾批判雨果的《小拿破仑》，认为“他认为这个事变只是某一个人的暴力行为。他没有觉察到，当他说这个人表现了世界历史上空前强大的个人主动性时，他就不是把这个人写成小人物而是写成巨人了。”这说明马克思认为雨果在这里（）。<br>A. 忽视了意识的能动作用<br>B. 混淆了谁是历史的创造者<br>C. 否认了社会革命的推动作用<br>D. 抹杀了杰出人物的历史作用<br>正确答案：B</p>
</li>
</ol>
<h3 id="多选-3"><a href="#多选-3" class="headerlink" title="多选"></a>多选</h3><ol>
<li><p>唯心史观的主要缺陷有（）。<br>A. 没有考究思想动机背后的物质动因和经济根源<br>B. 把社会历史看成精神发展史<br>C. 不懂社会历史的客观规律<br>D. 不懂人民群众在社会历史发展中的决定作用<br>正确答案：ABCD</p>
</li>
<li><p>社会存在主要是指社会物质生活条件，是社会生活的物质方面，主要包括（）。<br>A. 社会心理<br>B. 自然地理环境<br>C. 人口因素<br>D. 物质生产方式<br>正确答案：BCD</p>
</li>
<li><p>物质生产方式是社会发展的决定力量，体现在（）。<br>A. 物质生产活动及生产方式是人类社会赖以生存和发展的基础<br>B. 物质生产活动及生产方式决定着社会的结构. 性质和面貌<br>C. 物质生产活动及生产方式制约着人们的经济生活. 政治生活和精神生活<br>D. 物质生产活动及生产方式的变化发展决定整个社会历史的变化发展<br>正确答案：ABCD</p>
</li>
<li><p>根据不同的层次，社会意识可以分为（）。<br>A. 社会心理<br>B. 社会意识形式<br>C. 个体意识<br>D. 群体意识<br>正确答案：AB</p>
</li>
<li><p>以下各项中，属于意识形态的有（）。<br>A. 政治法律思想<br>B. 道德<br>C. 艺术<br>D. 自然科学<br>正确答案：ABC</p>
</li>
<li><p>马克思唯物史观的“两个划分”和“两个归结”对于正确认识社会历史具有重要意义，以下各项中，属于“两个划分”与“两个归结”的有（）。<br>A. 从社会生活各领域中划分出经济领域<br>B. 从一切社会关系中划分出生产关系<br>C. 把一切社会关系归结于生产关系<br>D. 把生产关系归结于生产力发展<br>正确答案：ABCD</p>
</li>
<li><p>文化对社会发展的重要作用表现在（）。<br>A. 文化为社会发展提供思想保证<br>B. 文化为社会发展提供精神动力<br>C. 文化为社会发展提供智力支持<br>D. 文化为社会发展提供凝聚力量<br>正确答案：ABCD</p>
</li>
<li><p>恩格斯说：“一个民族要想站在科学的最高峰，就一刻也不能没有理论思维。”哲学社会科学的重要性在于（）。<br>A. 反映一个民族的思维能力. 精神品格. 文明素质，体现了一个国家的综合国力和国际竞争力<br>B. 一个国家的发展水平，既取决于自然科学发展水平，也取决于哲学社会科学发展水平<br>C. 是人们认识世界. 改造世界的重要工具<br>D. 是推动历史发展和社会进步的重要力量<br>正确答案：ABCD</p>
</li>
<li><p>人类社会的基本矛盾是（）。<br>A. 共性与个性的矛盾<br>B. 客观规律性与主观能动性的矛盾<br>C. 生产力与生产关系的矛盾<br>D. 经济基础与上层建筑之间的矛盾<br>正确答案：CD</p>
</li>
<li><p>人类社会发展的基本规律是（）。<br>A. 能量守恒定律<br>B. 剩余价值规律<br>C. 生产力与生产关系的矛盾运动规律<br>D. 经济基础与上层建筑之间的矛盾运动规律<br>正确答案：CD</p>
</li>
<li><p>深入理解生产力范畴，需要把握生产力的水平. 性质. 状况和发展要求等重要方面，以下各项中正确的有（）。<br>A. 生产力的水平表现为生产发展的现实程度<br>B. 生产力的性质取决于生产的物质技术性质<br>C. 生产力的状况表现为生产力的运行状态和发展态势<br>D. 生产力的发展要求指现实的生产力不断获得解放和发展的基本要求<br>正确答案：ABCD</p>
</li>
<li><p>生产力的基本要素包括（）。<br>A. 劳动意识<br>B. 劳动资料<br>C. 劳动对象<br>D. 劳动者<br>正确答案：BCD</p>
</li>
<li><p>科学技术对生产力发展的重要意义在于（）。<br>A. 科学技术能够转化为实际生产能力<br>B. 科学技术会引起劳动资料. 劳动对象和劳动者素质的深刻变革和巨大进步<br>C. 科学技术能大幅提高管理效率和劳动生产率<br>D. 科学技术是先进生产力的集中体现和主要标志<br>正确答案：ABCD</p>
</li>
<li><p>依据生产资料所有制性质，生产关系区分为以生产资料私有制为基础的生产关系和以生产资料公有制为基础的生产关系，后者的根本特征是（）。<br>A. 生产资料为劳动者共同占有<br>B. 人们在生产过程中处于平等地位<br>C. 在产品分配上不存在剥削<br>D. 只在共产主义社会中存在<br>正确答案：ABC</p>
</li>
<li><p>关于生产关系对生产力能动的反作用，下列说法中正确的有（）。<br>A. 当生产关系适合生产力发展的客观要求时，对生产力起推动作用<br>B. 当生产关系不适合生产力发展的客观要求时，对生产力起阻碍作用<br>C. 生产关系推动生产力发展<br>D. 生产关系阻碍生产力发展<br>正确答案：AB</p>
</li>
<li><p>以下各项中，属于上层建筑的有（）。<br>A. 经济体制<br>B. 法律<br>C. 哲学<br>D. 政体<br>正确答案：BCD</p>
</li>
<li><p>关于观念上层建筑和政治上层建筑的关系，下列说法中正确的有（）。<br>A. 政治上层建筑是在一定意识形态指导下建立的<br>B. 政治上层建筑一旦形成就会影响并制约人们的思想理论观点<br>C. 在整个上层建筑中观念上层建筑居于主导地位<br>D. 在整个上层建筑中政治上层建筑居于主导地位<br>正确答案：ABD</p>
</li>
<li><p>关于国体和政体的关系，下列说法中正确的有（）。<br>A. 国体决定政体<br>B. 政体为国体服务<br>C. 政体决定国体<br>D. 国体为政体服务<br>正确答案：AB</p>
</li>
<li><p>社会主义民主是其他任何国家形态的民主都不能比拟的最广泛的民主，这是因为（）。<br>A. 社会主义民主的本质和核心是人民当家做主<br>B. 人民民主是社会主义的生命<br>C. 社会主义民主是对资产阶级民主的辩证否定<br>D. 社会主义民主是民主发展的历史性飞跃<br>正确答案：ABCD</p>
</li>
<li><p>关于经济基础上层建筑的辩证关系，下列认识中正确的有（）。<br>A. 经济基础决定上层建筑<br>B. 上层建筑对经济基础具有反作用<br>C. 经济基础与上层建筑相互作用构成二者的矛盾运动<br>D. 经济基础上层建筑之间构成了上层建筑一定要适合经济基础状况的规律<br>正确答案：ABCD</p>
</li>
<li><p>经济基础上层建筑之间构成了上层建筑一定要适合经济基础状况的规律，这里的“一定要适合”指的是（）。<br>A. 经济基础状况决定上层建筑的发展方向<br>B. 经济基础状况决定上层建筑相应的调整或变革<br>C. 上层建筑只能被动地适应经济基础，不具有反作用<br>D. 上层建筑的反作用必须取决于和服从于经济基础的性质和客观要求<br>正确答案：ABD</p>
</li>
<li><p>交往是指一定历史条件下的现实的个人. （）之间在物质和精神上相互往来. 相互作用. 彼此联系的活动。<br>A. 群体<br>B. 阶级<br>C. 民族<br>D. 国家<br>正确答案：ABCD</p>
</li>
<li><p>总体上说可以将交往划分为物质交往和精神交往，关于二者关系，下列认识中正确的有（）。<br>A. 物质交往是精神交往的基础和根源<br>B. 物质交往是精神交往的产物<br>C. 精神交往渗透与物质交往之中<br>D. 精神交往是物质交往的基础和根源<br>正确答案：AC</p>
</li>
<li><p>交往对社会生活的重要影响包括（）。<br>A. 促进生产力发展<br>B. 促进社会关系的进步<br>C. 促进文化的发展与传播<br>D. 促进人的全面发展<br>正确答案：ABCD</p>
</li>
<li><p>马克思. 恩格斯认为共产主义“是以生产力的普遍发展和与此相联系的世界交往为前提的”，这是因为（）。<br>A. 随着交往和竞争的扩大，生产力空前发展<br>B. 世界历史促使无产阶级走向联合<br>C. 交往是社会形态更替的基础<br>D. 共产主义就是世界历史的特征<br>正确答案：AB</p>
</li>
<li><p>关于社会制度和社会形态的关系，下列说法中正确的有（）。<br>A. 一定的社会形态总要以一定的社会制度形式呈现出来<br>B. 社会制度能够集中体现社会形态的性质<br>C. 人们往往用社会制度指代社会形态<br>D. 社会制度决定了社会形态<br>正确答案：ABC</p>
</li>
<li><p>依据经济基础特别是生产关系的不同性质，社会历史可划分为原始社会. （）。<br>A. 奴隶社会<br>B. 封建社会<br>C. 资本主义社会<br>D. 社会主义社会<br>正确答案：ABCD</p>
</li>
<li><p>人们的历史选择性是指（）。<br>A. 社会发展的客观必然性为人们的历史选择提供了基础. 范围和可能性空间<br>B. 社会形态更替的过程是一个主观能动性与客观规律性相统一的过程<br>C. 人们的历史选择性归根结底是人民群众的选择<br>D. 人们的历史选择性能够创造和改变历史规律<br>正确答案：ABC</p>
</li>
<li><p>面临环境日益被污染的状况，人类越来越重视环境问题，这是因为（）。<br>A. 地理环境是人类物质生活的必要条件<br>B. 地理环境直接决定社会的发展<br>C. 地理环境能决定社会的性质<br>D. 地理环境通过物质生产制约社会发展<br>正确答案：AD</p>
</li>
<li><p>意大利历史学家克罗齐认为：“一切历史都是思想史”，这种观点（）。<br>A. 夸大了思想因素在历史中的作用<br>B. 本质上是唯心史观<br>C. 承认了人民群众在历史发展中的决定作用<br>D. 肯定了历史发展的客观规律性<br>正确答案：AB</p>
</li>
<li><p>英国资产阶级革命开始于1640年，但在战胜封建制度以后，接着就出现了1660年的旧王朝复辟，直到1688年，英国的资本主义社会形态才稳固下来。这说明（）。<br>A. 社会形态更替的前进性<br>B. 社会形态更替的曲折性<br>C. 社会形态更替的多样性<br>D. 社会形态更替的统一性<br>正确答案：AB</p>
</li>
<li><p>马克思指出：“一个社会即使探索到本身运动的自然规律，……它还是既不能跳过也不能用法令取消自然的发展阶段。但是它能缩短和减轻分娩的痛苦。”这表明（）。<br>A. 人类社会的发展是合规律性与合目的性的统一<br>B. 人的自觉选择在社会发展中具有重要作用<br>C. 社会发展过程与自然界演变过程一样都是自觉的<br>D. 人类总体历史进程是不可超越的<br>正确答案：ABD</p>
</li>
<li><p>恩格斯指出旧唯物主义“认为在历史领域中起作用的精神的动力是最终原因，而不去研究……这些动力的动力是什么”，从根本上来说“这些动力的动力”是（）。<br>A. 自然地理环境与人的主观能动性的矛盾<br>B. 绝对理念与自我意识的矛盾<br>C. 生产力和生产关系的矛盾运动<br>D. 经济基础和上层建筑的矛盾运动<br>正确答案：CD</p>
</li>
<li><p>之所以说社会基本矛盾是推动社会历史发展的根本动力，是因为（）。<br>A. 社会基本矛盾决定了各种社会矛盾的产生和发展<br>B. 社会基本矛盾决定了各种社会矛盾之间的关系及其转变<br>C. 社会基本矛盾决定了社会形态由低级向高级的发展<br>D. 阶级斗争. 社会革命. 社会改革等都根源于社会基本矛盾<br>正确答案：ABCD</p>
</li>
<li><p>经济基础和上层建筑的矛盾之所以会影响和制约生产力和生产关系的矛盾，是因为（）。<br>A. 生产力与生产关系的矛盾的最终解决有赖于经济基础和上层建筑矛盾的解决<br>B. 生产关系的变化受制于上层建筑的变化<br>C. 当上层建筑不适应经济基础状况时，只有解决了经济基础和上层建筑的矛盾才能解放生产力<br>D. 经济基础上层建筑之间的矛盾是更为基本的矛盾<br>正确答案：ABC</p>
</li>
<li><p>在社会发展一定阶段上，由于社会经济. 政治. 文化等因素的变化，原有社会主要矛盾会朝着（）等方面转化。<br>A. 社会主要矛盾双方的内容发生一定变化<br>B. 矛盾地位发生变化<br>C. 成为基本矛盾<br>D. 决定基本矛盾<br>正确答案：AB</p>
</li>
<li><p>党的十九大指出，新时代我国社会主要矛盾已经发生转化，这种转化的客观依据有（）。<br>A. 人民美好生活需要日益广泛<br>B. 在民主. 法治. 公平. 正义. 安全. 环境等方面的要求日益增长<br>C. 发展的不平衡不充分成为满足人民日益增长的美好生活需要的主要制约因素<br>D. 社会基本矛盾在我国已经得到解决<br>正确答案：ABC</p>
</li>
<li><p>社会革命的实质是（）。<br>A. 革命阶级推翻反动阶级的统治<br>B. 新的社会制度代替旧的社会制度<br>C. 解放生产力<br>D. 推动社会发展<br>正确答案：ABCD</p>
</li>
<li><p>革命对社会发展的巨大作用包括（）。<br>A. 社会革命是实现社会形态更替的重要手段<br>B. 社会革命能充分发挥人民群众创造历史的积极和伟大作用<br>C. 无产阶级革命将为消除阶级对抗，并充分利用全人类的文明成果促进社会全面进步创造条件<br>D. 社会革命促进生产力和生产关系达到新的平衡，最终彻底消除二者矛盾<br>正确答案：ABC</p>
</li>
<li><p>改革在社会历史发展中的作用表现在（）。<br>A. 一定程度上解决社会基本矛盾<br>B. 是促进生产力发展的有效途径<br>C. 是推动社会进步手段<br>D. 是社会形态更替的决定性环节<br>正确答案：ABC</p>
</li>
<li><p>科技革命对生产方式的影响体现在（）。<br>A. 使人从生产主体向生产中介转化<br>B. 改变了社会生产力的构成要素<br>C. 改变了人们的劳动形式<br>D. 改变了社会经济结构<br>正确答案：BCD</p>
</li>
<li><p>科学技术革命所引起的变化包括（）。<br>A. 对生产方式产生深刻影响<br>B. 对生活方式产生巨大影响<br>C. 促进思维方式的变革<br>D. 推动社会发展<br>正确答案：ABCD</p>
</li>
<li><p>从历史观的角度看，“时势造英雄”与“英雄造时势”这两种观点的关系和差异为（）。<br>A. 两种根本对立的历史观<br>B. 前者是唯物史观，后者是唯心史观<br>C. 前者是唯心史观，后者是唯物史观<br>D. 两种不成立的错误观点<br>正确答案：AB</p>
</li>
<li><p>历史发展是“合力”作用的结果，这就是说（）。<br>A. 历史发展无规律可循<br>B. 历史发展是无法认识的<br>C. 历史发展的因素是复杂的<br>D. 社会中的每个人都是“合力”的一部分<br>正确答案：CD</p>
</li>
<li><p>马克思主义群众观点的主要内容包括（）。<br>A. 坚信人民群众自己解放自己<br>B. 全心全意为人民服务<br>C. 一切向人民群众负责<br>D. 虚心向群众学习<br>正确答案：ABCD</p>
</li>
<li><p>正确评价历史人物应该坚持（）。<br>A. 以成败论英雄的方法<br>B. 荣誉分析的方法<br>C. 历史分析方法<br>D. 阶级分析方法<br>正确答案：CD</p>
</li>
<li><p>下列各项中，属于无产阶级政党的群众路线内容的有（）。<br>A. 一切依靠群众<br>B. 一切按照群众的意见和要求办<br>C. 一切为了群众<br>D. 从群众中来，到群众中去<br>正确答案：ACD</p>
</li>
<li><p>唯物史观在考察谁是历史的创造者时坚持的原则包括（）。<br>A. 立足于现实的人及其本质来把握历史的创造者<br>B. 立足于整体的社会历史过程来探究谁是历史的创造者<br>C. 从社会历史发展的必然性入手来考察和说明谁是历史的创造者<br>D. 从人与历史关系的不同层次上考察谁是历史的创造者<br>正确答案：ABCD</p>
</li>
<li><p>在当代中国，人民群众包括（）。<br>A. 全体社会主义劳动者<br>B. 社会主义事业的建设者<br>C. 拥护社会主义的爱国者<br>D. 拥护祖国统一和致力于中华民族伟大复兴的爱国者<br>正确答案：ABCD</p>
</li>
<li><p>毛泽东指出：“人民，只有人民，才是创造世界历史的动力”，从唯物史观来看这是因为（）。<br>A. 生产力的发展必须借助人民的力量<br>B. 人民是社会革命的主力军<br>C. 人民推动了生产关系变革<br>D. 人民是社会历史发展的根本动力<br>正确答案：ABC</p>
</li>
<li><p>“我们党打江山. 守江山，守的就是人民的心。”这是因为（）。<br>A. 人民是历史的创造者<br>B. 社会心理是社会历史发展的决定力量<br>C. 中国共产党为人民而生. 因人民而兴<br>D. 中国共产党根基在人民. 血脉在人民<br>正确答案：ACD</p>
</li>
<li><p>关于群众. 阶级. 政党. 领袖的关系，下列说法中正确的是（）。<br>A. 群众是划分阶级的<br>B. 阶级通常是由政党领导的<br>C. 政党是由领袖来主持的<br>D. 群众. 阶级. 政党. 领袖构成一个有机整体<br>正确答案：ABCD</p>
</li>
<li><p>群众. 阶级. 政党. 领袖环环相扣. 相互依存，这启示我们，发展中国特色社会主义事业要（）。<br>A. 坚持党的群众观点群众路线<br>B. 巩固党的阶级基础和群众基础<br>C. 确保党的坚强领导核心地位<br>D. 更好发挥人民领袖的领导作用<br>正确答案：ABCD</p>
</li>
<li><p>唯物史观在考察谁是历史的创造者时坚持的原则有（）。<br>A. 立足于现实的人及其本质来把握历史的创造者<br>B. 从社会历史发展的偶然性入手来考察和说明谁是历史的创造者<br>C. 立足于整体的社会历史过程来探究谁是历史的创造者<br>D. 从人与历史关系的不同层次上考察谁是历史的创造者<br>正确答案：ACD</p>
</li>
</ol>
<h3 id="判断-3"><a href="#判断-3" class="headerlink" title="判断"></a>判断</h3><ol>
<li><p>自然地理环境是人类社会生存和发展永恒的. 必要的条件。<br>对</p>
</li>
<li><p>人口是重要的社会物质条件，对社会的性质和社会形态更替起决定作用。<br>错</p>
</li>
<li><p>相较于社会心理，社会意识形式是更低层次的社会意识，是自发的. 不系统的，不定型的社会意识。<br>错</p>
</li>
<li><p>在阶级社会中，占统治地位的思想文化，本质上是经济上占统治地位的阶级的意识形态，具有鲜明的政治属性。<br>对</p>
</li>
<li><p>文化蕴含着人类的思想智慧. 价值追求和审美情趣，是一个国家. 一个民族的灵魂。<br>对</p>
</li>
<li><p>文化自信是更基础. 更广泛. 更深厚的自信，是更基本. 更深沉. 更持久的力量。<br>对</p>
</li>
<li><p>中国特色社会主义文化积淀着中华民族最深层的精神追求，代表着中华民族独特的精神标识，是中国人民胜利前行的强大精神力量。<br>对</p>
</li>
<li><p>文化的核心是价值观。<br>对</p>
</li>
<li><p>生产力是人类在生产实践中形成的改造和影响自然以使其适合社会需要的物质力量。<br>对</p>
</li>
<li><p>一切自然物质都是现实的劳动对象。<br>错</p>
</li>
<li><p>在高新技术领域，脑力劳动和体力劳动具有直接同一的趋势。<br>对</p>
</li>
<li><p>在生产关系中，生产资料所有制关系是最基本的，它是人们进行物质资料生产的前提。<br>对</p>
</li>
<li><p>生产力和生产关系的有机统一，构成社会的生产方式，其中生产力是居支配地位. 起决定作用的方面。<br>对</p>
</li>
<li><p>新的生产关系总是完全适应生产力的发展状况。<br>错</p>
</li>
<li><p>生产力是推动社会进步的最活跃. 最革命的要素。<br>对</p>
</li>
<li><p>社会主义的根本任务是解放和发展社会生产力。<br>对</p>
</li>
<li><p>特定社会的发展阶段上往往只存在一种生产关系。<br>错</p>
</li>
<li><p>经济体制与生产力发展的关系更为直接. 更为具体，它在实践中总是与社会的基本经济制度结合在一起。<br>对</p>
</li>
<li><p>国家是一定历史阶段的产物，从原始社会开始就已经存在。<br>错</p>
</li>
<li><p>国家是经济上占支配地位的阶级为维护其根本利益而建立起来的强制性暴力机关。<br>对</p>
</li>
<li><p>经过无产阶级专政这种过渡形态，随着阶级消亡，国家才会消亡。<br>对</p>
</li>
<li><p>同一国体只能采取同一政体，同一政体只能适应固定的国体。<br>错</p>
</li>
<li><p>孤立. 封闭. 隔绝总是与落后的社会生产力水平相联系，而交流. 交往. 开放则往往与先进的社会生产力水平相联系。<br>对</p>
</li>
<li><p>人类历史向世界历史的转变是资本主义生产方式出现和向世界扩张的结果。<br>对</p>
</li>
<li><p>世界历史最重要的是强调整个世界的相互关联，任何民族. 任何国家都不能拒斥普遍交往。<br>对</p>
</li>
<li><p>社会历史形态更替的统一性表明，某一国家在发展过程中无法超越某一社会形态而实现跨越式发展。<br>错</p>
</li>
<li><p>观念上层建筑是观念结构中的主要部分。<br>对</p>
</li>
<li><p>生产力是社会进步的根本内容。<br>对</p>
</li>
<li><p>只有在生产力发展的基础上，才有可能充分满足人民群众的物质生活和精神生活的需要。<br>对</p>
</li>
<li><p>在阶级社会中，社会基本矛盾往往会通过一定社会的阶层或阶级的矛盾表现出来。<br>对</p>
</li>
<li><p>社会主要矛盾是其他一切社会矛盾的根源。<br>错</p>
</li>
<li><p>阶级斗争对社会发展的作用突出地表现在社会形态的更替中。<br>对</p>
</li>
<li><p>阶级斗争归根结底是围绕经济利益展开，因此各阶级都是从自身利益出发，不存在为全人类解放而斗争的阶级。<br>错</p>
</li>
<li><p>新中国成立之后，我国已经不存在阶级斗争了。<br>错</p>
</li>
<li><p>从量变质变规律来看，改革只能带来量变，质变只能依靠革命。<br>错</p>
</li>
<li><p>相较于革命，改革适用于解决现存的社会基本制度问题，把生产力从已经不能容纳它的旧的生产关系中解放出来。<br>错</p>
</li>
<li><p>改革有的是局部的. 浅层次的，但也有的是对生产关系和上层建筑有深层触动和调整。<br>对</p>
</li>
<li><p>科学技术都有利于人的发展。<br>错</p>
</li>
<li><p>生产力的发展和旧的生产关系. 经济基础的发展和旧的上层建筑之间出现矛盾冲突，是社会革命爆发的根本原因。<br>对</p>
</li>
<li><p>人民群众是历史的创造者，所以不受社会历史条件的制约。<br>错</p>
</li>
<li><p>先进的科学文化和思想道德对人民群众创造历史的活动具有积极的促进作用。<br>对</p>
</li>
<li><p>群众路线是我们党在革命. 建设. 改革时期不断取得胜利的重要法宝。<br>对</p>
</li>
<li><p>杰出人物是历史的创造者。<br>错</p>
</li>
<li><p>现实的人及其活动是社会历史存在和发展的前提。<br>对</p>
</li>
<li><p>人民群众创造历史的活动受到一定社会历史条件的制约，其中政治条件对于人民群众创造历史的活动有着首要的. 决定性的影响。<br>错</p>
</li>
<li><p>从质上看，人民群众是指全体社会人口。<br>错</p>
</li>
<li><p>人民群众创造历史的作用是同社会基本矛盾运动推动社会前进的过程相一致的。<br>对</p>
</li>
<li><p>人民群众的总体意愿和行动代表了历史发展的方向。<br>对</p>
</li>
<li><p>知识分子主要从事意识形态的生产，在物质资料生产中没有作用。<br>错</p>
</li>
<li><p>意识形态作为观念上层建筑是统治阶级进行统治的工具，因此只有统治阶级的意识形态家们才是精神生产活动的主体。<br>错</p>
</li>
<li><p>在阶级社会中，群众不是一个绝对同一的整体，而是由不同的阶级构成的。<br>对</p>
</li>
<li><p>一个阶级的政党要领导本阶级进行有组织的活动，就必须有自己的领袖。<br>对</p>
</li>
<li><p>没有政党领导的阶级，不能形成统一的意志和行动。<br>对</p>
</li>
<li><p>无产阶级政党是最广大人民群众利益的最忠实代表。<br>对</p>
</li>
<li><p>先进阶级的政治代表人物能够在革命斗争起着领导核心的作用。<br>对</p>
</li>
</ol>
<h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><h3 id="单选-4"><a href="#单选-4" class="headerlink" title="单选"></a>单选</h3><ol>
<li><p>商品经济经历了简单商品经济与发达商品经济两个阶段，其中简单商品经济以生产资料私有制和（）为基础。<br>A. 雇佣劳动<br>B. 个体劳动<br>C. 抽象劳动<br>D. 具体劳动<br>正确答案：B</p>
</li>
<li><p>从政治经济学角度看，自然经济与商品经济的主要区别在于（）。<br>A. 生产主体不同<br>B. 生产方式不同<br>C. 生产工具不同<br>D. 生产目的不同<br>正确答案：D</p>
</li>
<li><p>商品的使用价值反映的是（）。<br>A. 人与人之间的社会关系<br>B. 人与自然之间的物质关系<br>C. 人与世界之间的认识关系<br>D. 人与社会之间交往关系<br>正确答案：B</p>
</li>
<li><p>一切劳动产品所共有的属性是（）。<br>A. 价值<br>B. 交换价值<br>C. 使用价值<br>D. 历史价值<br>正确答案：C</p>
</li>
<li><p>（）构成社会财富的物质内容。<br>A. 抽象劳动<br>B. 使用价值<br>C. 具体劳动<br>D. 价值<br>正确答案：B</p>
</li>
<li><p>（）表现为一种使用价值同另一种使用价值交换的量的比例。<br>A. 使用价值<br>B. 剩余价值<br>C. 交换价值<br>D. 社会价值<br>正确答案：C</p>
</li>
<li><p>从政治经济学来看，阳光不具有价值，但利用太阳能所发的电具有价值，产生这种区别的原因是（）。<br>A. 阳光不是劳动产品，而太阳能发的电是劳动产品<br>B. 阳光不能满足人的需要，而太阳能发的电可以<br>C. 阳光是具体劳动的产物，太阳能发的电是抽象劳动的产物<br>D. 阳光是私人劳动的产物，而太阳能发的电是社会劳动的产物<br>正确答案：A</p>
</li>
<li><p>马克思指出：“一切劳动，一方面是人类劳动力在生理学意义上的耗费，……另一方面是人类劳动力在有一定目的的形式上的耗费”，后者指的是劳动二重性中的（）。<br>A. 抽象劳动<br>B. 具体劳动<br>C. 私人劳动<br>D. 社会劳动<br>正确答案：B</p>
</li>
<li><p>商品价值的量是由（）决定的。<br>A. 商品能满足人的需要的程度<br>B. 商品的自然属性<br>C. 生产商品所耗费的劳动量<br>D. 生产商品所采取的手段和方式<br>正确答案：C</p>
</li>
<li><p>生产商品所耗费的劳动量是按照（）来计量的。<br>A. 劳动者的疲劳程度<br>B. 劳动所耗费的原材料数量<br>C. 生产出的劳动产品的数量<br>D. 劳动所耗费的时间<br>正确答案：D</p>
</li>
<li><p>某企业提高了劳动生产率，生产单位商品的时间大大缩短，但其所生产的单位商品的价值却没有减小，这是因为（）。<br>A. 商品的价值量与劳动时间无关<br>B. 劳动生产率只能影响生产的数量，不能影响生产的质量<br>C. 商品的价值是在交换中形成确定的，和生产无关<br>D. 商品的价值量由社会必要劳动时间决定，而不是个别劳动时间<br>正确答案：D</p>
</li>
<li><p>复杂劳动等于自乘的或多倍的简单劳动，在商品经济条件下，这种换算是（）。<br>A. 劳动者之间的约定<br>B. 小商品生产者通过计算规定的<br>C. 行会等社会组织规定的<br>D. 在商品交换过程中自发实现的<br>正确答案：D</p>
</li>
<li><p>货币是商品经济内在矛盾发展的产物，货币的本质体现了一种（）。<br>A. 自然关系<br>B. 社会关系<br>C. 认识关系<br>D. 政治关系<br>正确答案：B</p>
</li>
<li><p>马克思指出：“商品价值从商品体跳到金体上，像我在别处说过的，是商品的惊险跳跃。这个跳跃如果不成功，摔坏的不是商品，但一定是商品占有者”，这里的“惊险跳跃”指的是（）。<br>A. 商品转化为货币<br>B. 价值转化为使用价值<br>C. 抽象劳动转化为具体劳动<br>D. 社会劳动转化为私人劳动<br>正确答案：A</p>
</li>
<li><p>“不少菜比肉还贵”，这是2021年国庆节后很多消费者的感受，专家分析季节性. 雨水等多重因素导致菜价上涨。从政治经济学角度看，“蔬菜涨价”说明（）。<br>A. 价值规律不起作用<br>B. 市场供求影响了商品的价格<br>C. 商品交换以价格为基础<br>D. 供求决定商品的价值量<br>正确答案：B</p>
</li>
<li><p>马克思指出商品经济的“规则只能作为没有规则性的盲目起作用的平均数规律来为自己开辟道路”，这说明（）。<br>A. 商品经济没有可认识和把握的规律<br>B. 上下波动的价格的平均数与价值相一致<br>C. 价值规律的调节具有自觉性<br>D. 价值与价格无法一致<br>正确答案：B</p>
</li>
<li><p>商品经济的基本矛盾是（）。<br>A. 价值与使用价值的矛盾<br>B. 具体劳动与抽象劳动的矛盾<br>C. 私人劳动与社会劳动的矛盾<br>D. 价值与价格的矛盾<br>正确答案：C</p>
</li>
<li><p>商品经济的交换本质是由（）决定的。<br>A. 私人劳动和社会劳动的矛盾<br>B. 价值和使用价值的矛盾<br>C. 具体劳动和抽象劳动的矛盾<br>D. 生产资料私人占有制和社会化大生产的矛盾<br>正确答案：A</p>
</li>
<li><p>解决私人劳动和社会劳动之间矛盾的唯一途径是（）。<br>A. 生产<br>B. 交换<br>C. 分配<br>D. 消费<br>正确答案：B</p>
</li>
<li><p>相对于英国古典政治经济学，马克思劳动价值论的创新之处在于（）。<br>A. 认识到了商品具有价值和使用价值的二因素<br>B. 提出了社会必要劳动量决定商品价值量<br>C. 区分了具体劳动和抽象劳动<br>D. 提出了劳动创造价值的观点<br>正确答案：C</p>
</li>
<li><p>15世纪后30年，在西欧开始的资本原始积累，就是以（）使生产者与生产资料相分离，资本迅速集中于少数人手中。<br>A. 商品交换<br>B. 暴力手段<br>C. 雇佣劳动<br>D. 社会化生产<br>正确答案：B</p>
</li>
<li><p>马克思指出：“美洲金银产地的发现，土著居民的被剿灭. 被奴役和被埋葬于矿井，对东印度开始进行的征服和掠夺，非洲变成商业性地猎获黑人的场所——这一切标志着资本主义生产时代的曙光”，这说明（）。<br>A. 资本主义改变了土著居民的悲惨命运<br>B. 掠夺黑奴是资本主义的根本规律<br>C. 资本主义通过暴力手段完成原始积累<br>D. 掠夺与暴力是资本主义的绝对规律<br>正确答案：C</p>
</li>
<li><p>表明资本运动的一般目的的资本总公式是（）。<br>A. 商品-货币-商品<br>B. 货币-商品-增殖后的货币<br>C. 劳动-货币-商品<br>D. 原材料-货币-商品<br>正确答案：B</p>
</li>
<li><p>（）是指人的劳动能力，是人的脑力和体力的总和。<br>A. 劳动<br>B. 具体劳动<br>C. 劳动力<br>D. 私人劳动<br>正确答案：C</p>
</li>
<li><p>（）标志着简单商品生产发展到资本主义商品生产的新阶段。<br>A. 劳动力成为商品<br>B. 资本主义制度的确立<br>C. 私人劳动和社会劳动矛盾的解决<br>D. 商品完成“惊险的跳跃”<br>正确答案：A</p>
</li>
<li><p>马克思说：“罗马的奴隶是由锁链，雇佣工人则由看不见的线系在自己的所有者手里。”这里的“看不见的线”指的是（）。<br>A. 市场价值规律<br>B. 以土地为基础的人身依附关系<br>C. 暴力掠夺的资本原始积累<br>D. 在“自由”“平等”形式下的资本家对工人的支配和剥削<br>正确答案：D</p>
</li>
<li><p>劳动力商品的突出特点在于（）。<br>A. 它的使用价值是价值的源泉<br>B. 不具有使用价值<br>C. 不具有价值<br>D. 它的使用价值决定交换价值<br>正确答案：A</p>
</li>
<li><p>劳动力的价值，也就是工人的工资的最低界限是（）。<br>A. 由政府强制规定的<br>B. 资本家按照利润率计算出来的<br>C. 由工人生活上不可缺少的生活资料的价值决定的<br>D. 由工人集体商讨划定的<br>正确答案：C</p>
</li>
<li><p>资本主义生产的直接目的和决定性动机是（）。<br>A. 扩大社会物质财富<br>B. 提高劳动生产率<br>C. 无休止地获取尽可能多的剩余价值<br>D. 实现人的自由全面的发展<br>正确答案：C</p>
</li>
<li><p>资本主义生产过程具有二重性，即（）。<br>A. 既是具体劳动又是抽象劳动<br>B. 既是劳动过程又是价值增殖过程<br>C. 既是商品生产过程又是商品交换过程<br>D. 既是自给自足过程又是交换过程<br>正确答案：B</p>
</li>
<li><p>关于资本主义劳动过程，下列说法中正确的是（）。<br>A. 劳动成果或产品全部归资本家所有<br>B. 是工人自由创造的劳动过程<br>C. 生产以满足资本家的生活需要为目的<br>D. 生产以满足工人的生活需要为目的<br>正确答案：A</p>
</li>
<li><p>所谓价值增殖过程，就是指超过一定点儿延长了的价值形成过程，这里的“一定点儿”指的是（）。<br>A. 资本家的全部投入<br>B. 原材料的价值<br>C. 工人创造的剩余价值<br>D. 对劳动力价值的补偿<br>正确答案：D</p>
</li>
<li><p>在价值增殖过程中，雇佣工人的劳动分为必要劳动和剩余劳动两个部分，其中剩余劳动用于（）。<br>A. 偿还劳动力价值<br>B. 无偿生产剩余价值<br>C. 完成规定工作任务之外的附加任务<br>D. 为雇佣工人创造价值<br>正确答案：B</p>
</li>
<li><p>以下各项中，在资本主义生产过程中属于可变资本的是（）。<br>A. 石油<br>B. 砂糖<br>C. 纱布<br>D. 劳动力<br>正确答案：D</p>
</li>
<li><p>确定资本家对工人的剥削程度，应该用剩余价值和（）相比。<br>A. 全部资本<br>B. 不变资本<br>C. 可变资本<br>D. 固定资本<br>正确答案：C</p>
</li>
<li><p>在必要劳动时间不变的条件下，由于延长工作日的长度或提高劳动强度而生产的剩余价值叫做（）。<br>A. 绝对剩余价值<br>B. 相对剩余价值<br>C. 平均剩余价值<br>D. 垄断剩余价值<br>正确答案：A</p>
</li>
<li><p>马克思在批判资本主义生产方式曾指出：“它靠缩短工人的寿命，在一定期限内延长工人的生产时间”，这是在评价（）的生产方法。<br>A. 相对剩余价值<br>B. 绝对剩余价值<br>C. 价值<br>D. 劳动力价值<br>正确答案：B</p>
</li>
<li><p>相对剩余价值的生产是通过提高（）实现的。<br>A. 个别劳动时间<br>B. 社会必要劳动时间<br>C. 个别劳动生产率<br>D. 社会必要劳动生产率<br>正确答案：D</p>
</li>
<li><p>全社会劳动生产率的提高，是资本家追逐（）的结果。<br>A. 绝对剩余价值<br>B. 平均剩余价值<br>C. 超额剩余价值<br>D. 垄断剩余价值<br>正确答案：C</p>
</li>
<li><p>在无人工厂中，进行生产的自动化的生产线或机器人的价值（）。<br>A. 由其自身再创造出来<br>B. 转移到产品中去<br>C. 成为剩余价值的源泉<br>D. 发生增殖<br>正确答案：B</p>
</li>
<li><p>（）是资本主社会失业现象的根源。<br>A. 资本积累<br>B. 具体劳动和抽象劳动的矛盾<br>C. 私人劳动和社会劳动的矛盾<br>D. 资本集中<br>正确答案：A</p>
</li>
<li><p>（）是资本从一种形式出发，经过一系列形式的变化，又回到原来出发点的运动。<br>A. 资本循环<br>B. 资本周转<br>C. 资本垄断<br>D. 资本平衡<br>正确答案：A</p>
</li>
<li><p>以下各项中，在资本主义生产过程中属于固定资本的是（）。<br>A. 面粉<br>B. 砂糖<br>C. 织布机<br>D. 布料<br>正确答案：C</p>
</li>
<li><p>资本主义条件下，工资的本质是（）。<br>A. 劳动的价值或价格<br>B. 劳动力的价值或价格<br>C. 工人剩余劳动创造的价值<br>D. 工人形成对资本家人身依附的条件<br>正确答案：B</p>
</li>
<li><p>剩余价值在资本家眼中就是利润，利润率反映的是预付资本的增值程度，通过剩余价值与（）相比来计算。<br>A. 可变资本<br>B. 不变资本<br>C. 全部预付资本<br>D. 流动资本<br>正确答案：C</p>
</li>
<li><p>（）是资本主义的基本矛盾。<br>A. 抽象劳动和具体劳动的矛盾<br>B. 私人劳动和社会劳动的矛盾<br>C. 生产资料私人占有和生产社会化之间的矛盾<br>D. 社会存在和社会意识的矛盾<br>正确答案：C</p>
</li>
<li><p>生产过剩是资本主义经济危机的本质特征，这种过剩是（）。<br>A. 相对于人类实际需要来说<br>B. 相对于劳动人民有支付能力的需求来说<br>C. 相对于资本主义生产条件来说<br>D. 相对于社会再生产的实物补偿来说<br>正确答案：B</p>
</li>
<li><p>资本主义经济危机爆发的根本原因是（）。<br>A. 货币作为流通手段和支付手段<br>B. 私人劳动与社会劳动之间的矛盾<br>C. 绝对过剩人口的存在<br>D. 无产阶级对资产阶级的对抗<br>正确答案：B</p>
</li>
<li><p>资产阶级意识形态的核心是（）。<br>A. 文学. 艺术和宗教<br>B. 政治思想和法律思想<br>C. 道德. 伦理<br>D. 哲学. 历史<br>正确答案：B</p>
</li>
<li><p>资本主义国家服务于资本主义经济基础，其对资本主义生产关系的调整（）。<br>A. 加剧了资本主义的基本矛盾<br>B. 表明了资本主义的生命力<br>C. 有利于资本主义社会生产力的发展<br>D. 缓和了社会主义和资本主义的矛盾<br>正确答案：C</p>
</li>
<li><p>资本主义国家的选举的实质是（）。<br>A. 资产阶级和无产阶级分权<br>B. 每个公民都能通过竞选参与政治活动，表达自己的愿望和要求<br>C. 协调统治阶级内部利益关系和矛盾的重要措施<br>D. 人民当家作主<br>正确答案：C</p>
</li>
<li><p>资本主义法律体系的支柱是（）原则。<br>A. 私有制<br>B. 公有制<br>C. 分权制衡<br>D. 中央集权<br>正确答案：A</p>
</li>
<li><p>资本主义意识形态是资产阶级的（）的集中体现。<br>A. 阶级意识<br>B. 社会心态<br>C. 个人意识<br>D. 自然科学<br>正确答案：A</p>
</li>
<li><p>最鲜明体现资本主义国家实质的国家职能是（）。<br>A. 对外交往职能<br>B. 经济职能<br>C. 社会职能<br>D. 政治统治职能<br>正确答案：D</p>
</li>
<li><p>资本主义国家的政权组织形式是（）。<br>A. 政治协商<br>B. 权力分散<br>C. 民主集中<br>D. 分权制衡<br>正确答案：D</p>
</li>
<li><p>资本主义国家的职能以（）为根本内容。<br>A. 服务工人阶级<br>B. 实现人的自由而全面的发展<br>C. 实现绝对理念<br>D. 服务于资本主义制度和资产阶级利益<br>正确答案：D</p>
</li>
<li><p>恩格斯指出：“现代国家，不管它的形式如何，本质上都是资本主义的机器，资本主义的国家，理想的总资本家”，这句话意在表明（）。<br>A. 只有资本主义国家能实现现代化<br>B. 只有现代国家是阶级统治的工具<br>C. 资本主义国家服务于资产阶级统治<br>D. 资本主义国家是人类发展最高形式<br>正确答案：C</p>
</li>
<li><p>马克思. 恩格斯在《共产党宣言》中指出：“你们的法不过是被奉为法律的你们这个阶级的意志”，这说明资本主义的法律（）。<br>A. 实现了人人平等的理想<br>B. 反映全人类的普遍诉求<br>C. 服务和维护资产阶级特权<br>D. 只有资产阶级遵守<br>正确答案：C</p>
</li>
<li><p>“（美国）政治里面有两件东西最重要，一个是金钱；另一个，我想不起来。”1895年，俄亥俄州议员马克·汉纳如此解释美国政治的运转方式，这说明（）。<br>A. 资本主义政治同经济生产直接同一<br>B. 资本主义民主是金钱操纵下的民主<br>C. 资本主义政治重视实际的人人平等<br>D. 资本主义政治是绝对的民主<br>正确答案：B</p>
</li>
<li><p>列宁指出：“牧师的使命是安慰被压迫者，给他描绘一幅保存阶级统治的条件下减少苦难和牺牲的前景。”这说明（）。<br>A. 意识形态是服务被统治阶级的<br>B. 意识形态通过论证社会制度合理性维护阶级统治<br>C. 意识形态不具有阶级性<br>D. 意识形态决定社会性质<br>正确答案：B</p>
</li>
<li><p>资本主义政党制度的实质是（）。<br>A. 资产阶级选择自己的国家管理者，实现其内部利益平衡的政治机制<br>B. 允许马克思主义政党独立执政<br>C. 不受资本主义国家政权的资本主义性质制约<br>D. 无产阶级专政的现实形式<br>正确答案：A</p>
</li>
</ol>
<h3 id="多选-4"><a href="#多选-4" class="headerlink" title="多选"></a>多选</h3><ol>
<li><p>商品经济得以产生的社会历史条件包括（）。<br>A. 生产资料公有制<br>B. 生产资料和劳动产品属于不同的所有者<br>C. 存在社会分工<br>D. 个体生产自给自足<br>正确答案：BC</p>
</li>
<li><p>商品具有（）两个因素。<br>A. 剩余价值<br>B. 价值<br>C. 使用价值<br>D. 附加价值<br>正确答案：BC</p>
</li>
<li><p>价值和使用价值之间具有对立性，二者不可兼得，这指的是（）。<br>A. 商品只能具有其中一个因素<br>B. 要获得商品的价值就必须放弃商品的使用价值<br>C. 要获得商品的使用价值就必须放弃商品的价值<br>D. 二者不具有统一性<br>正确答案：BC</p>
</li>
<li><p>生产商品的劳动的二重性指的是（）。<br>A. 私人劳动<br>B. 社会劳动<br>C. 抽象劳动<br>D. 具体劳动<br>正确答案：CD</p>
</li>
<li><p>影响劳动生产率的因素包括（）。<br>A. 劳动者的平均熟练程度<br>B. 科学技术的发展水平<br>C. 生产过程的社会结合<br>D. 生产资料的规模和效能<br>正确答案：ABCD</p>
</li>
<li><p>货币具有价值尺度. （）等职能。<br>A. 流通手段<br>B. 贮藏手段<br>C. 支付手段<br>D. 世界货币<br>正确答案：ABCD</p>
</li>
<li><p>价值规律是商品生产和商品交换的基本规律，其主要内容和客观要求有（）。<br>A. 商品的价值量由生产商品的社会必要劳动时间决定<br>B. 商品的价值量由生产商品的个别必要劳动时间决定<br>C. 商品交换以价值量为基础<br>D. 商品交换按照等价交换的原则进行<br>正确答案：ACD</p>
</li>
<li><p>马克思指出：“在私人劳动产品的偶然的不断变动的交换比例中，生产这些产品的社会必要劳动时间作为起调节作用的自然规律强制为自己开辟道路”，这说明（）。<br>A. 商品价值决定商品交换价值<br>B. 价值规律支配商品的生产与流通<br>C. 商品的价格与价值始终相等<br>D. 商品的价值形式始终是偶然的<br>正确答案：AB</p>
</li>
<li><p>价值规律在市场配置资源过程中的作用表现在（）。<br>A. 自发地调节生产资料和劳动力在社会各生产部门之间的分配比例<br>B. 自发地刺激社会生产力的发展<br>C. 自发地调节社会收入分配<br>D. 自发地控制商品流通<br>正确答案：ABC</p>
</li>
<li><p>价值规律在对经济活动调节时的消极后果包括（）。<br>A. 导致不同企业相互竞争<br>B. 导致社会资源浪费<br>C. 阻碍技术进步<br>D. 导致收入两极分化<br>正确答案：BCD</p>
</li>
<li><p>在商品经济条件下商品拜物教产生的必然性在于（）。<br>A. 劳动产品只有采取商品的形式才能进行交换<br>B. 劳动量只有采取价值量这一物的形式才能进行计算和比较<br>C. 生产者的劳动关系的社会性质只有采取物与物之间相交换的形式才能间接表现出来<br>D. 商品. 价值. 货币不具有社会属性只具有自然属性<br>正确答案：ABC</p>
</li>
<li><p>关于马克思劳动价值论的理论和实践意义，下列说法中正确的有（）。<br>A. 扬弃了英国古典政治经济学的观点<br>B. 揭示了私有制条件下商品经济的基本矛盾，为认识物与物关系背后的人与人的关系提供了理论依据<br>C. 揭示了商品经济的一般规律，对理解社会主义市场经济具有指导意义<br>D. 为剩余价值论的创立奠定了基础<br>正确答案：ABCD</p>
</li>
<li><p>资本主义产生的途径包括（）。<br>A. 从小商品经济分化出来<br>B. 从商人和高利贷者转化而来<br>C. 从破产农民发展而来<br>D. 从无产阶级转变而来<br>正确答案：AB</p>
</li>
<li><p>在西欧，资本原始积累开始于15世纪后30年，一直到19世纪才告结束。资本原始积累的途径包括（）。<br>A. 通过等价交换获取原材料<br>B. 通过土地依附关系占有农民剩余劳动<br>C. 用暴力手段剥夺农民的土地<br>D. 用暴力手段掠夺货币财富<br>正确答案：CD</p>
</li>
<li><p>劳动力成为商品的基本条件包括（）。<br>A. 资本家完全占有劳动者<br>B. 劳动者在法律上是自由人<br>C. 劳动者没有任何生产资料<br>D. 劳动者失去劳动能力<br>正确答案：BC</p>
</li>
<li><p>劳动力的价值由（）几个部分组成。<br>A. 维持劳动者本人生存所必需的生活资料的价值<br>B. 维持劳动者家属的生存所必需的生活资料的价值<br>C. 劳动者接受教育和训练所支出的费用<br>D. 劳动者在劳动中所创造的剩余价值<br>正确答案：ABC</p>
</li>
<li><p>关于所有制和所有权的关系，下列说法中正确的有（）。<br>A. 所有权是所有制的基础<br>B. 所有制是所有权的基础<br>C. 所有制是所有权的法律形态<br>D. 所有权是所有制的法律形态<br>正确答案：BD</p>
</li>
<li><p>在资本主义生产过程中，生产资料的价值（）。<br>A. 由劳动工人创造出来<br>B. 通过工人的具体劳动转移到产品中<br>C. 发生增殖<br>D. 不发生增殖<br>正确答案：BD</p>
</li>
<li><p>资本积累的源泉是剩余价值，资本积累规模的大小取决于（）。<br>A. 资本家对工人的剥削程度<br>B. 劳动生产率的高低<br>C. 所用资本和所费资本之间的差额<br>D. 资本家预付资本的大小<br>正确答案：ABCD</p>
</li>
<li><p>资本积累所造成的结果包括（）。<br>A. 社会财富集中在少数人手中<br>B. 社会财富占有两极分化<br>C. 产生社会失业现象<br>D. 价值规律失效<br>正确答案：ABC</p>
</li>
<li><p>某年，铁矿石社会生产效率提高. 价格下降，某钢铁企业趁此机会投入更多资金大量采购铁矿石，并提高了劳动生产率，在没有增加人力成本的情况下，完成了钢铁生产。这家钢铁企业的资本构成中发生变化的有（）。<br>A. 价值构成<br>B. 技术构成<br>C. 有机构成<br>D. 形式构成<br>正确答案：ABC</p>
</li>
<li><p>某创业公司筹集了300万资金，购入了原材料和机器设备。此处资本所执行的职能和在资本循环中所处的阶段分别是（）。<br>A. 商品资本职能<br>B. 生产阶段<br>C. 货币资本职能<br>D. 购买阶段<br>正确答案：CD</p>
</li>
<li><p>在产业资本运动中，在空间上并存，在时间上继起的三种职能形式是（）。<br>A. 货币资本<br>B. 生产资本<br>C. 商品资本<br>D. 借贷资本<br>正确答案：ABC</p>
</li>
<li><p>以下各项中，在社会生产中属于生产生产资料的部门有（）。<br>A. 开采铁矿石的矿场<br>B. 种植棉花的农场<br>C. 餐饮公司<br>D. 服装厂<br>正确答案：AB</p>
</li>
<li><p>社会再生产的顺利进行，要求实现“两个补偿”，即（）。<br>A. 生产资料和消费资料得到实物补偿<br>B. 资本耗费得到价值补偿<br>C. 资本家投入的精力的精神补偿<br>D. 工人提高劳动技能的知识补偿<br>正确答案：AB</p>
</li>
<li><p>马克思剩余价值理论的意义在于（）。<br>A. 揭露了资本主义生产关系的剥削本质<br>B. 阐明了资产阶级与无产阶级之间阶级斗争的经济根源<br>C. 指出了无产阶级革命的历史必然性<br>D. 成为无产阶级反对资产阶级的重要理论武器<br>正确答案：ABCD</p>
</li>
<li><p>社会资本再生产的周期包括（）几个阶段。<br>A. 危机<br>B. 萧条<br>C. 复苏<br>D. 高涨<br>正确答案：ABCD</p>
</li>
<li><p>资产阶级政党在国家政治生活中发挥着很大作用，包括（）。<br>A. 代表资产阶级执掌政权，对政府施加影响. 控制议会。<br>B. 制定和推行符合资产阶级利益的方针. 政策。<br>C. 操纵选举<br>D. 控制群众团体和舆论宣传<br>正确答案：ABCD</p>
</li>
<li><p>列宁说：“民主共和制是资本主义所能采用的最好的政治外壳。”这句话应理解为，民主共和制（）。<br>A. 便于掩盖资产阶级专政的实质。<br>B. 有利于维护资产阶级的统治。<br>C. 与资本主义经济制度相适应。<br>D. 有利于调节资产阶级内部各个集团之间的矛盾。<br>正确答案：ABCD</p>
</li>
<li><p>资本主义政治制度的历史和阶级的局限性主要表现在（）。<br>A. 资本主义的民主是金钱操纵下的民主，实际上是资产阶级精英统治下的民主。<br>B. 法律名义上的平等掩盖着事实上的不平等。<br>C. 资本主义国家的政党制是一种维护阶级统治的政治制度。<br>D. 资本主义国家多党制本质上仍然是资产阶级选择自己的国家管理者，实现内部利益平衡的政治机制。<br>正确答案：ABCD</p>
</li>
<li><p>在饱受疫情困扰的情况下，2020年美国大选的花费将近140亿美元，达到历史新高，这在某种程度上说明（）。<br>A. 资本主义选举事实上是有钱人的游戏<br>B. 资本主义选举投入更多也更科学<br>C. 资本主义政党为讨好选民忽视国家整体利益和长远利益<br>D. 资本主义选举本质上是资本玩弄民意的过程<br>正确答案：ACD</p>
</li>
<li><p>之所以说资本主义意识形态是资产阶级意识的集中体现，是因为（）。<br>A. 意识形态来自统治阶级的实践<br>B. 意识形态可以称为统治阶级进一步进行阶级统治的指导思想<br>C. 资产阶级意识形态服务于全人类的解放<br>D. 资产阶级意识形态主张实际的人人平等<br>正确答案：AB</p>
</li>
</ol>
<h3 id="判断-4"><a href="#判断-4" class="headerlink" title="判断"></a>判断</h3><ol>
<li><p>商品经济在任何社会形态中都占据主导地位。<br>错</p>
</li>
<li><p>一切商品都必须具有使用价值，离开了使用价值商品就不复存在。<br>对</p>
</li>
<li><p>商品的使用价值是用来满足商品生产者的需要的。<br>错</p>
</li>
<li><p>使用价值的大小，或者说对人的需要的满足程度决定了商品交换的比例。<br>错</p>
</li>
<li><p>价值是一切劳动产品所共有的社会属性。<br>错</p>
</li>
<li><p>商品之所以能按一定比例进行交换，是因为它们满足人的需求程度成一定比例。<br>错</p>
</li>
<li><p>劳动形成商品的价值，这意味着只要是劳动的产物就具有价值。<br>错</p>
</li>
<li><p>劳动的二重性决定商品的二因素，其中抽象劳动形成商品的价值。<br>对</p>
</li>
<li><p>商品的价值量与生产商品所耗费的劳动生产率成反比。<br>对</p>
</li>
<li><p>在货币产生后，一切商品只要转化为货币，商品使用价值和价值的矛盾就能解决。<br>对</p>
</li>
<li><p>在商品经济中，价值规律的表现形式是，商品的价格围绕商品的价值自发波动。<br>对</p>
</li>
<li><p>商品生产者的劳动的社会性质是由社会分工决定的。<br>对</p>
</li>
<li><p>具体劳动能否还原为抽象劳动，在根本上取决于私人劳动和社会劳动能否实现统一。<br>对</p>
</li>
<li><p>马克思所说的“商品拜物教”指的是商品. 价值. 货币的运动采取了人与人之间社会关系的虚幻形式。<br>错</p>
</li>
<li><p>理解政治经济的枢纽是劳动二重性理论。<br>对</p>
</li>
<li><p>资产阶级政治统治的建立和资本主义生产方式支配地位的形成，标志着资本主义制度的最终确立。<br>对</p>
</li>
<li><p>货币就是资本，资本就是货币。<br>错</p>
</li>
<li><p>没有人的劳动，任何社会生产都不能进行。<br>对</p>
</li>
<li><p>资本不是一种物，而是一种以物为中介的人和人之间的社会关系。<br>对</p>
</li>
<li><p>一旦货币购买的劳动力带来剩余价值，货币也就变成了资本。<br>对</p>
</li>
<li><p>经济意义上的所有制是指事实上生产资料归谁所有. 归谁支配，并凭借这种所有和支配实现生产和获得剩余产品。<br>对</p>
</li>
<li><p>资本主义对工人的剥削，建立在工人对资本家人身依附关系形成的基础上。<br>错</p>
</li>
<li><p>雇佣劳动者的剩余劳动是剩余价值的唯一源泉。<br>对</p>
</li>
<li><p>资本积累就是剩余价值的资本化。<br>对</p>
</li>
<li><p>资本家获得无偿占有的剩余价值后，并不是将其完全用于个人消费，而是将一部分转化为资本，用以购买追加的生产资料和劳动力，这就是资本主义简单再生产。<br>错</p>
</li>
<li><p>资本积累的本质就是资本家不断利用无偿占有的工人创造的剩余价值来扩大自己的资本规模。<br>对</p>
</li>
<li><p>在资本主义生产过程中，资本有机构成提高是一般趋势。<br>对</p>
</li>
<li><p>资本积累会导致相对过剩人口的出现，所谓相对过剩人口是指为社会生产所不需要的人口。<br>错</p>
</li>
<li><p>资本积累的历史趋势是资本主义制度的必然灭亡和社会主义制度的必然胜利。<br>对</p>
</li>
<li><p>平均利润的形成体现了资本家们在榨取更大剩余价值这一点上有着共同的阶级利益。<br>对</p>
</li>
<li><p>生产价格形成后，市场价格不再以价值为中心，这说明价值规律在资本主义条件下不再有效。<br>错</p>
</li>
<li><p>经济危机通过强制实现社会再生产平衡的方式，根除了资本主义基本矛盾。<br>错</p>
</li>
<li><p>经济危机实际上是资本主义条件下以强制的方式解决社会再生产的实现问题的途径。<br>对</p>
</li>
<li><p>资本主义的民主是金钱操纵下的民主，实际上是资产阶级精英统治下的民主。<br>对</p>
</li>
<li><p>资本主义政治制度是在资本主义经济基础之上建立的，它反映了资本主义社会的经济关系，反映了政治上占统治地位的资产阶级的要求。<br>对</p>
</li>
<li><p>资本主义国家是剥削阶级对人民群众进行阶级统治和阶级压迫的工具。<br>对</p>
</li>
<li><p>资本主义国家的宪法是在私有制原则. “主权在民”原则. 分权与制衡原则以及人权原则的基础上建立起来的。<br>对</p>
</li>
<li><p>资本主义国家的对外职能是对内职能的延伸。<br>对</p>
</li>
<li><p>资产阶级所说的“法律面前人人平等”只是名义上的平等。<br>对</p>
</li>
<li><p>资产阶级政党制度允许工人阶级政党存在和参与国家生活，说明资产阶级政党制度不服务于特定阶级。<br>错</p>
</li>
</ol>
<h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><h3 id="单选-5"><a href="#单选-5" class="headerlink" title="单选"></a>单选</h3><ol>
<li><p>（）是指生产资料. 劳动力和商品的生产日益集中于少数大企业的过程。<br>A. 生产集中<br>B. 资本积累<br>C. 资本循环<br>D. 资本周转<br>正确答案：A</p>
</li>
<li><p>（）是指大资本吞并小资本，或由许多小资本合并而成大资本的过程。<br>A. 生产集中<br>B. 资本集中<br>C. 扩大再生产<br>D. 资本循环<br>正确答案：B</p>
</li>
<li><p>尽管垄断组织的形式多种多样，但其本质上是一样的，即操纵垄断价格，以攫取高额（）。<br>A. 平均利润<br>B. 垄断利润<br>C. 使用价值<br>D. 交换价值<br>正确答案：B</p>
</li>
<li><p>垄断条件下，垄断企业商品按照（）出售。<br>A. 生产价格<br>B. 价值<br>C. 垄断价格<br>D. 使用价值<br>正确答案：C</p>
</li>
<li><p>相比于自由竞争，垄断下的竞争以（）为主要目的。<br>A. 榨取剩余价值<br>B. 获得平均利润<br>C. 获得垄断利润<br>D. 实现价值补偿<br>正确答案：C</p>
</li>
<li><p>（）是指操纵国民经济命脉，并实际控制国家政权的少数垄断资本家或垄断资本家集团。<br>A. 金融资本<br>B. 金融寡头<br>C. 统治阶级<br>D. 私人资本家<br>正确答案：B</p>
</li>
<li><p>金融寡头在经济领域的统治主要是通过（）实现的。<br>A. 参与制<br>B. 绝对剩余价值<br>C. 相对剩余价值<br>D. 商品交换<br>正确答案：A</p>
</li>
<li><p>垄断利润是垄断资本家凭借其在社会生产和流通中的垄断地位而获得的（）的高额利润。<br>A. 低于平均利润<br>B. 等于平均利润<br>C. 超过平均利润<br>D. 等于生产价格<br>正确答案：C</p>
</li>
<li><p>垄断资本所获得的高额利润，归根到底来自于（）。<br>A. 垄断资本家的预付资本<br>B. 垄断资本家所制定的垄断价格<br>C. 劳动工人所创造的剩余价值<br>D. 转移到产品中生产资料价值<br>正确答案：C</p>
</li>
<li><p>国家垄断资本主义的实质是（）。<br>A. 国家利用垄断组织造福民生<br>B. 私人垄断资本主义利用国家机器为其发展服务<br>C. 超越资本主义的新的社会形态<br>D. 消除基本矛盾后的资本主义运行机制<br>正确答案：B</p>
</li>
<li><p>某赛车在日本筹集资金，在意大利设计，在美国生产电子元件，在德国生产零配件，在法国完成组装。这体现了（）。<br>A. 金融全球化<br>B. 生产全球化<br>C. 福利制度全球化<br>D. 意识形态全球化<br>正确答案：B</p>
</li>
<li><p>导致经济及全球化迅猛发展的因素有多种，其中提供物质基础和根本推动力的是（）。<br>A. 跨国公司的发展<br>B. 资本主义意识形态<br>C. 科学技术的发展和生产力的发展<br>D. 国际组织的发展<br>正确答案：C</p>
</li>
<li><p>习近平指出：“面对经济全球化大势，像鸵鸟一样把头埋在沙里假装视而不见，或像堂吉诃德一样挥舞长矛加以抵制，都违背了历史规律。”这说明（）。<br>A. 经济全球化对发展中国家只有负面影响<br>B. 人不能认识和把握经济全球化发展规律<br>C. 经济全球化发展是不可阻挡的历史必然性<br>D. 各国只能被动的受经济全球化影响<br>正确答案：C</p>
</li>
<li><p>第二次世界大战之后，国家资本所有制形成并发挥重要作用，国家资本所有制就其性质而言（）。<br>A. 是一种生产资料公有制<br>B. 体现国家超越阶级实现平等的职能<br>C. 体现着总资本家剥削雇佣劳动者的关系<br>D. 是一种社会主义形式<br>正确答案：C</p>
</li>
<li><p>当代资本主义产生变化的根本推动力是（）。<br>A. 资本家的慈善活动<br>B. 生产力的发展和科学技术革命<br>C. 改良主义政党<br>D. 工人阶级的反抗<br>正确答案：B</p>
</li>
<li><p>从当代资本主义发展的实际情况来看，（）依然是资本主义的基本经济制度。<br>A. 生产资料公有制<br>B. 生产资料集体所有制<br>C. 生产资料私有制<br>D. 生产资料共有制<br>正确答案：C</p>
</li>
<li><p>由美国次贷危机引发的2008年国际金融危机对西方国家的经济生活. 政治生活和社会民生等方面都造成了消极影响，其背后深层次的根源是（）。<br>A. 资本主义的基本矛盾<br>B. 资本主义意识形态<br>C. 资本主义政治制度<br>D. 资本主义改良政党<br>正确答案：A</p>
</li>
<li><p>正确认识资本主义的历史过渡性要（）。<br>A. 否定资本主义生产关系的一切改良<br>B. 借鉴资本主义社会中反映人类文明进步的改良<br>C. 对资本主义采取全面肯定的态度<br>D. 发展资本主义的经济制度<br>正确答案：B</p>
</li>
<li><p>资本主义的发展在各个国家是极不平衡的，而且在商品生产下也只能是这样。由此得出一个必然的结论是（）。<br>A. 社会主义很难实现<br>B. 社会主义不能在所有国家内同时获得胜利<br>C. 社会主义必须在所有国家内同时获得胜利<br>D. 经济和政治发展的不平衡是资本主义的基本矛盾<br>正确答案：B</p>
</li>
<li><p>社会化大生产的程度提高，客观上要求（），以保持再生产顺利进行，同生产资料的私人占有形成了矛盾。<br>A. 攫取更高的剩余价值<br>B. 各生产部门间形成平均利润<br>C. 生产资料和劳动产品由全社会共有和支配<br>D. 形成垄断组织<br>正确答案：C</p>
</li>
<li><p>马克思曾这样描述资本家和工人：“一个笑容满面，雄心勃勃；一个战战兢兢，畏缩不前，像在市场上出卖了自己的皮一样，只有一个前途——让人家来鞣”。这段话意在说明（）。<br>A. 资本家与工人在天赋能力上的差异<br>B. 资本家超越常人的毅力和精神是其成功的根本<br>C. 资本主义社会呈两极分化趋势<br>D. 工人缺少伟大志向和理想<br>正确答案：C</p>
</li>
<li><p>马克思指出：“生产资料的集中和劳动的社会化，达到了同它的资本主义外壳不能相容的地步。这个外壳就要炸毁了。”这说明（）。<br>A. 资本主义必须发展为垄断形式才能化解资本主义基本矛盾<br>B. 资本主义的基本矛盾最终将否定资本主义自身<br>C. 资本主义作为外壳只具有上层建筑意义<br>D. 资本主义生产方式不会推动生产社会化<br>正确答案：B</p>
</li>
</ol>
<h3 id="多选-5"><a href="#多选-5" class="headerlink" title="多选"></a>多选</h3><ol>
<li><p>私人垄断资本主义是在（）基础上发展起来的。<br>A. 生产集中<br>B. 资本集中<br>C. 分散生产<br>D. 投资分散<br>正确答案：AB</p>
</li>
<li><p>垄断产生的原因包括（）。<br>A. 当生产集中发展到相当高的程度，极少数企业就会联合起来<br>B. 企业规模巨大，形成对竞争的限制<br>C. 激烈的竞争给竞争各方带来的损失越来越严重，为了避免两败俱伤，企业之间会达成妥协<br>D. 当生产率提高，相对过剩人口扩大<br>正确答案：ABC</p>
</li>
<li><p>关于垄断下的竞争的特点，下列说法中正确的有（）。<br>A. 以获取平均利润为目的<br>B. 采取非经济手段进行竞争<br>C. 竞争范围扩大到经济以外<br>D. 停止商品交换<br>正确答案：ABC</p>
</li>
<li><p>金融寡头实现对经济命脉和国家机器控制的手段包括（）。<br>A. 通过“参与制”控制经济领域<br>B. 通过“个人联合”控制国家机器<br>C. 通过建立政策咨询机构等方式影响政府政策<br>D. 掌握新闻出版. 广播电视等各个领域<br>正确答案：ABCD</p>
</li>
<li><p>垄断利润的来源有（）等几个方面。<br>A. 对本国无产阶级和其他劳动人民剥削的加强获得更多利润<br>B. 由于垄断资本可以通过垄断高价和垄断低价来控制市场，使得它能获得一些其他企业特别是非垄断企业的利润<br>C. 通过加强对其他国家劳动人民的剥削和掠夺从国外获取利润<br>D. 通过资本主义国家政权进行有利于垄断资本的再分配，从而将劳动人民创造的国民收入的一部分变成垄断资本的收入<br>正确答案：ABCD</p>
</li>
<li><p>国家垄断资本主义形成的原因包括（）。<br>A. 社会生产力发展，要求资本主义生产资料在更大范围内被支配<br>B. 经济波动和经济危机深化<br>C. 缓和社会矛盾<br>D. 协调利益关系<br>正确答案：ABCD</p>
</li>
<li><p>国家垄断资本主义的主要形式包括国家所有并直接经营企业. （）。<br>A. 国家与私人共有. 合营企业<br>B. 国家通过多种形式此案与私人垄断资本的再生产过程<br>C. 宏观调节<br>D. 微观规制<br>正确答案：ABCD</p>
</li>
<li><p>国家垄断资本主义微观规制的类型主要有（）。<br>A. 反托拉斯法<br>B. 公共事业规制<br>C. 社会经济规制<br>D. 意识形态规制<br>正确答案：ABC</p>
</li>
<li><p>（）是金融垄断资本得以形成和壮大的重要制度条件。<br>A. 金融管控<br>B. 反托拉斯法<br>C. 金融自由化<br>D. 金融创新<br>正确答案：CD</p>
</li>
<li><p>金融垄断资本的发展带来的结果包括（）。<br>A. 促进资本主义经济的发展<br>B. 实现事实上的人人平等<br>C. 造成了经济过度虚拟化<br>D. 消除了资本主义基本矛盾<br>正确答案：AC</p>
</li>
<li><p>垄断资本向世界范围内的扩展，反映了资本主义发展的必然逻辑，也反映了资本主义发展的本质。垄断资本向世界范围扩展的动因有（）。<br>A. 将国内过剩的资本输出<br>B. 将部分非要害的技术转移到国外<br>C. 争夺商品销售市场<br>D. 确保原材料和能源的可靠来源<br>正确答案：ABCD</p>
</li>
<li><p>垄断资本向世界范围扩展的基本形式包括（）。<br>A. 借贷资本输出<br>B. 核心技术输出<br>C. 生产资本输出<br>D. 商品资本输出<br>正确答案：ACD</p>
</li>
<li><p>垄断资本向世界范围扩展过程中，对资本输入国带来的影响包括（）。<br>A. 产业结构调整受制于外资投资战略<br>B. 促进了对外贸易的发展<br>C. 付出环境污染. 能源耗费的代价<br>D. 冲击本国民族产业<br>正确答案：ABCD</p>
</li>
<li><p>第二次世界大战以来，从事国际经济协调. 维护国际经济秩序的国际经济组织主要有（）。<br>A. 国际货币基金组织<br>B. 世界银行<br>C. 世界贸易组织<br>D. 七国集团<br>正确答案：ABC</p>
</li>
<li><p>关于国际协调组织的作用，下列说法中正确的有（）。<br>A. 加快了资本. 技术等生产要素在国际的流动<br>B. 有效缓解全球范围内的经济波动和经济危机<br>C. 加强各国之间的经济联系<br>D. 促进经济全球化发展<br>正确答案：ACD</p>
</li>
<li><p>列宁所归纳的帝国主义的基本特征包括垄断组织在经济生活中起决定作用. （）。<br>A. 在金融资本的基础上形成金融寡头的统治<br>B. 资本输出有了特别重要的意义<br>C. 瓜分世界的资本家国际垄断联盟已经形成<br>D. 最大资本主义大国已把世界上的领土瓜分完毕<br>正确答案：ABCD</p>
</li>
<li><p>经济全球化是指在（）的情况下，世界各国. 各地区的经济活动越来越超出某一国家和地区的范围而相互联系. 相互依赖的过程。<br>A. 生产不断发展<br>B. 科技加速进步<br>C. 社会分工和国际分工不断深化<br>D. 生产的社会化和国际化程度不断提高<br>正确答案：ABCD</p>
</li>
<li><p>经济全球化的表现包括（）。<br>A. 生产全球化<br>B. 福利全球化<br>C. 贸易全球化<br>D. 金融全球化<br>正确答案：ACD</p>
</li>
<li><p>导致经济全球化迅猛发展的因素主要有（）。<br>A. 科学技术的进步和生产力的发展<br>B. 跨国公司的发展<br>C. 各国经济体制的变革<br>D. 国际经济组织的发展<br>正确答案：ABCD</p>
</li>
<li><p>经济全球化对发展中国家的积极作用表现为（）。<br>A. 为发展中国家提供先进技术和管理经验<br>B. 为发展中国家提供更多的就业机会<br>C. 推动发展中国家贸易共享<br>D. 使发展中国家成为世界贸易最大受益者<br>正确答案：ABC</p>
</li>
<li><p>经济全球化是一把“双刃剑”，它在促进经济发展的同时也带来了一些负面影响，包括（）。<br>A. 发达国家与发展中国家在地位. 收益上的不平衡<br>B. 加剧发展中国家资源短缺和环境污染<br>C. 增加了经济风险<br>D. 增加全球经济的不稳定性<br>正确答案：ABCD</p>
</li>
<li><p>关于法人资本所有制，下列说法中正确的有（）。<br>A. 在第二次世界大战后崛起并居主导地位<br>B. 使公司资本的所有权与控制权重新趋于合一<br>C. 有企业法人资本所有制和机构法人资本所有制两种形式<br>D. 是一种基于资本雇佣劳动的垄断资本集体所有制<br>正确答案：ABCD</p>
</li>
<li><p>随着社会生产力的发展和工人阶级反抗力量的不断扩大，资本家开始采取一些缓和劳资关系的激励制度，具体包括（）。<br>A. 职工参与决策<br>B. 终身雇佣<br>C. 职工持股<br>D. 职工选举任命公司管理者<br>正确答案：ABC</p>
</li>
<li><p>在当代资本主义生产关系中，社会阶层. 阶级结构发生了新变化，包括（）。<br>A. 资产阶级与工人阶级之间不再具有剥削关系<br>B. 资本家一般不再直接经营和管理企业<br>C. 高级职业经理成为大公司经营活动的实际控制者<br>D. 知识型和服务型劳动者的数量不断增加<br>正确答案：BCD</p>
</li>
<li><p>20世纪70年代以来，资本主义经济危机所呈现出的新特点包括（）。<br>A. 去工业化和产业空心化日趋严重<br>B. 虚拟经济与实体经济严重脱节<br>C. 两极分化和社会对了加剧<br>D. 周期性危机与结构性危机交织在一起<br>正确答案：ABCD</p>
</li>
<li><p>第二次世界大战后资本主义变化的原因包括（）。<br>A. 科学技术革命和生产力的发展<br>B. 工人阶级争取自身权利和利益的斗争<br>C. 社会主义制度初步显现的优越性对资本主义产生了影响<br>D. 主张改良主义的政党起到了重要作用<br>正确答案：ABCD</p>
</li>
<li><p>第二次世界大战后资本主义发生的变化从根本上说是（）作用的结果。<br>A. 人类社会发展一般规律<br>B. 资本主义经济规律<br>C. 资产阶级的改良调整<br>D. 无产阶级的妥协让步<br>正确答案：AB</p>
</li>
<li><p>2008年国际金融危机所造成的影响包括（）。<br>A. 经济发展失调<br>B. 政治体制失灵<br>C. 社会流动性退化<br>D. 社会极端思想抬头<br>正确答案：ABCD</p>
</li>
<li><p>2008年爆发的国际金融危机暴露出了西方国家民主的弊端和局限，主要有（）。<br>A. 西式选举往往难以选贤<br>B. 政党利益可能凌驾于国家利益之上<br>C. “民主陷阱”会阻碍国家治理<br>D. 传统精英政治走向衰落<br>正确答案：ABCD</p>
</li>
<li><p>社会主义取代资本主义将是一个长期的历史过程，这是由于（）。<br>A. 资本主义基本矛盾的运动具有复杂性和曲折性<br>B. 资本主义生产关系的调整，在一定程度上还能容纳生产力继续发展<br>C. 资本主义已经积累了雄厚的经济实力和丰富的统治经验<br>D. 资本主义经济和政治发展不平衡规律的作用<br>正确答案：ABCD</p>
</li>
<li><p>同封建社会相比，资本主义显现的巨大历史进步性包括（）。<br>A. 将科学技术转变为强大的生产力<br>B. 资本追逐剩余价值的内在动力和竞争的外在压力推动了社会生产力的迅速发展<br>C. 资本主义意识形态推动了社会生产力发展<br>D. 实现了人的自由而全面发展<br>正确答案：ABC</p>
</li>
<li><p>当今世界，坚持和发展社会主义要（）。<br>A. 认清社会主义必然取代资本主义的历史趋势<br>B. 认识资本主义的自我调节能力<br>C. 充分估计西方西方发达国家在经济科技等方面长期占据优势的客观事实<br>D. 做好两种社会制度长期合作和斗争的各方面准备<br>正确答案：ABCD</p>
</li>
<li><p>“资产阶级在它的不到一百年的阶级统治中所创造的生产力，比过去一切世代创造的全部生产力还要多，还要大”。这说明（）。<br>A. 当生产关系适合生产力状况时，生产力会得到迅速发展<br>B. 在资本主义社会，资产阶级是历史的创造者<br>C. 资本主义生产关系代替封建制度是历史的进步<br>D. 资本主义生产关系的建立在一定程度上解放了社会生产力<br>正确答案：ACD</p>
</li>
</ol>
<h3 id="判断-5"><a href="#判断-5" class="headerlink" title="判断"></a>判断</h3><ol>
<li><p>垄断是指少数资本主义大企业为获得高额利润，通过相互协议或联合，对一个或几个部门商品的生产. 销售和价格进行操纵和控制。<br>对</p>
</li>
<li><p>垄断一旦形成，竞争就会消失。<br>错</p>
</li>
<li><p>垄断必须通过竞争来维持。<br>对</p>
</li>
<li><p>相比于垄断下的竞争，自由竞争的破坏性更大。<br>错</p>
</li>
<li><p>垄断价格是垄断组织凭借其垄断地位规定的，一定时期内背离了价值和生产价格。<br>对</p>
</li>
<li><p>垄断价格实现了垄断利润，也增加了社会的价值总量。<br>错</p>
</li>
<li><p>垄断价格的产生否定了价值规律。<br>错</p>
</li>
<li><p>国家垄断资本主义的出现从根本上改变了垄断资本主义的性质。<br>错</p>
</li>
<li><p>帝国主义的实质即垄断资本凭借垄断地位，获取高额垄断利润。<br>对</p>
</li>
<li><p>经济全球化是生产力发展和社会化大生产的必然要求。<br>对</p>
</li>
<li><p>第二次世界大战后，实体经济停滞，正是金融垄断资本主义的兴起破解了生产停滞的难题。<br>错</p>
</li>
<li><p>金融垄断资本主义的发展导致金融危机频繁发生，给全球经济带来灾难。<br>对</p>
</li>
<li><p>当代资本主义政治制度出现多元化的趋势，公民权利有所扩大。<br>对</p>
</li>
<li><p>第二次世界大战后，资本主义发生的变化导致剩余价值规律已不再起作用。<br>错</p>
</li>
<li><p>当代资本主义追逐剩余价值的本性没有改变，改变的只是获取剩余价值的方式和方法。<br>对</p>
</li>
<li><p>二战后，西方资本主义国家大多提高社会福利制度，从根本上改变了社会财富占有两极分化的现象。<br>错</p>
</li>
<li><p>真理是在一定条件下的真理，资本主义的新变化表明马克思主义政治经济学所适用的条件已经改变，马克思主义关于资本主义的基本论断已经过时。<br>错</p>
</li>
<li><p>社会主义必然代替资本主义的主要依据是生产的社会化与资本主义私人占有制之间的矛盾。<br>对</p>
</li>
<li><p>社会主义制度代替资本主义制度是生产关系一定要适应生产力发展规律的要求。<br>对</p>
</li>
<li><p>资产阶级的灭亡和无产阶级的胜利是同样不可避免的。<br>对</p>
</li>
<li><p>资本家通过用剩余价值做慈善事业而化解了资本主义的历史局限性。<br>错</p>
</li>
<li><p>资本主义最终消亡. 社会主义最终胜利，必然是一个很长的历史过程。<br>对</p>
</li>
<li><p>资本主义的局限性不可能根本消除，这决定了资本主义生产方式的历史过渡性。<br>对</p>
</li>
<li><p>只有用社会主义的生产方式取代资本主义生产方式，生产社会化和生产资料私人占有制之间的矛盾才能根本解决。<br>对</p>
</li>
<li><p>社会主义必然胜利是不可逆转的总趋势，但社会主义的最终胜利必然是一个很长的历史过程。<br>对</p>
</li>
<li><p>资本国有化将为社会主义革命提供直接的物质前提，是无产阶级社会主义革命的入口处。<br>对</p>
</li>
<li><p>反托拉斯法. 公共事业规制. 财政政策都属于国家垄断资本主义的宏观调控形式。<br>错</p>
</li>
<li><p>垄断价格包括垄断高价和垄断低价两种形式。<br>对</p>
</li>
<li><p>自由竞争资本主义逐步向垄断资本主义过渡是因为资本主义基本矛盾的逐渐消除。<br>错</p>
</li>
<li><p>垄断条件下，因为消除了竞争，所以损害了经济发展。<br>错</p>
</li>
<li><p>垄断价格不受价值规律影响，因此在经济上造成恶劣影响。<br>错</p>
</li>
<li><p>美国主导建立的布雷顿森林体系对促进世界经经济的恢复和发展发挥了重要作用，对推动世界多极化，去霸权化起到积极意义。<br>错</p>
</li>
<li><p>在垄断资本向世界扩张的过程中，资本输出国主要是发展中国家。<br>错</p>
</li>
<li><p>随着资本输出的不断增加，各国之间的经济联系日益密切，矛盾逐渐消除。<br>错</p>
</li>
<li><p>由于各国经济发展总是不平衡的，国际垄断同盟从经济上瓜分世界的趋势，还会在一定时间内持续。<br>对</p>
</li>
<li><p>2008年爆发的金融危机说明，建立国际经济新秩序. 改革现有国际经济协调机制. 加强全球治理已势在必行。<br>对</p>
</li>
<li><p>金融自由化浪潮的兴起和信息技术在金融领域的广泛应用，推动了金融全球化进程。<br>对</p>
</li>
<li><p>经济全球化是资本主义强国为扩张而创造出来的。<br>错</p>
</li>
<li><p>从历史的角度看，资本主义生产资料所有制是不断演进和变化的。<br>对</p>
</li>
<li><p>国家资本所有制就其性质而言，是生产资料公有制。<br>错</p>
</li>
<li><p>金融垄断资本主义是二战后资本主义垄断资本形式的新变化。<br>对</p>
</li>
<li><p>在资本主义条件下，在表面平等的交换关系背后，是资本对劳动的实际支配和控制。<br>对</p>
</li>
<li><p>“泰罗制”和“福特制”是适应资本主义工厂流水线作业的两种工资制度，他们的出现弱化工人阶级被控制和剥削的程度。<br>错</p>
</li>
<li><p>资本主义采取职工参与决策的方法激励工人，改变了工人被剥削的地位。<br>错</p>
</li>
<li><p>当代资本主义社会的社会阶层和阶级结构发生了变化，资本家不再直接管理公司，劳动工人成为公司经营活动的实际控制者。<br>错</p>
</li>
<li><p>第二次世界大战以后，资本主义国家经历了先加强政府干预经济，后弱化政府干预经济的过程。<br>对</p>
</li>
<li><p>正确认识资本主义的新变化，有助于我们进一步完善和发展社会主义制度。<br>对</p>
</li>
<li><p>当代资本主义存在诸多乱象，这些乱象的原因归根结底还在于资本主义制度本身。<br>对</p>
</li>
</ol>
<h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><h3 id="单选-6"><a href="#单选-6" class="headerlink" title="单选"></a>单选</h3><ol>
<li><p>1516年英国人托马斯·莫尔所著（）是空想社会主义的开山之作。<br>A. 《乌托邦》<br>B. 《道德情操论》<br>C. 《反杜林论》<br>D. 《哥达纲领批判》<br>正确答案：A</p>
</li>
<li><p>1864年，国际工人协会即（）成立，促进了马克思主义的传播，初步确立了马克思主义在工人运动中的指导地位。<br>A. 第一国际<br>B. 第二国际<br>C. 第三国际<br>D. 共产主义者同盟<br>正确答案：A</p>
</li>
<li><p>1871年爆发的（），是无产阶级夺取政权的第一次伟大尝试。<br>A. 里昂工人起义<br>B. 京汉铁路大罢工<br>C. 十月革命<br>D. 巴黎公社革命<br>正确答案：D</p>
</li>
<li><p>1889年7月，在恩格斯的指导下，国际社会主义者在巴黎举行代表大会，标志着（）。<br>A. 第一国际的诞生<br>B. 第二国际的诞生<br>C. 十月革命的爆发<br>D. 正义者同盟改组完成<br>正确答案：B</p>
</li>
<li><p>列宁深刻论述了社会主义革命可以首先在一个或者几个国家获得胜利，丰富和发展了马克思主义，其作出这一论断的依据是（）。<br>A. 马克思. 恩格斯理论中的逻辑漏洞<br>B. 资本主义的发展在各个国家是不平衡的<br>C. 资本主义基本矛盾在列宁时期已经化解<br>D. 剩余价值规律作用的消失<br>正确答案：B</p>
</li>
<li><p>（）实现了社会主义从理想到现实的伟大飞跃。<br>A. 十月革命<br>B. 巴黎公社革命<br>C. 第一国际<br>D. 第二国际<br>正确答案：A</p>
</li>
<li><p>1918年夏到1921年春，苏维埃政权实施了一系列特殊又带有强制性的非常措施，后来列宁说：“为了拯救国家，拯救军队，拯救工农政权，当时必须这样做”，“这样”指代的是（）。<br>A. 反抗俄国沙皇统治的二月革命<br>B. 为建立社会主义制度而进行的十月革命<br>C. 为应对帝国主义武装干涉和国内战争而采取的战时共产主义政策<br>D. 在国民经济恢复期实行的新经济政策<br>正确答案：C</p>
</li>
<li><p>苏联解体. 苏东剧变的最根本原因是（）方向出了问题。<br>A. 经济<br>B. 政治<br>C. 科学文化<br>D. 教育<br>正确答案：B</p>
</li>
<li><p>提出社会主义革命可能在一国或数国首先取得胜利论断的是（）。<br>A. 恩格斯<br>B. 马克思<br>C. 列宁<br>D. 莫尔<br>正确答案：C</p>
</li>
<li><p>列宁说：“如果社会主义在经济上尚未成熟，任何起义也创造不出社会主义来。”这就是说（）。<br>A. 社会主义革命只能在经济发达的国家发生和取得胜利<br>B. 经济力量是实现社会主义的唯一条件<br>C. 社会主义革命需要一定的物质前提<br>D. 社会主义革命能够在资本主义内部自发产生<br>正确答案：C</p>
</li>
<li><p>世界上第一个社会主义国家是（）。<br>A. 巴黎公社<br>B. 苏维埃俄国<br>C. 中华人民共和国<br>D. 巴伐利亚苏维埃共和国<br>正确答案：B</p>
</li>
<li><p>资本主义社会为自身被新的社会制度所取代而准备的精神条件是（）。<br>A. 社会化大生产<br>B. 现代无产阶级<br>C. 马克思主义理论<br>D. 市场经济体制<br>正确答案：C</p>
</li>
<li><p>我国在社会主义建设时期，以（）和《关于正确处理人民内部矛盾的问题》为主要标志，党对怎样建设社会主义有了自己的新认识。<br>A. 《井冈山的斗争》<br>B. 《论十大关系》<br>C. 《星星之火，可以燎原》<br>D. 《矛盾论》<br>正确答案：B</p>
</li>
<li><p>1978年12月，党的十一届三中全会重新确立了（）的思想路线。<br>A. 以阶级斗争为纲<br>B. 不唯上只唯书<br>C. 解放思想. 实事求是<br>D. 全盘西化<br>正确答案：C</p>
</li>
<li><p>1978年以后，经过实践探索，我们党提出了社会主义初级阶段等理论，第一次比较系统地初步回答了（）。<br>A. 社会主义如何从空想到科学<br>B. 如何建立社会主义政权<br>C. 在中国这样经济文化比较落后的国家如何建设. 巩固社会主义<br>D. 如何建设社会主义现代化强国<br>正确答案：C</p>
</li>
<li><p>社会主义经济制度的基础是（）。<br>A. 生产资料私人占有制<br>B. 国家垄断资本所有制<br>C. 社会主义公有制<br>D. 多种所有制共同发展<br>正确答案：C</p>
</li>
<li><p>马克思主义政党的最高纲领和最终奋斗目标是（）。<br>A. 建立社会主义制度<br>B. 成为社会主义事业的领导核心<br>C. 实现共产主义<br>D. 建立无产阶级专政<br>正确答案：C</p>
</li>
<li><p>下列选项中，体现社会主义的本质属性和要求的是（）。<br>A. 追求剩余价值<br>B. 坚持等价交换原则<br>C. 以土地为基础形成农民人身依附关系<br>D. 促进人的全面发展和社会和谐<br>正确答案：D</p>
</li>
<li><p>社会主义的根本目的在于（）。<br>A. 镇压资产阶级的反抗<br>B. 建立无产阶级专政<br>C. 无限扩大资本积累<br>D. 消灭剥削. 消除两极分化，最终达到共同富裕<br>正确答案：D</p>
</li>
<li><p>（）是指无产阶级以夺取政权为目的的斗争，它是无产阶级反对整个资产阶级的斗争形式。<br>A. 经济斗争<br>B. 文化斗争<br>C. 思想斗争<br>D. 政治斗争<br>正确答案：D</p>
</li>
<li><p>无产阶级革命的根本问题是（）。<br>A. 国家政权问题<br>B. 农民问题<br>C. 武装斗争问题<br>D. 统一战线中的领导权问题<br>正确答案：A</p>
</li>
<li><p>无产阶级政党的组织原则是（）。<br>A. 民主集中制<br>B. 理论联系实际<br>C. 实事求是<br>D. 政党利益至上<br>正确答案：A</p>
</li>
<li><p>邓小平指出：“绝不能要求马克思为解决他去世之后上百年. 几百年所产生的问题提供现成答案。列宁同样也不能承担为他去世以后五十年. 一百年所产生的问题提供现成答案的任务。”这表明（）。<br>A. 紧跟时代和实践的发展，在不断总结新鲜经验中进一步丰富和发展科学社会主义基本原则<br>B. 因为各国革命和建设实际情况的不同，科学社会主义不再有基本原则<br>C. 始终坚持科学社会主义基本原则，反对任何背离科学社会主义基本原则的错误倾向<br>D. 马克思主义理论不再适应于时代的变化发展<br>正确答案：A</p>
</li>
<li><p>（）是指无产阶级为改善劳动和生活条件而进行的斗争。<br>A. 经济斗争<br>B. 文化斗争<br>C. 思想斗争<br>D. 政治斗争<br>正确答案：A</p>
</li>
<li><p>（）是科学社会主义的核心命题。<br>A. 人民群众是历史的创造者<br>B. 社会基本矛盾是社会发展的根本动力<br>C. 资本主义必然灭亡，社会主义必然胜利<br>D. 无产阶级是最先进最革命的阶级<br>正确答案：C</p>
</li>
<li><p>“资本主义必然灭亡，社会主义必然胜利”提出的根本依据是（）。<br>A. 唯物史观<br>B. 剩余价值理论<br>C. 人类社会发展规律<br>D. 价值规律<br>正确答案：C</p>
</li>
<li><p>无产阶级是最先进最革命的阶级，是因为（）。<br>A. 无产阶级在时间上是新的阶级<br>B. 无产阶级人数众多<br>C. 无产阶级受到剥削和压迫最深<br>D. 无产阶级的理性觉醒程度最高<br>正确答案：C</p>
</li>
<li><p>（）是无产阶级反抗资产阶级斗争的最高形式。<br>A. 社会主义思想<br>B. 无产阶级革命<br>C. 参与制<br>D. 工会<br>正确答案：B</p>
</li>
<li><p>无产阶级革命是以（）为核心的社会革命。<br>A. 文化革命<br>B. 法律革命<br>C. 政治革命<br>D. 经济革命<br>正确答案：C</p>
</li>
<li><p>（）是造成资本主义罪恶的总根源。<br>A. 社会化再生产必须保持的比例关系<br>B. 科学技术推动下的资本有机构成不断提高<br>C. 强调私有财产神圣不容侵犯的资本主义法律<br>D. 生产资料私人占有制<br>正确答案：D</p>
</li>
<li><p>马克思. 恩格斯深入研究了生态问题产生的根源. 本质和表现，指出（）是造成生态问题的根本原因。<br>A. 实践中的主体客体化过程<br>B. 自然资源本身的有限性<br>C. 资本主义制度<br>D. 人类中心论<br>正确答案：C</p>
</li>
<li><p>习近平在《生物多样性公约》第十五次缔约方大会领导人峰会上指出：“人不负青山，青山定不负人。生态文明是人类文明发展的历史趋势。”这所体现的科学社会主义基本原则是（）。<br>A. 社会主义社会要实现人与自然的和谐共生<br>B. 社会主义社会要在生产资料公有制基础上组织生产<br>C. 社会主义社会要实行按劳分配<br>D. 社会主义社会实行无产阶级专政<br>正确答案：A</p>
</li>
<li><p>“事实雄辩地证明，改革开放是决定当代中国命运的关键抉择，是发展中国特色社会主义. 实现中华民族伟大复兴的必由之路；……只有改革开放才能发展中国. 发展社会主义. 发展马克思主义。”这表明（）。<br>A. 改革是无产阶级反抗资产阶级斗争的最高形式<br>B. 改革对于社会主义社会的发展具有重要意义<br>C. 改革是推动社会主义社会发展的根本动力<br>D. 改革使中国已经跨越了社会主义初级阶段<br>正确答案：B</p>
</li>
<li><p>社会主义国家的改革的性质是（）。<br>A. 改变共产党的领导地位<br>B. 自下而上的革命<br>C. 从根本上改变社会主义制度<br>D. 社会主义社会的自我发展和完善<br>正确答案：D</p>
</li>
<li><p>国际共产主义运动的历史表明，社会主义的发展道路不是单一性的，而是（）的。<br>A. 阶段性<br>B. 全面性<br>C. 整体性<br>D. 多样性<br>正确答案：D</p>
</li>
<li><p>社会主义国家在经济上落后于发达资本主义国家，这就决定了在社会主义制度下必须把（）作为根本任务。<br>A. 完善无产阶级专政<br>B. 推进计划经济<br>C. 大力发展生产力<br>D. 加强对外扩张<br>正确答案：C</p>
</li>
<li><p>恩格斯在评论《资本论》第一卷出版时说过：“一些读者可能会以为他将从这本书里得知共产主义的千年王国到底是什么样子，谁指望得到这种乐趣，谁就大错特错。”这是因为（）。<br>A. 《资本论》没有关于共产主义的内容<br>B. 马克思没能预见未来社会的基本特征<br>C. 社会主义在这里还是空想形态<br>D. 马克思没有提供建设社会主义的现成方案<br>正确答案：D</p>
</li>
</ol>
<h3 id="多选-6"><a href="#多选-6" class="headerlink" title="多选"></a>多选</h3><ol>
<li><p>空想社会主义在19世纪上半叶发展到最高阶段，其主要代表人物有（）。<br>A. 傅立叶<br>B. 圣西门<br>C. 欧文<br>D. 恩格斯<br>正确答案：ABC</p>
</li>
<li><p>以三大空想社会主义者为代表的空想社会主义学说的进步性在于（）。<br>A. 对资本主义旧制度的批判中包含许多切中要害的见解<br>B. 对社会主义新制度的描述闪烁着诸多天才的火花<br>C. 反映了早期无产阶级改造现存社会的愿望<br>D. 是早期无产阶级意识和利益的先声<br>正确答案：ABCD</p>
</li>
<li><p>马克思. 恩格斯创立和发展了（），为实现社会主义从空想到科学的飞跃奠定了坚实的理论基础。<br>A. 劳动价值论<br>B. 辩证法<br>C. 剩余价值论<br>D. 唯物史观<br>正确答案：CD</p>
</li>
<li><p>之所以说马克思. 恩格斯实现了社会主义从空想到科学的伟大飞跃，是因为他们（）。<br>A. 科学论证了社会主义必然代替资本主义的历史必然性<br>B. 阐明了无产阶级的历史使命和革命斗争策略<br>C. 科学预见了未来社会的基本特征<br>D. 提出了从资本主义社会向共产主义社会过渡时期的理论<br>正确答案：ABCD</p>
</li>
<li><p>在巴黎公社失败后，马克思. 恩格斯根据巴黎公社的经验，提出的理论论断包括（）。<br>A. 无产阶级取得成功并保持胜利果实的收到条件是要有革命武装<br>B. 必须打碎旧的国家机器，建立无产阶级的新型国家<br>C. 无产阶级政权是为人民服务的机关<br>D. 必须建立无产阶级政党。发挥党的政治领导作用<br>正确答案：ABCD</p>
</li>
<li><p>关于十月革命的历史意义，下列说法中正确的有（）。<br>A. 使社会主义作为一种崭新的社会形态和社会制度登上历史舞台<br>B. 推动了受帝国主义压迫的国家的人民觉醒<br>C. 促进民族解放力量的崛起<br>D. 深刻改变了国际力量对比和世界格局<br>正确答案：ABCD</p>
</li>
<li><p>在俄国社会主义革命取得胜利的初期，特别是实行新经济政策期间，列宁提出了许多关于如何建设社会主义的精辟论述，包括（）。<br>A. 把建设社会主义作为一个长期探索. 不断实践的过程<br>B. 把大力发展生产力. 提高劳动生产率放在首要地位<br>C. 在多种经济成分并存的条件下，利用商品. 货币和市场发展经济<br>D. 利用资本主义建设社会主义<br>正确答案：ABCD</p>
</li>
<li><p>导致苏联解体. 苏东剧变的原因包括（）。<br>A. 西方国家的“和平演变”策略<br>B. 国内改革放弃了社会主义道路<br>C. 国内改革放弃了无产阶级专政<br>D. 否定了党的奋斗史，动摇了理想信念<br>正确答案：ABCD</p>
</li>
<li><p>在苏联的社会主义建设过程中形成了社会主义的苏联模式，对苏联模式的正确评价有（）。<br>A. 承认市场的作用，充分调动了企业和劳动者的积极性<br>B. 在当时促进了社会主义制度的巩固和发展<br>C. 在当时有力地推动了社会生产力的发展<br>D. 为苏联反法西斯战争的胜利提供了有力的物质和人员保障<br>正确答案：BCD</p>
</li>
<li><p>从世界角度看，中国特色社会主义进入新时代，意味着（）。<br>A. 科学社会主义焕发出强大的生机活力<br>B. 拓展了发展中国家走向现代化的途径<br>C. 为既希望加快发展又希望保持自身独立性的国家和民族提供了全新选择<br>D. 为解决人类问题贡献了中国智慧和中国方案<br>正确答案：ABCD</p>
</li>
<li><p>在资本主义社会中，无产阶级和资产阶级之间斗争的形式有（）。<br>A. 经济斗争<br>B. 科研斗争<br>C. 政治斗争<br>D. 思想斗争<br>正确答案：ACD</p>
</li>
<li><p>无产阶级专政的任务包括（）。<br>A. 镇压剥削阶级的反抗和防御外敌入侵<br>B. 领导和组织国家建设<br>C. 发展社会主义民主<br>D. 推动社会全面进步<br>正确答案：ABCD</p>
</li>
<li><p>中国特色社会主义是根植于中国大地. 反映中国人民意愿. 适应中国和时代发展进步要求的科学社会主义，集中体现了（）的有机统一。<br>A. 科学社会主义基本原则<br>B. 当代中国实际<br>C. 中华优秀传统文化<br>D. 资本主义制度<br>正确答案：ABC</p>
</li>
<li><p>（）决定了我们必然要走出一条适合自身特点的社会主义发展道路。<br>A. 我国独特的历史文化传统<br>B. 现实的国情<br>C. 苏联模式的成功经验<br>D. 马克思共产主义理论的空想性<br>正确答案：AB</p>
</li>
<li><p>科学社会主义的基本原则是社会主义事业发展规律的集中体现，关于科学社会主义的基本原则，下列说法中正确的有（）。<br>A. 人类社会发展规律是“资本主义必然灭亡. 社会主义必然胜利”的根本依据。<br>B. 社会主义社会要对社会生产进行有计划的指导和调节，实行按需分配原则。<br>C. 无产阶级革命是无产阶级进行斗争的最高形式。<br>D. 社会主义社会要合乎自然规律地改造和利用自然，努力实现人与自然的和谐共生。<br>正确答案：ACD</p>
</li>
<li><p>社会主义的历史进程出现曲折. 弯路甚至重大挫折时，应该持（）态度。<br>A. 认识到一定曲折的不可避免性<br>B. 尽可能地避免某些曲折，使社会主义顺利发展<br>C. 直面曲折. 承认曲折<br>D. 总结经验教训，努力战胜和走出挫折<br>正确答案：ABCD</p>
</li>
<li><p>社会主义实现模式多样化的原因在于（）。<br>A. 政治经济水平的发展不同<br>B. 指导思想不同<br>C. 历史传统不同<br>D. 社会文化环境不同<br>正确答案：ACD</p>
</li>
<li><p>探索符合本国国情的发展道路必须（）。<br>A. 坚持对待马克思主义的科学态度<br>B. 从当时当地的历史条件出发<br>C. 充分吸收入类一切文明成果<br>D. 恪守科学社会主义所有经典论述<br>正确答案：ABC</p>
</li>
<li><p>“人民的伟力，是渡江战役的小木船，划出了改变历史的伟大胜利；人民的伟力，是‘小铁锹’挖出的大油田，把贫油的帽子甩到了太平洋；人民的伟力，是小岗村按下的‘红手印’，拉开了农村改革的历史大幕；……”这体现了（）。<br>A. 社会主义是亿万人民群众的伟大实践<br>B. 人民群众是社会历史的创造者<br>C. 必须紧紧依靠人民群众<br>D. 要凝聚起亿万人民群众的力量<br>正确答案：ABCD</p>
</li>
<li><p>社会主义在实践中开拓前进必须遵循（）。<br>A. 追逐剩余价值绝对规律<br>B. 人类社会发展规律<br>C. 社会主义建设规律<br>D. 共产党执政规律<br>正确答案：BCD</p>
</li>
<li><p>共产党执政规律的内容包括（）。<br>A. 始终站在人民大众的立场上<br>B. 坚持党中央权威和集中统一领导<br>C. 不断加强自身建设<br>D. 把党的政治建设摆在首位<br>正确答案：ABCD</p>
</li>
</ol>
<h3 id="判断-6"><a href="#判断-6" class="headerlink" title="判断"></a>判断</h3><ol>
<li><p>19世纪初期的空想社会主义是科学社会主义的直接思想来源。<br>对</p>
</li>
<li><p>空想社会主义反映了早期无产阶级意识和利益，是科学的思想体系。<br>错</p>
</li>
<li><p>恩格斯晚年看到了资本主义的新变化，注重合法斗争，否定了暴力革命的作用。<br>错</p>
</li>
<li><p>社会主义发展史证明，苏联模式是特定历史条件下的产物，并不是社会主义的唯一模式。<br>对</p>
</li>
<li><p>中国革命的胜利，是继十月革命之后20世纪最重大的事件。<br>对</p>
</li>
<li><p>在世界社会主义遇到严重挫折的严峻考验面前，中国共产党成功把中国特色社会主义推向21世纪，向世界展示了社会主义的优越性。<br>对</p>
</li>
<li><p>新中国30年的探索取得了多方面的巨大成绩，为新时期开创中国特色社会主义提供了宝贵经验. 理论准备和物质基础。<br>对</p>
</li>
<li><p>只有将科学社会主义基本原则与本国国情相结合，才能创造性地回答和解决本国实际问题。<br>对</p>
</li>
<li><p>无产阶级政党是无产阶级反对资产阶级的斗争发展到一定阶段的产物。<br>对</p>
</li>
<li><p>建立在社会主义公有制基础上的社会是以人民为主体的社会，实现好. 维护好. 发展好人民群众的利益，是社会主义的本质要求。<br>对</p>
</li>
<li><p>生产资料公有制是社会主义经济制度的根基。<br>对</p>
</li>
<li><p>在共产主义的不同阶段，应当实行具有不同特征的分配制度。<br>对</p>
</li>
<li><p>实行单一的计划经济，忽略或排斥市场的作用，不利于社会主义社会生产力的发展。<br>对</p>
</li>
<li><p>马克思主义政党的根本宗旨是为人民群众谋利益。<br>对</p>
</li>
<li><p>社会阶级消灭的前提是生产高度发展。<br>对</p>
</li>
<li><p>“资产阶级的灭亡和无产阶级的胜利是同样不可避免的”是共产主义理想信念的核心要义。<br>对</p>
</li>
<li><p>“无论哪一个社会形态，在它所能容纳的全部生产力发挥岀来以前，是决不会灭亡的；而新的更高的生产关系，在它的物质存在条件在旧社会的胎胞里成熟以前，是决不会出现的”是对“两个必然”的否定。<br>错</p>
</li>
<li><p>无产阶级不是一成不变的，而是会随着社会发展而有所变化，不断实现自身的发展和提高。<br>对</p>
</li>
<li><p>暴力革命是无产阶级革命的一般形式，在无产阶级反抗资产阶级的斗争中，和平地取得政权或进行社会改造是没有可能的。<br>错</p>
</li>
<li><p>共产主义是人类最美好的社会制度。<br>对</p>
</li>
<li><p>共产主义是人类最美好的境界，是真正的历史的终结。<br>错</p>
</li>
<li><p>坚定共产主义理想信念，坚守共产党人精神追求，始终是共产党人安身立命的根本。<br>对</p>
</li>
<li><p>习近平新时代中国特色社会主义思想，标志着我们党在自觉把科学社会主义基本原则与中国实际和时代特征相结合上达到了新的境界。<br>对</p>
</li>
<li><p>社会主义制度能够从根本上消除资本主义导致的两极分化和不公平不公正现象，为人的发展提供可靠的保障，这是我们对社会主义保持必胜信念的坚实根据。<br>对</p>
</li>
<li><p>不同国家试图用同样的“一条道路”“一种模式”发展社会主义是行不通的。<br>对</p>
</li>
<li><p>探索社会主义发展道路，必须坚持对待马克思主义的科学态度。<br>对</p>
</li>
<li><p>在社会主义建设取得了重大成就，社会主义制度有了长足进步之后，资本主义的进攻方式则往往转变为以“和平演变”为主。<br>对</p>
</li>
<li><p>探索社会主义发展道路，必须充分吸收入类一切文明成果。<br>对</p>
</li>
<li><p>除了生产力. 社会发展阶段以及时代和实践的不断发展之外，历史文化传统的差异性是造成不同国家社会主义发展道路多样性的重要条件。<br>对</p>
</li>
<li><p>从总体实力看，发达资本主义国家仍然比发展中的社会主义国家要强大。<br>对</p>
</li>
<li><p>在社会主义进程中产生的种种问题的根源并不在于制度本身，而相当程度上在于人们没有认识和掌握社会主义建设规律。<br>对</p>
</li>
<li><p>各个民族从历史上继承下来的经济. 政治. 文化条件的不同，决定了每个民族都必须从自己的实际出发，按照自己民族的特点进行社会主义建设。<br>对</p>
</li>
<li><p>苏联. 东欧社会主义的失败是社会主义本身的失败。<br>错</p>
</li>
<li><p>社会主义国家只有尽快发展经济，提高综合国力，才能摆脱落后挨打的局面。<br>对</p>
</li>
<li><p>共产党执政规律具有丰富的内涵和实践要求，执政最根本的是人心向背。<br>对</p>
</li>
</ol>
<h2 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h2><h3 id="单选-7"><a href="#单选-7" class="headerlink" title="单选"></a>单选</h3><ol>
<li><p>马克思主义展望未来社会的科学方法之一是（）。<br>A. 立足于既揭示未来社会的一般特征，又作详尽的细节描绘<br>B. 立足于揭示未来社会的详尽细节，而不作一般特征的描绘<br>C. 立足于描绘未来社会的全部特征，而不仅指出未来社会发展的方向<br>D. 立足于揭示未来社会的一般特征，而不作详尽的细节描绘<br>正确答案：D</p>
</li>
<li><p>共产主义社会实现的根本条件是（）。<br>A. 国家垄断资本主义的形成<br>B. 人类理性的高度觉醒<br>C. 人类19世纪创造的优秀理论成果<br>D. 生产力的高度发达<br>正确答案：D</p>
</li>
<li><p>在展望未来社会的问题上，马克思主义与空想社会主义的根本区别是（）。<br>A. 是否坚持科学的立场. 观点. 方法<br>B. 展望的目的和动机是否正确<br>C. 是否有预见未来社会详细特征<br>D. 是否包含着对现存制度的批判<br>正确答案：A</p>
</li>
<li><p>列宁指出，马克思提出共产主义问题“正像一个自然科学家已经知道某一新的生物变种是怎样产生以及朝着哪个方向演变才提出该生物变种的发展问题一样”，马克思对共产主义的描述（）。<br>A. 立足于对先天理念的回忆<br>B. 立足于对人类社会特别是资本主义社会发展规律的揭示<br>C. 是对人们已经知道的内容的重复<br>D. 是对自然界发展规律的揭示<br>正确答案：B</p>
</li>
<li><p>马克思曾说：“新思潮的优点又恰恰在于我们不想教条地预期未来，而只是想通过批判旧世界发现新世界”，这说明（）。<br>A. 马克思主义没有预见到未来社会的发展<br>B. 马克思主义只具有批判性不具有革命性<br>C. 马克思主义在剖析资本主义的基础上阐发未来新世界<br>D. 马克思主义不能指导人民建立新世界<br>正确答案：C</p>
</li>
<li><p>恩格斯指出：“共产主义者不是把某种哲学作为前提，而是把迄今为止的全部历史，特别是这一历史在文明各国造成的实际结果作为前提。”这说明（）。<br>A. 马克思主义哲学不是共产主义者的指导思想<br>B. 共产主义就是人类迄今为止的全部历史<br>C. 共产主义已经在各国实现<br>D. 共产主义思潮是人类历史发展的必然结果<br>正确答案：D</p>
</li>
<li><p>马克思. 恩格斯在展望未来社会时，总是只限于指出未来社会发展的方向. 原则和基本特征，这是因为（）。<br>A. 马克思主义具有局限性，不能科学预见未来<br>B. 共产主义本身不具有现实性和必然性<br>C. 未来的具体事情只能由未来的具体实践来回答<br>D. 马克思. 恩格斯个人十分谦逊<br>正确答案：C</p>
</li>
<li><p>马克思在《哥达纲领批判》中指出：“只有在那个时候，才能完全超出资产阶级权利的狭隘眼界，社会才能在自己的旗帜上写上：各尽所能，按需分配！”此处的“那个时候”可能指的是（）。<br>A. 社会生产力高度发展物质财富极大丰富的时候<br>B. 绝对精神完成实体化的时候<br>C. 无产阶级专政登上历史舞台的时候<br>D. 社会主义在各国普遍建立的时候<br>正确答案：A</p>
</li>
<li><p>共产主义社会的生产资料将实现（）。<br>A. 私人直接占有<br>B. 国家直接占有<br>C. 法人资本所有<br>D. 社会直接占有<br>正确答案：D</p>
</li>
<li><p>在共产主义社会，人与自然达成和谐，这意味着（）。<br>A. 人不再需要改造世界<br>B. 人彻底超脱自然规律<br>C. 人能够以合乎自然规律的方式改造和利用自然<br>D. 人与自然的运动达到绝对静止<br>正确答案：C</p>
</li>
<li><p>精神境界极大提高是共产主义新人的重要体现，这种精神境界主要表现为（）。<br>A. 自觉地为他人. 集体和社会服务和奉献<br>B. 万法唯识不动本心<br>C. 存理灭欲<br>D. 超脱万物<br>正确答案：A</p>
</li>
<li><p>（）是马克思主义追求的根本价值目标。<br>A. 批判资本主义社会<br>B. 认识人类社会发展规律<br>C. 建立无产阶级专政<br>D. 实现人的自由而全面的发展<br>正确答案：D</p>
</li>
<li><p>共产主义社会中人的自由而全面的发展指的是（）的发展。<br>A. 社会统治者<br>B. 少数社会精英<br>C. 社会管理者<br>D. 全体社会成员<br>正确答案：D</p>
</li>
<li><p>恩格斯指出，在共产主义社会，“支配着人们的自然规律而同人们相对立的规律，那时就将被人们熟练地运用”，这说明在共产主义社会（）。<br>A. 人可以创造和改变自然规律<br>B. 人完全摆脱自然规律的影响<br>C. 人实现了从必然王国向自由王国的飞跃<br>D. 规律不再具有认识价值<br>正确答案：C</p>
</li>
<li><p>共产主义理想之所以是能够实现的社会理想，是因为它（）。<br>A. 细节描绘充分<br>B. 是人类向往的美好境界<br>C. 具有客观必然性<br>D. 是人类不断追求的目标<br>正确答案：C</p>
</li>
<li><p>无产阶级特殊的社会地位和历史使命，决定了它只有解放（）才能使自己最后得到彻底解放。<br>A. 全人类<br>B. 资产阶级<br>C. 农民阶级<br>D. 地主阶级<br>正确答案：A</p>
</li>
<li><p>社会主义的任务中，最根本的是（）。<br>A. 发展生产力<br>B. 形成社会主义意识形态<br>C. 建立平等的法律制度<br>D. 实行按劳分配<br>正确答案：A</p>
</li>
<li><p>在全世界实现共产主义，首先将取决于（）。<br>A. 人类理性的觉醒<br>B. 绝对理念的发展阶段<br>C. 社会主义国家的巩固和发展<br>D. 对共产主义描绘的详尽性<br>正确答案：C</p>
</li>
<li><p>习近平指出：“共产主义决不是‘土豆烧牛肉’那么简单”，意在启示我们（）。<br>A. 共产主义的物质财富并不丰富<br>B. 实现共产主义需要长期实践探索<br>C. 共产主义不可实现<br>D. 共产主义社会人们不再有吃穿等生活需要<br>正确答案：B</p>
</li>
<li><p>（）是共产主义的低级阶段，也是实现共产主义的必由之路。<br>A. 资本主义<br>B. 社会主义<br>C. 无政府主义<br>D. 市场经济<br>正确答案：B</p>
</li>
</ol>
<h3 id="多选-7"><a href="#多选-7" class="headerlink" title="多选"></a>多选</h3><ol>
<li><p>属于共产主义社会的特征的有（）。<br>A. 社会财富极大丰富，消费品按需分配<br>B. 社会关系高度和谐，人们的精神境界极大提高<br>C. 社会财富极大丰富，消费品按劳分配<br>D. 每个人自由而全面的发展<br>正确答案：ABD</p>
</li>
<li><p>“共产主义”一词具有多种含义，包括（）。<br>A. 共产主义思想体系<br>B. 绝对平均主义社会<br>C. 共产主义社会<br>D. 共产主义运动<br>正确答案：ACD</p>
</li>
<li><p>相较于以往人们对现实社会的批判，马克思. 恩格斯的高明之处在于（）。<br>A. 不做详尽的描述<br>B. 揭示社会弊端的根源<br>C. 揭示现实社会否定自身的力量<br>D. 在设想未来社会的基础上批判现实<br>正确答案：BC</p>
</li>
<li><p>关于“按劳分配”原则，下列说法中正确的有（）。<br>A. 就其用“劳动”代替资本作为分配标准而言是平等的<br>B. 就其把“劳动”这同一标准运用在不同情况的人身上是不平等的<br>C. 导致劳动能力不同的人在收入分配上的差距<br>D. 在某种意义上还是商品等价交换的原则<br>正确答案：ABCD</p>
</li>
<li><p>以下各项中，在共产主义社会中将会消失的有（）。<br>A. 阶级<br>B. 国家<br>C. 所有社会管理机构<br>D. 战争<br>正确答案：ABD</p>
</li>
<li><p>在共产主义社会，工业与农业. 城市与乡村. 脑力与体力的差别将会消失，这种消失是指（）。<br>A. 利益对立的消失<br>B. 利益划分的消失<br>C. 活动方式差异的消失<br>D. 环节划分的消失<br>正确答案：AB</p>
</li>
<li><p>分工是人类生产活动发展到一定阶段的产物，关于分工，下列说法中正确的有（）。<br>A. 分工对于提升劳动熟练程度具有重要作用<br>B. 在共产主义社会中，分工将会消失<br>C. 自然形成的分工限制了人的活动范围<br>D. 资本主义社会创造了消除旧式分工的条件<br>正确答案：ACD</p>
</li>
<li><p>在共产主义社会，劳动成为“生活的第一需要”，这意味着（）。<br>A. 劳动能力和劳动时间不再是分配的尺度<br>B. 劳动不再是固定. 僵化在一定范围内的劳动<br>C. 劳动不再具有强迫性<br>D. 劳动成为人生快乐的巨大源泉<br>正确答案：ABCD</p>
</li>
<li><p>人的自由而全面的发展，是在（）实现的。<br>A. 在多样化的生产劳动过程中<br>B. 没有法律的社会中<br>C. 在生产劳动之外的大量自由时间中<br>D. 在统一化的劳动生产过程中<br>正确答案：AC</p>
</li>
<li><p>关于共产主义理想，下列说法中正确的有（）。<br>A. 共产主义实现的可能十分渺茫<br>B. 共产主义是能够实现的理想<br>C. 在社会主义历史阶段不应树立共产主义理想<br>D. 共产主义理想的实现是一个漫长的历史过程<br>正确答案：BD</p>
</li>
<li><p>实现共产主义是一个长期的实践过程，因为（）。<br>A. 社会主义的充分发展需要很长的历史时期<br>B. 社会主义向共产主义的过渡需要很长的历史时期<br>C. 当代资本主义的灭亡是一个长期的过程<br>D. 资本主义灭亡向社会主义. 共产主义的转变也是一个长期的过程<br>正确答案：ABCD</p>
</li>
<li><p>对共产主义基本特征的认识应根据对（）等的认识来把握。<br>A. 人类社会结构<br>B. 生产力状况<br>C. 生产关系状况<br>D. 社会生活和精神生活<br>正确答案：ABCD</p>
</li>
<li><p>马克思主义不仅从社会形态更替规律上对共产主义社会理想实现的必然性作了一般性的历史观论证，而且通过对资本主义的科学批判作了具体阐明，包括（）。<br>A. 揭示了资本主义生产方式的特点，论证了资本主义发展自我否定的趋势<br>B. 揭示了生产社会化与生产资料私人占有之间的基本矛盾，论证了资本主义的历史暂时性<br>C. 揭示了资本主义剥削的秘密与资本主义的非正义性，论证了工人阶级推翻旧世界. 建设新世界的历史使命<br>D. 揭示了工人阶级和资产阶级斗争的发展规律和趋势，论述了工人阶级解放斗争胜利的必然性<br>正确答案：ABCD</p>
</li>
<li><p>实现共产主义是人类最伟大的事业，它的实现（）。<br>A. 离不开工人阶级及其政党的能动性发挥<br>B. 离不开社会主义国家建设事业的推进<br>C. 离不开世界社会主义运动的发展<br>D. 必须找到现实的阶级力量<br>正确答案：ABCD</p>
</li>
<li><p>从层次上看，共产主义远大理想与中国特色社会主义共同理想的关系，是（）的关系。<br>A. 社会理想和个人理想<br>B. 最终理想和阶段性理想<br>C. 最高纲领与最低纲领<br>D. 全人类理想和全体中国人民理想<br>正确答案：BCD</p>
</li>
<li><p>关于共同理想与远大理想之间的关系，以下说法中正确的有（）。<br>A. 实现共同理想是实现远大理想的必经阶段<br>B. 实现远大理想是实现共同理想的必然趋势和最终目的<br>C. 共同理想和远大理想是辩证统一的<br>D. 实现了共同理想也就实现了远大理想<br>正确答案：ABC</p>
</li>
<li><p>当前，中国特色社会主义进入了新时代，为当代大学生提供了施展才华的历史机遇，大学生应该（）。<br>A. 坚定社会主义共同理想信念<br>B. 积极投身新时代中国特色社会主义事业<br>C. 做新时代的奋进者. 开拓者. 奉献者。<br>D. 用马克思主义信仰的力量开创美好未来。<br>正确答案：ABCD</p>
</li>
<li><p>关于远大理想和共同理想的关系，下列说法中正确的有（）。<br>A. 没有远大理想的指引，就不会有共同理想的确立和坚持<br>B. 没有共同理想的实现，远大理想就没有现实的基础<br>C. 忘记远大理想而只顾眼前，就会失去前进的方向<br>D. 离开现实工作而空谈远大理想，就会脱离实际<br>正确答案：ABCD</p>
</li>
<li><p>习近平指出：“青年是标志时代的最灵敏的晴雨表，时代的责任赋予青年，时代的光荣属于青年。”这说明（）。<br>A. 青年是祖国的未来. 民族的希望<br>B. 青年兴则国家兴，青年强则国家强<br>C. 青年的综合素质是一个国家发展活力的重要体现<br>D. 青年一代有理想. 有本领. 有担当，国家就有前途，民族就有希望<br>正确答案：ABCD</p>
</li>
<li><p>中国特色社会主义共同理想与共产主义远大理想的内在关系包括（）。<br>A. 最终理想与阶段性理想的关系<br>B. 最高纲领与最低纲领的关系<br>C. 少数人的理想与多数人的理想的关系<br>D. 全人类理想与全体中国人民理想的关系<br>正确答案：ABD</p>
</li>
<li><p>当代青年学习马克思主义基本原理和马克思主义中国化成果要坚持（）。<br>A. 学而信<br>B. 学而用<br>C. 学而行<br>D. 把学习成果转化为不可撼动的理想信念<br>正确答案：ABCD</p>
</li>
</ol>
<h3 id="判断-7"><a href="#判断-7" class="headerlink" title="判断"></a>判断</h3><ol>
<li><p>在马克思主义产生以前，人们已掌握预见未来的科学方法，发现人类社会发展的客观规律。<br>错</p>
</li>
<li><p>在展望未来理想社会时，要在社会主义社会发展中不断深化对未来共产主义社会的认识。<br>对</p>
</li>
<li><p>共产主义社会里，由于部分有觉悟的人的无私奉献，一般人坐享其成成为可能。<br>错</p>
</li>
<li><p>共产主义社会将按照自然资源的情况和社会成员的需要，对生产进行有计划的组织和管理。<br>对</p>
</li>
<li><p>实现人的自由而全面的发展，是马克思主义追求的根本价值目标，也是共产主义社会的根本特征。<br>对</p>
</li>
<li><p>在共产主义社会，个人劳动直接成为社会劳动的一部分，个人利益直接在社会利益中得到实现。<br>对</p>
</li>
<li><p>在共产主义社会，劳动者个人的劳动通过交换价值的途径向社会劳动转化，社会成员之间的相互服务采取等价交换的形式来进行。<br>错</p>
</li>
<li><p>在共产主义社会，国家将消亡，所有的社会组织管理机构都随之消亡，军队. 警察. 监狱等也将失去作用。<br>错</p>
</li>
<li><p>在共产主义社会，与社会生产力的高度发展和社会关系的高度和谐相联系，人们的精神境界得到极大提高。<br>对</p>
</li>
<li><p>在共产主义社会，劳动不再是单调枯燥和具有强迫性的劳动，而成为人们乐于从事的自我实现的活动。<br>对</p>
</li>
<li><p>列宁对社会主义和共产主义做了区分，这是对马克思共产主义理论的否定。<br>错</p>
</li>
<li><p>共产主义社会，人不需要从事劳动，因而是自由的。<br>错</p>
</li>
<li><p>社会主义社会经过长期发展进入共产主义社会，这是一个客观必然的历史进程。<br>对</p>
</li>
<li><p>共产主义理想是以人类社会发展规律以及资本主义社会的基本矛盾发展为依据的。<br>对</p>
</li>
<li><p>社会主义社会和共产主义社会没有关联，社会主义革命的胜利无法被当作共产主义理想是可以实现的证据。<br>错</p>
</li>
<li><p>现代产业工人不占有生产资料而靠向资本家出卖劳动力为生，并通常处于某种贫困状态，所以是“无产阶级”。<br>对</p>
</li>
<li><p>从资本主义到社会主义有一个过渡时期，这是一个充满矛盾和斗争的复杂历史过程。<br>对</p>
</li>
<li><p>在完成资本主义向社会主义的转变以后，还要经历一个社会主义发展阶段，最后才能逐步走向共产主义。<br>对</p>
</li>
<li><p>现存的资本主义国家将来不论发达到何种程度，当其实现根本性制度变革的时候，也只能是首先进入共产主义社会的低级阶段即社会主义社会，而不可能直接达到共产主义社会的高级阶段。<br>对</p>
</li>
<li><p>社会主义是实现共产主义的必由之路。<br>对</p>
</li>
<li><p>进入社会主义时期的国家应该以具有自身特点的方式逐步向共产主义方面迈进。<br>对</p>
</li>
<li><p>无产阶级是先进生产力的代表，深受资产阶级的剥削和压迫，为争取自身的解放进行了不懈的斗争。<br>对</p>
</li>
<li><p>远大理想与共同理想的关系是最终理想与阶段性理想的关系。<br>对</p>
</li>
<li><p>共产主义远大理想体现的是全人类解放的共性，是面向全人类的。<br>对</p>
</li>
<li><p>中国悠久的历史和特殊的国情决定了走中国特色社会主义道路是中华民族通向共产主义的必由之路。<br>对</p>
</li>
<li><p>中国特色社会主义道路，就是在中国共产党的领导下，立足基本国情，以经济建设为中心，坚持四项基本原则，坚持改革开放，解放和发展社会生产力，逐步实现全体人民共同富裕，建设社会主义现代化强国。<br>对</p>
</li>
<li><p>中国特色社会主义是党的最高纲领和基本纲领的统一。<br>对</p>
</li>
<li><p>远大理想可以有多个，阶段性理想则只能有一个。<br>错</p>
</li>
<li><p>理想是指引人们奋斗方向的航标，也是推动人们前进的强大精神动力。<br>对</p>
</li>
<li><p>共产主义理想是人类最伟大的社会理想。<br>对</p>
</li>
<li><p>经过长期的探索，特别是经过改革开放以来的伟大实践，我们已经找到了中国特色社会主义这条正确道路。<br>对</p>
</li>
<li><p>中国特色社会主义道路是中华民族最终走向共产主义的必由之路。<br>对</p>
</li>
<li><p>党的最高纲领和最低纲领的区分最初是在革命年代做出的，在今天已经不再需要区分二者。<br>错</p>
</li>
<li><p>当讲到坚定中国特色社会主义共同理想的时候，不仅是指中国人民对社会主义理想的向往和追求，而且也包含着对“中国道路”的认同。<br>对</p>
</li>
<li><p>中国特色社会主义新时代为当代大学生提供了施展人生才华的极为有利的历史机遇。<br>对</p>
</li>
<li><p>共产主义远大理想不只属于中国人民，而是属于全人类的。<br>对</p>
</li>
<li><p>没有共同理想的实现，远大理想就没有现实的基础。<br>对</p>
</li>
<li><p>社会主义运动的实践，特别是社会主义国家的兴起和不断发展，已经并正在用事实证明共产主义理想实现的必然性。<br>对</p>
</li>
<li><p>社会主义社会与共产主义社会具有根本性质上的一致性。<br>对</p>
</li>
<li><p>共产主义共同愿望来自于人民群众的根本利益和需要，也来自他们对现实生活的感受。<br>对</p>
</li>
<li><p>“工人阶级”和“无产阶级”是两个不同阶级，有一定的交叉性。<br>错</p>
</li>
<li><p>在无产阶级产生以前，任何阶级都不可能实现消灭剥削和压迫的社会理想。<br>对</p>
</li>
<li><p>马克思主义的诞生使无产阶级有了科学理论指导和坚强的领导核心。<br>对</p>
</li>
<li><p>不具备主观客观条件下的革命，是不可能成功和建立起共产主义新社会的。<br>对</p>
</li>
<li><p>马克思. 恩格斯在剩余价值学说的基础上，准确地判断了资本主义具体何时灭亡的问题。<br>错</p>
</li>
<li><p>资本主义社会灭亡后将直接进入共产主义社会的高级阶段。<br>错</p>
</li>
<li><p>社会主义的充分发展和共产主义的实现将是一个漫长的历史过程。<br>对</p>
</li>
<li><p>共产主义不是教义，而是运动。<br>对</p>
</li>
<li><p>在共产主义社会，乐意为社会公共事业作出贡献已经成为人的自觉。<br>对</p>
</li>
</ol>
]]></content>
      <categories>
        <category>课程学习</category>
        <category>马克思</category>
      </categories>
      <tags>
        <tag>课程学习</tag>
        <tag>马克思</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2中的$listeners和v-model</title>
    <url>/135xyq.github.io/2021/09/15/Vue-$listeners&amp;v-model/</url>
    <content><![CDATA[<h1 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h1><p><strong>针对<code>dom</code>节点的原生事件</strong>，<code>vue</code>支持多种修饰符以简化代码</p>
<p>详见：<a href="https://cn.vuejs.org/v2/guide/events.html#%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6">事件修饰符、按键修饰符、系统修饰符</a></p>
<h1 id="listeners"><a href="#listeners" class="headerlink" title="$listeners"></a>$listeners</h1><p><code>$listeners</code>是<code>vue</code>的一个实例属性，它用于获取父组件传过来的所有事件函数</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Child</span> @<span class="attr">event1</span>=<span class="string">&quot;handleEvent1&quot;</span> @<span class="attr">event2</span>=<span class="string">&quot;handleEvent2&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="built_in">this</span>.$listeners; <span class="comment">// &#123; event1: handleEvent1, event2: handleEvent2 &#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>$emit</code>和<code>$listeners</code>通信的异同</p>
<p>相同点：均可实现子组件向父组件传递消息</p>
<p>差异点：</p>
<ul>
<li>  <code>$emit</code>更加符合单向数据流，子组件仅发出通知，由父组件监听做出改变；而<code>$listeners</code>则是在子组件中直接使用了父组件的方法。</li>
<li>  调试工具可以监听到子组件<code>$emit</code>的事件，但无法监听到<code>$listeners</code>中的方法调用。</li>
<li>  由于<code>$listeners</code>中可以获得传递过来的方法，因此调用方法可以得到其返回值。但<code>$emit</code>仅仅是向父组件发出通知，无法知晓父组件处理的结果</li>
</ul>
</blockquote>
<blockquote>
<p>对于上述中的第三点，可以在<code>$emit</code>中传递回调函数来解决</p>
<p>父组件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Child</span> @<span class="attr">click</span>=<span class="string">&quot;handleClick&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">	<span class="keyword">import</span> Child <span class="keyword">from</span> <span class="string">&quot;./Child&quot;</span>;</span></span><br><span class="line"><span class="javascript">	<span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">		<span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">			Child,</span></span><br><span class="line"><span class="javascript">		&#125;,</span></span><br><span class="line"><span class="javascript">		<span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">			<span class="function"><span class="title">handleClick</span>(<span class="params">data, callback</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">				<span class="built_in">console</span>.log(data); <span class="comment">// 得到子组件事件中的数据</span></span></span><br><span class="line"><span class="javascript">				<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">					callback(<span class="number">1</span>); <span class="comment">// 一段时间后，调用子组件传递的回调函数</span></span></span><br><span class="line"><span class="javascript">				&#125;, <span class="number">3000</span>);</span></span><br><span class="line"><span class="javascript">			&#125;,</span></span><br><span class="line"><span class="javascript">		&#125;,</span></span><br><span class="line"><span class="javascript">	&#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>子组件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;handleClick&quot;</span>&gt;</span>click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">	<span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">		<span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">			<span class="function"><span class="title">handleClick</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">				<span class="built_in">this</span>.$emit(<span class="string">&quot;click&quot;</span>, <span class="number">123</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">					<span class="built_in">console</span>.log(data); <span class="comment">// data为父组件处理完成后得到的数据</span></span></span><br><span class="line"><span class="javascript">				&#125;);</span></span><br><span class="line"><span class="javascript">			&#125;,</span></span><br><span class="line"><span class="javascript">		&#125;,</span></span><br><span class="line"><span class="javascript">	&#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h1><p><code>v-model</code>指令实质是一个语法糖，它是<code>value</code>属性和<code>input</code>事件的<em>结合体</em></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">:value</span>=<span class="string">&quot;data&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;data=$event.target.value&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 等同于 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;data&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>详见：<a href="https://cn.vuejs.org/v2/guide/forms.html">表单输入绑定</a></p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue2</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2  css module 和 ref</title>
    <url>/135xyq.github.io/2021/09/03/Vue-css%20module%20%E5%92%8C%20ref/</url>
    <content><![CDATA[<h1 id="使用-css-module"><a href="#使用-css-module" class="headerlink" title="使用 css module"></a>使用 css module</h1><p>需要将样式文件命名为<code>xxx.module.ooo</code></p>
<p><code>xxx</code>为文件名</p>
<p><code>ooo</code>为样式文件后缀名，可以是<code>css</code>、<code>less</code></p>
<h1 id="得到组件渲染的-Dom"><a href="#得到组件渲染的-Dom" class="headerlink" title="得到组件渲染的 Dom"></a>得到组件渲染的 Dom</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    获取某个组件渲染的Dom根元素</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getComponentRootDom</span>(<span class="params">comp, props</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">		<span class="attr">render</span>: <span class="function">(<span class="params">h</span>) =&gt;</span> h(comp, &#123; props &#125;),</span><br><span class="line">	&#125;);</span><br><span class="line">	vm.$mount();</span><br><span class="line">	<span class="keyword">return</span> vm.$el;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="扩展-vue-实例"><a href="#扩展-vue-实例" class="headerlink" title="扩展 vue 实例"></a>扩展 vue 实例</h1><p><img src="/images/vue2/%E5%BC%B9%E5%87%BA%E6%B6%88%E6%81%AF-1.jpg" alt="弹出消息"></p>
<h1 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">p</span> <span class="attr">ref</span>=<span class="string">&quot;para&quot;</span>&gt;</span>some paragraph<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">ChildComp</span> <span class="attr">ref</span>=<span class="string">&quot;comp&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;handleClick&quot;</span>&gt;</span>查看所有引用<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">	<span class="keyword">import</span> ChildComp <span class="keyword">from</span> <span class="string">&quot;./ChildComp&quot;</span>;</span></span><br><span class="line"><span class="javascript">	<span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">		<span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">			ChildComp,</span></span><br><span class="line"><span class="javascript">		&#125;,</span></span><br><span class="line"><span class="javascript">		<span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">			<span class="function"><span class="title">handleClick</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">				<span class="comment">// 获取持有的所有引用</span></span></span><br><span class="line"><span class="javascript">				<span class="built_in">console</span>.log(<span class="built_in">this</span>.$refs);</span></span><br><span class="line"><span class="javascript">				<span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="javascript">        &#123;</span></span></span><br><span class="line"><span class="comment"><span class="javascript">        	para: p元素（原生DOM）,</span></span></span><br><span class="line"><span class="comment"><span class="javascript">        	comp: ChildComp的组件实例</span></span></span><br><span class="line"><span class="comment"><span class="javascript">        &#125;</span></span></span><br><span class="line"><span class="comment"><span class="javascript">        */</span></span></span><br><span class="line"><span class="javascript">			&#125;,</span></span><br><span class="line"><span class="javascript">		&#125;,</span></span><br><span class="line"><span class="javascript">	&#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过<code>ref</code>可以直接操作<code>dom</code>元素，甚至可能直接改动子组件，这些都不符合<code>vue</code>的设计理念。</p>
<p>除非迫不得已，否则不要使用<code>ref</code></p>
</blockquote>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue2</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2自定义指令</title>
    <url>/135xyq.github.io/2021/08/30/Vue-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="定义指令"><a href="#定义指令" class="headerlink" title="定义指令"></a>定义指令</h1><h2 id="全局定义"><a href="#全局定义" class="headerlink" title="全局定义"></a>全局定义</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指令名称为：mydirec1</span></span><br><span class="line">Vue.directive(<span class="string">&#x27;mydirec1&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// 指令配置</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指令名称为：mydirec2</span></span><br><span class="line">Vue.directive(<span class="string">&#x27;mydirec2&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// 指令配置</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>之后，所有的组件均可以使用<code>mydirec1</code>和<code>mydirec2</code>指令</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 某个组件代码 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">MyComp</span> <span class="attr">v-mydirec1</span>=<span class="string">&quot;js表达式&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-mydirec2</span>=<span class="string">&quot;js表达式&quot;</span>&gt;</span></span><br><span class="line">      ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">v-mydirec1</span>=<span class="string">&quot;js表达式&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="局部定义"><a href="#局部定义" class="headerlink" title="局部定义"></a>局部定义</h2><p>局部定义是指在某个组件中定义指令，和局部注册组件类似。</p>
<p>定义的指令仅在该组件中有效。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 某个组件代码 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">MyComp</span> <span class="attr">v-mydirec1</span>=<span class="string">&quot;js表达式&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-mydirec2</span>=<span class="string">&quot;js表达式&quot;</span>&gt;</span></span><br><span class="line">      ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">v-mydirec1</span>=<span class="string">&quot;js表达式&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 定义指令</span></span></span><br><span class="line"><span class="javascript">  <span class="attr">directives</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 指令名称：mydirec1</span></span></span><br><span class="line"><span class="javascript">    <span class="attr">mydirec1</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 指令配置</span></span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 指令名称：mydirec2</span></span></span><br><span class="line"><span class="javascript">    <span class="attr">mydirec2</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 指令配置</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>和全局注册组件一样，为了让指令更加通用，通常我们会把指令的配置提取到其他模块。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 某个组件代码 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">MyComp</span> <span class="attr">v-mydirec1</span>=<span class="string">&quot;js表达式&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-mydirec2</span>=<span class="string">&quot;js表达式&quot;</span>&gt;</span></span><br><span class="line">      ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">v-mydirec1</span>=<span class="string">&quot;js表达式&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 导入当前组件需要用到的指令配置对象</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> mydirec1 <span class="keyword">from</span> <span class="string">&quot;@/directives/mydirec1&quot;</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> mydirec2 <span class="keyword">from</span> <span class="string">&quot;@/directives/mydirec2&quot;</span>;</span></span><br><span class="line"><span class="javascript">	<span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 定义指令</span></span></span><br><span class="line"><span class="javascript">    <span class="attr">directives</span>: &#123;</span></span><br><span class="line"><span class="javascript">      mydirec1,</span></span><br><span class="line"><span class="javascript">      mydirec2</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="指令配置对象"><a href="#指令配置对象" class="headerlink" title="指令配置对象"></a>指令配置对象</h1><p>没有配置的指令，就像没有配置的组件一样，毫无意义</p>
<p>vue支持在指令中配置一些<strong>钩子函数</strong>，在适当的时机，vue会调用这些钩子函数并传入适当的参数，以便开发者完成自己想做的事情。</p>
<p>常用的钩子函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指令配置对象</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="title">bind</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">inserted</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 被绑定元素插入父节点时调用。</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">update</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 所在组件的 VNode 更新时调用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> <a href="https://cn.vuejs.org/v2/guide/custom-directive.html#%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0">查看更多的钩子函数</a></p>
</blockquote>
<p>每个钩子函数在调用时，vue都会向其传递一些参数，其中最重要的是前两个参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指令配置对象</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="title">bind</span>(<span class="params">el, binding</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// el 是被绑定元素对应的真实DOM</span></span><br><span class="line">    <span class="comment">// binding 是一个对象，描述了指令中提供的信息</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="binding-对象"><a href="#binding-对象" class="headerlink" title="binding 对象"></a>binding 对象</h2><p><img src="/images/vue2/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6-bingding%E5%AF%B9%E8%B1%A1.jpg" alt="自定义组件"></p>
<blockquote>
<p><a href="https://cn.vuejs.org/v2/guide/custom-directive.html#%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0">查看更多binding对象的属性</a></p>
</blockquote>
<h1 id="配置简化"><a href="#配置简化" class="headerlink" title="配置简化"></a>配置简化</h1><p>比较多的时候，在配置自定义指令时，我们都会配置两个钩子函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="title">bind</span>(<span class="params">el, bingding</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">update</span>(<span class="params">el, bingding</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，在元素绑定和更新时，都能运行到钩子函数</p>
<p>如果这两个钩子函数实现的功能相同，可以直接把指令配置简化为一个单独的函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">el, bingding</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 该函数会被同时设置到bind和update中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<blockquote>
<p>更多的自定义指令用法见<a href="https://cn.vuejs.org/v2/guide/custom-directive.html">官网</a></p>
</blockquote>
]]></content>
      <categories>
        <category>前端学习笔记</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue2</tag>
      </tags>
  </entry>
</search>
